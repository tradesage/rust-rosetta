[
  {
    "local_code": "extern crate num;\n\nuse std::f64;\nuse std::iter::Map;\nuse std::ops::Range;\n\ntype DoorIter = Map<Range<u32>, fn(u32) -> DoorState>;\n\n#[derive(Debug, PartialEq)]\nenum DoorState {\n    Open,\n    Closed,\n}\n\n// This is an example of returning an iterator, this allows the caller to\n// choose if they want to allocate or just process as a stream.\nfn calculate_doors() -> DoorIter {\n    fn door_status(door_number: u32) -> DoorState {\n        let x = f64::from(door_number).sqrt();\n        if (x - x.round()).abs() < f64::EPSILON {\n            DoorState::Open\n        } else {\n            DoorState::Closed\n        }\n    }\n\n    (1u32..101).map(door_status as fn(u32) -> DoorState)\n}\n\nfn main() {\n    let doors = calculate_doors();\n    for (i, x) in doors.enumerate() {\n        println!(\"Door {} is {:?}\", i + 1, x);\n    }\n}\n\n#[test]\nfn solution() {\n    let doors = calculate_doors().collect::<Vec<DoorState>>();\n\n    // test that the doors with index corresponding to\n    // a perfect square are now open\n    for i in 1..11 {\n        assert_eq!(doors[i * i - 1], DoorState::Open);\n    }\n}\n//! this is the unoptimized version that performs all 100\n//! passes, as per the original description of the problem\n\nfn main() {\n    // states for the 100 doors\n    // uses a vector of booleans,\n    // where state==false means the door is closed\n    let mut doors = [false; 100];\n    solve(&mut doors);\n\n    for (idx, door) in doors.iter().enumerate() {\n        println!(\"door {} open: {}\", idx + 1, door);\n    }\n}\n\n/// unoptimized solution for the 100 Doors problem,\n/// performs all 100 passes and mutates the vector with\n/// the states in place\nfn solve(doors: &mut [bool]) {\n    for pass in 1..101 {\n        let mut p = pass;\n        while p <= 100 {\n            // flip the state of the door\n            doors[p - 1] = !doors[p - 1];\n            p += pass;\n        }\n    }\n}\n\n#[test]\nfn solution() {\n    let mut doors = [false; 100];\n    solve(&mut doors);\n\n    // test that the doors with index corresponding to\n    // a perfect square are now open\n    for i in 1..11 {\n        assert!(doors[i * i - 1]);\n    }\n}\n",
    "path": "tasks/100-doors",
    "remote_code": "fn main() {\n    let mut door_open = [false; 100];\n    for pass in 1..100 {\n        let mut door = pass;\n        while door <= 100 {\n            door_open[door - 1] = !door_open[door - 1];\n            door += pass;\n        }\n    }\n    for (i, &is_open) in door_open.iter().enumerate() {\n        println!(\"Door {} is {}.\", i + 1, if is_open {\"open\"} else {\"closed\"});\n    }\n}\n}",
    "title": "100 doors",
    "url": "http://rosettacode.org/wiki/100_doors"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate rand;\n\nuse rand::prelude::*;\n\n// Do a full run of checking boxes in a random order for a single prisoner\nfn check_random_boxes(prisoner: u8, boxes: &[u8]) -> bool {\n    let checks = {\n        let mut b: Vec<u8> = (1u8..=100u8).collect();\n        b.shuffle(&mut rand::thread_rng());\n        b\n    };\n    checks.into_iter().take(50).any(|check| boxes[check as usize - 1] == prisoner)\n}\n\n// Do a full run of checking boxes in the optimized order for a single prisoner\nfn check_ordered_boxes(prisoner: u8, boxes: &[u8]) -> bool {\n    let mut next_check = prisoner;\n    (0..50).any(|_| {\n        next_check = boxes[next_check as usize - 1];\n        next_check == prisoner\n    })\n}\n\nfn main() {\n    let mut boxes: Vec<u8> = (1u8..=100u8).collect();\n\n    let trials = 100000;\n\n    let ordered_successes = (0..trials).filter(|_| {\n        boxes.shuffle(&mut rand::thread_rng());\n        (1u8..=100u8).all(|prisoner| check_ordered_boxes(prisoner, &boxes))\n    }).count();\n\n    let random_successes = (0..trials).filter(|_| {\n        boxes.shuffle(&mut rand::thread_rng());\n        (1u8..=100u8).all(|prisoner| check_random_boxes(prisoner, &boxes))\n    }).count();\n\n    println!(\"{} / {} ({:.02}%) successes in ordered\", ordered_successes, trials, ordered_successes as f64 * 100.0 / trials as f64);\n    println!(\"{} / {} ({:.02}%) successes in random\", random_successes, trials, random_successes as f64 * 100.0 / trials as f64);\n\n}",
    "title": "100 prisoners",
    "url": "http://rosettacode.org/wiki/100_prisoners"
  },
  {
    "local_code": "extern crate rand;\n\nuse std::collections::HashMap;\nuse std::fmt;\n\nuse rand::distributions::{Distribution, Standard};\nuse rand::prelude::*;\n\n#[derive(Copy, Clone, PartialEq, Debug)]\nenum Cell {\n    Card(usize),\n    Empty,\n}\n\n#[derive(Eq, PartialEq, Hash, Debug)]\nenum Direction {\n    Up,\n    Down,\n    Left,\n    Right,\n}\n\nenum Action {\n    Move(Direction),\n    Quit,\n}\n\ntype Board = [Cell; 16];\nconst EMPTY: Board = [Cell::Empty; 16];\n\nstruct P15 {\n    board: Board,\n}\n\nimpl Distribution<P15> for Standard {\n    // TODO: make the board valid right from the start.\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> P15 {\n        let mut board = EMPTY;\n        for (i, cell) in board.iter_mut().enumerate().skip(1) {\n            *cell = Cell::Card(i);\n        }\n\n        board.shuffle(rng);\n\n        if !P15::is_valid(board) {\n            // random swap\n            // NOTE: because 16 is a power of two, we could use the faster\n            // modulo reduction (`n % 16`) without bias; `gen_range` is\n            // presented here for the general case.\n            let i = rng.gen_range(0, 16);\n            let mut j = rng.gen_range(0, 16);\n            while j == i {\n                j = rng.gen_range(0, 16);\n            }\n            board.swap(i, j);\n        }\n        debug_assert!(P15::is_valid(board));\n\n        P15 { board }\n    }\n}\n\nimpl P15 {\n    // TODO: optimize\n    fn is_valid(mut board: Board) -> bool {\n        let mut permutations = 0;\n\n        let pos = board.iter().position(|&cell| cell == Cell::Empty).unwrap();\n\n        if pos != 15 {\n            board.swap(pos, 15);\n            permutations += 1;\n        }\n\n        for i in 1..16 {\n            let pos = board\n                .iter()\n                .position(|&cell| match cell {\n                    Cell::Card(value) if value == i => true,\n                    _ => false,\n                })\n                .unwrap();\n\n            if pos + 1 != i {\n                board.swap(pos, i - 1);\n                permutations += 1;\n            }\n        }\n\n        permutations % 2 == 0\n    }\n\n    fn get_empty_position(&self) -> usize {\n        self.board.iter().position(|&c| c == Cell::Empty).unwrap()\n    }\n\n    fn get_moves(&self) -> HashMap<Direction, Cell> {\n        let mut moves = HashMap::new();\n        let i = self.get_empty_position();\n\n        if i > 3 {\n            moves.insert(Direction::Up, self.board[i - 4]);\n        }\n        if i % 4 != 0 {\n            moves.insert(Direction::Left, self.board[i - 1]);\n        }\n        if i < 12 {\n            moves.insert(Direction::Down, self.board[i + 4]);\n        }\n        if i % 4 != 3 {\n            moves.insert(Direction::Right, self.board[i + 1]);\n        }\n        moves\n    }\n\n    fn play(&mut self, direction: &Direction) {\n        let i = self.get_empty_position();\n        // This is safe because `ask_action` only returns legal moves\n        match *direction {\n            Direction::Up => self.board.swap(i, i - 4),\n            Direction::Left => self.board.swap(i, i - 1),\n            Direction::Right => self.board.swap(i, i + 1),\n            Direction::Down => self.board.swap(i, i + 4),\n        };\n    }\n\n    fn is_complete(&self) -> bool {\n        self.board.iter().enumerate().all(|(i, &cell)| match cell {\n            Cell::Card(value) => value == i + 1,\n            Cell::Empty => i == 15,\n        })\n    }\n}\n\nimpl fmt::Display for P15 {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        writeln!(f, \"+----+----+----+----+\")?;\n        for (i, &cell) in self.board.iter().enumerate() {\n            match cell {\n                Cell::Card(value) => write!(f, \"| {:2} \", value)?,\n                Cell::Empty => write!(f, \"|    \")?,\n            };\n\n            if i % 4 == 3 {\n                writeln!(f, \"|\")?;\n                writeln!(f, \"+----+----+----+----+\")?;\n            }\n        }\n        Ok(())\n    }\n}\n\nfn main() {\n    let mut p15: P15 = rand::random();\n\n    for turns in 1.. {\n        println!(\"{}\", p15);\n        match ask_action(&p15.get_moves()) {\n            Action::Move(direction) => {\n                p15.play(&direction);\n            }\n            Action::Quit => {\n                println!(\"Bye !\");\n                break;\n            }\n        }\n\n        if p15.is_complete() {\n            println!(\"Well done ! You won in {} turns\", turns);\n            break;\n        }\n    }\n}\n\nfn ask_action(moves: &HashMap<Direction, Cell>) -> Action {\n    use std::io::{self, Write};\n    use Action::*;\n    use Direction::*;\n\n    println!(\"Possible moves:\");\n\n    if let Some(&Cell::Card(value)) = moves.get(&Up) {\n        println!(\"\\tU) {}\", value);\n    }\n    if let Some(&Cell::Card(value)) = moves.get(&Left) {\n        println!(\"\\tL) {}\", value);\n    }\n    if let Some(&Cell::Card(value)) = moves.get(&Right) {\n        println!(\"\\tR) {}\", value);\n    }\n    if let Some(&Cell::Card(value)) = moves.get(&Down) {\n        println!(\"\\tD) {}\", value);\n    }\n    println!(\"\\tQ) Quit\");\n    print!(\"Choose your move : \");\n    io::stdout().flush().unwrap();\n\n    let mut action = String::new();\n    io::stdin().read_line(&mut action).expect(\"read error\");\n    match action.to_uppercase().trim() {\n        \"U\" if moves.contains_key(&Up) => Move(Up),\n        \"L\" if moves.contains_key(&Left) => Move(Left),\n        \"R\" if moves.contains_key(&Right) => Move(Right),\n        \"D\" if moves.contains_key(&Down) => Move(Down),\n        \"Q\" => Quit,\n        _ => {\n            println!(\"Unknown action: {}\", action);\n            ask_action(moves)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn board_from_ints(ints: &[usize; 16]) -> Board {\n        let mut board = EMPTY;\n        for (cell, &int) in board.iter_mut().zip(ints.iter()) {\n            *cell = if int == 0 {\n                Cell::Empty\n            } else {\n                Cell::Card(int)\n            }\n        }\n        board\n    }\n\n    fn make_valid<R: Rng>(rng: &mut R, mut board: Board) -> Board {\n        // get 2 indices from a single random byte\n        let rand_byte = rng.gen::<u8>() as usize;\n        // modulo reduction for test speed\n        let i = rand_byte % 16;\n        let mut j = rand_byte >> (8 - 2);\n\n        while j == i {\n            j = rng.gen::<u8>() as usize % 16; // rng.gen_range(0, 16);\n        }\n        board.swap(i, j);\n        board\n    }\n\n    #[test]\n    fn board_creation() {\n        let p15: P15 = rand::random();\n        assert!(P15::is_valid(p15.board));\n    }\n\n    #[test]\n    fn board_validity() {\n        let mut rng = thread_rng();\n\n        fn assert_is_valid(ints: &[usize; 16]) {\n            let board = board_from_ints(ints);\n            assert!(P15::is_valid(board));\n        }\n\n        fn assert_is_not_valid<R: Rng>(rng: &mut R, ints: &[usize; 16]) {\n            let board = board_from_ints(ints);\n            assert!(!P15::is_valid(board));\n            assert!(P15::is_valid(make_valid(rng, board)));\n        }\n\n        assert_is_not_valid(\n            &mut rng,\n            &[2, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0],\n        );\n        assert_is_not_valid(\n            &mut rng,\n            &[13, 10, 11, 6, 5, 7, 4, 8, 1, 12, 14, 9, 3, 15, 2, 0],\n        );\n        assert_is_not_valid(\n            &mut rng,\n            &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 14, 0],\n        );\n        assert_is_not_valid(\n            &mut rng,\n            &[2, 1, 3, 4, 5, 8, 7, 6, 9, 10, 12, 11, 15, 13, 14, 0],\n        );\n        assert_is_not_valid(\n            &mut rng,\n            &[4, 15, 7, 9, 3, 12, 1, 8, 5, 0, 11, 2, 13, 6, 10, 14],\n        );\n\n        assert_is_valid(&[7, 1, 3, 14, 6, 0, 4, 8, 5, 9, 13, 2, 12, 15, 11, 10]);\n        assert_is_valid(&[7, 9, 1, 14, 6, 0, 13, 10, 8, 3, 12, 4, 15, 5, 2, 11]);\n        assert_is_valid(&[15, 8, 9, 14, 5, 10, 1, 0, 12, 4, 3, 13, 11, 2, 7, 6]);\n        assert_is_valid(&[1, 12, 4, 8, 10, 7, 2, 11, 6, 3, 15, 14, 9, 13, 5, 0]);\n    }\n\n    #[test]\n    fn directions() {\n        fn get_puzzle_moves(ints: &[usize; 16]) -> HashMap<Direction, Cell> {\n            let board = board_from_ints(&ints);\n            let puzzle = P15 { board };\n            puzzle.get_moves()\n        }\n\n        let mut test = HashMap::new();\n        test.insert(Direction::Up, Cell::Card(12));\n        test.insert(Direction::Left, Cell::Card(15));\n        let moves = get_puzzle_moves(&[13, 6, 8, 3, 1, 5, 2, 4, 9, 7, 10, 12, 14, 11, 15, 0]);\n        assert_eq!(moves, test);\n\n        let mut test = HashMap::new();\n        test.insert(Direction::Up, Cell::Card(12));\n        test.insert(Direction::Left, Cell::Card(14));\n        test.insert(Direction::Right, Cell::Card(8));\n        test.insert(Direction::Down, Cell::Card(15));\n        let moves = get_puzzle_moves(&[7, 12, 2, 1, 14, 0, 8, 13, 3, 15, 4, 6, 11, 5, 10, 9]);\n        assert_eq!(moves, test);\n    }\n\n    #[test]\n    fn victory() {\n        let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0];\n        let board = board_from_ints(&input);\n        let puzzle = P15 { board };\n        assert!(puzzle.is_complete());\n    }\n}\n",
    "path": "tasks/15-puzzle-game",
    "remote_code": "extern crate rand;\n \nuse std::collections::HashMap;\nuse std::fmt;\n \nuse rand::Rng;\nuse rand::seq::SliceRandom;\n \n#[derive(Copy, Clone, PartialEq, Debug)]\nenum Cell {\n    Card(usize),\n    Empty,\n}\n \n#[derive(Eq, PartialEq, Hash, Debug)]\nenum Direction {\n    Up,\n    Down,\n    Left,\n    Right,\n}\n \nenum Action {\n    Move(Direction),\n    Quit,\n}\n \ntype Board = [Cell; 16];\nconst EMPTY: Board = [Cell::Empty; 16];\n \nstruct P15 {\n    board: Board,\n}\n \nimpl P15 {\n    fn new() -> Self {\n        let mut board = EMPTY;\n        for (i, cell) in board.iter_mut().enumerate().skip(1) {\n            *cell = Cell::Card(i);\n        }\n \n        let mut rng = rand::thread_rng();\n \n        board.shuffle(&mut rng);\n        if !Self::is_valid(board) {\n            // random swap\n            let i = rng.gen_range(0, 16);\n            let mut j = rng.gen_range(0, 16);\n            while j == i {\n                j = rng.gen_range(0, 16);\n            }\n            board.swap(i, j);\n        }\n \n        Self { board }\n    }\n \n    fn is_valid(mut board: Board) -> bool {\n        // TODO: optimize\n        let mut permutations = 0;\n \n        let pos = board.iter().position(|&cell| cell == Cell::Empty).unwrap();\n \n        if pos != 15 {\n            board.swap(pos, 15);\n            permutations += 1;\n        }\n \n        for i in 1..16 {\n            let pos = board\n                .iter()\n                .position(|&cell| match cell {\n                    Cell::Card(value) if value == i => true,\n                    _ => false,\n                })\n                .unwrap();\n \n            if pos + 1 != i {\n                board.swap(pos, i - 1);\n                permutations += 1;\n            }\n        }\n \n        permutations % 2 == 0\n    }\n \n    fn get_empty_position(&self) -> usize {\n        self.board.iter().position(|&c| c == Cell::Empty).unwrap()\n    }\n \n    fn get_moves(&self) -> HashMap<Direction, Cell> {\n        let mut moves = HashMap::new();\n        let i = self.get_empty_position();\n \n        if i > 3 {\n            moves.insert(Direction::Up, self.board[i - 4]);\n        }\n        if i % 4 != 0 {\n            moves.insert(Direction::Left, self.board[i - 1]);\n        }\n        if i < 12 {\n            moves.insert(Direction::Down, self.board[i + 4]);\n        }\n        if i % 4 != 3 {\n            moves.insert(Direction::Right, self.board[i + 1]);\n        }\n        moves\n    }\n \n    fn play(&mut self, direction: &Direction) {\n        let i = self.get_empty_position();\n        // This is safe because `ask_action` only returns legal moves\n        match *direction {\n            Direction::Up => self.board.swap(i, i - 4),\n            Direction::Left => self.board.swap(i, i - 1),\n            Direction::Right => self.board.swap(i, i + 1),\n            Direction::Down => self.board.swap(i, i + 4),\n        };\n    }\n \n    fn is_complete(&self) -> bool {\n        self.board.iter().enumerate().all(|(i, &cell)| match cell {\n            Cell::Card(value) => value == i + 1,\n            Cell::Empty => i == 15,\n        })\n    }\n}\n \nimpl fmt::Display for P15 {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        r#try!(write!(f, \"+----+----+----+----+\\n\"));\n        for (i, &cell) in self.board.iter().enumerate() {\n            match cell {\n                Cell::Card(value) => r#try!(write!(f, \"| {:2} \", value)),\n                Cell::Empty => r#try!(write!(f, \"|    \")),\n            }\n \n            if i % 4 == 3 {\n                r#try!(write!(f, \"|\\n\"));\n                r#try!(write!(f, \"+----+----+----+----+\\n\"));\n            }\n        }\n        Ok(())\n    }\n}\n \nfn main() {\n    let mut p15 = P15::new();\n \n    for turns in 1.. {\n        println!(\"{}\", p15);\n        match ask_action(&p15.get_moves()) {\n            Action::Move(direction) => {\n                p15.play(&direction);\n            }\n            Action::Quit => {\n                println!(\"Bye !\");\n                break;\n            }\n        }\n \n        if p15.is_complete() {\n            println!(\"Well done ! You won in {} turns\", turns);\n            break;\n        }\n    }\n}\n \nfn ask_action(moves: &HashMap<Direction, Cell>) -> Action {\n    use std::io::{self, Write};\n    use Action::*;\n    use Direction::*;\n \n    println!(\"Possible moves:\");\n \n    if let Some(&Cell::Card(value)) = moves.get(&Up) {\n        println!(\"\\tU) {}\", value);\n    }\n    if let Some(&Cell::Card(value)) = moves.get(&Left) {\n        println!(\"\\tL) {}\", value);\n    }\n    if let Some(&Cell::Card(value)) = moves.get(&Right) {\n        println!(\"\\tR) {}\", value);\n    }\n    if let Some(&Cell::Card(value)) = moves.get(&Down) {\n        println!(\"\\tD) {}\", value);\n    }\n    println!(\"\\tQ) Quit\");\n    print!(\"Choose your move : \");\n    io::stdout().flush().unwrap();\n \n    let mut action = String::new();\n    io::stdin().read_line(&mut action).expect(\"read error\");\n    match action.to_uppercase().trim() {\n        \"U\" if moves.contains_key(&Up) => Move(Up),\n        \"L\" if moves.contains_key(&Left) => Move(Left),\n        \"R\" if moves.contains_key(&Right) => Move(Right),\n        \"D\" if moves.contains_key(&Down) => Move(Down),\n        \"Q\" => Quit,\n        _ => {\n            println!(\"Unknown action: {}\", action);\n            ask_action(moves)\n        }\n    }\n}",
    "title": "15 Puzzle Game",
    "url": "http://rosettacode.org/wiki/15_Puzzle_Game"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "15 puzzle solver",
    "url": "http://rosettacode.org/wiki/15_puzzle_solver"
  },
  {
    "local_code": "extern crate rand;\n\nuse std::io;\nuse std::ops::{Index, IndexMut};\n\nuse rand::prelude::*;\n\nconst GRID_DIMENSION: usize = 4;\n\n/// A key press.\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\nenum Key {\n    Up,\n    Left,\n    Down,\n    Right,\n    Quit,\n}\n\n#[derive(Debug, PartialEq)]\nenum State {\n    Playing,\n    Won,\n    Lost,\n}\n\n/// Error returned when the grid is full.\n#[derive(Debug)]\nstruct GridFullError;\n\n/// Error returned when no tiles were actually moved.\n#[derive(Debug)]\nstruct NoTilesMovedError;\n\n/// An optionally filled tile in the grid.\ntype Tile = Option<u32>;\n\n/// The set of game tiles.\n#[derive(Debug, PartialEq, Eq)]\nstruct Grid([[Tile; GRID_DIMENSION]; GRID_DIMENSION]);\n\nimpl Index<(usize, usize)> for Grid {\n    type Output = Tile;\n\n    fn index(&self, (x, y): (usize, usize)) -> &Self::Output {\n        &self.0[x][y]\n    }\n}\n\nimpl IndexMut<(usize, usize)> for Grid {\n    fn index_mut(&mut self, (x, y): (usize, usize)) -> &mut Self::Output {\n        &mut self.0[x][y]\n    }\n}\n\nimpl Grid {\n    fn new() -> Self {\n        Grid([[None; GRID_DIMENSION]; GRID_DIMENSION])\n    }\n\n    fn is_move_available(&self) -> bool {\n        for x in 0..4 {\n            for y in 0..4 {\n                if self[(x, y)].is_none() {\n                    return true;\n                }\n                if x < 3 && self[(x + 1, y)] == self[(x, y)] {\n                    return true;\n                };\n                if x > 0 && self[(x - 1, y)] == self[(x, y)] {\n                    return true;\n                };\n                if y < 3 && self[(x, y + 1)] == self[(x, y)] {\n                    return true;\n                };\n                if y > 0 && self[(x, y - 1)] == self[(x, y)] {\n                    return true;\n                };\n            }\n        }\n        false\n    }\n\n    fn spawn_tile(&mut self) -> Result<(), GridFullError> {\n        if !self.is_move_available() {\n            return Err(GridFullError);\n        }\n\n        let mut rng = thread_rng();\n\n        loop {\n            // `GRID_DIMENSION` is a power of two so modulo reduction is\n            // unbiased. Because we only need 2 bits, we can just generate a\n            // `u8` and split the bits. This is faster than generating two\n            // `usize` values.\n            let r = rng.gen::<u8>() as usize;\n            let rand_tile = &mut self[(r % GRID_DIMENSION, r >> (8 - 2))];\n\n            if rand_tile.is_none() {\n                let tile = if rng.gen_bool(1.0 / 10.0) { 4 } else { 2 };\n                *rand_tile = Some(tile);\n                break;\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Given a slice of tiles, shifts and merges the tiles towards the left end of the vector.\n    ///\n    /// Returns a tuple containing the new vector and the change in score.\n    fn merge(vector: &[Tile]) -> (Vec<Tile>, u32) {\n        // Remove intermediate empty tiles.\n        let mut shifted = vector.iter().filter_map(|&x| x).collect::<Vec<_>>();\n\n        // Merge tiles that are next to each other, leaving an empty space.\n        let mut score = 0;\n        for i in 0..shifted.len() {\n            if i + 1 < shifted.len() && shifted[i + 1] == shifted[i] {\n                shifted[i] *= 2;\n                shifted[i + 1] = 0;\n                score += shifted[i];\n            }\n        }\n\n        // Remove intermediate empty tiles\n        let mut shifted = shifted\n            .into_iter()\n            .filter(|&x| x != 0)\n            .map(Some)\n            .collect::<Vec<_>>();\n\n        // Fill remaining array.\n        let len = shifted.len();\n        shifted.extend(std::iter::repeat(None).take(GRID_DIMENSION - len));\n\n        (shifted, score)\n    }\n\n    /// Shift tiles left.\n    fn shift_left(&mut self) -> Result<u32, NoTilesMovedError> {\n        let mut moved = false;\n        let mut score = 0;\n        for row in 0..GRID_DIMENSION {\n            let tiles: Vec<_> = (0..GRID_DIMENSION).map(|col| self[(row, col)]).collect();\n\n            let (merged_row, row_score) = Grid::merge(&tiles);\n            score += row_score;\n            if !moved && tiles != merged_row {\n                moved = true;\n            }\n\n            for (col, tile) in merged_row.iter().enumerate() {\n                self[(row, col)] = *tile;\n            }\n        }\n\n        if moved {\n            Ok(score)\n        } else {\n            Err(NoTilesMovedError)\n        }\n    }\n\n    /// Shift tiles up.\n    fn shift_up(&mut self) -> Result<u32, NoTilesMovedError> {\n        let mut moved = false;\n        let mut score = 0;\n        for col in 0..GRID_DIMENSION {\n            let mut tiles = vec![];\n\n            for row in 0..GRID_DIMENSION {\n                tiles.push(self[(row, col)]);\n            }\n\n            let (merged_col, col_score) = Grid::merge(&tiles);\n            score += col_score;\n            if !moved && tiles != merged_col {\n                moved = true;\n            }\n\n            for (row, tile) in merged_col.iter().enumerate() {\n                self[(row, col)] = *tile;\n            }\n        }\n\n        if moved {\n            Ok(score)\n        } else {\n            Err(NoTilesMovedError)\n        }\n    }\n\n    /// Shift tiles down.\n    fn shift_down(&mut self) -> Result<u32, NoTilesMovedError> {\n        let mut moved = false;\n        let mut score = 0;\n        for col in 0..GRID_DIMENSION {\n            let mut tiles = vec![];\n\n            for row in (0..GRID_DIMENSION).rev() {\n                tiles.push(self[(row, col)]);\n            }\n\n            let (merged_col, col_score) = Grid::merge(&tiles);\n            score += col_score;\n            if !moved && tiles != merged_col {\n                moved = true;\n            }\n\n            for (row, tile) in merged_col.iter().rev().enumerate() {\n                self[(row, col)] = *tile;\n            }\n        }\n\n        if moved {\n            Ok(score)\n        } else {\n            Err(NoTilesMovedError)\n        }\n    }\n\n    /// Shift tiles down.\n    fn shift_right(&mut self) -> Result<u32, NoTilesMovedError> {\n        let mut moved = false;\n        let mut score = 0;\n        for row in 0..GRID_DIMENSION {\n            let mut tiles = vec![];\n\n            for col in (0..GRID_DIMENSION).rev() {\n                tiles.push(self[(row, col)]);\n            }\n\n            let (merged_row, row_score) = Grid::merge(&tiles);\n            score += row_score;\n            if !moved && tiles != merged_row {\n                moved = true;\n            }\n\n            for (col, tile) in merged_row.iter().rev().enumerate() {\n                self[(row, col)] = *tile;\n            }\n        }\n\n        if moved {\n            Ok(score)\n        } else {\n            Err(NoTilesMovedError)\n        }\n    }\n}\n\ntrait Ui {\n    /// Wait for a key press, and report the key.\n    fn wait_key(&mut self) -> Key;\n\n    /// Draw the game.\n    fn draw(&mut self, game: &Game) -> io::Result<()>;\n}\n\nstruct Game {\n    grid: Grid,\n    state: State,\n    score: u32,\n}\n\nimpl Game {\n    fn new() -> Self {\n        let mut g = Game {\n            grid: Grid::new(),\n            state: State::Playing,\n            score: 0,\n        };\n\n        for _ in 0..2 {\n            g.grid.spawn_tile().unwrap();\n        }\n\n        g\n    }\n\n    fn step(&mut self, key: Key) {\n        match key {\n            key if self.state != State::Lost => {\n                let move_result = match key {\n                    Key::Up => self.grid.shift_up(),\n                    Key::Down => self.grid.shift_down(),\n                    Key::Left => self.grid.shift_left(),\n                    Key::Right => self.grid.shift_right(),\n                    _ => unreachable!(),\n                };\n\n                if let Ok(score) = move_result {\n                    self.add_score(score);\n                    self.grid.spawn_tile().unwrap();\n                }\n\n                if !self.grid.is_move_available() {\n                    self.state = State::Lost;\n                    return;\n                }\n            }\n            _ => (),\n        }\n    }\n\n    fn add_score(&mut self, score: u32) {\n        self.score += score;\n        if score == 2048 {\n            self.state = State::Won;\n        }\n    }\n}\n\n#[cfg(unix)]\nmod ui_imp {\n    extern crate termion;\n\n    use super::{Game, Key, State, Ui};\n\n    use std::io::prelude::*;\n    use std::io::{self, Stdin, Stdout};\n\n    use self::termion::event::Key as TermKey;\n    use self::termion::input::Keys;\n    use self::termion::raw::{IntoRawMode, RawTerminal};\n    use self::termion::{color, cursor, style};\n\n    pub struct Termion {\n        keys: Keys<Stdin>,\n        stdout: RawTerminal<Stdout>,\n    }\n\n    impl Termion {\n        pub fn new() -> Self {\n            use ui_imp::termion::input::TermRead;\n\n            let mut stdout = io::stdout().into_raw_mode().unwrap();\n            write!(stdout, \"{}\", termion::clear::All).unwrap();\n\n            Termion {\n                keys: io::stdin().keys(),\n                stdout,\n            }\n        }\n    }\n\n    impl Ui for Termion {\n        fn wait_key(&mut self) -> Key {\n            while let Some(key) = self.keys.next() {\n                let key = match key.unwrap() {\n                    TermKey::Char('q') => Key::Quit,\n                    TermKey::Up => Key::Up,\n                    TermKey::Down => Key::Down,\n                    TermKey::Left => Key::Left,\n                    TermKey::Right => Key::Right,\n                    _ => continue,\n                };\n\n                return key;\n            }\n\n            Key::Quit\n        }\n\n        fn draw(&mut self, game: &Game) -> io::Result<()> {\n            write!(self.stdout, \"{}{}\", cursor::Hide, termion::clear::All)?;\n            write!(self.stdout, \"{}Score: {}\", cursor::Goto(16, 1), game.score)?;\n\n            const CELL_WIDTH: usize = 10;\n            const CELL_HEIGHT: usize = 5;\n            const GRID_X_OFFSET: usize = 0;\n            const GRID_Y_OFFSET: usize = 2;\n\n            for row in 0..4 {\n                for col in 0..4 {\n                    let tile = game.grid[(row, col)];\n                    let x = 1 + GRID_X_OFFSET + col * CELL_WIDTH;\n                    let y = GRID_Y_OFFSET + row * CELL_HEIGHT;\n\n                    write!(\n                        self.stdout,\n                        \"{}┌────────┐\",\n                        cursor::Goto(x as u16, y as u16)\n                    )?;\n\n                    for i in 1..=3 {\n                        let y = y + i;\n                        write!(\n                            self.stdout,\n                            \"{}│        │\",\n                            cursor::Goto(x as u16, y as u16)\n                        )?;\n                    }\n\n                    if let Some(value) = tile {\n                        let text_x = x + CELL_WIDTH / 2 - (1 + value.to_string().len() / 3);\n                        let text_y = y + CELL_HEIGHT / 2;\n\n                        write!(\n                            self.stdout,\n                            \"{}{}{}{}{}{}\",\n                            cursor::Goto(text_x as u16, text_y as u16),\n                            style::Bold,\n                            color::Fg(color::LightWhite),\n                            value,\n                            color::Fg(color::Reset),\n                            style::Reset\n                        )?;\n                    }\n\n                    write!(\n                        self.stdout,\n                        \"{}└────────┘\",\n                        cursor::Goto(x as u16, y as u16 + 4)\n                    )?;\n                }\n            }\n\n            match game.state {\n                State::Won => write!(self.stdout, \"{}You won!\", cursor::Goto(16, 12))?,\n                State::Lost => write!(self.stdout, \"{}You lost!\", cursor::Goto(16, 12))?,\n                _ => (),\n            }\n\n            write!(self.stdout, \"{}←,↑,→,↓ or q\", cursor::Goto(14, 22))?;\n\n            self.stdout.flush()?;\n            Ok(())\n        }\n    }\n}\n\n#[cfg(unix)]\nfn main() {\n    use ui_imp::Termion;\n\n    let mut game = Game::new();\n    let mut ui = Termion::new();\n\n    loop {\n        ui.draw(&game).unwrap();\n        let key = ui.wait_key();\n        if let Key::Quit = key {\n            break;\n        }\n        game.step(key);\n    }\n}\n\n#[cfg(not(unix))]\nfn main() {\n    println!(\"This solution is not supported on Windows.\");\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{Grid, GRID_DIMENSION};\n\n    #[test]\n    fn merge() {\n        let test_cases = [\n            ([None, None, None, None], [None, None, None, None]),\n            ([None, None, None, Some(2)], [Some(2), None, None, None]),\n            ([None, None, Some(2), Some(2)], [Some(4), None, None, None]),\n            ([None, Some(2), None, Some(2)], [Some(4), None, None, None]),\n            ([Some(2), None, None, Some(2)], [Some(4), None, None, None]),\n            ([Some(2), None, Some(2), None], [Some(4), None, None, None]),\n            (\n                [Some(2), Some(2), Some(2), None],\n                [Some(4), Some(2), None, None],\n            ),\n            (\n                [Some(2), None, Some(2), Some(2)],\n                [Some(4), Some(2), None, None],\n            ),\n            (\n                [Some(2), Some(2), None, Some(2)],\n                [Some(4), Some(2), None, None],\n            ),\n            (\n                [Some(2), Some(2), Some(2), Some(2)],\n                [Some(4), Some(4), None, None],\n            ),\n            (\n                [Some(4), Some(4), Some(2), Some(2)],\n                [Some(8), Some(4), None, None],\n            ),\n            (\n                [Some(2), Some(2), Some(4), Some(4)],\n                [Some(4), Some(8), None, None],\n            ),\n            (\n                [Some(8), None, Some(2), Some(2)],\n                [Some(8), Some(4), None, None],\n            ),\n            (\n                [Some(4), None, Some(2), Some(2)],\n                [Some(4), Some(4), None, None],\n            ),\n        ];\n\n        for &(candidate, expected) in &test_cases {\n            let (merged, _) = Grid::merge(&candidate);\n            assert_eq!(&merged, &expected);\n        }\n    }\n\n    #[test]\n    fn directions() {\n        let mut grid = Grid::new();\n        grid[(0, 0)] = Some(2);\n\n        grid.shift_right().unwrap();\n        assert_eq!(grid[(0, GRID_DIMENSION - 1)], Some(2));\n        println!(\"{:?}\", grid);\n\n        grid.shift_down().unwrap();\n        assert_eq!(grid[(GRID_DIMENSION - 1, GRID_DIMENSION - 1)], Some(2));\n        println!(\"{:?}\", grid);\n\n        grid.shift_left().unwrap();\n        println!(\"{:?}\", grid);\n        assert_eq!(grid[(GRID_DIMENSION - 1, 0)], Some(2));\n\n        grid.shift_up().unwrap();\n        assert_eq!(grid[(0, 0)], Some(2));\n    }\n\n    #[test]\n    fn non_greedy_movement() {\n        let mut grid = Grid::new();\n        for i in 0..4 {\n            grid[(0, i)] = Some(2);\n        }\n\n        grid.shift_right().unwrap();\n\n        let mut expected_grid = Grid::new();\n        expected_grid[(0, 2)] = Some(4);\n        expected_grid[(0, 3)] = Some(4);\n        assert_eq!(grid, expected_grid);\n    }\n\n    #[test]\n    fn move_direction_priority() {\n        let mut grid = Grid::new();\n        for i in 1..4 {\n            grid[(0, i)] = Some(2);\n        }\n\n        grid.shift_right().unwrap();\n\n        let mut expected_grid = Grid::new();\n        expected_grid[(0, 2)] = Some(2);\n        expected_grid[(0, 3)] = Some(4);\n        assert_eq!(grid, expected_grid);\n    }\n}\n",
    "path": "tasks/2048",
    "remote_code": "\nuse std::io::{self,BufRead};\nextern crate rand;\n\nenum Usermove {\n    Up,\n    Down,\n    Left,\n    Right,\n}\n\nfn print_game(field :& [[u32;4];4] ){\n    println!(\"{:?}\",&field[0] );\n    println!(\"{:?}\",&field[1] );\n    println!(\"{:?}\",&field[2] );\n    println!(\"{:?}\",&field[3] );\n}\n\nfn get_usermove()-> Usermove {\n    let umove: Usermove ;\n    loop{\n        let mut input = String::new();\n        io::stdin().read_line(&mut input).unwrap();\n\n        match input.chars().nth(0){\n            Some('a') =>{umove = Usermove::Left ;break },\n            Some('w') =>{umove = Usermove::Up   ;break },\n            Some('s') =>{umove = Usermove::Down ;break },\n            Some('d') =>{umove = Usermove::Right;break },\n            _   => {println!(\"input was {}: invalid character should be a,s,w or d \",input.chars().nth(0).unwrap());} ,\n        }\n    }\n    umove\n}\n\n//this function inplements the user moves.\n//for every element it looks if the element is zero\n// if the element is zero it looks against the direction of the movement if any\n//element is not zero then it will move it to the element its place then it will look for\n//a matching element\n//  if the element is not zero then it will look for a match if no match is found\n// then it will look for the next element\n\nfn do_game_step(step : &Usermove, field:&mut [[u32;4];4]){\n    match *step {\n        Usermove::Left =>{\n            for array in field{\n                for  col in 0..4 {\n                    for testcol in (col+1)..4 {\n                        if array[testcol] != 0 {\n                            if array[col] == 0 {\n                                array[col] += array[testcol];\n                                array[testcol] = 0;\n                            }\n                            else if array[col] == array[testcol] {\n                                array[col] += array[testcol];\n                                array[testcol] = 0;\n                                break;\n                            } else {\n                                break\n                            }\n                        }\n                    }\n                }\n            }\n        } ,\n        Usermove::Right=>{\n            for array in field{\n                for  col in (0..4).rev() {\n                    for testcol in (0..col).rev() {\n                        if array[testcol] != 0 {\n                            if array[col] == 0 {\n                                array[col] += array[testcol];\n                                array[testcol] = 0;\n                            }\n                            else if array[col] == array[testcol] {\n                                array[col] += array[testcol];\n                                array[testcol] = 0;\n                                break;\n                            }else {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        } ,\n        Usermove::Down   =>{\n            for col in 0..4 {\n                for row in (0..4).rev() {\n                    for testrow in (0..row).rev() {\n                        if field[testrow][col] != 0 {\n                            if field[row][col] == 0 {\n                                field[row][col] += field[testrow][col];\n                                field[testrow][col] = 0;\n                            } else if field[row][col] == field[testrow][col] {\n                                field[row][col] += field[testrow][col];\n                                field[testrow][col] = 0;\n                                break;\n                            }else {\n                                break;\n                            }\n\n                        }\n                    }\n                }\n            }\n        } ,\n        Usermove::Up =>{\n            for col in 0..4 {\n                for row in 0..4{\n                    for testrow in (row+1)..4 {\n                        if field[testrow][col] != 0 {\n                            if field[row][col] == 0 {\n                                field[row][col] += field[testrow][col];\n                                field[testrow][col] = 0;\n                            } else if field[row][col] == field[testrow][col] {\n                                field[row][col] += field[testrow][col];\n                                field[testrow][col] = 0;\n                                break;\n                            }else {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        },\n    }\n}\n\nfn spawn( field: &mut  [[u32;4];4]){\n    loop{\n        let x = rand::random::<usize>();\n        if field[x % 4][(x/4)%4] == 0 {\n            if x % 10 == 0 {\n                field[x % 4][(x/4)%4]= 4;\n            }else{\n                field[x % 4][(x/4)%4]= 2;\n            }\n            break;\n        }\n    }\n}\n\n\nfn main() {\n    let mut field : [[u32; 4];4] =  [[0;4];4];\n    let mut test : [[u32; 4];4] ;\n    'gameloop:loop {\n        //check if there is still an open space\n        test=field.clone();\n        spawn(&mut field);\n        //if all possible moves do not yield a change then there is no valid move left\n        //and it will be game over\n        for i in [Usermove::Up,Usermove::Down,Usermove::Left,Usermove::Right].into_iter(){\n            do_game_step(i, &mut test);\n            if test != field{\n                break;//found a valid move\n            }\n            match *i{\n                Usermove::Right=> {\n                    println!(\"No more valid move, you lose\");\n                    break 'gameloop;\n                },\n                _=>{},\n            }\n        }\n        print_game(&field);\n        println!(\"move the blocks\");\n\n        test=field.clone();\n        while test==field {\n            do_game_step(&get_usermove(), &mut field);\n        }\n\n        for row in field.iter(){\n            if row.iter().any(|x| *x == 2048){\n                print_game(&field );\n                println!(\"You Won!!\");\n                break;\n            }\n        }\n    }\n}\n",
    "title": "2048",
    "url": "http://rosettacode.org/wiki/2048"
  },
  {
    "local_code": "//! Implements with a recursive descent parser for a simple calculator (+ - * /) using the\n//! [shunting yard algorithm]. It follows operator precedence (i.e. 2 + 3 * 3 = 11), understands\n//! negation (-5 + 6 = 1), ignores whitespace and allows the use of parentheses.\n//!\n//! [shunting yard algorithm]: http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm.\n\nextern crate rand;\n\nuse std::cmp::Ordering::{self, Greater};\nuse std::f32;\nuse std::iter::Peekable;\nuse std::str::CharIndices;\n\nuse rand::distributions::Uniform;\nuse rand::prelude::*;\n\nfn main() {\n    use std::io;\n\n    let mut rng = rand::thread_rng();\n    let input = io::stdin();\n\n    loop {\n        let mut sample = Uniform::from(1..=9)\n            .sample_iter(&mut rng)\n            .take(4)\n            .collect::<Vec<_>>();\n\n        println!(\"make 24 by combining the following 4 numbers with + - * / or (q)uit\");\n        println!(\"{:?}\", sample);\n        let mut line = String::new();\n        let _ = input.read_line(&mut line).unwrap();\n        match line.trim() {\n            \"q\" => break,\n            input => {\n                if check_values(&mut sample, input) {\n                    match Parser::new(input).parse() {\n                        Ok(i) => {\n                            if (i - 24.0).abs() < f32::EPSILON {\n                                println!(\"you made it!\");\n                            } else {\n                                println!(\"you entered {}, try again!\", i);\n                            }\n                        }\n                        Err(s) => println!(\"{}\", s),\n                    };\n                } else {\n                    println!(\"unrecognized input, try again\")\n                }\n            }\n        }\n    }\n}\n\n/// Returns true if the entered expression uses the values contained in sample\npub fn check_values(sample: &mut [u32], input: &str) -> bool {\n    let lex = Lexer::new(input);\n\n    let mut numbers_used = lex\n        .filter_map(|(_, a)| match a {\n            Token::Int(i) => Some(i),\n            _ => None,\n        })\n        .collect::<Vec<u32>>();\n\n    numbers_used.sort();\n    sample.sort();\n    numbers_used == sample\n}\n\n/// the tokens that our parser is going to recognize\n#[derive(PartialEq, Eq, Debug, Copy, Clone)]\npub enum Token {\n    LParen,\n    RParen,\n    Plus,\n    Minus,\n    Slash,\n    Star,\n    Unknown,\n    Int(u32),\n}\n\nimpl Token {\n    /// are tokens associated to a binary operation?\n    fn is_binary(&self) -> bool {\n        match *self {\n            Token::Plus | Token::Minus | Token::Slash | Token::Star => true,\n            _ => false,\n        }\n    }\n}\n\npub struct Lexer<'a> {\n    input: Peekable<CharIndices<'a>>,\n}\n\nimpl<'a> Lexer<'a> {\n    pub fn new(input: &str) -> Lexer {\n        Lexer {\n            input: input.char_indices().peekable(),\n        }\n    }\n\n    fn expect<I>(iter: &mut I, expected: &[Token]) -> Result<Token, String>\n    where\n        I: Iterator<Item = (usize, Token)>,\n    {\n        match iter.next() {\n            Some((_, a)) if expected.contains(&a) => Ok(a),\n            Some((n, other)) => Err(format!(\n                \"Parsing error: {:?} was unexpected at offset {}\",\n                other, n\n            )),\n            None => Err(\"unexpected end of token list\".into()),\n        }\n    }\n}\n\nimpl<'a> Iterator for Lexer<'a> {\n    type Item = (usize, Token);\n\n    fn next(&mut self) -> Option<(usize, Token)> {\n        if let Some((idx, c)) = self\n            .input\n            .by_ref()\n            .skip_while(|&(_, c)| c.is_whitespace())\n            .next()\n        {\n            let ret = match c {\n                '(' => Token::LParen,\n                ')' => Token::RParen,\n                '+' => Token::Plus,\n                '-' => Token::Minus,\n                '/' => Token::Slash,\n                '*' => Token::Star,\n                d @ '0'..='9' => {\n                    let mut val = d.to_digit(10).unwrap();\n                    while let Some(dg) = self\n                        .input\n                        .by_ref()\n                        .peek()\n                        .and_then(|&(_, di)| di.to_digit(10))\n                    {\n                        val = val * 10 + dg;\n                        self.input.by_ref().next();\n                    }\n                    Token::Int(val)\n                }\n                _ => Token::Unknown,\n            };\n            Some((idx, ret))\n        } else {\n            None\n        }\n    }\n}\n\n/// Operators are a \"higher level\" concept than tokens as they define the semantics of the\n/// expression language e.g. token \"Minus\" can correspond to the unary Neg Operator (-a) or to the\n/// binary Sub operator (a - b)\n#[derive(PartialEq, Eq, Copy, Clone, Debug)]\npub enum Operator {\n    Neg,\n    Add,\n    Sub,\n    Mul,\n    Div,\n    Sentinel,\n}\n\nimpl Operator {\n    fn precedence(&self) -> usize {\n        match *self {\n            Operator::Sentinel => 0,\n            Operator::Add | Operator::Sub => 1,\n            Operator::Neg => 2,\n            Operator::Mul | Operator::Div => 3,\n        }\n    }\n}\n\n/// Operator precedence for binary operators:\n/// * if x has higher precedence than y precedence for x > precedence for y\n/// * if x and y have equal precedence the first one has precedence\n/// e.g. in expression (4 / 2 * 2) operators * and / have the same precedence, but the operations\n/// must be performed in the order they appear (division first, multiplication second) otherwise\n/// results are different\nimpl PartialOrd for Operator {\n    fn partial_cmp(&self, other: &Operator) -> Option<Ordering> {\n        match (self.precedence(), other.precedence()) {\n            (a, b) if a == b => Some(Greater),\n            (a, b) => a.partial_cmp(&b),\n        }\n    }\n}\n\n/// Recursive descent parser with the shunting yard algorithm as explained in the crate\n/// documentation. I followed the names of the methods as closely as possible vs. the pseudo-code\n/// that illustrates the algorithm.\npub struct Parser<'a> {\n    operators: Vec<Operator>,\n    operands: Vec<f32>,\n    lexer: Peekable<Lexer<'a>>,\n}\n\nimpl<'a> Parser<'a> {\n    pub fn new(input: &str) -> Parser {\n        Parser {\n            operators: vec![],\n            operands: vec![],\n            lexer: Lexer::new(input).peekable(),\n        }\n    }\n\n    pub fn parse(&mut self) -> Result<f32, String> {\n        self.operators.push(Operator::Sentinel);\n        self.e()?;\n        self.operands\n            .last()\n            .cloned()\n            .ok_or_else(|| String::from(\"something went wrong, got no result\"))\n    }\n\n    fn e(&mut self) -> Result<(), String> {\n        self.p()?;\n        while let Some(&(_, x)) = self.lexer.by_ref().peek() {\n            if !x.is_binary() {\n                break;\n            }\n\n            let op = match x {\n                Token::Plus => Operator::Add,\n                Token::Minus => Operator::Sub,\n                Token::Star => Operator::Mul,\n                Token::Slash => Operator::Div,\n                // there are no other binary operators\n                _ => unreachable!(),\n            };\n            self.push_operator(op);\n\n            // Consume the peeked value\n            self.lexer.by_ref().next();\n            self.p()?;\n        }\n\n        while let Some(&op) = self.operators.last() {\n            if op == Operator::Sentinel {\n                return Ok(());\n            }\n            self.pop_operator();\n        }\n        unreachable!() // algorithm fail: reached the end without finding\n                       // the sentinel\n    }\n\n    fn p(&mut self) -> Result<(), String> {\n        match self.lexer.by_ref().next() {\n            Some((_, Token::Int(n))) => self.operands.push(n as f32),\n            Some((_, Token::LParen)) => {\n                self.operators.push(Operator::Sentinel);\n                self.e()?;\n                Lexer::expect(&mut self.lexer, &[Token::RParen])?;\n                self.operators.pop();\n            }\n            Some((_, Token::Minus)) => {\n                self.push_operator(Operator::Neg);\n                self.p()?;\n            }\n            Some((p, e)) => return Err(format!(\"unexpected token {:?} at pos {}\", e, p)),\n            _ => return Err(\"unexpected end of command\".to_string()),\n        }\n        Ok(())\n    }\n\n    fn pop_operator(&mut self) {\n        match self.operators.pop() {\n            Some(Operator::Add) => self.binary_op(|t1, t2| t1 + t2),\n            Some(Operator::Sub) => self.binary_op(|t1, t2| t1 - t2),\n            Some(Operator::Mul) => self.binary_op(|t1, t2| t1 * t2),\n            Some(Operator::Div) => self.binary_op(|t1, t2| t1 / t2),\n            Some(Operator::Neg) => self.unary_op(|t1| -t1),\n            _ => unreachable!(),\n        }\n    }\n\n    fn push_operator(&mut self, op: Operator) {\n        match self.operators.last() {\n            Some(&last_op) if last_op > op => self.pop_operator(),\n            _ => {}\n        }\n        self.operators.push(op);\n    }\n\n    #[inline]\n    fn binary_op<F>(&mut self, op: F)\n    where\n        F: Fn(f32, f32) -> f32,\n    {\n        match (self.operands.pop(), self.operands.pop()) {\n            (Some(t1), Some(t2)) => self.operands.push(op(t2, t1)),\n            _ => unreachable!(),\n        }\n    }\n\n    #[inline]\n    fn unary_op<F>(&mut self, op: F)\n    where\n        F: Fn(f32) -> f32,\n    {\n        match self.operands.pop() {\n            Some(t1) => self.operands.push(op(t1)),\n            _ => unreachable!(),\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::check_values;\n    use super::Operator::{Add, Div, Mul, Sub};\n    use super::Token::{Int, LParen, Plus, RParen, Slash, Star};\n    use super::{Lexer, Parser, Token};\n\n    #[test]\n    fn test_precedence() {\n        assert!(Mul > Add);\n        // Ordering matters for these pairs\n        assert!(Mul > Div);\n        assert!(Div > Mul);\n\n        assert!(Add > Sub);\n        assert!(Sub > Add);\n\n        assert!(!(Mul < Div));\n    }\n\n    #[test]\n    fn lexer_iter() {\n        // test read token and character's offset in the iterator\n        let t = |lex: &mut Lexer, exp_tok: Token, exp_pos: usize| {\n            assert_eq!(lex.next(), Some((exp_pos, exp_tok)));\n        };\n\n        let tok = &mut Lexer::new(\"  15 + 4\");\n        t(tok, Int(15), 2);\n        t(tok, Plus, 5);\n        let read = Lexer::expect(tok, &[LParen, Int(4), RParen]);\n        assert_eq!(read, Ok(Int(4)));\n\n        let mut tok = Lexer::new(\"\");\n        assert_eq!(tok.next(), None);\n\n        let tok = &mut Lexer::new(\"     \");\n        assert_eq!(tok.next(), None);\n\n        let tok = &mut Lexer::new(\"2 * (3+4/2)\");\n        t(tok, Int(2), 0);\n        t(tok, Star, 2);\n        t(tok, LParen, 4);\n        t(tok, Int(3), 5);\n        t(tok, Plus, 6);\n        t(tok, Int(4), 7);\n        t(tok, Slash, 8);\n        t(tok, Int(2), 9);\n        t(tok, RParen, 10);\n    }\n\n    #[test]\n    fn parse() {\n        fn t(input: &str, expected: Result<f32, String>) {\n            assert_eq!(Parser::new(input).parse(), expected)\n        }\n\n        t(\"2+2\", Ok(4.));\n        t(\"2+3*4\", Ok(14.));\n        t(\"4*(3+2)\", Ok(20.));\n        t(\"5/(3+2)*3\", Ok(3.));\n        t(\"2++12\", Err(\"unexpected token Plus at pos 2\".to_string()));\n        t(\"-2+12\", Ok(10.));\n        t(\"-2*(2+3)\", Ok(-10.));\n\n        // Testing precedence\n        t(\"4 / 2 * 2\", Ok(4.));\n        t(\"2 * 2 / 4\", Ok(1.));\n    }\n\n    #[test]\n    fn try_check_values() {\n        let m = &mut [1, 2, 3, 4];\n        assert!(check_values(m, \"1+3 -(4/2)\"));\n        // new testcase for #314\n        assert!(check_values(m, \"1+2+3+4\"));\n    }\n}\n//! Modeled after [the Scala solution]\n//!\n//! [the Scala solution]: http://rosettacode.org/wiki/24_game/Solve#Scala\n\n#![feature(slice_patterns)]\n\nextern crate num;\nextern crate permutohedron;\n\nuse num::rational::{Ratio, Rational};\nuse num::traits::Zero;\nuse permutohedron::Heap;\n\n/// convenience macro to create a fixed-sized vector of rationals by writing `rational![1, 2, ...]`\n/// instead of `[Ratio::<isize>::from_integer(1), Ratio::<isize>::from_integer(2), ...]`\nmacro_rules! rationals(\n    ($($e:expr),+) => ([$(Ratio::<isize>::from_integer($e)),+])\n);\n\nfn main() {\n    let mut r = rationals![1, 3, 7, 9];\n    let sol = solve(&mut r, 24).unwrap_or_else(|| \"no solution found\".to_string());\n    println!(\"{}\", sol);\n}\n\n/// for a vector of rationals r, find the combination of arithmetic operations that yield\n/// `target_val` as a result (if such combination exists)\nfn solve(r: &mut [Rational], target_val: isize) -> Option<String> {\n    // need to sort because next_permutation()\n    // returns permutations in lexicographic order\n    r.sort();\n    loop {\n        let all_ops = compute_all_operations(r);\n        for &(res, ref ops) in &all_ops {\n            if res == Ratio::from_integer(target_val) {\n                return Some(ops.to_string());\n            }\n        }\n        let mut perm = Heap::new(r);\n        if perm.next_permutation() == None {\n            return None;\n        }\n    }\n}\n\n/// applies all the valid combinations of + - * and / to the numbers in l and for each combination\n/// creates a tuple with the result and the expression in String form returns all (result,\n/// expression in string form) results in a vector\nfn compute_all_operations(l: &[Rational]) -> Vec<(Rational, String)> {\n    match *l {\n        [] => vec![],\n        [x] => vec![(x, (format!(\"{}\", x)))],\n        [x, ref rest @ ..] => {\n            let mut rt = Vec::new();\n            for &(y, ref exp) in &compute_all_operations(rest) {\n                let mut sub = vec![(x * y, \"*\"), (x + y, \"+\"), (x - y, \"-\")];\n                if y != Zero::zero() {\n                    sub.push((x / y, \"/\"));\n                }\n                for &(z, op) in &sub {\n                    let aux = (z, (format!(\"({} {} {})\", x, op, exp)));\n                    rt.push(aux);\n                }\n            }\n            rt\n        }\n    }\n}\n\n#[test]\nfn test_rationals_macro() {\n    assert_eq!(\n        // without the rationals! macro\n        [\n            Ratio::from_integer(1),\n            Ratio::from_integer(2),\n            Ratio::from_integer(3),\n            Ratio::from_integer(4)\n        ],\n        // with the rationals! macro\n        (rationals![1, 2, 3, 4])\n    );\n}\n\n#[test]\n#[ignore]\nfn test_solve() {\n    let mut r = rationals![1, 3, 7, 9];\n    assert_eq!(solve(&mut r, 24), Some(\"(9 / (3 / (1 + 7)))\".to_string()));\n}\n//! Uses RPN expression\n\nextern crate rand;\n\nfn main() {\n    use rand::Rng;\n    use std::io::{self, Write};\n\n    let mut rng = rand::thread_rng();\n    let stdin = io::stdin();\n    let mut stdout = io::stdout();\n\n    // generating 4 numbers\n    let choices: Vec<u32> = (0..4).map(|_| rng.gen_range(1, 10)).collect();\n    println!(\"Make 24 with the following numbers\");\n\n    // start the game loop\n    let mut buffer = String::new();\n    loop {\n        println!(\n            \"Your numbers: {}, {}, {}, {}\",\n            choices[0], choices[1], choices[2], choices[3]\n        );\n        buffer.clear();\n        stdin.read_line(&mut buffer).expect(\"Failed to read line!\");\n        match check_input(&buffer[..], &choices[..]) {\n            Ok(()) => {\n                println!(\"Good job!\");\n                break;\n            }\n            Err(e) => println!(\"{}\", e),\n        }\n        print!(\"Try again? (y/n): \");\n        stdout.flush().unwrap();\n        buffer.clear();\n        stdin.read_line(&mut buffer).expect(\"Failed to read line!\");\n        if buffer.trim() != \"y\" {\n            break;\n        }\n    }\n}\n\nfn check_input(expr: &str, choices: &[u32]) -> Result<(), String> {\n    let mut stack: Vec<u32> = Vec::new();\n    for token in expr.split_whitespace() {\n        if is_operator(token) {\n            let (a, b) = (stack.pop(), stack.pop());\n            match (a, b) {\n                (Some(x), Some(y)) => stack.push(evaluate(y, x, token)),\n                (_, _) => return Err(\"Not a valid RPN expression!\".to_string()),\n            }\n        } else {\n            match token.parse::<u32>() {\n                Ok(n) => {\n                    // check if the number is valid\n                    if !choices.contains(&n) {\n                        return Err(format!(\"Cannot use {}\", n));\n                    }\n                    stack.push(n)\n                }\n                Err(_) => return Err(format!(\"Invalid input: {}\", token)),\n            }\n        }\n    }\n\n    let ans = stack.pop();\n    if !stack.is_empty() {\n        return Err(\"Not a valid RPN expression!\".to_string());\n    }\n    match ans {\n        Some(x) if x == 24 => Ok(()),\n        Some(x) => Err(format!(\"Wrong answer. Result: {}\", x)),\n        None => Err(\"Error encountered!\".to_string()),\n    }\n}\n\nfn evaluate(a: u32, b: u32, op: &str) -> u32 {\n    match op {\n        \"+\" => a + b,\n        \"-\" => a - b,\n        \"*\" => a * b,\n        \"/\" => a / b,\n        _ => unreachable!(),\n    }\n}\n\nfn is_operator(op: &str) -> bool {\n    [\"*\", \"-\", \"+\", \"/\"].contains(&op)\n}\n\n#[cfg(tests)]\nmod tests {\n    const v1: [u32; 4] = [4u32, 3, 6, 2];\n\n    #[test]\n    fn correct_result() {\n        assert_eq!(check_input(\"4 3 * 6 2 * +\", &v1), Ok(()));\n    }\n\n    #[test]\n    fn incorrect_result() {\n        assert_eq!(\n            check_input(\"4 3 * 2 6 + -\", &v1),\n            Err(\"Wrong answer. Result: 4\".to_string())\n        );\n    }\n\n    #[test]\n    fn wrong_numbers_in_input() {\n        assert_eq!(\n            check_input(\"4 5 + 6 2 * -\", &v1),\n            Err(\"Cannot use 5\".to_string())\n        );\n    }\n\n    #[test]\n    fn invalid_chars_in_input() {\n        assert_eq!(\n            check_input(\"4 ) + _ 2 * -\", &v1),\n            Err(\"Invalid input: )\".to_string())\n        );\n    }\n\n    fn invalid_rpn_expression() {\n        assert_eq!(\n            check_input(\"4 3 + 6 2 *\", &v1),\n            Err(\"Not a valid RPN expression!\".to_string())\n        );\n    }\n}\n",
    "path": "tasks/24-game",
    "remote_code": "use std::io::{self,BufRead};\nextern crate rand;\nuse rand::Rng;\n\nfn op_type(x: char) -> i32{\n    match x {\n        '-' | '+' => return 1,\n        '/' | '*' => return 2,\n        '(' | ')' => return -1,\n        _   => return 0,\n    }\n}\n\nfn to_rpn(input: &mut String){\n\n    let mut rpn_string : String = String::new();\n    let mut rpn_stack : String = String::new();\n    let mut last_token = '#';\n    for token in input.chars(){\n        if token.is_digit(10) {\n            rpn_string.push(token);\n        }\n        else if op_type(token) == 0 {\n            continue;\n        }\n        else if op_type(token) > op_type(last_token) || token == '(' {\n                rpn_stack.push(token);\n                last_token=token;\n        }\n        else {\n            while let Some(top) = rpn_stack.pop() {\n                if top=='(' {\n                    break;\n                }\n                rpn_string.push(top);\n            }\n            if token != ')'{\n                rpn_stack.push(token);\n            }\n        }\n    }\n    while let Some(top) = rpn_stack.pop() {\n        rpn_string.push(top);\n    }\n\n    println!(\"you formula results in {}\", rpn_string);\n\n    *input=rpn_string;\n}\n\nfn calculate(input: &String, list : &mut [u32;4]) -> f32{\n    let mut stack : Vec<f32> = Vec::new();\n    let mut accumulator : f32 = 0.0;\n\n    for token in input.chars(){\n        if token.is_digit(10) {\n            let test = token.to_digit(10).unwrap() as u32;\n            match list.iter().position(|&x| x == test){\n                Some(idx) => list[idx]=10 ,\n                _         => println!(\" invalid digit: {} \",test),\n            }\n            stack.push(accumulator);\n            accumulator = test as f32;\n        }else{\n            let a = stack.pop().unwrap();\n            accumulator = match token {\n                '-' => a-accumulator,\n                '+' => a+accumulator,\n                '/' => a/accumulator,\n                '*' => a*accumulator,\n                _ => {accumulator},//NOP\n            };\n        }\n    }\n    println!(\"you formula results in {}\",accumulator);\n    accumulator\n}\n\nfn main() {\n\n    let mut rng = rand::thread_rng();\n    let mut list :[u32;4]=[rng.gen::<u32>()%10,rng.gen::<u32>()%10,rng.gen::<u32>()%10,rng.gen::<u32>()%10];\n\n    println!(\"form 24 with using + - / * {:?}\",list);\n    //get user input\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    //convert to rpn\n    to_rpn(&mut input);\n    let result = calculate(&input, &mut list);\n\n    if list.iter().any(|&list| list !=10){\n        println!(\"and you used all numbers\");\n        match result {\n            24.0 => println!(\"you won\"),\n            _ => println!(\"but your formulla doesn't result in 24\"),\n        }\n    }else{\n        println!(\"you didn't use all the numbers\");\n    }\n\n}",
    "title": "24 game",
    "url": "http://rosettacode.org/wiki/24_game"
  },
  {
    "local_code": "//! Modeled after [the Scala solution]\n//!\n//! [the Scala solution]: http://rosettacode.org/wiki/24_game/Solve#Scala\n\n#![feature(slice_patterns)]\n\nextern crate num;\nextern crate permutohedron;\n\nuse num::rational::{Ratio, Rational};\nuse num::traits::Zero;\nuse permutohedron::Heap;\n\n/// convenience macro to create a fixed-sized vector of rationals by writing `rational![1, 2, ...]`\n/// instead of `[Ratio::<isize>::from_integer(1), Ratio::<isize>::from_integer(2), ...]`\nmacro_rules! rationals(\n    ($($e:expr),+) => ([$(Ratio::<isize>::from_integer($e)),+])\n);\n\nfn main() {\n    let mut r = rationals![1, 3, 7, 9];\n    let sol = solve(&mut r, 24).unwrap_or_else(|| \"no solution found\".to_string());\n    println!(\"{}\", sol);\n}\n\n/// for a vector of rationals r, find the combination of arithmetic operations that yield\n/// `target_val` as a result (if such combination exists)\nfn solve(r: &mut [Rational], target_val: isize) -> Option<String> {\n    // need to sort because next_permutation()\n    // returns permutations in lexicographic order\n    r.sort();\n    loop {\n        let all_ops = compute_all_operations(r);\n        for &(res, ref ops) in &all_ops {\n            if res == Ratio::from_integer(target_val) {\n                return Some(ops.to_string());\n            }\n        }\n        let mut perm = Heap::new(r);\n        if perm.next_permutation() == None {\n            return None;\n        }\n    }\n}\n\n/// applies all the valid combinations of + - * and / to the numbers in l and for each combination\n/// creates a tuple with the result and the expression in String form returns all (result,\n/// expression in string form) results in a vector\nfn compute_all_operations(l: &[Rational]) -> Vec<(Rational, String)> {\n    match *l {\n        [] => vec![],\n        [x] => vec![(x, (format!(\"{}\", x)))],\n        [x, ref rest @ ..] => {\n            let mut rt = Vec::new();\n            for &(y, ref exp) in &compute_all_operations(rest) {\n                let mut sub = vec![(x * y, \"*\"), (x + y, \"+\"), (x - y, \"-\")];\n                if y != Zero::zero() {\n                    sub.push((x / y, \"/\"));\n                }\n                for &(z, op) in &sub {\n                    let aux = (z, (format!(\"({} {} {})\", x, op, exp)));\n                    rt.push(aux);\n                }\n            }\n            rt\n        }\n    }\n}\n\n#[test]\nfn test_rationals_macro() {\n    assert_eq!(\n        // without the rationals! macro\n        [\n            Ratio::from_integer(1),\n            Ratio::from_integer(2),\n            Ratio::from_integer(3),\n            Ratio::from_integer(4)\n        ],\n        // with the rationals! macro\n        (rationals![1, 2, 3, 4])\n    );\n}\n\n#[test]\n#[ignore]\nfn test_solve() {\n    let mut r = rationals![1, 3, 7, 9];\n    assert_eq!(solve(&mut r, 24), Some(\"(9 / (3 / (1 + 7)))\".to_string()));\n}\n",
    "path": "tasks/24-game/solve",
    "remote_code": "#[derive(Clone, Copy, Debug)]\nenum Operator {\n    Sub,\n    Plus,\n    Mul,\n    Div,\n}\n\n#[derive(Clone, Debug)]\nstruct Factor {\n    content: String,\n    value: i32,\n}\n\nfn apply(op: Operator, left: &[Factor], right: &[Factor]) -> Vec<Factor> {\n    let mut ret = Vec::new();\n    for l in left.iter() {\n        for r in right.iter() {\n            use Operator::*;\n            ret.push(match op {\n                Sub if l.value > r.value => Factor {\n                    content: format!(\"({} - {})\", l.content, r.content),\n                    value: l.value - r.value,\n                },\n                Plus => Factor {\n                    content: format!(\"({} + {})\", l.content, r.content),\n                    value: l.value + r.value,\n                },\n                Mul => Factor {\n                    content: format!(\"({} x {})\", l.content, r.content),\n                    value: l.value * r.value,\n                },\n                Div if l.value >= r.value && r.value > 0 && l.value % r.value == 0 => Factor {\n                    content: format!(\"({} / {})\", l.content, r.content),\n                    value: l.value / r.value,\n                },\n                _ => continue,\n            })\n        }\n    }\n    ret\n}\n\nfn calc(op: [Operator; 3], numbers: [i32; 4]) -> Vec<Factor> {\n    fn calc(op: &[Operator], numbers: &[i32], acc: &[Factor]) -> Vec<Factor> {\n        use Operator::*;\n        if op.is_empty() {\n            return Vec::from(acc)\n        }\n        let mut ret = Vec::new();\n        let mono_factor = [Factor {\n            content: numbers[0].to_string(),\n            value: numbers[0],\n        }];\n        match op[0] {\n            Mul => ret.extend_from_slice(&apply(op[0], acc, &mono_factor)),\n            Div => {\n                ret.extend_from_slice(&apply(op[0], acc, &mono_factor));\n                ret.extend_from_slice(&apply(op[0], &mono_factor, acc));\n            },\n            Sub => {\n                ret.extend_from_slice(&apply(op[0], acc, &mono_factor));\n                ret.extend_from_slice(&apply(op[0], &mono_factor, acc));\n            },\n            Plus => ret.extend_from_slice(&apply(op[0], acc, &mono_factor)),   \n        }\n        calc(&op[1..], &numbers[1..], &ret)\n    }\n    calc(&op, &numbers[1..], &[Factor { content: numbers[0].to_string(), value: numbers[0] }])\n}\n\nfn solutions(numbers: [i32; 4]) -> Vec<Factor> {\n    use std::collections::hash_set::HashSet;\n    let mut ret = Vec::new();\n    let mut hash_set = HashSet::new();\n    \n    for ops in OpIter(0) {\n        for o in orders().iter() {\n            let numbers = apply_order(numbers, o);\n            let r = calc(ops, numbers);\n            ret.extend(r.into_iter().filter(|&Factor { value, ref content }| value == 24 && hash_set.insert(content.to_owned())))\n        }\n    }\n    ret\n}\n\nfn main() {\n    let mut numbers = Vec::new();\n    if let Some(input) = std::env::args().skip(1).next() {\n        for c in input.chars() {\n            if let Ok(n) = c.to_string().parse() {\n                numbers.push(n)\n            }\n            if numbers.len() == 4 {\n                let numbers = [numbers[0], numbers[1], numbers[2], numbers[3]];\n                let solutions = solutions(numbers);\n                let len = solutions.len();\n                if len == 0 {\n                    println!(\"no solution for {}, {}, {}, {}\", numbers[0], numbers[1], numbers[2], numbers[3]);\n                    return\n                }\n                println!(\"solutions for {}, {}, {}, {}\", numbers[0], numbers[1], numbers[2], numbers[3]);\n                for s in solutions {\n                    println!(\"{}\", s.content)\n                }\n                println!(\"{} solutions found\", len);\n                return\n            }\n        }\n    } else {\n        println!(\"empty input\")\n    }\n}\n\n\nstruct OpIter (usize);\n\nimpl Iterator for OpIter {\n    type Item = [Operator; 3];\n    fn next(&mut self) -> Option<[Operator; 3]> {\n        use Operator::*;\n        const OPTIONS: [Operator; 4] = [Mul, Sub, Plus, Div];\n        if self.0 >= 1 << 6 {\n            return None\n        }\n        let f1 = OPTIONS[(self.0 & (3 << 4)) >> 4];\n        let f2 = OPTIONS[(self.0 & (3 << 2)) >> 2];\n        let f3 = OPTIONS[(self.0 & (3 << 0)) >> 0];\n        self.0 += 1;\n        Some([f1, f2, f3])\n    }\n}\n\nfn orders() -> [[usize; 4]; 24] {\n    [\n        [0, 1, 2, 3],\n        [0, 1, 3, 2],\n        [0, 2, 1, 3],\n        [0, 2, 3, 1],\n        [0, 3, 1, 2],\n        [0, 3, 2, 1],\n        [1, 0, 2, 3],\n        [1, 0, 3, 2],\n        [1, 2, 0, 3],\n        [1, 2, 3, 0],\n        [1, 3, 0, 2],\n        [1, 3, 2, 0],\n        [2, 0, 1, 3],\n        [2, 0, 3, 1],\n        [2, 1, 0, 3],\n        [2, 1, 3, 0],\n        [2, 3, 0, 1],\n        [2, 3, 1, 0],\n        [3, 0, 1, 2],\n        [3, 0, 2, 1],\n        [3, 1, 0, 2],\n        [3, 1, 2, 0],\n        [3, 2, 0, 1],\n        [3, 2, 1, 0]\n    ]\n}\n\nfn apply_order(numbers: [i32; 4], order: &[usize; 4]) -> [i32; 4] {\n    [numbers[order[0]], numbers[order[1]], numbers[order[2]], numbers[order[3]]]\n}\n",
    "title": "24 game/Solve",
    "url": "http://rosettacode.org/wiki/24_game/Solve"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n#![feature(inclusive_range_syntax)]\n\nfn is_unique(a: u8, b: u8, c: u8, d: u8, e: u8, f: u8, g: u8) -> bool {\n    a != b && a != c && a != d && a != e && a != f && a != g &&\n    b != c && b != d && b != e && b != f && b != g &&\n    c != d && c != e && c != f && c != g &&\n    d != e && d != f && d != g &&\n    e != f && e != g &&\n    f != g\n}\n\nfn is_solution(a: u8, b: u8, c: u8, d: u8, e: u8, f: u8, g: u8) -> bool {\n    a + b == b + c + d &&\n        b + c + d == d + e + f &&\n        d + e + f == f + g\n}\n\nfn four_squares(low: u8, high: u8, unique: bool) -> Vec<Vec<u8>> {\n    let mut results: Vec<Vec<u8>> = Vec::new();\n\n    for a in low..=high {\n        for b in low..=high {\n            for c in low..=high {\n                for d in low..=high {\n                    for e in low..=high {\n                        for f in low..=high {\n                            for g in low..=high {\n                                if (!unique || is_unique(a, b, c, d, e, f, g)) &&\n                                    is_solution(a, b, c, d, e, f, g) {\n                                    results.push(vec![a, b, c, d, e, f, g]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    results\n}\n\nfn print_results(solutions: &Vec<Vec<u8>>) {\n    for solution in solutions {\n        println!(\"{:?}\", solution)\n    }\n}\n\nfn print_results_summary(solutions: usize, low: u8, high: u8, unique: bool) {\n    let uniqueness = if unique {\n        \"unique\"\n    } else {\n        \"non-unique\"\n    };\n    println!(\"{} {} solutions in {} to {} range\", solutions, uniqueness, low, high)\n}\n\nfn uniques(low: u8, high: u8) {\n    let solutions = four_squares(low, high, true);\n    print_results(&solutions);\n    print_results_summary(solutions.len(), low, high, true);\n}\n\nfn nonuniques(low: u8, high: u8) {\n    let solutions = four_squares(low, high, false);\n    print_results_summary(solutions.len(), low, high, false);\n}\n\nfn main() {\n    uniques(1, 7);\n    println!();\n    uniques(3, 9);\n    println!();\n    nonuniques(0, 9);\n}\n",
    "title": "4-rings or 4-squares puzzle",
    "url": "http://rosettacode.org/wiki/4-rings_or_4-squares_puzzle"
  },
  {
    "local_code": "extern crate num;\n\nuse num::{BigUint, One, Zero};\nuse std::cmp::min;\n\npub struct Solver {\n    /// The `cache` is a private implementation detail,\n    /// it would be an improvement to throw away unused values\n    /// from the cache (to reduce memory for larger inputs)\n    cache: Vec<Vec<BigUint>>,\n}\n\nimpl Solver {\n    pub fn new() -> Solver {\n        // Setup the cache with the initial row\n        Solver {\n            cache: vec![vec![One::one()]],\n        }\n    }\n\n    /// Returns a string representing a line\n    pub fn row_string(&mut self, idx: usize) -> String {\n        let r = self.cumulative(idx);\n\n        (0..idx)\n            .map(|i| &r[i + 1] - &r[i])\n            .map(|n| n.to_string())\n            .collect::<Vec<String>>()\n            .join(\", \")\n    }\n\n    /// Convenience method to access the last column in a culmulated calculation\n    pub fn row_sum(&mut self, idx: usize) -> &BigUint {\n        // This can never fail as we always add zero or one, so it's never empty.\n        self.cumulative(idx).last().unwrap()\n    }\n\n    fn cumulative(&mut self, idx: usize) -> &[BigUint] {\n        for l in self.cache.len()..idx + 1 {\n            let mut r: Vec<BigUint> = vec![Zero::zero()];\n\n            for x in 1..l + 1 {\n                let w = {\n                    let y = &r[x - 1];\n                    let z = &self.cache[l - x][min(x, l - x)];\n                    y + z\n                };\n                r.push(w)\n            }\n            self.cache.push(r);\n        }\n\n        &self.cache[idx][..]\n    }\n}\n\nimpl Default for Solver {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nfn main() {\n    let mut solver = Solver::new();\n\n    println!(\"rows\");\n    for n in 1..11 {\n        println!(\"{}: {}\", n, solver.row_string(n));\n    }\n\n    println!(\"sums\");\n    for &y in &[23, 123, 1234, 12_345] {\n        println!(\"{}: {}\", y, solver.row_sum(y));\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Solver;\n    use num::BigUint;\n\n    #[test]\n    fn cumulative() {\n        let mut solver = Solver::new();\n        let mut t = |n: usize, expected: &str| {\n            assert_eq!(solver.row_sum(n), &expected.parse::<BigUint>().unwrap());\n        };\n\n        t(23, \"1255\");\n        t(123, \"2552338241\");\n        t(1234, \"156978797223733228787865722354959930\");\n    }\n\n    #[test]\n    fn row() {\n        let mut solver = Solver::new();\n        let mut t = |n: usize, expected: &str| {\n            assert_eq!(solver.row_string(n), expected);\n        };\n\n        t(1, \"1\");\n        t(2, \"1, 1\");\n        t(3, \"1, 1, 1\");\n        t(4, \"1, 2, 1, 1\");\n        t(5, \"1, 2, 2, 1, 1\");\n        t(6, \"1, 3, 3, 2, 1, 1\");\n    }\n}\n",
    "path": "tasks/9-billion-names-of-god-the-integer",
    "remote_code": "extern crate num;\n\nuse std::cmp;\nuse num::bigint::BigUint;\n\nfn cumu(n: usize, cache: &mut Vec<Vec<BigUint>>) {\n    for l in cache.len()..n+1 {\n        let mut r = vec![BigUint::from(0u32)];\n        for x in 1..l+1 {\n            let prev = r[r.len() - 1].clone();\n            r.push(prev + cache[l-x][cmp::min(x, l-x)].clone());\n        }\n        cache.push(r);\n    }\n}\n\nfn row(n: usize, cache: &mut Vec<Vec<BigUint>>) -> Vec<BigUint> {\n    cumu(n, cache);\n    let r = &cache[n];\n    let mut v: Vec<BigUint> = Vec::new();\n\n    for i in 0..n {\n        v.push(&r[i+1] - &r[i]);\n    }\n    v\n}\n\nfn main() {\n    let mut cache = vec![vec![BigUint::from(1u32)]];\n\n    println!(\"rows:\");\n    for x in 1..26 {\n        let v: Vec<String> = row(x, &mut cache).iter().map(|e| e.to_string()).collect();\n        let s: String = v.join(\" \");\n        println!(\"{}: {}\", x, s);\n    }\n\n    println!(\"sums:\");\n    for x in vec![23, 123, 1234, 12345] {\n        cumu(x, &mut cache);\n        let v = &cache[x];\n        let s = v[v.len() - 1].to_string();\n        println!(\"{}: {}\", x, s);\n    }\n}",
    "title": "9 billion names of God the integer",
    "url": "http://rosettacode.org/wiki/9_billion_names_of_God_the_integer"
  },
  {
    "local_code": "use std::string::String;\n\nfn main() {\n    for num_bottles in (1u32..100).rev() {\n        println!(\"{}\", bottles_line(num_bottles, true));\n        println!(\"{}\", bottles_line(num_bottles, false));\n        println!(\"Take one down, pass it around...\");\n        println!(\"{}\", bottles_line(num_bottles - 1, true));\n        println!(\"-----------------------------------\");\n    }\n}\n\nfn bottles_line(num_bottles: u32, on_the_wall: bool) -> String {\n    let tail = if on_the_wall {\n        \"of beer on the wall!\\n\"\n    } else {\n        \"of beer\\n\"\n    };\n\n    match num_bottles {\n        0 => format!(\"No bottles {}\", tail),\n        1 => format!(\"One bottle {}\", tail),\n        n => format!(\"{} bottles {}\", n, tail),\n    }\n}\n\n#[test]\nfn gen_bottle_line() {\n    let ln = bottles_line(42, false);\n    let ln2 = bottles_line(42, true);\n\n    assert_eq!(ln, \"42 bottles of beer\\n\");\n    assert_eq!(ln2, \"42 bottles of beer on the wall!\\n\");\n}\n",
    "path": "tasks/99-bottles-of-beer",
    "remote_code": "fn main() {\n\tfor n in (0..100).rev() {\n\t\tmatch n {\n\t\t\t0 => {\n\t\t\t\tprintln!(\"No more bottles of beer on the wall, no more bottles of beer.\");\n\t\t\t\tprintln!(\"Go to the store and buy some more, 99 bottles of beer on the wall.\");\n\t\t\t},\n\t\t\t1 => {\n\t\t\t\tprintln!(\"1 bottle of beer on the wall, 1 bottle of beer.\");\n\t\t\t\tprintln!(\"Take one down and pass it around, no more bottles of beer on the wall.\\n\");\n\t\t\t},\n\t\t\t_ => {\n\t\t\t\tprintln!(\"{0:?} bottles of beer on the wall, {0:?} bottles of beer.\", n);\n\t\t\t\tprintln!(\"Take one down and pass it around, {} bottles of beer on the wall.\\n\", n-1);\n\t\t\t},\n\t\t}\n\t}\n}",
    "title": "99 Bottles of Beer",
    "url": "http://rosettacode.org/wiki/99_Bottles_of_Beer"
  },
  {
    "local_code": "use std::io;\n\nfn main() {\n    let mut input = String::new();\n    let _ = io::stdin().read_line(&mut input).unwrap();\n    let words = input\n        .split_whitespace()\n        .take(2)\n        .map(|i| i.parse::<i32>().ok())\n        .collect::<Vec<Option<i32>>>();\n\n    let err_msg = \"Please enter 2 integers\";\n    let sum = if words.len() == 2 {\n        words[0].expect(err_msg) + words[1].expect(err_msg)\n    } else {\n        panic!(err_msg)\n    };\n\n    println!(\"{}\", sum);\n}\n",
    "path": "tasks/a-plus-b",
    "remote_code": "use std::io;\n\nfn main() {\n    let mut line = String::new();\n    io::stdin().read_line(&mut line).expect(\"reading stdin\");\n\n    let mut i: i64 = 0;\n    for word in line.split_whitespace() {\n        i += word.parse::<i64>().expect(\"trying to interpret your input as numbers\");\n    }\n    println!(\"{}\", i);\n}",
    "title": "A+B",
    "url": "http://rosettacode.org/wiki/A%2BB"
  },
  {
    "local_code": "use std::collections::HashSet;\n\nconst WORDS: &[&str] = &[\"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\"];\n\nconst BLOCKS: &[&str] = &[\n    \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\", \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\",\n    \"FS\", \"LY\", \"PC\", \"ZM\",\n];\n\nfn main() {\n    println!(\"******\\nmethod 1\\n******\");\n    for word in WORDS {\n        println!(\"can {} be built? {}\", word, can_be_built_input_first(*word))\n    }\n\n    println!(\"\\n******\\nmethod 2\\n******\");\n    for word in WORDS {\n        println!(\n            \"can {} be built? {}\",\n            word,\n            can_be_built_blocks_first(*word)\n        )\n    }\n}\n\n/// First method (common solution among other languages)\n///\n/// Iterates through the letters of the input and checks if there is a suitable\n/// *unused* block for each letter\nfn can_be_built_input_first(input: &str) -> bool {\n    let mut used = HashSet::new();\n\n    for chr in input.chars() {\n        for (ind, block) in BLOCKS.iter().enumerate() {\n            if !used.contains(&ind) && block.contains(chr) {\n                used.insert(ind);\n                break;\n            }\n        }\n    }\n\n    // If the number of used indices is equal to the input length, then we\n    // have can successfully make the word with the blocks.\n    used.len() == input.len()\n}\n\n/// Second method\n///\n/// Iterates over the blocks. For each block it checks if it can be used for one\n/// of the characters in the input that hasn't already been fulfilled.\n/// It should be more efficient than the first method whenever there are more\n/// blocks than characters in the input.\nfn can_be_built_blocks_first(input: &str) -> bool {\n    let mut matched = HashSet::new();\n\n    BLOCKS.iter().any(|block| {\n        for letter in block.chars() {\n            let needle = input.char_indices().find(|&(i, c)| {\n                // See if any of the letters in the block can be used for this word\n                c == letter && !matched.contains(&i)\n            });\n\n            if let Some((idx, _)) = needle {\n                // letter with offset idx in the original word has been matched\n                matched.insert(idx);\n                // don't check the other letter in this block\n                // (we can use one character per block)\n                break;\n            }\n        }\n\n        // The iterator will halt if/when this becomes true, so it will early\n        // return whenever there is a solution found.\n        matched.len() == input.len()\n    })\n}\n\n#[test]\nfn test_solutions() {\n    let expected = [true, true, false, true, false, true, true];\n\n    for (&word, &exp) in WORDS.iter().zip(expected.iter()) {\n        assert_eq!(can_be_built_input_first(word), exp);\n        assert_eq!(can_be_built_blocks_first(word), exp);\n    }\n}\n",
    "path": "tasks/abc-problem",
    "remote_code": "use std::iter::repeat;\n\nfn rec_can_make_word(index: usize, word: &str, blocks: &[&str], used: &mut[bool]) -> bool {\n    let c = word.chars().nth(index).unwrap().to_uppercase().next().unwrap();\n    for i in 0..blocks.len() {\n        if !used[i] && blocks[i].chars().any(|s| s == c) {\n            used[i] = true;\n            if index == 0 || rec_can_make_word(index - 1, word, blocks, used) {\n                return true;\n            }\n            used[i] = false;\n        }\n    }\n    false\n}\n\nfn can_make_word(word: &str, blocks: &[&str]) -> bool {\n    return rec_can_make_word(word.chars().count() - 1, word, blocks, \n                             &mut repeat(false).take(blocks.len()).collect::<Vec<_>>());\n}\n\nfn main() {\n    let blocks = [(\"BO\"), (\"XK\"), (\"DQ\"), (\"CP\"), (\"NA\"), (\"GT\"), (\"RE\"), (\"TG\"), (\"QD\"), (\"FS\"), \n                  (\"JW\"), (\"HU\"), (\"VI\"), (\"AN\"), (\"OB\"), (\"ER\"), (\"FS\"), (\"LY\"), (\"PC\"), (\"ZM\")];\n    let words = [\"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\"];\n    for word in &words {\n        println!(\"{} -> {}\", word, can_make_word(word, &blocks))\n    }\n}\n",
    "title": "ABC Problem",
    "url": "http://rosettacode.org/wiki/ABC_Problem"
  },
  {
    "local_code": "extern crate aks_test_for_primes;\n\nfn main() {\n    for p in 0..8 {\n        println!(\"{}: {:?}\", p, aks_test_for_primes::coefficients(p));\n    }\n\n    for p in (1..51).filter(|&x| aks_test_for_primes::is_prime(x)) {\n        print!(\"{} \", p);\n    }\n}\npub fn is_prime(p: u32) -> bool {\n    if p < 2 {\n        false\n    } else {\n        let mut c = coefficients(p as usize);\n        c[0] -= 1;\n        for coefficient in c.iter().take((c.len() + 1) / 2) {\n            if (coefficient % (i64::from(p))) != 0 {\n                return false;\n            }\n        }\n        true\n    }\n}\n\npub fn coefficients(p: usize) -> Vec<i64> {\n    if p == 0 {\n        vec![1]\n    } else {\n        let mut result = vec![1, -1];\n        let zero = Some(0i64);\n        for _ in 1..p {\n            result = {\n                let a = result.iter().chain(zero.iter());\n                let b = zero.iter().chain(result.iter());\n                a.zip(b).map(|(x, &y)| *x - y).collect()\n            };\n        }\n        result\n    }\n}\n\n#[test]\nfn test_solution() {\n    let exp_coefficients = vec![\n        vec![1i64],\n        vec![1, -1],\n        vec![1, -2, 1],\n        vec![1, -3, 3, -1],\n        vec![1, -4, 6, -4, 1],\n        vec![1, -5, 10, -10, 5, -1],\n        vec![1, -6, 15, -20, 15, -6, 1],\n        vec![1, -7, 21, -35, 35, -21, 7, -1],\n    ];\n    let exp_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47];\n\n    for (i, exp) in exp_coefficients.iter().enumerate() {\n        assert_eq!(*exp, coefficients(i));\n    }\n\n    let primes: Vec<u32> = (1..51).filter(|&i| is_prime(i)).collect();\n    assert_eq!(exp_primes, &primes[..]);\n}\n",
    "path": "tasks/aks-test-for-primes",
    "remote_code": "fn aks_coefficients(k: usize) -> Vec<i64> {\n    let mut coefficients = vec![0i64; k + 1];\n    coefficients[0] = 1;\n    for i in 1..(k + 1) {\n        coefficients[i] = -(1..i).fold(coefficients[0], |prev, j|{\n            let old = coefficients[j];\n            coefficients[j] = old - prev;\n            old\n        });\n    }\n    coefficients\n}\n\nfn is_prime(p: usize) -> bool {\n    if p < 2 {\n        false\n    } else {\n        let c = aks_coefficients(p);\n        (1..p / 2 + 1).all(|i| c[i] % p as i64 == 0)\n    }\n}\n\nfn main() {\n    for i in 0..8 {\n        println!(\"{}: {:?}\", i, aks_coefficients(i));\n    }\n    for i in (1..=50).filter(|&i| is_prime(i)) {\n        print!(\"{} \", i);\n    }\n}",
    "title": "AKS test for primes",
    "url": "http://rosettacode.org/wiki/AKS_test_for_primes"
  },
  {
    "local_code": "extern crate avl_tree;\nextern crate rand;\nextern crate structopt;\n\nuse rand::distributions::Uniform;\nuse rand::Rng;\nuse structopt::StructOpt;\n\n#[derive(Debug, StructOpt)]\nstruct Opt {\n    /// Number of nodes in the random tree\n    #[structopt(short = \"r\", default_value = \"100\")]\n    nodes: usize,\n\n    /// Number of random inserts and deletes\n    #[structopt(short = \"n\", default_value = \"0\")]\n    operations: usize,\n}\n\nfn main() {\n    let opt = Opt::from_args();\n\n    let mut tree = avl_tree::random_bal_tree(opt.nodes as u32);\n    let mut rng = rand::thread_rng();\n    // `Uniform` rather than `gen_range`'s `Uniform::sample_single`\n    let key_range = Uniform::new(-(opt.operations as i32) / 2, (opt.operations as i32) / 2);\n    let value_range = Uniform::new(-1.0, 1.0);\n    tree.insert_bal(0, rng.sample(value_range));\n    for _ in 0..opt.operations {\n        tree.insert_bal(rng.sample(key_range), rng.sample(value_range));\n    }\n    let (_, bals) = tree.gather_balances();\n    assert!(*bals.iter().max().unwrap() < 2);\n    assert!(*bals.iter().min().unwrap() > -2);\n\n    println!(\n        \"AVL tree after ~{} random inserts and ~{} random deletes, starting with {} nodes:\",\n        opt.operations, opt.operations, opt.nodes\n    );\n    println!(\"{}\", tree);\n}\n/// This implementation uses an addressable vector as the tree's store.\n/// It is possible to construct a mutable tree using Rc<RefCell<>>,\n/// but it adds some complexity.\n///\n/// \"Pointers\" to nodes are indices into the vector store, and have\n/// trait Copy.\n///\n/// The index of a node in the vector store should not be confused with its key.\nextern crate rand;\nextern crate term_painter;\n\nuse std::cmp::Ordering;\nuse std::fmt::{Debug, Display, Formatter, Result};\n\nuse rand::distributions::Uniform;\nuse rand::prelude::*;\nuse term_painter::Color::*;\nuse term_painter::ToStyle;\n\npub type NodePtr = Option<usize>;\n\n#[derive(Debug, PartialEq, Clone, Copy)]\npub enum Side {\n    Left,\n    Right,\n    Up,\n    Root,\n}\n\n#[derive(Debug, PartialEq, Clone, Copy)]\nenum DisplayElement {\n    TrunkSpace,\n    SpaceLeft,\n    SpaceRight,\n    SpaceSpace,\n    Root,\n}\n\nimpl DisplayElement {\n    fn string(&self) -> String {\n        match *self {\n            DisplayElement::TrunkSpace => \"    │   \".to_string(),\n            DisplayElement::SpaceRight => \"    ┌───\".to_string(),\n            DisplayElement::SpaceLeft => \"    └───\".to_string(),\n            DisplayElement::SpaceSpace => \"        \".to_string(),\n            DisplayElement::Root => \"├──\".to_string(),\n        }\n    }\n}\n\n/// Handedness of balanced insert and delete operations differs only by values encapsulated here.\nstruct BalanceConstants {\n    bal_incr: i8,\n    this_side: Side,\n    that_side: Side,\n    key_order: Ordering, // Ins only\n    // These are used in the +1/-1 & -1/+1 deletion cases\n    gcm1_child_adj: i8, // Del only, balance adjustment to child for b = -1 grandchild\n    gcm1_parent_adj: i8, // Del only, balance adjustment to parent for b = -1 grandchild\n    gcp1_child_adj: i8, // Del only, balance adjustment to child for b = 1 grandchild\n    gcp1_parent_adj: i8, // Del only, balance adjustment to parent for b = 1 grandchild\n}\n\nconst BALANCE_CONSTANTS_A: BalanceConstants = BalanceConstants {\n    bal_incr: -1,\n    this_side: Side::Left,\n    that_side: Side::Right,\n    key_order: Ordering::Greater,\n    gcm1_child_adj: 0,\n    gcm1_parent_adj: 1,\n    gcp1_child_adj: -1,\n    gcp1_parent_adj: 0,\n};\n\nconst BALANCE_CONSTANTS_B: BalanceConstants = BalanceConstants {\n    bal_incr: 1,\n    this_side: Side::Right,\n    that_side: Side::Left,\n    key_order: Ordering::Less,\n    gcm1_child_adj: 1,\n    gcm1_parent_adj: 0,\n    gcp1_child_adj: 0,\n    gcp1_parent_adj: -1,\n};\n\n#[derive(Debug, Clone, Copy)]\npub struct Node<K, V> {\n    key: K,\n    value: V,\n    balance: i8,\n    left: NodePtr,\n    right: NodePtr,\n    up: NodePtr,\n}\n\n#[derive(Debug)]\npub struct AVLTree<K, V> {\n    root: NodePtr,\n    store: Vec<Node<K, V>>,\n}\n\nimpl<K: Ord + Copy + Debug + Display, V: Debug + Copy + Display> Default for AVLTree<K, V> {\n    fn default() -> Self {\n        AVLTree::new()\n    }\n}\n\nimpl<K: Ord + Copy + Debug + Display, V: Debug + Copy + Display> AVLTree<K, V> {\n    pub fn get_node(&self, np: NodePtr) -> Node<K, V> {\n        assert!(np.is_some());\n        self.store[np.unwrap()]\n    }\n\n    pub fn get_balance(&self, np: NodePtr) -> i8 {\n        assert!(np.is_some());\n        self.store[np.unwrap()].balance\n    }\n\n    pub fn get_key(&self, np: NodePtr) -> K {\n        assert!(np.is_some());\n        self.store[np.unwrap()].key\n    }\n\n    pub fn get_value(&self, np: NodePtr) -> V {\n        assert!(np.is_some());\n        self.store[np.unwrap()].value\n    }\n\n    pub fn get_pointer(&self, np: NodePtr, side: Side) -> NodePtr {\n        assert!(np.is_some());\n        self.store[np.unwrap()].get_ptr(side)\n    }\n\n    pub fn set_balance(&mut self, np: NodePtr, bal: i8) {\n        assert!(np.is_some());\n        self.store[np.unwrap()].balance = bal;\n    }\n\n    pub fn set_key(&mut self, np: NodePtr, to: K) {\n        assert!(np.is_some());\n        self.store[np.unwrap()].key = to;\n    }\n\n    pub fn set_value(&mut self, np: NodePtr, to: V) {\n        assert!(np.is_some());\n        self.store[np.unwrap()].value = to;\n    }\n\n    pub fn set_pointer(&mut self, np: NodePtr, side: Side, to: NodePtr) {\n        assert!(np.is_some());\n        self.store[np.unwrap()].set_ptr(side, to);\n    }\n\n    pub fn increment_balance(&mut self, np: NodePtr, delta: i8) -> i8 {\n        assert!(np.is_some());\n        self.store[np.unwrap()].balance += delta;\n        self.store[np.unwrap()].balance\n    }\n\n    pub fn new() -> Self {\n        AVLTree {\n            root: None,\n            store: Vec::<Node<K, V>>::with_capacity(20_000),\n        }\n    }\n\n    /// Insert key-value\n    pub fn insert(&mut self, k: K, v: V) -> Option<Node<K, V>> {\n        let (n, _) = self.insert_node(Node::new(k, v));\n        n\n    }\n\n    /// Insert Node struct\n    pub fn insert_node(&mut self, mut n: Node<K, V>) -> (Option<Node<K, V>>, Side) {\n        if self.root.is_none() {\n            assert!(self.store.is_empty());\n            self.store.push(n);\n            self.root = Some(0);\n            return (Some(n), Side::Root);\n        }\n\n        let mut p = self.root; // Possibly None\n        let mut prev = p;\n        let mut side = Side::Left;\n        while p.is_some() {\n            prev = p;\n            match n.key.cmp(&self.get_key(p)) {\n                Ordering::Less => {\n                    side = Side::Left;\n                    p = self.get_pointer(p, side);\n                }\n                Ordering::Greater => {\n                    side = Side::Right;\n                    p = self.get_pointer(p, side);\n                }\n                Ordering::Equal => {\n                    println!(\"Key exists\");\n                    return (None, side);\n                }\n            }\n        }\n        // Set child's pointer\n        n.up = prev;\n        // Stow the node\n        self.store.push(n);\n        // Set parent's pointer\n        let ptr = Some(self.store.len() - 1);\n        self.set_pointer(prev, side, ptr);\n        (Some(n), side)\n    }\n\n    /// Insert key-value and rebalance\n    pub fn insert_bal(&mut self, k: K, v: V) -> Option<Node<K, V>> {\n        self.insert_node_bal(Node::new(k, v))\n    }\n\n    /// Insert Node struct and rebalance\n    pub fn insert_node_bal(&mut self, n: Node<K, V>) -> Option<Node<K, V>> {\n        let (nins, side) = self.insert_node(n);\n        if nins.is_none() || side == Side::Root {\n            return nins;\n        }\n\n        let mut p = nins.unwrap().up;\n        let mut is_left = side == Side::Left;\n\n        while p.is_some() {\n            let i_c = get_insertion_constants(is_left);\n\n            let b = self.increment_balance(p, i_c.bal_incr);\n            if b == 0 {\n                break; // No further adjustments necessary\n            } else if b.abs() > 1 {\n                let child_p = self.get_pointer(p, i_c.this_side);\n                match self.get_balance(child_p) * b {\n                    2 => {\n                        // -2/-1 & +2/+1 patterns\n                        self.single_rotation(i_c.this_side, p, child_p);\n                        self.set_balance(p, 0);\n                        self.set_balance(child_p, 0);\n                        break;\n                    }\n                    -2 => {\n                        // -2/+1 & +2/-1 patterns\n                        let grand_p = self.get_pointer(child_p, i_c.that_side);\n                        self.double_rotation(i_c.this_side, p, child_p, grand_p);\n                        if self.get_pointer(child_p, i_c.this_side).is_none() {\n                            // Degenerate case, no subtrees\n                            self.set_balance(child_p, 0);\n                            self.set_balance(p, 0);\n                        } else if n.key.cmp(&self.get_key(grand_p)) == i_c.key_order {\n                            self.set_balance(child_p, i_c.bal_incr);\n                            self.set_balance(p, 0);\n                        } else {\n                            self.set_balance(child_p, 0);\n                            self.set_balance(p, -i_c.bal_incr);\n                        }\n                        self.set_balance(grand_p, 0);\n                        break;\n                    }\n                    _ => unreachable!(),\n                }\n            }\n\n            let child_p = p;\n            p = self.get_pointer(p, Side::Up);\n            if p.is_some() {\n                let left_p = self.get_pointer(p, Side::Left);\n                is_left = left_p.is_some() && left_p == child_p;\n            }\n        }\n\n        nins\n    }\n\n    /// Remove the node at index from the store and patch the hole in the vector,\n    /// modifying pointers in the moved node's parents and children.\n    fn remove_carefully(&mut self, p: NodePtr) {\n        assert!(p.is_some());\n        let index = p.unwrap();\n        let old_index = self.store.len() - 1;\n        self.store.swap_remove(index);\n\n        if index == old_index {\n            // Nothing moved\n            return;\n        }\n\n        // Element -1 has moved into the spot _index_. The in-pointers that need modifying\n        // belong to that element's parent and children.\n\n        // Fix child pointer in parent:\n        let parent_p = self.get_pointer(p, Side::Up);\n        if parent_p.is_some() {\n            let l = self.get_pointer(parent_p, Side::Left);\n            if l == Some(old_index) {\n                self.set_pointer(parent_p, Side::Left, Some(index));\n            } else {\n                self.set_pointer(parent_p, Side::Right, Some(index));\n            }\n        }\n\n        // Fix parent pointers in children:\n        let l = self.get_pointer(p, Side::Left);\n        let r = self.get_pointer(p, Side::Right);\n        if l.is_some() {\n            self.set_pointer(l, Side::Up, Some(index));\n        }\n        if r.is_some() {\n            self.set_pointer(r, Side::Up, Some(index));\n        }\n\n        // Fix root if necessary\n        if self.root == Some(old_index) {\n            self.root = Some(index);\n        }\n    }\n\n    /// Uses delete-by-copy procedure if node with key k has two children.\n    /// Returns (parent, side) tuple.\n    pub fn delete(&mut self, k: K) -> (NodePtr, Side) {\n        let mut p = self.root;\n        let mut prev = None;\n        let mut res = None;\n        let mut side = Side::Root;\n        while p.is_some() {\n            match k.cmp(&self.get_key(p)) {\n                Ordering::Equal => {\n                    break;\n                }\n                Ordering::Less => {\n                    prev = p;\n                    side = Side::Left;\n                    p = self.get_pointer(p, side);\n                }\n                Ordering::Greater => {\n                    prev = p;\n                    side = Side::Right;\n                    p = self.get_pointer(p, side);\n                }\n            }\n        }\n\n        if p.is_none() {\n            println!(\"Key {:?} not found\", k);\n            return (res, side);\n        }\n\n        let n = self.get_node(p);\n        // Is this a leaf?\n        if n.is_leaf() {\n            if n.key.cmp(&self.get_key(self.root)) == Ordering::Equal {\n                self.root = None;\n                assert_eq!(self.store.len(), 1);\n            } else {\n                self.set_pointer(prev, side, None);\n            }\n            self.remove_carefully(p);\n            // The prev pointer is now stale\n            res = if prev == Some(self.store.len()) {\n                p\n            } else {\n                prev\n            };\n\n        // Is this a one-child node?\n        } else if n.left.is_none() || n.right.is_none() {\n            let ch = if n.left.is_some() { n.left } else { n.right };\n            if n.key.cmp(&self.get_key(self.root)) == Ordering::Equal {\n                self.set_pointer(ch, Side::Up, None);\n                self.root = ch;\n            } else {\n                self.set_pointer(prev, side, ch);\n                self.set_pointer(ch, Side::Up, prev);\n            }\n            self.remove_carefully(p);\n            // The prev pointer is now stale\n            res = if prev == Some(self.store.len()) {\n                p\n            } else {\n                prev\n            };\n\n        // Complicated case:  two children, do delete-by-copy. Replace n with its first\n        // predecessor (the mirror image using the first successor would work as well).\n        } else {\n            let mut tmp = n.left;\n            let mut last = tmp;\n            prev = self.get_pointer(tmp, Side::Up);\n            while tmp.is_some() && self.get_pointer(last, Side::Right).is_some() {\n                prev = self.get_pointer(tmp, Side::Up);\n                last = tmp;\n                tmp = self.get_pointer(tmp, Side::Right);\n            }\n            tmp = last;\n            // Copy ...\n            let the_key = self.get_key(tmp);\n            let the_value = self.get_value(tmp);\n            self.set_key(p, the_key);\n            self.set_value(p, the_value);\n\n            let left_ptr = self.get_pointer(tmp, Side::Left);\n            if prev == p {\n                self.set_pointer(p, Side::Left, left_ptr);\n                if left_ptr.is_some() {\n                    self.set_pointer(left_ptr, Side::Up, p);\n                }\n                side = Side::Left;\n            } else {\n                self.set_pointer(prev, Side::Right, left_ptr);\n                if left_ptr.is_some() {\n                    self.set_pointer(left_ptr, Side::Up, prev);\n                }\n                side = Side::Right;\n            }\n\n            self.remove_carefully(tmp);\n            // The prev pointer is now stale\n            res = if prev.unwrap() == self.store.len() {\n                tmp\n            } else {\n                prev\n            };\n        }\n\n        (res, side)\n    }\n\n    /// Rebalance on delete\n    pub fn delete_bal(&mut self, k: K) -> Option<Node<K, V>> {\n        // slug: (pointer to parent of deleted node, side of deleted node)\n        let slug = self.delete(k);\n        let (pdel, side) = slug;\n        if pdel.is_none() {\n            return None;\n        };\n        let ndel = self.get_node(pdel);\n\n        let mut p = pdel;\n        let mut is_left = side == Side::Left;\n\n        // Rebalance and update balance factors. There are two different rotation sequences that\n        // are the same within handedness,\n        // and the +1/-1 / -1/+1 sequence has three possible balance adjustments\n        // depending on the grandchild.\n        while p.is_some() {\n            let d_c = get_deletion_constants(is_left);\n\n            let b = self.increment_balance(p, d_c.bal_incr);\n            if b.abs() == 1 {\n                break; // No further adjustments necessary\n            } else if b.abs() > 1 {\n                let child_p = self.get_pointer(p, d_c.this_side);\n                match self.get_balance(child_p) * b {\n                    2 => {\n                        // +1/+1 & -1/-1 patterns\n                        self.single_rotation(d_c.this_side, p, child_p);\n                        self.set_balance(p, 0);\n                        p = self.get_pointer(p, Side::Up);\n                        self.set_balance(p, 0);\n                    }\n                    0 => {\n                        // +1/0 & -1/0 patterns\n                        self.single_rotation(d_c.this_side, p, child_p);\n                        self.set_balance(p, d_c.bal_incr);\n                        p = self.get_pointer(p, Side::Up);\n                        self.set_balance(p, -d_c.bal_incr);\n                        break; // No height change\n                    }\n                    -2 => {\n                        // +1/-1/x & -1/+1/x patterns\n                        let grand_p = self.get_pointer(child_p, d_c.that_side);\n                        self.double_rotation(d_c.this_side, p, child_p, grand_p);\n                        // p is now one child, grand_p is the other, child_p is their parent\n                        match self.get_balance(grand_p) {\n                            -1 => {\n                                self.set_balance(p, d_c.gcm1_parent_adj);\n                                self.set_balance(child_p, d_c.gcm1_child_adj);\n                            }\n                            0 => {\n                                self.set_balance(p, 0);\n                                self.set_balance(child_p, 0);\n                            }\n                            1 => {\n                                self.set_balance(p, d_c.gcp1_parent_adj);\n                                self.set_balance(child_p, d_c.gcp1_child_adj);\n                            }\n                            _ => unreachable!(),\n                        }\n                        self.set_balance(grand_p, 0);\n                        p = self.get_pointer(p, Side::Up);\n                    }\n                    _ => unreachable!(),\n                }\n            }\n\n            let child_p = p;\n            p = self.get_pointer(p, Side::Up);\n            if p.is_some() {\n                let left_p = self.get_pointer(p, Side::Left);\n                is_left = left_p.is_some() && left_p == child_p;\n            }\n        }\n\n        Some(ndel)\n    }\n\n    /// Returns node value\n    pub fn lookup(&self, k: K) -> Option<V> {\n        self.search(k).map(|n| n.value)\n    }\n\n    /// Returns node (not pointer)\n    pub fn search(&self, k: K) -> Option<Node<K, V>> {\n        let mut p = self.root;\n        let mut res = None;\n\n        while p.is_some() {\n            match k.cmp(&self.get_key(p)) {\n                Ordering::Less => {\n                    p = self.get_pointer(p, Side::Left);\n                }\n                Ordering::Greater => {\n                    p = self.get_pointer(p, Side::Right);\n                }\n                Ordering::Equal => {\n                    res = Some(self.get_node(p));\n                    break;\n                }\n            }\n        }\n        res\n    }\n\n    /// Do an in-order traversal, where a \"visit\" prints the row with that node in it.\n    fn display(&self, p: NodePtr, side: Side, e: &[DisplayElement], f: &mut Formatter) {\n        if p.is_none() {\n            return;\n        }\n\n        let mut elems = e.to_vec();\n        let node = self.get_node(p);\n        let mut tail = DisplayElement::SpaceSpace;\n        if node.up != self.root {\n            // Direction switching, need trunk element to be printed for lines before that node\n            // is visited.\n            let new_elem = if side == Side::Left && node.right.is_some() {\n                DisplayElement::TrunkSpace\n            } else {\n                DisplayElement::SpaceSpace\n            };\n            elems.push(new_elem);\n        }\n        let hindex = elems.len() - 1;\n        self.display(node.right, Side::Right, &elems, f);\n\n        if p == self.root {\n            elems[hindex] = DisplayElement::Root;\n            tail = DisplayElement::TrunkSpace;\n        } else if side == Side::Right {\n            // Right subtree finished\n            elems[hindex] = DisplayElement::SpaceRight;\n            // Prepare trunk element in case there is a left subtree\n            tail = DisplayElement::TrunkSpace;\n        } else\n        // if side == Side::Left\n        {\n            elems[hindex] = DisplayElement::SpaceLeft;\n            let parent_p = self.get_pointer(p, Side::Up);\n            let gp_p = self.get_pointer(parent_p, Side::Up);\n            if gp_p.is_some() && self.get_pointer(gp_p, Side::Right) == parent_p {\n                // Direction switched, need trunk element starting with this node/line\n                elems[hindex - 1] = DisplayElement::TrunkSpace;\n            }\n        }\n\n        // Visit node => print accumulated elements. Each node gets a line.\n        {\n            for e in elems.clone() {\n                let _ = write!(f, \"{}\", e.string());\n            }\n            let _ = write!(\n                f,\n                \"{key:>width$} \",\n                key = Green.bold().paint(node.key),\n                width = 2\n            );\n            let _ = write!(\n                f,\n                \"{value:>width$} \",\n                value = Blue.bold().paint(format!(\"{:.*}\", 2, node.value)),\n                width = 4\n            );\n            let _ = write!(\n                f,\n                \"{bal:<-width$}\\n\",\n                bal = Red.bold().paint(node.balance),\n                width = 2\n            );\n\n            elems[hindex] = tail;\n        }\n\n        self.display(node.left, Side::Left, &elems, f);\n    }\n\n    pub fn gather_balances(&self) -> (Vec<K>, Vec<i8>) {\n        let mut keys = Vec::<K>::new();\n        let mut bals = Vec::<i8>::new();\n\n        self.gather_balances_impl(self.root, &mut keys, &mut bals);\n        (keys, bals)\n    }\n\n    fn gather_balances_impl(&self, p: NodePtr, k: &mut Vec<K>, b: &mut Vec<i8>) {\n        if p.is_none() {\n            return;\n        }\n        let r = self.get_pointer(p, Side::Right);\n        self.gather_balances_impl(r, k, b);\n        k.push(self.get_key(p));\n        b.push(self.get_balance(p));\n        let l = self.get_pointer(p, Side::Left);\n        self.gather_balances_impl(l, k, b)\n    }\n\n    pub fn compute_balances(&mut self, p: NodePtr) -> i8 {\n        self.compute_balances_impl(p, 0)\n    }\n\n    fn compute_balances_impl(&mut self, p: NodePtr, level: i8) -> i8 {\n        if p.is_none() {\n            return level - 1;\n        }\n        let r = self.get_pointer(p, Side::Right);\n        let l = self.get_pointer(p, Side::Left);\n        let rb = self.compute_balances_impl(r, level + 1);\n        let lb = self.compute_balances_impl(l, level + 1);\n        self.set_balance(p, rb - lb);\n        std::cmp::max(rb, lb)\n    }\n\n    ///     P                Q\n    ///   /   \\     =>     /   \\\n    ///  h     Q          P     h'\n    fn rotate_left(&mut self, p: NodePtr, q: NodePtr) {\n        assert!(p.is_some());\n        assert!(q.is_some());\n        let p_parent = self.get_pointer(p, Side::Up);\n        // Take care of parent pointers\n        self.set_pointer(q, Side::Up, p_parent);\n        self.set_pointer(p, Side::Up, q);\n        let ql = self.get_pointer(q, Side::Left);\n        if ql.is_some() {\n            self.set_pointer(ql, Side::Up, p);\n        }\n\n        // Take care of child pointers\n        self.set_pointer(q, Side::Left, p);\n        self.set_pointer(p, Side::Right, ql);\n        if p_parent.is_some() {\n            let side = if self.get_pointer(p_parent, Side::Right) == p {\n                Side::Right\n            } else {\n                Side::Left\n            };\n            self.set_pointer(p_parent, side, q);\n        } else {\n            self.root = q;\n        }\n    }\n\n    ///     P                Q\n    ///   /   \\     =>     /   \\\n    ///  Q     h          h'    P\n    fn rotate_right(&mut self, p: NodePtr, q: NodePtr) {\n        assert!(p.is_some());\n        assert!(q.is_some());\n        let p_parent = self.get_pointer(p, Side::Up);\n        // Take care of parent pointers\n        self.set_pointer(q, Side::Up, p_parent);\n        self.set_pointer(p, Side::Up, q);\n        let qr = self.get_pointer(q, Side::Right);\n        if qr.is_some() {\n            self.set_pointer(qr, Side::Up, p);\n        }\n\n        // Take care of child pointers\n        self.set_pointer(q, Side::Right, p);\n        self.set_pointer(p, Side::Left, qr);\n        if p_parent.is_some() {\n            let side = if self.get_pointer(p_parent, Side::Right) == p {\n                Side::Right\n            } else {\n                Side::Left\n            };\n            self.set_pointer(p_parent, side, q);\n        } else {\n            self.root = q;\n        }\n    }\n\n    fn single_rotation(&mut self, side: Side, p: NodePtr, q: NodePtr) {\n        if side == Side::Left {\n            self.rotate_right(p, q);\n        } else {\n            self.rotate_left(p, q);\n        }\n    }\n\n    fn double_rotation(&mut self, side: Side, p: NodePtr, child_p: NodePtr, grand_p: NodePtr) {\n        if side == Side::Left {\n            self.rotate_left(child_p, grand_p);\n            self.rotate_right(p, grand_p);\n        } else {\n            self.rotate_right(child_p, grand_p);\n            self.rotate_left(p, grand_p);\n        }\n    }\n}\n\nimpl<K: Ord + Copy, V: Copy> Node<K, V> {\n    pub fn new(k: K, v: V) -> Node<K, V> {\n        Node {\n            key: k,\n            value: v,\n            balance: 0,\n            left: None,\n            right: None,\n            up: None,\n        }\n    }\n\n    pub fn is_leaf(&self) -> bool {\n        self.left.is_none() && self.right.is_none()\n    }\n\n    pub fn set_ptr(&mut self, side: Side, to: NodePtr) {\n        let field = match side {\n            Side::Up => &mut self.up,\n            Side::Left => &mut self.left,\n            _ => &mut self.right,\n        };\n        *field = to;\n    }\n\n    pub fn get_ptr(&self, side: Side) -> NodePtr {\n        match side {\n            Side::Up => self.up,\n            Side::Left => self.left,\n            _ => self.right,\n        }\n    }\n}\n\nimpl<K: Ord + Copy + Debug + Display, V: Debug + Copy + Display> Display for AVLTree<K, V> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        if self.root.is_none() {\n            write!(f, \"[empty]\")\n        } else {\n            let v: Vec<DisplayElement> = Vec::new();\n            self.display(self.root, Side::Up, &v, f);\n            Ok(())\n        }\n    }\n}\n\nfn get_insertion_constants(is_left: bool) -> &'static BalanceConstants {\n    if is_left {\n        &BALANCE_CONSTANTS_A\n    } else {\n        &BALANCE_CONSTANTS_B\n    }\n}\n\nfn get_deletion_constants(is_left: bool) -> &'static BalanceConstants {\n    get_insertion_constants(!is_left)\n}\n\npub fn random_bal_tree(n: u32) -> AVLTree<i32, f32> {\n    let mut tree: AVLTree<i32, f32> = AVLTree::new();\n    let mut rng = rand::thread_rng();\n    // `Uniform` rather than `gen_range`'s `Uniform::sample_single` for speed\n    let key_range = Uniform::new(-(n as i32) / 2, (n as i32) / 2);\n    let value_range = Uniform::new(-1.0, 1.0);\n    tree.insert_bal(0, rng.sample(value_range));\n    for _ in 0..n {\n        tree.insert_bal(rng.sample(key_range), rng.sample(value_range));\n    }\n    tree\n}\n\n#[cfg(test)]\nmod tests {\n    use rand::distributions::Uniform;\n    use rand::prelude::*;\n\n    use super::AVLTree;\n    use random_bal_tree;\n\n    #[test]\n    fn test_insert() {\n        let mut tree: AVLTree<i32, f32> = AVLTree::new();\n        tree.insert(0, 0.0);\n        tree.insert(8, 8.8);\n        tree.insert(-8, -8.8);\n        assert!(tree.insert(4, 4.4).is_some());\n        tree.insert(12, 12.12);\n\n        assert_eq!(tree.lookup(4), Some(4.4));\n        assert_eq!(tree.lookup(5), None);\n        assert_eq!(tree.lookup(-8), Some(-8.8));\n\n        let s = &tree.store;\n        assert_eq!(\n            s[s[s[tree.root.unwrap()].right.unwrap()].right.unwrap()].value,\n            12.12\n        );\n        assert_eq!(\n            s[s[s[tree.root.unwrap()].right.unwrap()].right.unwrap()].left,\n            None\n        );\n    }\n\n    #[test]\n    fn test_delete() {\n        let mut tree: AVLTree<i32, f32> = AVLTree::new();\n        tree.insert(0, 0.0);\n        tree.insert(8, 8.8);\n        tree.insert(-8, -8.8);\n        assert!(tree.insert(4, 4.4).is_some());\n        tree.insert(12, 12.12);\n\n        // delete leaf\n        tree.delete(12);\n        assert_eq!(tree.lookup(12), None);\n        let mut n = tree.search(8).unwrap();\n        assert_eq!(n.right, None);\n\n        // delete one-child node\n        tree.delete(4);\n        assert_eq!(tree.lookup(4), None);\n        n = tree.search(0).unwrap();\n        assert_eq!(tree.store[n.right.unwrap()].key, 8);\n\n        // delete two-child node\n        tree.insert(6, 6.6);\n        tree.insert(10, 10.10);\n        tree.insert(7, 7.7);\n        tree.delete(8);\n        n = tree.search(7).unwrap();\n        assert_eq!(tree.store[n.left.unwrap()].key, 6);\n        assert_eq!(tree.store[n.right.unwrap()].key, 10);\n        assert_eq!(tree.store[n.up.unwrap()].key, 0);\n\n        // delete two-child root\n        tree.delete(0);\n        assert_eq!(tree.store[tree.root.unwrap()].key, -8);\n\n        // delete one-child root\n        tree.delete(-8);\n        assert_eq!(tree.store[tree.root.unwrap()].key, 7);\n\n        // delete no-child root\n        tree.delete(6);\n        tree.delete(7);\n        tree.delete(10);\n        assert!(tree.root.is_none());\n        assert_eq!(tree.store.len(), 0);\n    }\n\n    #[test]\n    fn test_rotate_left() {\n        let mut tree: AVLTree<i32, f32> = AVLTree::new();\n        tree.insert(0, 0.0);\n        tree.insert(8, 8.8);\n        tree.insert(4, 4.4);\n        tree.insert(-8, -8.8);\n\n        let mut r = tree.root;\n        let mut right = tree.store[r.unwrap()].right;\n        tree.rotate_left(r, right);\n        r = tree.root;\n        right = tree.store[r.unwrap()].right;\n        let left = tree.store[r.unwrap()].left;\n        let left_left = tree.store[left.unwrap()].left;\n        let left_right = tree.store[left.unwrap()].right;\n        assert_eq!(right, None);\n        assert_eq!(tree.store[left.unwrap()].key, 0);\n        assert_eq!(tree.store[left_left.unwrap()].key, -8);\n        assert_eq!(tree.store[left_right.unwrap()].key, 4);\n        assert_eq!(tree.store[r.unwrap()].key, 8);\n    }\n\n    #[test]\n    fn test_rotate_right() {\n        let mut tree: AVLTree<i32, f32> = AVLTree::new();\n        tree.insert(0, 0.0);\n        tree.insert(8, 8.8);\n        tree.insert(-8, -8.8);\n        tree.insert(-4, 4.4);\n\n        let mut r = tree.root;\n        let mut left = tree.store[r.unwrap()].left;\n        tree.rotate_right(r, left);\n        r = tree.root;\n        left = tree.store[r.unwrap()].left;\n        let right = tree.store[r.unwrap()].right;\n        let right_right = tree.store[right.unwrap()].right;\n        let right_left = tree.store[right.unwrap()].left;\n        assert_eq!(left, None);\n        assert_eq!(tree.store[right.unwrap()].key, 0);\n        assert_eq!(tree.store[right_right.unwrap()].key, 8);\n        assert_eq!(tree.store[right_left.unwrap()].key, -4);\n        assert_eq!(tree.store[r.unwrap()].key, -8);\n    }\n\n    #[test]\n    // This tree tests all four insertion types\n    fn test_balanced_inserts() {\n        let mut tree: AVLTree<i32, f32> = AVLTree::new();\n        tree.insert_bal(0, 0.0);\n        tree.insert_bal(8, 8.8);\n        tree.insert_bal(-8, -8.8);\n        tree.insert_bal(12, 12.12);\n        tree.insert_bal(16, 16.16);\n        tree.insert_bal(11, 11.11);\n        tree.insert_bal(4, 4.4);\n        tree.insert_bal(-10, -8.8);\n        tree.insert_bal(-12, -8.8);\n        tree.insert_bal(-9, -8.8);\n\n        let mut res = tree.gather_balances();\n        let (_, bals) = res;\n        assert!(bals.iter().max().unwrap() < &2);\n        assert!(bals.iter().min().unwrap() > &-2);\n\n        for _ in 0..10 {\n            tree = random_bal_tree(1000);\n            res = tree.gather_balances();\n            let (_, bals) = res;\n            assert!(bals.iter().max().unwrap() < &2);\n            assert!(bals.iter().min().unwrap() > &-2);\n        }\n    }\n\n    #[test]\n    /// This sequence hits all five rotation possibilities on each side.\n    fn test_balanced_deletes() {\n        let mut tree: AVLTree<i32, f32> = AVLTree::new();\n        tree.insert_bal(0, 0.0);\n        tree.insert_bal(-32, 0.0);\n        tree.insert_bal(32, 0.0);\n        tree.insert_bal(-64, 0.0);\n        tree.insert_bal(64, 0.0);\n        tree.delete_bal(64);\n        tree.delete_bal(32);\n        tree.delete_bal(-32);\n        tree.delete_bal(-64);\n        tree.delete_bal(0);\n        assert_eq!(tree.root, None);\n        assert_eq!(tree.store.len(), 0);\n\n        tree.insert_bal(0, 0.0);\n        tree.insert_bal(-32, 0.0);\n        tree.insert_bal(32, 0.0);\n        tree.insert_bal(-64, 0.0);\n        tree.insert_bal(64, 0.0);\n        tree.insert_bal(-16, 0.0);\n        tree.insert_bal(16, 0.0);\n        tree.insert_bal(-8, 0.0);\n        tree.insert_bal(8, 0.0);\n        tree.insert_bal(-12, 0.0);\n        tree.insert_bal(-7, 0.0);\n        tree.insert_bal(-6, 0.0);\n        tree.insert_bal(-11, 0.0);\n\n        tree.delete_bal(-64);\n        tree.delete_bal(-32);\n        tree.delete_bal(-7);\n        tree.delete_bal(-6);\n        tree.delete_bal(-16);\n        tree.delete_bal(-11);\n        tree.delete_bal(-12);\n        tree.delete_bal(8);\n        tree.delete_bal(-8);\n        tree.delete_bal(0);\n        tree.insert_bal(24, 0.0);\n        tree.insert_bal(8, 0.0);\n        tree.insert_bal(4, 0.0);\n        tree.insert_bal(128, 0.0);\n        tree.insert_bal(48, 0.0);\n        tree.delete_bal(32);\n        tree.delete_bal(48);\n\n        tree.insert_bal(-24, 0.0);\n        tree.insert_bal(-8, 0.0);\n        tree.insert_bal(-128, 0.0);\n        tree.insert_bal(-48, 0.0);\n        tree.insert_bal(-20, 0.0);\n        tree.insert_bal(-30, 0.0);\n        tree.insert_bal(-22, 0.0);\n        tree.insert_bal(-21, 0.0);\n        tree.delete_bal(24);\n        tree.delete_bal(64);\n        tree.delete_bal(-30);\n        tree.delete_bal(-22);\n        tree.delete_bal(-21);\n        tree.delete_bal(-128);\n        tree.delete_bal(128);\n        tree.delete_bal(-8);\n        tree.insert_bal(-96, 0.0);\n        tree.insert_bal(-95, 0.0);\n        tree.insert_bal(-10, 0.0);\n        tree.insert_bal(6, 0.0);\n        tree.delete_bal(-24);\n\n        let mut res = tree.gather_balances();\n        let (_, bals) = res;\n        assert!(bals.iter().max().unwrap() < &2);\n        assert!(bals.iter().min().unwrap() > &-2);\n\n        let mut p = tree.root;\n        while p.is_some() {\n            let key = tree.store[p.unwrap()].key;\n            tree.delete_bal(key);\n            p = tree.root;\n        }\n        assert_eq!(tree.root, None);\n        assert_eq!(tree.store.len(), 0);\n\n        // */*/+1 patterns\n        tree.insert(6, 0.0);\n        tree.insert(-1, 0.0);\n        tree.insert(9, 0.0);\n        tree.insert(7, 0.0);\n        tree.insert(3, 0.0);\n        tree.insert(-9, 0.0);\n        tree.insert(4, 0.0);\n        p = tree.root;\n        tree.compute_balances(p);\n        tree.delete_bal(-9);\n        res = tree.gather_balances();\n        let (_, bals) = res;\n        tree.compute_balances(p);\n        res = tree.gather_balances();\n        let (_, bals_after) = res;\n        assert_eq!(bals, bals_after);\n\n        tree.insert(6, 0.0);\n        tree.insert(-1, 0.0);\n        tree.insert(3, 0.0);\n        tree.insert(9, 0.0);\n        tree.insert(7, 0.0);\n        tree.insert(11, 0.0);\n        tree.insert(8, 0.0);\n        p = tree.root;\n        tree.compute_balances(p);\n        tree.delete_bal(-1);\n        res = tree.gather_balances();\n        let (_, bals) = res;\n        tree.compute_balances(p);\n        res = tree.gather_balances();\n        let (_, bals_after) = res;\n        assert_eq!(bals, bals_after);\n\n        let mut rng = thread_rng();\n        for _ in 0..100 {\n            tree = random_bal_tree(100);\n            for i in Uniform::from(-50..50).sample_iter(&mut rng).take(80) {\n                tree.delete_bal(i);\n            }\n        }\n\n        res = tree.gather_balances();\n        let (_, bals) = res;\n\n        if bals.len() > 0 {\n            assert!(*bals.iter().max().unwrap() < 2);\n            assert!(*bals.iter().min().unwrap() > -2);\n        }\n\n        return;\n    }\n}\n",
    "path": "tasks/avl-tree",
    "remote_code": null,
    "title": "AVL tree",
    "url": "http://rosettacode.org/wiki/AVL_tree"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Abbreviations, automatic",
    "url": "http://rosettacode.org/wiki/Abbreviations,_automatic"
  },
  {
    "local_code": "use std::collections::HashMap;\n\nfn main() {\n    let commands = \"\n        Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy \\\n        COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find \\\n        NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput \\\n        Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO \\\n        MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT \\\n        READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT \\\n        RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up \\\n    \";\n    let split = commands.split_ascii_whitespace();\n    let count_hashtable: HashMap<&str, usize> = split\n        .map(|word| {\n            (\n                word,\n                word.chars().take_while(|c| c.is_ascii_uppercase()).count(),\n            )\n        })\n        .collect();\n\n    let line = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\";\n    let mut words_vec: Vec<String> = vec![];\n    for word in line.split_ascii_whitespace() {\n        let split = commands.split_ascii_whitespace();\n        let abbr = split\n            .filter(|x| {\n                x.to_ascii_lowercase()\n                    .starts_with(&word.to_ascii_lowercase())\n                    && word.len() >= *count_hashtable.get(x).unwrap()\n            })\n            .next();\n        words_vec.push(match abbr {\n            Some(word) => word.to_ascii_uppercase(),\n            None => String::from(\"*error*\"),\n        });\n    }\n    let corrected_line = words_vec.join(\" \");\n    println!(\"{}\", corrected_line);\n}\n",
    "path": "tasks/abbreviations-easy",
    "remote_code": "use std::collections::HashMap;\n\nfn main() {\n    let commands = \"\n        Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy \\\n        COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find \\\n        NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput \\\n        Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO \\\n        MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT \\\n        READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT \\\n        RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up \\\n    \";\n    let split = commands.split_ascii_whitespace();\n    let count_hashtable: HashMap<&str, usize> = split.map(|word| {\n        (word, word.chars().take_while(|c| c.is_ascii_uppercase()).count())\n    }).collect();\n\n    let line = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\";\n    let mut words_vec: Vec<String> = vec![];\n    for word in line.split_ascii_whitespace() {\n        let split = commands.split_ascii_whitespace();\n        let abbr = split.filter(|x| {\n            x.to_ascii_lowercase().starts_with(&word.to_ascii_lowercase()) &&\n            word.len() >= *count_hashtable.get(x).unwrap()\n        }).next();\n        words_vec.push(match abbr {\n            Some(word) => word.to_ascii_uppercase(),\n            None => String::from(\"*error*\"),\n        });\n    }\n    let corrected_line = words_vec.join(\" \");\n    println!(\"{}\", corrected_line);\n}\n",
    "title": "Abbreviations, easy",
    "url": "http://rosettacode.org/wiki/Abbreviations,_easy"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::collections::HashMap;\n\n// The plan here is to build a hashmap of all the commands keyed on the minimum number of\n// letters than can be provided in the input to match. For each known command it will appear\n// in a list of possible commands for a given string lengths. A command can therefore appear a\n// number of times. For example, the command 'recover' has a minimum abbreviation length of 3.\n// In the hashmap 'recover' will be stored behind keys for 3, 4, 5, 6 & 7 as any abbreviation of\n// 'recover' from 3 until 7 letters inclusive can match. This way, once the length of the input\n// string is known a subset of possible matches can be retrieved immediately and then checked.\n//\nfn main() {\n    let command_table_string =\n        \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3\n   compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate\n   3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2\n   forward 2  get  help 1 hexType 4  input_command 1 powerInput 3  join 1 split 2 spltJOIN load\n   locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2\n   msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3\n   refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left\n   2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\";\n\n    // Split up the command table string using the whitespace and set up an iterator\n    // to run through it. We need the iterator to be peekable so that we can look ahead at\n    // the next item.\n    let mut iter = command_table_string.split_whitespace().peekable();\n\n    let mut command_table = HashMap::new();\n\n    // Attempt to take two items at a time from the command table string. These two items will be\n    // the command string and the minimum length of the abbreviation. If there is no abbreviation length\n    // then there is no number provided. As the second item might not be a number, so we need to peek at\n    // it first. If it is a number we can use it as a key for the hashmap. If it is not a number then\n    // we use the length of the first item instead because no abbreviations are available for the\n    // word i.e. the whole word must be used. A while loop is used because we need to control iteration\n    // and look ahead.\n    //\n    while let Some(command_string) = iter.next() {\n        let command_string_length = command_string.len() as i32;\n\n        let min_letter_match = match iter.peek() {\n            Some(potential_number) => match potential_number.parse::<i32>() {\n                Ok(number) => {\n                    iter.next();\n                    number\n                }\n                Err(_) => command_string_length,\n            },\n            None => break,\n        };\n\n        // The word must be stored for every valid abbreviation length.\n        //\n        for i in min_letter_match..=command_string_length {\n            let cmd_list = command_table.entry(i).or_insert_with(Vec::new);\n            cmd_list.push(command_string.to_uppercase());\n        }\n    }\n\n    const ERROR_TEXT: &str = \"*error*\";\n\n    let test_input_text = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\";\n\n    let mut output_text = String::new();\n\n    let mut iter = test_input_text.split_whitespace().peekable();\n\n    // Run through each item in the input string, find the length of it\n    // and then use this to fetch a list of possible matches.\n    // A while loop is used because we need to look ahead in order to indentify\n    // the last item and avoid adding an unnecessary space.\n    //\n    while let Some(input_command) = iter.next() {\n        let input_command_length = input_command.len() as i32;\n\n        let command_list = match command_table.get(&input_command_length) {\n            Some(list) => list,\n            None => {\n                output_text.push_str(ERROR_TEXT);\n                continue;\n            }\n        };\n\n        let input_command_caps = input_command.to_uppercase();\n        let matched_commands: Vec<&String> = command_list\n            .iter()\n            .filter(|command| command.starts_with(&input_command_caps))\n            .collect();\n\n        // Should either be 0 or 1 command found\n        assert!(\n            matched_commands.len() < 2,\n            \"Strange.. {:?}\",\n            matched_commands\n        );\n\n        match matched_commands.first() {\n            Some(cmd) => output_text.push_str(cmd),\n            None => output_text.push_str(ERROR_TEXT),\n        }\n\n        if iter.peek().is_some() {\n            output_text.push(' ');\n        }\n    }\n\n    println!(\"Input was: {}\", test_input_text);\n    println!(\"Output is: {}\", output_text);\n\n    let correct_output = \"RIGHT REPEAT *error* PUT MOVE RESTORE *error* *error* *error* POWERINPUT\";\n    assert_eq!(output_text, correct_output)\n}",
    "title": "Abbreviations, simple",
    "url": "http://rosettacode.org/wiki/Abbreviations,_simple"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// This is the main algorithm.\n//\n// It loops over the current state of the sandpile and updates it on-the-fly.\nfn advance(field: &mut Vec<Vec<usize>>, boundary: &mut [usize; 4]) -> bool\n{ \n    // This variable is used to check whether we changed anything in the array. If no, the loop terminates.\n    let mut done = false;\n\n    for y in boundary[0]..boundary[2]\n    {\n        for x in boundary[1]..boundary[3]\n        {\n            if field[y][x] >= 4\n            {\n                // This part was heavily inspired by the Pascal version. We subtract 4 as many times as we can\n                // and distribute it to the neighbors. Also, in case we have outgrown the current boundary, we\n                // update it to once again contain the entire sandpile.\n\n                // The amount that gets added to the neighbors is the amount here divided by four and (implicitly) floored.\n                // The remaining sand is just current modulo 4.\n                let rem: usize = field[y][x] / 4;\n                field[y][x] %= 4;\n\n                // The isize casts are necessary because usize can not go below 0.\n                // Also, the reason why x and y are compared to boundary[2]-1 and boundary[3]-1 is because for loops in\n                // Rust are upper bound exclusive. This means a loop like 0..5 will only go over 0,1,2,3 and 4.\n                if y as isize - 1 >= 0 {field[y-1][x] += rem; if y == boundary[0] {boundary[0]-=1;}}\n                if x as isize - 1 >= 0 {field[y][x-1] += rem; if x == boundary[1] {boundary[1]-=1;}}\n                if y+1 < field.len() {field[y+1][x] += rem; if x == boundary[2]-1 {boundary[2]+=1;}}\n                if x+1 < field.len() {field[y][x+1] += rem; if y == boundary[3]-1 {boundary[3]+=1;}}\n\n                done = true;\n            }\n        }\n    }\n\n    done\n}\n\n// This function can be used to display the sandpile in the console window.\n//\n// Each row is mapped onto chars and those characters are then collected into a string.\n// These are then printed to the console.\n//\n// Eg.: [0,1,1,2,3,0] -> [' ','░','░','▒','▓',' ']-> \" ░░▒▓ \"\nfn display(field: &Vec<Vec<usize>>)\n{\n    for row in field\n    {\n        let char_row = {\n            row.iter().map(|c| {match c {\n                0 => ' ',\n                1 => '░',\n                2 => '▒',\n                3 => '▓',\n                _ => '█'\n            }}).collect::<String>()\n        };\n        println!(\"{}\", char_row);\n    }\n}\n\n// This function writes the end result to a file called \"output.ppm\".\n//\n// PPM is a very simple image format, however, it entirely uncompressed which leads to huge image sizes.\n// Even so, for demonstrative purposes it's perfectly good to use. For something more robust, look into PNG libraries.\n//\n// Read more about the format here: http://netpbm.sourceforge.net/doc/ppm.html\nfn write_pile(pile: &Vec<Vec<usize>>) {\n    use std::fs::File;\n    use std::io::Write;\n\n    // We first create the file (or erase its contents if it already existed).\n    let mut file = File::create(\"./output.ppm\").unwrap();\n\n    // Then we add the image signature, which is \"P3 <newline>[width of image] [height of image]<newline>[maximum value of color]<newline>\".\n    write!(file, \"P3\\n{} {}\\n255\\n\", pile.len(), pile.len()).unwrap();\n\n    for row in pile {\n        // For each row, we create a new string which has more or less enough capacity to hold the entire row.\n        // This is for performance purposes, but shouldn't really matter much.\n        let mut line = String::with_capacity(row.len() * 14);\n\n        // We map each value in the field to a color.\n        // These are just simple RGB values, 0 being the background, the rest being the \"sand\" itself.\n        for elem in row {\n            line.push_str(match elem {\n                0 => \"100 40 15 \",\n                1 => \"117 87 30 \",\n                2 => \"181 134 47 \",\n                3 => \"245 182 66 \",\n                _ => unreachable!(),\n            });\n        }\n\n        // Finally we write this string into the file.\n        write!(file, \"{}\\n\", line).unwrap();\n    }\n}\n\nfn main() {\n    // This is how big the final image will be. Currently the end result would be a 16x16 picture.\n    let field_size = 16;\n    let mut playfield = vec![vec![0; field_size]; field_size];\n\n    // We put the initial sand in the exact middle of the field.\n    // This isn't necessary per se, but it ensures that sand can fully topple.\n    //\n    // The boundary is initially just the single tile which has the sand in it, however, as the algorithm\n    // progresses, this will grow larger too.\n    let mut boundary = [field_size/2-1, field_size/2-1, field_size/2, field_size/2];\n    playfield[field_size/2 - 1][field_size/2 - 1] = 16;\n\n    // This is the main loop. We update the field until it returns false, signalling that the pile reached its\n    // final state.\n    while advance(&mut playfield, &mut boundary) {};\n\n    // Once this happens, we simply display the result. Uncomment the line below to write it to a file.\n    // Calling display with large field sizes is not recommended as it can easily become too large for the console.\n    display(&playfield);\n    //write_pile(&playfield);\n}",
    "title": "Abelian sandpile model",
    "url": "http://rosettacode.org/wiki/Abelian_sandpile_model"
  },
  {
    "local_code": "trait Shape {\n    fn area(&self) -> i32;\n\n    fn is_shape(&self) -> bool {\n        true\n    }\n}\n\nstruct Square {\n    side_length: i32,\n}\n\nimpl Shape for Square {\n    fn area(&self) -> i32 {\n        self.side_length * self.side_length\n    }\n}\n\nfn main() {\n    let square = Square { side_length: 2 };\n    println!(\"The square's area is: {}\", square.area());\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{Shape, Square};\n\n    #[test]\n    fn area() {\n        let square = Square { side_length: 2 };\n        assert_eq!(square.area(), 4);\n    }\n\n    #[test]\n    fn is_shape() {\n        let square = Square { side_length: 2 };\n        assert!(square.is_shape())\n    }\n}\n",
    "path": "tasks/abstract-type",
    "remote_code": "trait Shape {\n    fn area(self) -> i32;\n}",
    "title": "Abstract type",
    "url": "http://rosettacode.org/wiki/Abstract_type"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn divisors(n: u64) -> Vec<u64> {\n    let mut divs = vec![1];\n    let mut divs2 = Vec::new();\n\n    for i in (2..).take_while(|x| x * x <= n).filter(|x| n % x == 0) {\n        divs.push(i);\n        let j = n / i;\n        if i != j {\n            divs2.push(j);\n        }\n    }\n    divs.extend(divs2.iter().rev());\n\n    divs\n}\n\nfn sum_string(v: Vec<u64>) -> String {\n    v[1..]\n        .iter()\n        .fold(format!(\"{}\", v[0]), |s, i| format!(\"{} + {}\", s, i))\n}\n\nfn abundant_odd(search_from: u64, count_from: u64, count_to: u64, print_one: bool) -> u64 {\n    let mut count = count_from;\n    for n in (search_from..).step_by(2) {\n        let divs = divisors(n);\n        let total: u64 = divs.iter().sum();\n        if total > n {\n            count += 1;\n            let s = sum_string(divs);\n            if !print_one {\n                println!(\"{}. {} < {} = {}\", count, n, s, total);\n            } else if count == count_to {\n                println!(\"{} < {} = {}\", n, s, total);\n            }\n        }\n        if count == count_to {\n            break;\n        }\n    }\n    count_to\n}\n\nfn main() {\n    let max = 25;\n    println!(\"The first {} abundant odd numbers are:\", max);\n    let n = abundant_odd(1, 0, max, false);\n\n    println!(\"The one thousandth abundant odd number is:\");\n    abundant_odd(n, 25, 1000, true);\n\n    println!(\"The first abundant odd number above one billion is:\");\n    abundant_odd(1e9 as u64 + 1, 0, 1, true);\n}",
    "title": "Abundant odd numbers",
    "url": "http://rosettacode.org/wiki/Abundant_odd_numbers"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications\nuse std::cmp::Ordering;\nuse std::iter::Map;\nuse std::ops::Range;\n\nfn divisors(n: i32) -> Vec<i32> {\n    let mut results = Vec::new();\n\n    for i in 1..(n / 2 + 1) {\n        if n % i == 0 {\n            results.push(i);\n        }\n    }\n    results\n}\n\nfn classify_numbers() -> Map<Range<i32>, fn(i32) -> Ordering> {\n    fn sum_divisors_and_cmp(n: i32) -> Ordering {\n        divisors(n).iter().fold(0, std::ops::Add::add).cmp(&n)\n    }\n    (1i32..20_001).map(sum_divisors_and_cmp as fn(i32) -> Ordering)\n}\n\nfn main() {\n    let mut deficient = 0;\n    let mut perfect = 0;\n    let mut abundant = 0;\n    for item in classify_numbers() {\n        match item {\n            Ordering::Less => deficient += 1,\n            Ordering::Equal => perfect += 1,\n            Ordering::Greater => abundant += 1,\n        }\n    }\n    println!(\"deficient: {}\", deficient);\n    println!(\"perfect: {}\", perfect);\n    println!(\"abundant: {}\", abundant);\n}\n\n#[test]\nfn test_divisors() {\n    let n = 6;\n    let divs = divisors(n);\n    let expected_divs: Vec<i32> = vec![1, 2, 3];\n    assert_eq!(divs, expected_divs);\n}\n\n#[test]\nfn test_classify_numbers() {\n    let mut deficient = 0;\n    let mut perfect = 0;\n    let mut abundant = 0;\n    for item in classify_numbers() {\n        match item {\n            Ordering::Less => deficient += 1,\n            Ordering::Equal => perfect += 1,\n            Ordering::Greater => abundant += 1,\n        }\n    }\n\n    // Numbers taken from the wiki page.\n    assert_eq!(deficient, 15043);\n    assert_eq!(perfect, 4);\n    assert_eq!(abundant, 4953);\n}\n",
    "path": "tasks/abundant-deficient-and-perfect-number-classifications",
    "remote_code": "fn main() {\n    // deficient starts at 1 because 1 is deficient but proper_divisors returns\n    // and empty Vec\n    let (mut abundant, mut deficient, mut perfect) = (0u32, 1u32, 0u32);\n    for i in 1..20_001 {\n        if let Some(divisors) = i.proper_divisors() {\n            let sum: u64 = divisors.iter().sum();\n            if sum < i {\n                deficient += 1\n            } else if sum > i {\n                abundant += 1\n            } else {\n                perfect += 1\n            }\n        }\n    }\n    println!(\"deficient:\\t{:5}\\nperfect:\\t{:5}\\nabundant:\\t{:5}\",\n             deficient, perfect, abundant);\n}\n",
    "title": "Abundant, deficient and perfect number classifications",
    "url": "http://rosettacode.org/wiki/Abundant,_deficient_and_perfect_number_classifications"
  },
  {
    "local_code": "use std::ops::Add;\n\nfn accum<'a, T>(mut n: T) -> Box<dyn FnMut(T) -> T + 'a>\nwhere\n    T: 'a + Add<T, Output = T> + Copy,\n{\n    Box::new(move |i: T| {\n        n = n + i;\n        n\n    })\n}\n\nfn main() {\n    println!(\"{}\", accumulate());\n}\n\n#[test]\nfn test() {\n    use std::f32;\n\n    assert!((8.3 - accumulate()).abs() < f32::EPSILON);\n}\n\n/// Deviation: works with all types implementing addition, but not a mixture\n/// of types (it is possible to handle mixed types, but would require type\n/// switching at the moment).\nfn accumulate() -> f32 {\n    let mut g = accum(1f32);\n    g(5.);\n    let _ = accum(3i32);\n    g(2.3)\n}\n",
    "path": "tasks/accumulator-factory",
    "remote_code": "// rustc -V\n// rustc 1.2.0-nightly (0cc99f9cc 2015-05-17) (built 2015-05-18)\n\nuse std::ops::Add;\n\nfn foo<Num>(n: Num) -> Box<FnMut(Num) -> Num>\n        where Num: Add<Output=Num> + Copy + 'static {\n    let mut acc = n;\n    Box::new(move |i: Num| {\n        acc = acc + i;\n        acc\n    })\n}\n\nfn main() {\n    let mut x = foo(1.);\n    x(5.);\n    foo(3.);\n    println!(\"{}\", x(2.3));\n}",
    "title": "Accumulator factory",
    "url": "http://rosettacode.org/wiki/Accumulator_factory"
  },
  {
    "local_code": "fn ack(m: isize, n: isize) -> isize {\n    if m == 0 {\n        n + 1\n    } else if n == 0 {\n        ack(m - 1, 1)\n    } else {\n        ack(m - 1, ack(m, n - 1))\n    }\n}\n\n#[test]\nfn test_ack() {\n    let expected = 125;\n    let found = ack(3, 4);\n    assert_eq!(expected, found)\n}\n\nfn main() {\n    let a = ack(3, 4);\n    println!(\"{}\", a);\n}\n",
    "path": "tasks/ackermann-function",
    "remote_code": "fn ack(m: isize, n: isize) -> isize {\n    if m == 0 {\n        n + 1\n    } else if n == 0 {\n        ack(m - 1, 1)\n    } else {\n        ack(m - 1, ack(m, n - 1))\n    }\n}\n\nfn main() {\n    let a = ack(3, 4);\n    println!(\"{}\", a); // 125\n}\n",
    "title": "Ackermann function",
    "url": "http://rosettacode.org/wiki/Ackermann_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nlet conn = ldap3::LdapConn::new(\"ldap://ldap.example.com\")?;\nconn.simple_bind(\"bind_dn\", \"bind_pass\")?.success()?;\n",
    "title": "Active Directory/Connect",
    "url": "http://rosettacode.org/wiki/Active_Directory/Connect"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Active Directory/Search for a user",
    "url": "http://rosettacode.org/wiki/Active_Directory/Search_for_a_user"
  },
  {
    "local_code": "use std::f64::consts::PI;\nuse std::ops::Mul;\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nuse num::traits::Zero;\nuse num::Float;\n\nuse channel::{select, SendError, Sender};\nuse crossbeam_channel as channel;\n\npub type Actor<S> = Sender<Box<dyn Fn(u32) -> S + Send>>;\npub type ActorResult<S> = Result<(), SendError<Box<dyn Fn(u32) -> S + Send>>>;\n\n/// Rust supports both shared-memory and actor models of concurrency, and the `Integrator` utilizes\n/// both.  We use an `Actor` to send the `Integrator` new functions, while we use a `Mutex`\n/// (shared-memory concurrency) to hold the result of the integration.\n///\n/// Note that these are not the only options here--there are many, many ways you can deal with\n/// concurrent access.  But when in doubt, a plain old `Mutex` is often a good bet.  For example,\n/// this might look like a good situation for a `RwLock`--after all, there's no reason for a read\n/// in the main task to block writes.  Unfortunately, unless you have significantly more reads than\n/// writes (which is certainly not the case here), a `Mutex` will usually outperform a `RwLock`.\npub struct Integrator<S: 'static, T: Send> {\n    input: Actor<S>,\n    output: Arc<Mutex<T>>,\n}\n\n/// In Rust, time durations are strongly typed.  This is usually exactly what you want, but for a\n/// problem like this--where the integrated value has unusual (unspecified?) units--it can actually\n/// be a bit tricky.  Right now, `Duration`s can only be multiplied or divided by `i32`s, so in\n/// order to be able to actually do math with them we say that the type parameter `S` (the result\n/// of the function being integrated) must yield `T` (the type of the integrated value) when\n/// multiplied by `f64`.  We could possibly replace `f64` with a generic as well, but it would make\n/// things a bit more complex.\nimpl<S, T> Integrator<S, T>\nwhere\n    S: Mul<f64, Output = T> + Float + Zero,\n    T: 'static + Clone + Send + Float,\n{\n    pub fn new(frequency: u32) -> Integrator<S, T> {\n        // We create a pipe allowing functions to be sent from tx (the sending end) to input (the\n        // receiving end).  In order to change the function we are integrating from the task in\n        // which the Integrator lives, we simply send the function through tx.\n        let (tx, input) = channel::unbounded();\n        // The easiest way to do shared-memory concurrency in Rust is to use atomic reference\n        // counting, or Arc, around a synchronized type (like Mutex<T>).  Arc gives you a guarantee\n        // that memory will not be freed as long as there is at least one reference to it.\n        // It is similar to C++'s shared_ptr, but it is guaranteed to be safe and is never\n        // incremented unless explicitly cloned (by default, it is moved).\n        let s: Arc<Mutex<T>> = Arc::new(Mutex::new(Zero::zero()));\n        let integrator = Integrator {\n            input: tx,\n            // Here is the aforementioned clone.  We have to do it before s enters the closure,\n            // because once that happens it is moved into the closure (and later, the new task) and\n            // becomes inaccessible to the outside world.\n            output: Arc::clone(&s),\n        };\n        thread::spawn(move || {\n            // The frequency is how often we want to \"tick\" as we update our integrated total.  In\n            // Rust, timers can yield Receivers that are periodically notified with an empty\n            // message (where the period is the frequency).  This is useful because it lets us wait\n            // on either a tick or another type of message (in this case, a request to change the\n            // function we are integrating).\n            let periodic = channel::tick(Duration::from_millis(frequency.into()));\n            let mut t = 0;\n            let mut k: Box<dyn Fn(u32) -> S + Send> = Box::new(|_| Zero::zero());\n            let mut k_0: S = Zero::zero();\n            loop {\n                // Here's the selection we talked about above.  Note that we are careful to call\n                // the *non*-failing function, recv(), here.  The reason we do this is because\n                // recv() will return Err when the sending end of a channel is dropped.  While\n                // this is unlikely to happen for the timer (so again, you could argue for failure\n                // there), it's normal behavior for the sending end of input to be dropped, since\n                // it just happens when the Integrator falls out of scope.  So we handle it cleanly\n                // and break out of the loop, rather than failing.\n                select! {\n                    recv(periodic) -> res => match res {\n                        Ok(_) => {\n                            t += frequency;\n                            let k_1: S = k(t);\n                            // Rust Mutexes are a bit different from Mutexes in many other\n                            // languages, in that the protected data is actually encapsulated by\n                            // the Mutex.  The reason for this is that Rust is actually capable of\n                            // enforcing (via its borrow checker) the invariant that the contents\n                            // of a Mutex may only be read when you have acquired its lock.  This\n                            // is enforced by way of a MutexGuard, the return value of lock(),\n                            // which implements some special traits (Deref and DerefMut) that allow\n                            // access to the inner element \"through\" the guard.  The element so\n                            // acquired has a lifetime bounded by that of the MutexGuard, the\n                            // MutexGuard can only be acquired by taking a lock, and the only way\n                            // to release the lock is by letting the MutexGuard fall out of scope,\n                            // so it's impossible to access the data incorrectly.  There are some\n                            // additional subtleties around the actual implementation, but that's\n                            // the basic idea.\n                            let mut s = s.lock().unwrap();\n                            *s = *s + (k_1 + k_0) * (f64::from(frequency) / 2.);\n                            k_0 = k_1;\n                        }\n                        Err(_) => break,\n                    },\n                    recv(input) -> res => match res {\n                        Ok(k_new) => k = k_new,\n                        Err(_) => break,\n                    }\n                }\n            }\n        });\n        integrator\n    }\n\n    pub fn input(&self, k: Box<dyn Fn(u32) -> S + Send>) -> ActorResult<S> {\n        // The meat of the work is done in the other thread, so to set the\n        // input we just send along the Sender we set earlier...\n        self.input.send(k)\n    }\n\n    pub fn output(&self) -> T {\n        // ...and to read the input, we simply acquire a lock on the output Mutex and return a\n        // copy. Why do we have to copy it?  Because, as mentioned above, Rust won't let us\n        // retain access to the interior of the Mutex unless we have possession of its lock.  There\n        // are ways and circumstances in which one can avoid this (e.g. by using atomic types) but\n        // a copy is a perfectly reasonable solution as well, and a lot easier to reason about :)\n        *self.output.lock().unwrap()\n    }\n}\n\n/// This function is fairly straightforward.  We create the integrator, set its input function k(t)\n/// to 2pi * f * t, and then wait as described in the Rosetta stone problem.\nfn integrate() -> f64 {\n    let object = Integrator::new(10);\n    object\n        .input(Box::new(|t: u32| {\n            let two_seconds_ms = 2 * 1000;\n            let f = 1. / f64::from(two_seconds_ms);\n            (2. * PI * f * f64::from(t)).sin()\n        }))\n        .expect(\"Failed to set input\");\n    thread::sleep(Duration::from_secs(2));\n    object.input(Box::new(|_| 0.)).expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(500));\n    object.output()\n}\n\nfn main() {\n    println!(\"{}\", integrate());\n}\n\n/// Will fail on a heavily loaded machine\n#[test]\n#[ignore]\nfn solution() {\n    // We should just be able to call integrate, but can't represent the closure properly due to\n    // rust-lang/rust issue #17060 if we make frequency or period a variable.\n    // FIXME(pythonesque): When unboxed closures are fixed, fix integrate() to take two arguments.\n    let object = Integrator::new(10);\n    object\n        .input(Box::new(|t: u32| {\n            let two_seconds_ms = 2 * 1000;\n            let f = 1. / (two_seconds_ms / 10) as f64;\n            (2. * PI * f * t as f64).sin()\n        }))\n        .expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(200));\n    object.input(Box::new(|_| 0.)).expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(100));\n    assert_eq!(object.output() as u32, 0)\n}\n",
    "path": "tasks/active-object",
    "remote_code": "#![feature(mpsc_select)]\n\nextern crate num;\nextern crate schedule_recv;\n\nuse num::traits::Zero;\nuse num::Float;\nuse schedule_recv::periodic_ms;\nuse std::f64::consts::PI;\nuse std::ops::Mul;\nuse std::sync::mpsc::{self, SendError, Sender};\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\npub type Actor<S> = Sender<Box<Fn(u32) -> S + Send>>;\npub type ActorResult<S> = Result<(), SendError<Box<Fn(u32) -> S + Send>>>;\n\n/// Rust supports both shared-memory and actor models of concurrency, and the `Integrator` utilizes\n/// both.  We use an `Actor` to send the `Integrator` new functions, while we use a `Mutex`\n/// (shared-memory concurrency) to hold the result of the integration.\n///\n/// Note that these are not the only options here--there are many, many ways you can deal with\n/// concurrent access.  But when in doubt, a plain old `Mutex` is often a good bet.  For example,\n/// this might look like a good situation for a `RwLock`--after all, there's no reason for a read\n/// in the main task to block writes.  Unfortunately, unless you have significantly more reads than\n/// writes (which is certainly not the case here), a `Mutex` will usually outperform a `RwLock`.\npub struct Integrator<S: 'static, T: Send> {\n    input: Actor<S>,\n    output: Arc<Mutex<T>>,\n}\n\n/// In Rust, time durations are strongly typed.  This is usually exactly what you want, but for a\n/// problem like this--where the integrated value has unusual (unspecified?) units--it can actually\n/// be a bit tricky.  Right now, `Duration`s can only be multiplied or divided by `i32`s, so in\n/// order to be able to actually do math with them we say that the type parameter `S` (the result\n/// of the function being integrated) must yield `T` (the type of the integrated value) when\n/// multiplied by `f64`.  We could possibly replace `f64` with a generic as well, but it would make\n/// things a bit more complex.\nimpl<S, T> Integrator<S, T>\nwhere\n    S: Mul<f64, Output = T> + Float + Zero,\n    T: 'static + Clone + Send + Float,\n{\n    pub fn new(frequency: u32) -> Integrator<S, T> {\n        // We create a pipe allowing functions to be sent from tx (the sending end) to input (the\n        // receiving end).  In order to change the function we are integrating from the task in\n        // which the Integrator lives, we simply send the function through tx.\n        let (tx, input) = mpsc::channel();\n        // The easiest way to do shared-memory concurrency in Rust is to use atomic reference\n        // counting, or Arc, around a synchronized type (like Mutex<T>).  Arc gives you a guarantee\n        // that memory will not be freed as long as there is at least one reference to it.\n        // It is similar to C++'s shared_ptr, but it is guaranteed to be safe and is never\n        // incremented unless explicitly cloned (by default, it is moved).\n        let s: Arc<Mutex<T>> = Arc::new(Mutex::new(Zero::zero()));\n        let integrator = Integrator {\n            input: tx,\n            // Here is the aforementioned clone.  We have to do it before s enters the closure,\n            // because once that happens it is moved into the closure (and later, the new task) and\n            // becomes inaccessible to the outside world.\n            output: Arc::clone(&s),\n        };\n        thread::spawn(move || -> () {\n            // The frequency is how often we want to \"tick\" as we update our integrated total.  In\n            // Rust, timers can yield Receivers that are periodically notified with an empty\n            // message (where the period is the frequency).  This is useful because it lets us wait\n            // on either a tick or another type of message (in this case, a request to change the\n            // function we are integrating).\n            let periodic = periodic_ms(frequency);\n            let mut t = 0;\n            let mut k: Box<Fn(u32) -> S + Send> = Box::new(|_| Zero::zero());\n            let mut k_0: S = Zero::zero();\n            loop {\n                // Here's the selection we talked about above.  Note that we are careful to call\n                // the *non*-failing function, recv(), here.  The reason we do this is because\n                // recv() will return Err when the sending end of a channel is dropped.  While\n                // this is unlikely to happen for the timer (so again, you could argue for failure\n                // there), it's normal behavior for the sending end of input to be dropped, since\n                // it just happens when the Integrator falls out of scope.  So we handle it cleanly\n                // and break out of the loop, rather than failing.\n                select! {\n                    res = periodic.recv() => match res {\n                        Ok(_) => {\n                            t += frequency;\n                            let k_1: S = k(t);\n                            // Rust Mutexes are a bit different from Mutexes in many other\n                            // languages, in that the protected data is actually encapsulated by\n                            // the Mutex.  The reason for this is that Rust is actually capable of\n                            // enforcing (via its borrow checker) the invariant that the contents\n                            // of a Mutex may only be read when you have acquired its lock.  This\n                            // is enforced by way of a MutexGuard, the return value of lock(),\n                            // which implements some special traits (Deref and DerefMut) that allow\n                            // access to the inner element \"through\" the guard.  The element so\n                            // acquired has a lifetime bounded by that of the MutexGuard, the\n                            // MutexGuard can only be acquired by taking a lock, and the only way\n                            // to release the lock is by letting the MutexGuard fall out of scope,\n                            // so it's impossible to access the data incorrectly.  There are some\n                            // additional subtleties around the actual implementation, but that's\n                            // the basic idea.\n                            let mut s = s.lock().unwrap();\n                            *s = *s + (k_1 + k_0) * (f64::from(frequency) / 2.);\n                            k_0 = k_1;\n                        }\n                        Err(_) => break,\n                    },\n                    res = input.recv() => match res {\n                        Ok(k_new) => k = k_new,\n                        Err(_) => break,\n                    }\n                }\n            }\n        });\n        integrator\n    }\n\n    pub fn input(&self, k: Box<Fn(u32) -> S + Send>) -> ActorResult<S> {\n        // The meat of the work is done in the other thread, so to set the\n        // input we just send along the Sender we set earlier...\n        self.input.send(k)\n    }\n\n    pub fn output(&self) -> T {\n        // ...and to read the input, we simply acquire a lock on the output Mutex and return a\n        // copy. Why do we have to copy it?  Because, as mentioned above, Rust won't let us\n        // retain access to the interior of the Mutex unless we have possession of its lock.  There\n        // are ways and circumstances in which one can avoid this (e.g. by using atomic types) but\n        // a copy is a perfectly reasonable solution as well, and a lot easier to reason about :)\n        *self.output.lock().unwrap()\n    }\n}\n\n/// This function is fairly straightforward.  We create the integrator, set its input function k(t)\n/// to 2pi * f * t, and then wait as described in the Rosetta stone problem.\nfn integrate() -> f64 {\n    let object = Integrator::new(10);\n    object\n        .input(Box::new(|t: u32| {\n            let two_seconds_ms = 2 * 1000;\n            let f = 1. / f64::from(two_seconds_ms);\n            (2. * PI * f * f64::from(t)).sin()\n        }))\n        .expect(\"Failed to set input\");\n    thread::sleep(Duration::from_secs(2));\n    object.input(Box::new(|_| 0.)).expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(500));\n    object.output()\n}\n\nfn main() {\n    println!(\"{}\", integrate());\n}\n\n/// Will fail on a heavily loaded machine\n#[test]\n#[ignore]\nfn solution() {\n    // We should just be able to call integrate, but can't represent the closure properly due to\n    // rust-lang/rust issue #17060 if we make frequency or period a variable.\n    // FIXME(pythonesque): When unboxed closures are fixed, fix integrate() to take two arguments.\n    let object = Integrator::new(10);\n    object\n        .input(Box::new(|t: u32| {\n            let two_seconds_ms = 2 * 1000;\n            let f = 1. / (two_seconds_ms / 10) as f64;\n            (2. * PI * f * t as f64).sin()\n        }))\n        .expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(200));\n    object.input(Box::new(|_| 0.)).expect(\"Failed to set input\");\n    thread::sleep(Duration::from_millis(100));\n    assert_eq!(object.output() as u32, 0)\n}",
    "title": "Active object",
    "url": "http://rosettacode.org/wiki/Active_object"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Add a variable to a class instance at runtime",
    "url": "http://rosettacode.org/wiki/Add_a_variable_to_a_class_instance_at_runtime"
  },
  {
    "local_code": "fn main() {\n    // Get the memory address of a variable\n    let var = 1_i32;\n    println!(\"address of var: {:p}\", &var);\n\n    // Get the value at a certain memory address\n    let address = &var as *const i32;\n    println!(\"value at {:p}: {:?}\", address, var);\n\n    // Set the value at a certain memory address\n    unsafe {\n        *(address as *mut i32) = 0;\n        println!(\"value at {:p}: {:?}\", address, var);\n    }\n}\n",
    "path": "tasks/address-of-a-variable",
    "remote_code": "let v1 = vec![vec![1,2,3]; 10];\nprintln!(\"Original address: {:p}\", &v1);\nlet mut v2;\n// Override rust protections on reading from uninitialized memory\nunsafe {v2 = mem::uninitialized();} \nlet addr = &mut v2 as *mut _;\n\n// ptr::write() though it takes v1 by value, v1s destructor is not run when it goes out of\n// scope, which is good since then we'd have a vector of free'd vectors\nunsafe {ptr::write(addr, v1)}\nprintln!(\"New address: {:p}\", &v2);",
    "title": "Address of a variable",
    "url": "http://rosettacode.org/wiki/Address_of_a_variable"
  },
  {
    "local_code": "const TEST_STR: &str = r\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\n\";\n\nfn main() {\n    let (chunks, max_lengths) = align_columns(TEST_STR);\n    print_aligned_columns(&chunks, &max_lengths);\n}\n\nfn align_columns(text: &str) -> (Vec<Vec<String>>, Vec<usize>) {\n    let lines: Vec<String> = text.split('\\n').map(|s| s.to_string()).collect();\n    let mut max_lengths: Vec<usize> = Vec::new();\n    let mut chunks: Vec<Vec<String>> = Vec::new();\n\n    for line in &lines {\n        let split_line: Vec<String> = line.split('$').map(|s| s.to_string()).collect();\n        chunks.push(split_line.clone());\n        let v: Vec<usize> = split_line.iter().map(|chunk| chunk.len()).collect();\n\n        for i in 0..v.len() {\n            if i < max_lengths.len() {\n                max_lengths[i] = std::cmp::max(max_lengths[i], v[i]);\n            } else {\n                max_lengths.push(v[i]);\n            }\n        }\n    }\n\n    (chunks, max_lengths)\n}\n\nfn print_aligned_columns(chunks: &[Vec<String>], max_lengths: &[usize]) {\n    // left aligned\n    for chunk in chunks {\n        for (i, split) in chunk.iter().enumerate() {\n            print!(\"{0:<1$}\", split, 1 + max_lengths[i]);\n        }\n        println!();\n    }\n    println!();\n    // right aligned\n    for chunk in chunks {\n        for (i, split) in chunk.iter().enumerate() {\n            print!(\"{0:>1$}\", split, 1 + max_lengths[i]);\n        }\n        println!();\n    }\n    println!();\n    // center aligned\n    for chunk in chunks {\n        for (i, split) in chunk.iter().enumerate() {\n            let spaces: usize = 1 + max_lengths[i] - split.len();\n            for _ in 0..spaces >> 1 {\n                print!(\" \");\n            }\n            print!(\"{}\", split);\n            for _ in 0..(spaces - (spaces >> 1)) {\n                print!(\" \");\n            }\n        }\n        println!();\n    }\n}\n\n#[test]\nfn test_result() {\n    let (chunks, max_lengths) = align_columns(TEST_STR);\n    for chunkset in &chunks {\n        // the number of words in a chunkset is <= the number of values in max_lengths\n        assert!(chunkset.len() <= max_lengths.len());\n        for j in 0..chunkset.len() {\n            // a word in a chunkset cannot be longer than max_lengths\n            assert!(chunkset[j].len() <= max_lengths[j]);\n        }\n    }\n    print_aligned_columns(&chunks, &max_lengths);\n}\n",
    "path": "tasks/align-columns",
    "remote_code": "use std::iter::{Extend, repeat};\n\nenum AlignmentType { Left, Center, Right }\n\nfn get_column_widths(text: &str) -> Vec<usize> {\n    let mut widths = Vec::new();\n    for line in text.lines().map(|s| s.trim_matches(' ').trim_right_matches('$')) {\n        let lens = line.split('$').map(|s| s.chars().count());\n        for    (idx, len) in lens.enumerate() {\n            if idx < widths.len() {\n                widths[idx] = std::cmp::max(widths[idx], len);\n            }\n            else {\n                widths.push(len);\n            }\n        }\n    }\n    widths\n}\n\nfn align_columns(text: &str, alignment: AlignmentType) -> String {\n    let widths = get_column_widths(text);\n    let mut result = String::new();\n    for line in text.lines().map(|s| s.trim_matches(' ').trim_right_matches('$')) {\n        for (s, w) in line.split('$').zip(widths.iter()) {\n            let blank_count = w - s.chars().count();\n            let (pre, post) = match alignment {\n                AlignmentType::Left => (0, blank_count),\n                AlignmentType::Center => (blank_count / 2, (blank_count + 1) / 2),\n                AlignmentType::Right => (blank_count, 0),\n            };\n            result.extend(repeat(' ').take(pre));\n            result.push_str(s);\n            result.extend(repeat(' ').take(post));\n            result.push(' ');\n        }\n        result.push_str(\"\\n\");\n    }\n    result\n}\n\nfn main() {\n    let text = r#\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\"#;\n\n    println!(\"{}\", align_columns(text, AlignmentType::Left));\n    println!(\"{}\", repeat('-').take(110).collect::<String>());\n    println!(\"{}\", align_columns(text, AlignmentType::Center));\n    println!(\"{}\", repeat('-').take(110).collect::<String>());\n    println!(\"{}\", align_columns(text, AlignmentType::Right));\n}",
    "title": "Align columns",
    "url": "http://rosettacode.org/wiki/Align_columns"
  },
  {
    "local_code": "#[derive(Debug, PartialEq)]\nenum AliquotType {\n    Terminating,\n    Perfect,\n    Amicable,\n    Sociable,\n    Aspiring,\n    Cyclic,\n    NonTerminating,\n}\n\n#[cfg_attr(feature = \"clippy\", allow(needless_range_loop))]\nfn classify_aliquot(num: i64) -> (AliquotType, Vec<i64>) {\n    let limit = 1i64 << 47; // 140737488355328\n    let mut terms = Some(num).into_iter().collect::<Vec<_>>();\n    for i in 0..16 {\n        let n = terms[i];\n        let divsum = (1..(n + 1) / 2 + 1)\n            .filter(|&x| n % x == 0 && n != x)\n            .fold(0, |sum, x| sum + x);\n        let classification = if divsum == 0 {\n            Some(AliquotType::Terminating)\n        } else if divsum > limit {\n            Some(AliquotType::NonTerminating)\n        } else if let Some(prev_idx) = terms.iter().position(|&x| x == divsum) {\n            let cycle_len = terms.len() - prev_idx;\n            Some(if prev_idx == 0 {\n                match cycle_len {\n                    1 => AliquotType::Perfect,\n                    2 => AliquotType::Amicable,\n                    _ => AliquotType::Sociable,\n                }\n            } else if cycle_len == 1 {\n                AliquotType::Aspiring\n            } else {\n                AliquotType::Cyclic\n            })\n        } else {\n            None\n        };\n        terms.push(divsum);\n        if let Some(result) = classification {\n            return (result, terms);\n        }\n    }\n    (AliquotType::NonTerminating, terms)\n}\n\nfn main() {\n    let nums = [\n        1i64, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 28, 496, 220, 1184, 12_496, 1_264_460, 790, 909,\n        562, 1064, 1488, /* , 15355717786080 */\n    ];\n    for num in &nums {\n        println!(\"{} {:?}\", num, classify_aliquot(*num));\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{classify_aliquot, AliquotType};\n\n    #[test]\n    fn terminating() {\n        assert_eq!(\n            classify_aliquot(11),\n            (AliquotType::Terminating, vec![11, 1, 0])\n        );\n        assert_eq!(\n            classify_aliquot(12),\n            (AliquotType::Terminating, vec![12, 16, 15, 9, 4, 3, 1, 0])\n        );\n    }\n\n    #[test]\n    fn perfect() {\n        assert_eq!(classify_aliquot(28), (AliquotType::Perfect, vec![28, 28]));\n        assert_eq!(\n            classify_aliquot(496),\n            (AliquotType::Perfect, vec![496, 496])\n        );\n    }\n\n    #[test]\n    fn amicable() {\n        assert_eq!(\n            classify_aliquot(220),\n            (AliquotType::Amicable, vec![220, 284, 220])\n        );\n        assert_eq!(\n            classify_aliquot(1184),\n            (AliquotType::Amicable, vec![1184, 1210, 1184])\n        );\n    }\n\n    #[test]\n    fn sociable() {\n        assert_eq!(\n            classify_aliquot(12_496),\n            (\n                AliquotType::Sociable,\n                vec![12_496, 14_288, 15_472, 14_536, 14_264, 12_496]\n            )\n        );\n        assert_eq!(\n            classify_aliquot(1_264_460),\n            (\n                AliquotType::Sociable,\n                vec![1_264_460, 1_547_860, 1_727_636, 1_305_184, 1_264_460]\n            )\n        );\n    }\n\n    #[test]\n    fn aspiring() {\n        assert_eq!(\n            classify_aliquot(790),\n            (AliquotType::Aspiring, vec![790, 650, 652, 496, 496])\n        );\n        assert_eq!(\n            classify_aliquot(909),\n            (AliquotType::Aspiring, vec![909, 417, 143, 25, 6, 6])\n        );\n    }\n\n    #[test]\n    fn cyclic() {\n        assert_eq!(\n            classify_aliquot(562),\n            (AliquotType::Cyclic, vec![562, 284, 220, 284])\n        );\n        assert_eq!(\n            classify_aliquot(1064),\n            (AliquotType::Cyclic, vec![1064, 1336, 1184, 1210, 1184])\n        );\n    }\n\n    #[ignore]\n    #[test]\n    fn non_terminating() {\n        assert_eq!(\n            classify_aliquot(1488),\n            (\n                AliquotType::NonTerminating,\n                vec![\n                    1488, 2480, 3472, 4464, 8432, 9424, 10_416, 21_328, 22_320, 55_056, 95_728,\n                    96_720, 236_592, 459_792, 881_392, 882_384,\n                ]\n            )\n        );\n        assert_eq!(\n            classify_aliquot(15_355_717_786_080),\n            (\n                AliquotType::NonTerminating,\n                vec![15_355_717_786_080, 44_534_663_601_120, 144_940_087_464_480]\n            )\n        );\n    }\n}\n",
    "path": "tasks/aliquot-sequence-classifications",
    "remote_code": "#[derive(Debug)]\nenum AliquotType { Terminating, Perfect, Amicable, Sociable, Aspiring, Cyclic, NonTerminating }\n\nfn classify_aliquot(num: i64) -> (AliquotType, Vec<i64>) {\n    let limit = 1i64 << 47; //140737488355328\n    let mut terms = Some(num).into_iter().collect::<Vec<_>>();\n    for i in 0..16 {\n        let n = terms[i];\n        let divsum = (1..(n + 1) / 2 + 1).filter(|&x| n % x == 0 && n != x).fold(0, |sum, x| sum + x);\n        let classification = if divsum == 0 {\n            Some(AliquotType::Terminating)\n        }\n        else if divsum > limit {\n            Some(AliquotType::NonTerminating)\n        }\n        else if let Some(prev_idx) = terms.iter().position(|&x| x == divsum) {\n            let cycle_len = terms.len() - prev_idx;\n            Some(if prev_idx == 0 {\n                match cycle_len {\n                    1 => AliquotType::Perfect,\n                    2 => AliquotType::Amicable,\n                    _ => AliquotType::Sociable\n                }\n            }\n            else {\n                if cycle_len == 1 {AliquotType::Aspiring} else {AliquotType::Cyclic}\n            })\n        }\n        else {\n            None\n        };\n        terms.push(divsum);\n        if let Some(result) = classification {\n            return (result, terms);\n        }\n    }\n    (AliquotType::NonTerminating, terms)\n}\n\nfn main() {\n    let nums = [1i64, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488/*, 15355717786080*/];\n    for num in &nums {\n        println!(\"{} {:?}\", num, classify_aliquot(*num));\n    }\n}",
    "title": "Aliquot sequence classifications",
    "url": "http://rosettacode.org/wiki/Aliquot_sequence_classifications"
  },
  {
    "local_code": "fn is_kprime(mut n: usize, k: usize) -> bool {\n    let mut p = 2;\n    let mut f = 0;\n\n    while f < k && p * p <= n {\n        while 0 == n % p {\n            n /= p;\n            f += 1;\n        }\n        p += 1;\n    }\n\n    f + (n > 1) as usize == k\n}\n\nfn get_kprimes(k: usize, amount: usize) -> Vec<usize> {\n    (2..).filter(|&x| is_kprime(x, k)).take(amount).collect()\n}\n\nfn main() {\n    for k in 1..6 {\n        println!(\"k = {}: {:?}\", k, get_kprimes(k, 10));\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::get_kprimes;\n\n    #[test]\n    fn k_equals_1() {\n        assert!(get_kprimes(1, 10) == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]);\n    }\n\n    #[test]\n    fn k_equals_2() {\n        assert!(get_kprimes(2, 10) == [4, 6, 9, 10, 14, 15, 21, 22, 25, 26]);\n    }\n\n    #[test]\n    fn k_equals_3() {\n        assert!(get_kprimes(3, 10) == [8, 12, 18, 20, 27, 28, 30, 42, 44, 45]);\n    }\n\n    #[test]\n    fn k_equals_4() {\n        assert!(get_kprimes(4, 10) == [16, 24, 36, 40, 54, 56, 60, 81, 84, 88]);\n    }\n\n    #[test]\n    fn k_equals_5() {\n        assert!(get_kprimes(5, 10) == [32, 48, 72, 80, 108, 112, 120, 162, 168, 176]);\n    }\n}\n",
    "path": "tasks/almost-prime",
    "remote_code": "fn is_kprime(n: u32, k: u32) -> bool {\n    let mut primes = 0;\n    let mut f = 2;\n    let mut rem = n;\n    while primes < k && rem > 1{\n        while (rem % f) == 0 && rem > 1{\n            rem /= f;\n            primes += 1;\n        }\n        f += 1;\n    }\n    rem == 1 && primes == k\n}\n\nstruct KPrimeGen {\n    k: u32,\n    n: u32,\n}\n\nimpl Iterator for KPrimeGen {\n    type Item = u32;\n    fn next(&mut self) -> Option<u32> {\n        self.n += 1;\n        while !is_kprime(self.n, self.k) {\n            self.n += 1;\n        }\n        Some(self.n)\n    }\n}\n\nfn kprime_generator(k: u32) -> KPrimeGen {\n    KPrimeGen {k: k, n: 1}\n}\n\nfn main() {\n    for k in 1..6 {\n        println!(\"{}: {:?}\", k, kprime_generator(k).take(10).collect::<Vec<_>>());\n    }\n}",
    "title": "Almost prime",
    "url": "http://rosettacode.org/wiki/Almost_prime"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Amb",
    "url": "http://rosettacode.org/wiki/Amb"
  },
  {
    "local_code": "fn sum_of_divisors(val: u32) -> u32 {\n    (1..val / 2 + 1)\n        .filter(|n| val % n == 0)\n        .fold(0, |sum, n| sum + n)\n}\n\nfn main() {\n    let iter = (1..20_000)\n        .map(|i| (i, sum_of_divisors(i)))\n        .filter(|&(i, div_sum)| i > div_sum);\n\n    for (i, sum1) in iter {\n        if sum_of_divisors(sum1) == i {\n            println!(\"{} {}\", i, sum1);\n        }\n    }\n}\n",
    "path": "tasks/amicable-pairs",
    "remote_code": "fn sum_of_divisors(val: u32) -> u32 {\n    (1..val/2+1).filter(|n| val % n == 0)\n                .fold(0, |sum, n| sum + n)\n}\n\nfn main() {\n    let iter = (1..20_000).map(|i| (i, sum_of_divisors(i)))\n                          .filter(|&(i, div_sum)| i > div_sum);\n\n    for (i, sum1) in iter {\n        if sum_of_divisors(sum1) == i {\n           println!(\"{} {}\", i, sum1);\n        }\n    }\n}",
    "title": "Amicable pairs",
    "url": "http://rosettacode.org/wiki/Amicable_pairs"
  },
  {
    "local_code": "use std::collections::hash_map::Entry::{Occupied, Vacant};\nuse std::collections::{HashMap, HashSet};\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::io::BufReader;\n\nfn sorted_characters(string: &str) -> String {\n    let mut chars = string.chars().collect::<Vec<char>>();\n    chars.sort();\n    chars.iter().cloned().collect()\n}\n\n/// Returns groups of anagrams where each group consists of a set\n/// containing the words\nfn anagrams<T: Iterator<Item = String>>(lines: T) -> HashMap<String, HashSet<String>> {\n    let mut groups = HashMap::new();\n\n    // Make groups of words according to the letters they contain\n    for line in lines {\n        let s = line.trim();\n        let sorted = sorted_characters(s);\n        let set = match groups.entry(sorted) {\n            Vacant(entry) => entry.insert(HashSet::new()), // Insert new set if not found\n            Occupied(entry) => entry.into_mut(),\n        };\n\n        set.insert(s.to_string());\n    }\n\n    groups\n}\n\n/// Returns the groups of anagrams that contain the most words in them\nfn largest_groups(groups: &HashMap<String, HashSet<String>>) -> HashMap<String, HashSet<String>> {\n    let max_length = groups.iter().map(|(_, group)| group.len()).max().unwrap();\n    groups\n        .iter()\n        .filter_map(|(key, group)| {\n            if group.len() == max_length {\n                Some((key.clone(), group.clone()))\n            } else {\n                None\n            }\n        })\n        .collect()\n}\n\nfn main() {\n    let reader = BufReader::new(File::open(\"resources/unixdict.txt\").unwrap());\n    let lines = reader.lines().map(|l| l.unwrap());\n\n    let anagram_groups = anagrams(lines);\n    let largest_groups = largest_groups(&anagram_groups);\n\n    // Print the words in the largest groups of anagrams\n    for group in largest_groups.values() {\n        for word in group {\n            print!(\"{} \", word)\n        }\n        println!();\n    }\n}\n\n#[test]\nfn basic_test() {\n    fn to_hash(s: &[&str]) -> HashSet<String> {\n        s.iter().map(|s| s.to_string()).collect()\n    };\n\n    fn assert_has_value(map: &HashMap<String, HashSet<String>>, set: &HashSet<String>) {\n        assert!(map.values().any(|v| v == set));\n    }\n\n    // Groups of anagrams\n    let group1 = &to_hash(&[\"lane\", \"neal\", \"lean\"]);\n    let group2 = &to_hash(&[\"angel\", \"angle\", \"galen\"]);\n    let group3 = &to_hash(&[\"glare\", \"large\"]);\n\n    // Prepare the input for the program\n    let word_iter = group1.iter().chain(group2.iter().chain(group3.iter()));\n\n    // Here begins the real testing\n    let all_groups = &anagrams(word_iter.map(|s| s.to_string()));\n    let largest_groups = &largest_groups(all_groups);\n\n    // Groups 1, 2 and 3 are contained in \"all_groups\"\n    assert_has_value(all_groups, group1);\n    assert_has_value(all_groups, group2);\n    assert_has_value(all_groups, group3);\n\n    // Groups 1 and 2 are contained in \"largest_groups\". Group 3 is not.\n    assert_has_value(largest_groups, group1);\n    assert_has_value(largest_groups, group2);\n    assert!(largest_groups.values().all(|group| group != group3));\n}\n",
    "path": "tasks/anagrams",
    "remote_code": "use std::collections::HashMap;\nuse std::fs::File;\nuse std::io::{BufRead,BufReader};\nuse std::borrow::ToOwned;\n\nextern crate unicode_segmentation;\nuse unicode_segmentation::{UnicodeSegmentation};\n\nfn main () {\n    let file = BufReader::new(File::open(\"unixdict.txt\").unwrap());\n    let mut map = HashMap::new();\n    for line in file.lines() {\n        let s = line.unwrap();\n        //Bytes:      let mut sorted = s.trim().bytes().collect::<Vec<_>>();\n        //Codepoints: let mut sorted = s.trim().chars().collect::<Vec<_>>();\n        let mut sorted = s.trim().graphemes(true).map(ToOwned::to_owned).collect::<Vec<_>>();\n        sorted.sort();\n\n        map.entry(sorted).or_insert_with(Vec::new).push(s);\n    }\n\n    if let Some(max_len) = map.values().map(|v| v.len()).max() {\n        for anagram in map.values().filter(|v| v.len() == max_len) {\n            for word in anagram {\n                print!(\"{} \", word);\n            }\n            println!();\n        }\n    }\n}",
    "title": "Anagrams",
    "url": "http://rosettacode.org/wiki/Anagrams"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "//! Deranged anagrams\nuse std::cmp::Ordering;\nuse std::collections::HashMap;\nuse std::fs::File;\nuse std::io;\nuse std::io::BufReader;\nuse std::io::BufRead;\nuse std::usize::MAX;\n\n/// Get words from unix dictionary file\npub fn get_words() -> Result<Vec<String>, io::Error> {\n    let mut words = vec!();\n    // open file\n    let f = File::open(\"data/unixdict.txt\")?;\n    // read line by line\n    let reader = BufReader::new(&f);\n    for line in reader.lines() {\n        words.push(line?)\n    }\n    Ok(words)\n}\n\n/// Get the longest deranged anagram in the given list of word if any\npub fn longest_deranged(v: &mut Vec<String>) -> Option<(String,String)>{\n    // sort by length descending then by alphabetical order\n    v.sort_by(|s1, s2| {\n        let mut c = s2.len().cmp(&s1.len());\n        if c == Ordering::Equal {\n            c = s1.cmp(s2);\n        }\n        c\n    });\n    // keep all strings keyed by sorted characters (since anagrams have the same list of sorted characters)\n    let mut signatures : HashMap<Vec<char>, Vec<&String>> = HashMap::new();\n    // save on memory by only keeping in the map strings of the current processed length\n    let mut previous_length = MAX;\n    for s in v {\n        // length change, clear the map\n        if s.len()<previous_length {\n            signatures.clear();\n            previous_length = s.len();\n        }\n        // generate key as sorted characters\n        let mut sorted_chars = s.chars().collect::<Vec<char>>();\n        sorted_chars.sort();\n        let anagrams = signatures.entry(sorted_chars).or_insert(vec!());\n        // find if any anagram (string with the same sorted character vector) is deranged\n        if let Some(a) = anagrams.iter().filter(|anagram| is_deranged(anagram, s)).next(){\n            return Some(((*a).clone(), s.clone()));\n        }\n        anagrams.push(s);\n    }\n    None\n}\n\n/// check if two strings do NOT have the same character in the same position\npub fn is_deranged(s1: &String, s2: &String) -> bool {\n    // we zip the character iterators and check we find no position with the same two characters\n    s1.chars().zip(s2.chars()).filter(|(a,b)| a == b).next().is_none()\n}\n\n/// an example main method printing the results\nfn main() {\n    let r = get_words();\n    match r {\n        Ok(mut v) => {\n            let od = longest_deranged(&mut v);\n            match od {\n                None => println!(\"No deranged anagrams found!\"),\n                Some((s1,s2)) => println!(\"{} {}\",s1,s2),\n            }\n        },\n        Err(e) => panic!(\"Could not read words: {}\",e)\n    } \n}\n\n\n",
    "title": "Anagrams/Deranged anagrams",
    "url": "http://rosettacode.org/wiki/Anagrams/Deranged_anagrams"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n/// Calculate difference between two bearings, in -180 to 180 degrees range\npub fn angle_difference(bearing1: f64, bearing2: f64) -> f64 {\n    let diff = (bearing2 - bearing1) % 360.0;\n    if diff < -180.0 {\n        360.0 + diff\n    } else if diff > 180.0 {\n        -360.0 + diff\n    } else {\n        diff\n    }\n\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_angle_difference() {\n        assert_eq!(25.00, angle_difference(20.00, 45.00));\n        assert_eq!(90.00, angle_difference(-45.00, 45.00));\n        assert_eq!(175.00, angle_difference(-85.00, 90.00));\n        assert_eq!(-175.00, angle_difference(-95.00, 90.00));\n        assert_eq!(170.00, angle_difference(-45.00, 125.00));\n        assert_eq!(-170.00, angle_difference(-45.00, 145.00));\n        approx_eq(-118.1184, angle_difference(29.4803, -88.6381));\n        approx_eq(-80.7109, angle_difference(-78.3251 , -159.036));\n        approx_eq(-139.5832, angle_difference(-70099.74233810938, 29840.67437876723));\n        approx_eq(-72.3439, angle_difference(-165313.6666297357, 33693.9894517456));\n        approx_eq(-161.5029, angle_difference(1174.8380510598456, -154146.66490124757));\n        approx_eq(37.2988, angle_difference(60175.77306795546, 42213.07192354373));\n    }\n\n    // approximate equality on floats.\n    // see also https://crates.io/crates/float-cmp\n    fn approx_eq(f1: f64, f2: f64) {\n        assert!((f2-f1).abs() < 0.0001, \"{} != {}\", f1, f2)\n    }\n}\n",
    "title": "Angle difference between two bearings",
    "url": "http://rosettacode.org/wiki/Angle_difference_between_two_bearings"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::{\n    marker::PhantomData,\n    f64::consts::PI,\n};\n\npub trait AngleUnit: Copy {\n    const TURN: f64;\n    const NAME: &'static str;\n}\n\nmacro_rules! unit {\n    ($name:ident, $value:expr, $string:expr) => (\n        #[derive(Debug, Copy, Clone)]\n        struct $name;\n        impl AngleUnit for $name {\n            const TURN: f64 = $value;\n            const NAME: &'static str = $string;\n        }\n    );\n}\n\nunit!(Degrees,  360.0,      \"Degrees\");\nunit!(Radians,  PI * 2.0,   \"Radians\");\nunit!(Gradians, 400.0,      \"Gradians\");\nunit!(Mils,     6400.0,     \"Mils\");\n\n#[derive(Copy, Clone, PartialEq, PartialOrd)]\nstruct Angle<T: AngleUnit>(f64, PhantomData<T>);\n\nimpl<T: AngleUnit> Angle<T> {\n    pub fn new(val: f64) -> Self {\n        Self(val, PhantomData)\n    }\n\n    pub fn normalize(self) -> Self {\n        Self(self.0 % T::TURN, PhantomData)\n    }\n\n    pub fn val(self) -> f64 {\n        self.0\n    }\n\n    pub fn convert<U: AngleUnit>(self) -> Angle<U> {\n        Angle::new(self.0 * U::TURN / T::TURN)\n    }\n\n    pub fn name(self) -> &'static str {\n        T::NAME\n    }\n}\n\nfn print_angles<T: AngleUnit>() {\n    let angles = [-2.0, -1.0, 0.0, 1.0, 2.0, 6.2831853, 16.0, 57.2957795, 359.0, 399.0, 6399.0, 1000000.0];\n    println!(\"{:<12} {:<12} {:<12} {:<12} {:<12} {:<12}\", \"Angle\", \"Unit\", \"Degrees\", \"Gradians\", \"Mils\", \"Radians\");\n\n    for &angle in &angles {\n        let deg = Angle::<T>::new(angle).normalize();\n        println!(\"{:<12} {:<12} {:<12.4} {:<12.4} {:<12.4} {:<12.4}\",\n                 angle,\n                 deg.name(),\n                 deg.convert::<Degrees>().val(),\n                 deg.convert::<Gradians>().val(),\n                 deg.convert::<Mils>().val(),\n                 deg.convert::<Radians>().val(),\n        );\n    }\n\n    println!();\n}\n\nfn main() {\n    print_angles::<Degrees>();\n    print_angles::<Gradians>();\n    print_angles::<Mils>();\n    print_angles::<Radians>();\n}",
    "title": "Angles (geometric), normalization and conversion",
    "url": "http://rosettacode.org/wiki/Angles_(geometric),_normalization_and_conversion"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Animate a pendulum",
    "url": "http://rosettacode.org/wiki/Animate_a_pendulum"
  },
  {
    "local_code": "#[cfg(feature = \"gtk\")]\nmod graphical {\n    extern crate gtk;\n\n    use self::gtk::traits::*;\n    use self::gtk::{Inhibit, Window, WindowType};\n    use std::ops::Not;\n    use std::sync::{Arc, RwLock};\n\n    pub fn create_window() {\n        gtk::init().expect(\"Failed to initialize GTK\");\n\n        let window = Window::new(WindowType::Toplevel);\n        window.connect_delete_event(|_, _| {\n            gtk::main_quit();\n            Inhibit(false)\n        });\n        let button = gtk::Button::new_with_label(\"Hello World! \");\n        window.add(&button);\n\n        let lock = Arc::new(RwLock::new(false));\n\n        let lock_button = lock.clone();\n        button.connect_clicked(move |_| {\n            let mut reverse = lock_button.write().unwrap();\n            *reverse = reverse.not();\n        });\n\n        let lock_thread = lock.clone();\n        gtk::timeout_add(100, move || {\n            let reverse = lock_thread.read().unwrap();\n            let mut text = button.get_label().unwrap();\n            let len = &text.len();\n\n            if *reverse {\n                let begin = &text.split_off(1);\n                text.insert_str(0, begin);\n            } else {\n                let end = &text.split_off(len - 1);\n                text.insert_str(0, end);\n            }\n\n            button.set_label(&text);\n\n            gtk::Continue(true)\n        });\n\n        window.show_all();\n        gtk::main();\n    }\n}\n\n#[cfg(feature = \"gtk\")]\nfn main() {\n    graphical::create_window();\n}\n\n#[cfg(not(feature = \"gtk\"))]\nfn main() {}\n",
    "path": "tasks/animation",
    "remote_code": "#[cfg(feature = \"gtk\")]\nmod graphical {\n    extern crate gtk;\n\n    use self::gtk::traits::*;\n    use self::gtk::{Inhibit, Window, WindowType};\n    use std::ops::Not;\n    use std::sync::{Arc, RwLock};\n\n    pub fn create_window() {\n        gtk::init().expect(\"Failed to initialize GTK\");\n\n        let window = Window::new(WindowType::Toplevel);\n        window.connect_delete_event(|_, _| {\n            gtk::main_quit();\n            Inhibit(false)\n        });\n        let button = gtk::Button::new_with_label(\"Hello World! \");\n        window.add(&button);\n\n        let lock = Arc::new(RwLock::new(false));\n\n        let lock_button = lock.clone();\n        button.connect_clicked(move |_| {\n            let mut reverse = lock_button.write().unwrap();\n            *reverse = reverse.not();\n        });\n\n        let lock_thread = lock.clone();\n        gtk::timeout_add(100, move || {\n            let reverse = lock_thread.read().unwrap();\n            let mut text = button.get_label().unwrap();\n            let len = &text.len();\n\n            if *reverse {\n                let begin = &text.split_off(1);\n                text.insert_str(0, begin);\n            } else {\n                let end = &text.split_off(len - 1);\n                text.insert_str(0, end);\n            }\n\n            button.set_label(&text);\n\n            gtk::Continue(true)\n        });\n\n        window.show_all();\n        gtk::main();\n    }\n}\n\n\n#[cfg(feature = \"gtk\")]\nfn main() {\n    graphical::create_window();\n}\n\n#[cfg(not(feature = \"gtk\"))]\nfn main() {}",
    "title": "Animation",
    "url": "http://rosettacode.org/wiki/Animation"
  },
  {
    "local_code": "fn fib(n: i64) -> Option<i64> {\n    // A function declared inside another function does not pollute the outer namespace.\n    fn actual_fib(n: i64) -> i64 {\n        if n < 2 {\n            n\n        } else {\n            actual_fib(n - 1) + actual_fib(n - 2)\n        }\n    }\n\n    if n < 0 {\n        None\n    } else {\n        Some(actual_fib(n))\n    }\n}\n\nfn main() {\n    println!(\"Fib(-1) = {:?}\", fib(-1));\n    println!(\"Fib(0) = {:?}\", fib(0));\n    println!(\"Fib(1) = {:?}\", fib(1));\n    println!(\"Fib(2) = {:?}\", fib(2));\n    println!(\"Fib(3) = {:?}\", fib(3));\n    println!(\"Fib(4) = {:?}\", fib(4));\n    println!(\"Fib(5) = {:?}\", fib(5));\n    println!(\"Fib(10) = {:?}\", fib(10));\n}\n\n#[test]\nfn test_fib() {\n    assert_eq!(fib(0).unwrap(), 0);\n    assert_eq!(fib(1).unwrap(), 1);\n    assert_eq!(fib(2).unwrap(), 1);\n    assert_eq!(fib(3).unwrap(), 2);\n    assert_eq!(fib(4).unwrap(), 3);\n    assert_eq!(fib(5).unwrap(), 5);\n    assert_eq!(fib(10).unwrap(), 55);\n}\n\n#[test]\nfn test_invalid_argument() {\n    assert_eq!(fib(-1), None);\n}\n",
    "path": "tasks/anonymous-recursion",
    "remote_code": "fn fib(n: i64) -> Option<i64> {\n    // A function declared inside another function does not pollute the outer namespace.\n    fn actual_fib(n: i64) -> i64 {\n        if n < 2 {\n            n\n        } else {\n            actual_fib(n - 1) + actual_fib(n - 2)\n        }\n    }\n\n    if n < 0 {\n        None\n    } else {\n        Some(actual_fib(n))\n    }\n}\n\nfn main() {\n    println!(\"Fib(-1) = {:?}\", fib(-1));\n    println!(\"Fib(0) = {:?}\", fib(0));\n    println!(\"Fib(1) = {:?}\", fib(1));\n    println!(\"Fib(2) = {:?}\", fib(2));\n    println!(\"Fib(3) = {:?}\", fib(3));\n    println!(\"Fib(4) = {:?}\", fib(4));\n    println!(\"Fib(5) = {:?}\", fib(5));\n    println!(\"Fib(10) = {:?}\", fib(10));\n}\n\n#[test]\nfn test_fib() {\n    assert_eq!(fib(0).unwrap(), 0);\n    assert_eq!(fib(1).unwrap(), 1);\n    assert_eq!(fib(2).unwrap(), 1);\n    assert_eq!(fib(3).unwrap(), 2);\n    assert_eq!(fib(4).unwrap(), 3);\n    assert_eq!(fib(5).unwrap(), 5);\n    assert_eq!(fib(10).unwrap(), 55);\n}\n\n#[test]\nfn test_invalid_argument() {\n    assert_eq!(fib(-1), None);\n}",
    "title": "Anonymous recursion",
    "url": "http://rosettacode.org/wiki/Anonymous_recursion"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Anti-primes",
    "url": "http://rosettacode.org/wiki/Anti-primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::BufRead;\nuse std::io::BufReader;\nuse std::io::BufWriter;\nuse std::io::Result;\nuse std::io::Write;\nuse std::path::Path;\n\n/// Password record with all fields\n#[derive(Eq, PartialEq, Debug)]\npub struct PasswordRecord {\n    pub account: String,\n    pub password: String,\n    pub uid: u64,\n    pub gid: u64,\n    pub gecos: Vec<String>,\n    pub directory: String,\n    pub shell: String,\n}\n\n\nimpl PasswordRecord {\n    /// new instance, cloning all fields\n    pub fn new(\n        account: &str,\n        password: &str,\n        uid: u64,\n        gid: u64,\n        gecos: Vec<&str>,\n        directory: &str,\n        shell: &str,\n    ) -> PasswordRecord {\n        PasswordRecord {\n            account: account.to_string(),\n            password: password.to_string(),\n            uid,\n            gid,\n            gecos: gecos.iter().map(|s| s.to_string()).collect(),\n            directory: directory.to_string(),\n            shell: shell.to_string(),\n        }\n    }\n\n    /// convert to one line string\n    pub fn to_line(&self) -> String {\n        let gecos = self.gecos.join(\",\");\n        format!(\n            \"{}:{}:{}:{}:{}:{}:{}\",\n            self.account, self.password, self.uid, self.gid, gecos, self.directory, self.shell\n        )\n    }\n\n    /// read record from line\n    pub fn from_line(line: &str) -> PasswordRecord {\n        let sp: Vec<&str> = line.split(\":\").collect();\n        if sp.len() < 7 {\n            panic!(\"Less than 7 fields found\");\n        } else {\n            let uid = sp[2].parse().expect(\"Cannot parse uid\");\n            let gid = sp[3].parse().expect(\"Cannot parse gid\");\n            let gecos = sp[4].split(\",\").collect();\n            PasswordRecord::new(sp[0], sp[1], uid, gid, gecos, sp[5], sp[6])\n        }\n    }\n}\n\n/// read all records from file\npub fn read_password_file(file_name: &str) -> Result<Vec<PasswordRecord>> {\n    let p = Path::new(file_name);\n    if !p.exists() {\n        Ok(vec![])\n    } else {\n        let f = OpenOptions::new().read(true).open(p)?;\n        Ok(BufReader::new(&f)\n            .lines()\n            .map(|l| PasswordRecord::from_line(&l.unwrap()))\n            .collect())\n    }\n}\n\n/// overwrite file with records\npub fn overwrite_password_file(file_name: &str, recs: &Vec<PasswordRecord>) -> Result<()> {\n    let f = OpenOptions::new()\n        .create(true)\n        .write(true)\n        .open(file_name)?;\n    write_records(f, recs)\n}\n\n/// append records to file\npub fn append_password_file(file_name: &str, recs: &Vec<PasswordRecord>) -> Result<()> {\n    let f = OpenOptions::new()\n        .create(true)\n        .append(true)\n        .open(file_name)?;\n    write_records(f, recs)\n}\n\n/// internal, write records line by line\nfn write_records(f: File, recs: &Vec<PasswordRecord>) -> Result<()> {\n    let mut writer = BufWriter::new(f);\n    for rec in recs {\n        write!(writer, \"{}\\n\", rec.to_line())?;\n    }\n    Ok(())\n}\n\nfn main(){\n    let recs1 = vec![\n            PasswordRecord::new(\n                \"jsmith\",\n                \"x\",\n                1001,\n                1000,\n                vec![\n                    \"Joe Smith\",\n                    \"Room 1007\",\n                    \"(234)555-8917\",\n                    \"(234)555-0077\",\n                    \"jsmith@rosettacode.org\",\n                ],\n                \"/home/jsmith\",\n                \"/bin/bash\",\n            ),\n            PasswordRecord::new(\n                \"jdoe\",\n                \"x\",\n                1002,\n                1000,\n                vec![\n                    \"Jane Doe\",\n                    \"Room 1004\",\n                    \"(234)555-8914\",\n                    \"(234)555-0044\",\n                    \"jdoe@rosettacode.org\",\n                ],\n                \"/home/jdoe\",\n                \"/bin/bash\",\n            ),\n        ];\n\n    overwrite_password_file(\"passwd\", &recs1).expect(\"cannot write file\");\n    let recs2 = read_password_file(\"passwd\").expect(\"cannot read file\");\n    println!(\"Original file:\");\n    for r in recs2 {\n        println!(\"{}\",r.to_line());\n    }\n    let append0 = vec![PasswordRecord::new(\n            \"xyz\",\n            \"x\",\n            1003,\n            1000,\n            vec![\n                \"X Yz\",\n                \"Room 1003\",\n                \"(234)555-8913\",\n                \"(234)555-0033\",\n                \"xyz@rosettacode.org\",\n            ],\n            \"/home/xyz\",\n            \"/bin/bash\",\n        )];\n    append_password_file(\"passwd\", &append0).expect(\"cannot append to file\");\n    let recs2 = read_password_file(\"passwd\").expect(\"cannot read file\");\n    println!(\"\");\n    println!(\"Appended file:\");\n    for r in recs2 {\n        println!(\"{}\",r.to_line());\n    }\n}\n",
    "title": "Append a record to the end of a text file",
    "url": "http://rosettacode.org/wiki/Append_a_record_to_the_end_of_a_text_file"
  },
  {
    "local_code": "fn main() {\n    let array = [1, 2, 3, 4, 5];\n    println!(\"{:?}\", array);\n\n    println!(\"{:?}\", array.iter().map(callback).collect::<Vec<i32>>());\n}\n\nfn callback(val: &i32) -> i32 {\n    *val + 1\n}\n",
    "path": "tasks/apply-a-callback-to-an-array",
    "remote_code": "fn echo(n: &i32) {\n    println!(\"{}\", n);\n}\n\nfn main() {\n    let a: [i32; 5];\n    a = [1, 2, 3, 4, 5];\n    let _: Vec<_> = a.into_iter().map(echo).collect();\n}",
    "title": "Apply a callback to an array",
    "url": "http://rosettacode.org/wiki/Apply_a_callback_to_an_array"
  },
  {
    "local_code": "struct IIRFilter<'f>(&'f [f32], &'f [f32]);\n\nimpl<'f> IIRFilter<'f> {\n    pub fn with_coefficients(a: &'f [f32], b: &'f [f32]) -> IIRFilter<'f> {\n        IIRFilter(a, b)\n    }\n\n    // Performs the calculation as an iterator chain.\n    pub fn apply<I: Iterator<Item = &'f f32> + 'f>(\n        &self,\n        samples: I,\n    ) -> impl Iterator<Item = f32> + 'f {\n        // Name some things for readability\n        let a_coeff = self.0;\n        let b_coeff = self.1;\n\n        let mut prev_results = Vec::<f32>::new();\n        let mut prev_samples = Vec::<f32>::new();\n\n        // The actual calculation, done one number at a time\n        samples.enumerate().map(move |(i, sample)| {\n            prev_samples.push(*sample);\n            prev_results.push(0f32);\n\n            // For each coefficient in b, calculate the weight and sum them.\n            let sum_b: f32 = b_coeff\n                .iter()\n                .enumerate()\n                .map(|(j, c)| {\n                    if i >= j {\n                        (*c) * prev_samples[i - j]\n                    } else {\n                        0f32\n                    }\n                })\n                .sum();\n\n            // For each coefficient in a, calculate the weight and sum them.\n            let sum_a: f32 = a_coeff\n                .iter()\n                .enumerate()\n                .map(|(j, c)| {\n                    if i >= j {\n                        (*c) * prev_results[i - j]\n                    } else {\n                        0f32\n                    }\n                })\n                .sum();\n\n            // perform the final calculation\n            let result = (sum_b - sum_a) / a_coeff[0];\n\n            // update the previous result for the next iteration\n            prev_results[i] = result;\n\n            // return the current result in this iteration\n            result\n        })\n    }\n}\n\nfn main() {\n    let a: &[f32] = &[1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17];\n    let b: &[f32] = &[0.16666667, 0.5, 0.5, 0.16666667];\n\n    let samples: Vec<f32> = vec![\n        -0.917843918645,\n        0.141984778794,\n        1.20536903482,\n        0.190286794412,\n        -0.662370894973,\n        -1.00700480494,\n        -0.404707073677,\n        0.800482325044,\n        0.743500089861,\n        1.01090520172,\n        0.741527555207,\n        0.277841675195,\n        0.400833448236,\n        -0.2085993586,\n        -0.172842103641,\n        -0.134316096293,\n        0.0259303398477,\n        0.490105989562,\n        0.549391221511,\n        0.9047198589,\n    ];\n\n    for (i, result) in IIRFilter::with_coefficients(a, b)\n        .apply(samples.iter())\n        .enumerate()\n    {\n        print!(\"{:.8}\", result);\n        if (i + 1) % 5 != 0 {\n            print!(\", \");\n        } else {\n            println!();\n        }\n    }\n    println!();\n}\n\n#[test]\nfn test() {\n    use std::cmp::Ordering;\n\n    let a: &[f32] = &[1.00000000, -2.77555756e-16, 3.33333333e-01, -1.85037171e-17];\n    let b: &[f32] = &[0.16666667, 0.5, 0.5, 0.16666667];\n\n    let samples: Vec<f32> = vec![\n        -0.917843918645,\n        0.141984778794,\n        1.20536903482,\n        0.190286794412,\n        -0.662370894973,\n        -1.00700480494,\n        -0.404707073677,\n        0.800482325044,\n        0.743500089861,\n        1.01090520172,\n        0.741527555207,\n        0.277841675195,\n        0.400833448236,\n        -0.2085993586,\n        -0.172842103641,\n        -0.134316096293,\n        0.0259303398477,\n        0.490105989562,\n        0.549391221511,\n        0.9047198589,\n    ];\n\n    let expected = vec![\n        -0.15297399,\n        -0.43525785,\n        -0.13604343,\n        0.69750333,\n        0.65644467,\n        -0.43548250,\n        -1.08923948,\n        -0.53767651,\n        0.51705003,\n        1.05224979,\n        0.96185434,\n        0.69568992,\n        0.42435625,\n        0.19626230,\n        -0.02783510,\n        -0.21172196,\n        -0.17474557,\n        0.06925842,\n        0.38544586,\n        0.65177077,\n    ]\n    .into_iter();\n\n    let actual = IIRFilter::with_coefficients(a, b).apply(samples.iter());\n\n    let failed = actual\n        .zip(expected)\n        .inspect(|(act, exp)| {\n            eprintln!(\"{} <=> {}: {:?}\", act, exp, act.partial_cmp(&exp));\n        })\n        .any(|(act, exp)| act.partial_cmp(&exp) != Some(Ordering::Equal));\n    assert!(!failed);\n}\n",
    "path": "tasks/apply-a-digital-filter",
    "remote_code": null,
    "title": "Apply a digital filter (direct form II transposed)",
    "url": "http://rosettacode.org/wiki/Apply_a_digital_filter_(direct_form_II_transposed)"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "/// Return whether the two numbers `a` and `b` are close.\n/// Closeness is determined by the `epsilon` parameter - \n/// the numbers are considered close if the difference between them\n/// is no more than epsilon * max(abs(a), abs(b)).\nfn isclose(a: f64, b: f64, epsilon: f64) -> bool {\n    (a - b).abs() <= a.abs().max(b.abs()) * epsilon\n}\n\nfn main() {\n    fn sqrt(x: f64) -> f64 { x.sqrt() }\n    macro_rules! test {\n        ($a: expr, $b: expr) => {\n            let operator = if isclose($a, $b, 1.0e-9) { '≈' } else { '≉' };\n            println!(\"{:>28} {} {}\", stringify!($a), operator, stringify!($b))\n        }\n    }\n\n    test!(100000000000000.01, 100000000000000.011);\n    test!(100.01, 100.011);\n    test!(10000000000000.001/10000.0, 1000000000.0000001000);\n    test!(0.001, 0.0010000001);\n    test!(0.000000000000000000000101, 0.0);\n    test!( sqrt(2.0) * sqrt(2.0), 2.0);\n    test!(-sqrt(2.0) * sqrt(2.0), -2.0);\n    test!(3.14159265358979323846, 3.14159265358979324);\n}\n",
    "title": "Approximate Equality",
    "url": "http://rosettacode.org/wiki/Approximate_Equality"
  },
  {
    "local_code": "extern crate num;\n\nuse num::{BigInt, Signed};\n\n// Dumbest iterative approach\nfn big_pow(base: &BigInt, exp: BigInt) -> BigInt {\n    if exp.is_negative() {\n        panic!(\"Negative exponent won't compute!\")\n    }\n    let mut tmp = base.clone();\n    for _ in num::range(BigInt::from(1), exp) {\n        tmp = tmp * base;\n    }\n    tmp\n}\n\n// 5^4^3^2\nfn main() {\n    // Exponent is small enough to not use BigInt\n    let exp = BigInt::from(num::pow(4, num::pow(3, 2)));\n\n    let result = big_pow(&BigInt::from(5), exp).to_string();\n    let num_length = result.len();\n\n    println!(\"{}\", result);\n    println!(\"Number has {} digits.\", num_length);\n    assert!(result.starts_with(\"62060698786608744707\"));\n    assert!(result.ends_with(\"92256259918212890625\"));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::big_pow;\n    use num::BigInt;\n\n    #[test]\n    #[should_panic]\n    fn negative_exp_test() {\n        let num = BigInt::from(100);\n        let exp = BigInt::from(-100);\n        big_pow(&num, exp);\n    }\n\n    #[test]\n    fn big_powas() {\n        assert_eq!(\n            big_pow(&BigInt::from(100), BigInt::from(100)).to_string(),\n            \"10000000000000000000000000000000000000000000000000000000000000\\\n             000000000000000000000000000000000000000000000000000000000000000\\\n             000000000000000000000000000000000000000000000000000000000000000\\\n             0000000000000\"\n        );\n\n        assert_eq!(\n            big_pow(&BigInt::from(2), BigInt::from(89)).to_string(),\n            \"618970019642690137449562112\"\n        );\n\n        assert_eq!(\n            big_pow(&BigInt::from(2), BigInt::from(107)).to_string(),\n            \"162259276829213363391578010288128\"\n        );\n\n        assert_eq!(\n            big_pow(&BigInt::from(2), BigInt::from(127)).to_string(),\n            \"170141183460469231731687303715884105728\"\n        );\n\n        assert_eq!(\n            big_pow(&BigInt::from(2), BigInt::from(521)).to_string(),\n            \"6864797660130609714981900799081393217269435300143305409394\\\n             46345918554318339765605212255964066145455497729631139148085\\\n             8037121987999716643812574028291115057152\"\n        );\n    }\n}\n",
    "path": "tasks/arbitrary-precision-integers-included",
    "remote_code": "extern crate num;\nuse num::bigint::BigUint;\nuse num::FromPrimitive;\nuse num::pow::pow;\n\nfn main() {\n    let big = BigUint::from_u8(5).unwrap();\n    let answer_as_string = format!(\"{}\", pow(big,pow(4,pow(3,2))));\n    \n      // The rest is output formatting.\n    let first_twenty: String = answer_as_string.chars().take(20).collect();\n    let last_twenty_reversed: Vec<char> = answer_as_string.chars().rev().take(20).collect();\n    let last_twenty: String = last_twenty_reversed.into_iter().rev().collect();\n    println!(\"Number of digits: {}\", answer_as_string.len());\n    println!(\"First and last digits: {:?}..{:?}\", first_twenty, last_twenty);\n}",
    "title": "Arbitrary-precision integers (included)",
    "url": "http://rosettacode.org/wiki/Arbitrary-precision_integers_(included)"
  },
  {
    "local_code": "#[macro_use(px)]\nextern crate bmp;\n\nuse bmp::{Image, Pixel};\nuse std::f64;\n\n#[cfg_attr(feature = \"cargo-clippy\", allow(many_single_char_names))]\nfn main() {\n    let width = 600u32;\n    let half_width = (width / 2) as i32;\n    let mut img = Image::new(width, width);\n    let draw_color = px!(255, 128, 128);\n\n    // Constants defining the spiral size.\n    let a = 1.0_f64;\n    let b = 9.0_f64;\n\n    // max_angle = number of spirals * 2pi.\n    let max_angle = 5.0_f64 * 2.0_f64 * f64::consts::PI;\n\n    let mut theta = 0.0_f64;\n    while theta < max_angle {\n        theta += 0.002_f64;\n\n        let r = a + b * theta;\n        let x = (r * theta.cos()) as i32 + half_width;\n        let y = (r * theta.sin()) as i32 + half_width;\n        img.set_pixel(x as u32, y as u32, draw_color);\n    }\n\n    // Save the image\n    img.save(\"archimedean_spiral.bmp\")\n        .unwrap_or_else(|e| panic!(\"Failed to save: {}\", e));\n}\n",
    "path": "tasks/archimedean-spiral",
    "remote_code": "#[macro_use(px)]\nextern crate bmp;\n\nuse bmp::{Image, Pixel};\nuse std::f64;\n\nfn main() {\n    let width = 600u32;\n    let half_width = (width / 2) as i32;\n    let mut img = Image::new(width, width);\n    let draw_color = px!(255, 128, 128);\n\n    // Constants defining the spiral size.\n    let a = 1.0_f64;\n    let b = 9.0_f64;\n\n    // max_angle = number of spirals * 2pi.\n    let max_angle = 5.0_f64 * 2.0_f64 * f64::consts::PI;\n\n    let mut theta = 0.0_f64;\n    while theta < max_angle {\n        theta = theta + 0.002_f64;\n\n        let r = a + b * theta;\n        let x = (r * theta.cos()) as i32 + half_width;\n        let y = (r * theta.sin()) as i32 + half_width;\n        img.set_pixel(x as u32, y as u32, draw_color);\n    }\n\n    // Save the image\n    let _ = img.save(\"archimedean_spiral.bmp\").unwrap_or_else(|e| panic!(\"Failed to save: {}\", e));\n}",
    "title": "Archimedean spiral",
    "url": "http://rosettacode.org/wiki/Archimedean_spiral"
  },
  {
    "local_code": "extern crate typed_arena;\n\nuse typed_arena::Arena;\n\nfn main() {\n    // Memory is allocated using the default allocator (currently jemalloc).  The memory is\n    // allocated in chunks, and when one chunk is full another is allocated.  This ensures that\n    // references to an arena don't become invalid when the original chunk runs out of space.  The\n    // chunk size is configurable as an argument to Arena::with_capacity if necessary.\n    let arena = Arena::new();\n    // The arena crate contains two types of arenas: TypedArena and Arena.  Arena is\n    // reflection-basd and slower, but can allocate objects of any type.  TypedArena is faster, and\n    // can allocate only objects of one type.  The type is determined by type inference--if you try\n    // to allocate an integer, then Rust's compiler knows it is an integer arena.\n    let v1 = arena.alloc(1i32);\n\n    // TypedArena returns a mutable reference\n    let v2 = arena.alloc(3);\n    *v2 += 38;\n    println!(\"{}\", *v1 + *v2);\n\n    // The arena's destructor is called as it goes out of scope, at which point it deallocates\n    // everything stored within it at once.\n}\n",
    "path": "tasks/arena-storage-pool",
    "remote_code": "#![feature(rustc_private)]\n\nextern crate arena;\n\nuse arena::TypedArena;\n\nfn main() {\n    // Memory is allocated using the default allocator (currently jemalloc).  The memory is\n    // allocated in chunks, and when one chunk is full another is allocated.  This ensures that\n    // references to an arena don't become invalid when the original chunk runs out of space.  The\n    // chunk size is configurable as an argument to TypedArena::with_capacity if necessary.\n    let arena = TypedArena::new();\n\n    // The arena crate contains two types of arenas: TypedArena and Arena.  Arena is\n    // reflection-basd and slower, but can allocate objects of any type.  TypedArena is faster, and\n    // can allocate only objects of one type.  The type is determined by type inference--if you try\n    // to allocate an integer, then Rust's compiler knows it is an integer arena.\n    let v1 = arena.alloc(1i32);\n\n    // TypedArena returns a mutable reference\n    let v2 = arena.alloc(3);\n    *v2 += 38;\n    println!(\"{}\", *v1 + *v2);\n\n    // The arena's destructor is called as it goes out of scope, at which point it deallocates\n    // everything stored within it at once.\n}",
    "title": "Arena storage pool",
    "url": "http://rosettacode.org/wiki/Arena_storage_pool"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "//! Simple calculator parser and evaluator\n\n\n/// Binary operator\n#[derive(Debug)]\npub enum Operator {\n    Add,\n    Substract,\n    Multiply,\n    Divide\n}\n\n/// A node in the tree\n#[derive(Debug)]\npub enum Node {\n    Value(f64),\n    SubNode(Box<Node>),\n    Binary(Operator, Box<Node>,Box<Node>),\n}\n\n/// parse a string into a node\npub fn parse(txt :&str) -> Option<Node> {\n    let chars = txt.chars().filter(|c| *c != ' ').collect();\n    parse_expression(&chars, 0).map(|(_,n)| n)\n}\n\n/// parse an expression into a node, keeping track of the position in the character vector\nfn parse_expression(chars: &Vec<char>, pos: usize) -> Option<(usize,Node)> {\n    match parse_start(chars, pos) {\n        Some((new_pos, first)) => {\n            match parse_operator(chars, new_pos) {\n                Some((new_pos2,op)) => {\n                    if let Some((new_pos3, second)) = parse_expression(chars, new_pos2) {\n                        Some((new_pos3, combine(op, first, second)))\n                    } else {\n                        None\n                    }\n                },\n                None => Some((new_pos,first)), \n            }\n        },\n        None => None,\n    }\n}\n\n/// combine nodes to respect associativity rules\nfn combine(op: Operator, first: Node, second: Node) -> Node {\n    match second {\n        Node::Binary(op2,v21,v22) => if precedence(&op)>=precedence(&op2) {\n            Node::Binary(op2,Box::new(combine(op,first,*v21)),v22)\n        } else {\n            Node::Binary(op,Box::new(first),Box::new(Node::Binary(op2,v21,v22)))\n        },\n        _ => Node::Binary(op,Box::new(first),Box::new(second)),\n    }\n}\n\n/// a precedence rank for operators\nfn precedence(op: &Operator) -> usize {\n    match op{\n        Operator::Multiply | Operator::Divide => 2,\n        _ => 1\n    }\n}\n\n/// try to parse from the start of an expression (either a parenthesis or a value)\nfn parse_start(chars: &Vec<char>, pos: usize) -> Option<(usize,Node)> {\n    match start_parenthesis(chars, pos){\n        Some (new_pos) => {\n            let r = parse_expression(chars, new_pos);\n            end_parenthesis(chars, r)\n        },\n        None => parse_value(chars, pos),\n    }\n}\n\n/// match a starting parentheseis\nfn start_parenthesis(chars: &Vec<char>, pos: usize) -> Option<usize>{\n    if pos<chars.len() && chars[pos] == '(' {\n        Some(pos+1)\n    } else {\n        None\n    }\n}\n\n/// match an end parenthesis, if successful will create a sub node contained the wrapped expression\nfn end_parenthesis(chars: &Vec<char>, wrapped :Option<(usize,Node)>) -> Option<(usize,Node)>{\n    match wrapped {\n        Some((pos, node)) => if pos<chars.len() && chars[pos] == ')' {\n                Some((pos+1,Node::SubNode(Box::new(node))))\n            } else {\n                None\n            },\n        None => None,\n    }\n}\n\n/// parse a value: an decimal with an optional minus sign\nfn parse_value(chars: &Vec<char>, pos: usize) -> Option<(usize,Node)>{\n    let mut new_pos = pos;\n    if new_pos<chars.len() && chars[new_pos] == '-' {\n        new_pos = new_pos+1;\n    }\n    while new_pos<chars.len() && (chars[new_pos]=='.' || (chars[new_pos] >= '0' && chars[new_pos] <= '9')) {\n        new_pos = new_pos+1;\n    }\n    if new_pos>pos {\n        if let Ok(v) = dbg!(chars[pos..new_pos].iter().collect::<String>()).parse() {\n            Some((new_pos,Node::Value(v)))\n        } else {\n            None\n        }\n    } else {\n        None\n    }\n\n}\n\n/// parse an operator\nfn parse_operator(chars: &Vec<char>, pos: usize) -> Option<(usize,Operator)> {\n    if pos<chars.len() {\n        let ops_with_char = vec!(('+',Operator::Add),('-',Operator::Substract),('*',Operator::Multiply),('/',Operator::Divide));\n        for (ch,op) in ops_with_char {\n            if chars[pos] == ch {\n                return Some((pos+1, op));\n            }\n        }\n    } \n    None\n}\n\n/// eval a string\npub fn eval(txt :&str) -> f64 {\n    match parse(txt) {\n        Some(t) => eval_term(&t),\n        None => panic!(\"Cannot parse {}\",txt),\n    }\n    \n}\n\n/// eval a term, recursively\nfn eval_term(t: &Node) -> f64 {\n    match t {\n        Node::Value(v) => *v,\n        Node::SubNode(t) => eval_term(t),\n        Node::Binary(Operator::Add,t1,t2) => eval_term(t1) + eval_term(t2),\n        Node::Binary(Operator::Substract,t1,t2) => eval_term(t1) - eval_term(t2),\n        Node::Binary(Operator::Multiply,t1,t2) => eval_term(t1) * eval_term(t2),\n        Node::Binary(Operator::Divide,t1,t2) => eval_term(t1) / eval_term(t2),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_eval(){\n        assert_eq!(2.0,eval(\"2\"));\n        assert_eq!(4.0,eval(\"2+2\"));\n        assert_eq!(11.0/4.0, eval(\"2+3/4\"));\n        assert_eq!(2.0, eval(\"2*3-4\"));\n        assert_eq!(3.0, eval(\"1+2*3-4\"));\n        assert_eq!(89.0/6.0, eval(\"2*(3+4)+5/6\"));\n        assert_eq!(14.0, eval(\"2 * (3 -1) + 2 * 5\"));\n        assert_eq!(7000.0, eval(\"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\"));\n        assert_eq!(-9.0/4.0, eval(\"2*-3--4+-.25\"));\n        assert_eq!(1.5, eval(\"1 - 5 * 2 / 20 + 1\"));\n        assert_eq!(3.5, eval(\"2 * (3 + ((5) / (7 - 11)))\"));\n        \n    }\n}\n\n",
    "title": "Arithmetic evaluation",
    "url": "http://rosettacode.org/wiki/Arithmetic_evaluation"
  },
  {
    "local_code": "//! Accepts two command line arguments\n//! cargo run --name agm arg1 arg2\n\nuse std::f32;\n\nfn main() {\n    let mut args = std::env::args();\n\n    let x = args.next().unwrap().to_owned().parse::<f32>().unwrap();\n    let y = args.next().unwrap().to_owned().parse::<f32>().unwrap();\n\n    let result = agm(x, y);\n    println!(\"The arithmetic-geometric mean is {}\", result);\n}\n\nfn agm(x: f32, y: f32) -> f32 {\n    let mut a = x;\n    let mut g = y;\n    let mut a1: f32;\n    let mut g1: f32;\n\n    if a * g < 0f32 {\n        panic!(\"The arithmetic-geometric mean is undefined for numbers less than zero!\");\n    } else {\n        loop {\n            a1 = (a + g) / 2f32;\n            g1 = (a * g).sqrt();\n            a = a1;\n            g = g1;\n            if (a - g).abs() < f32::EPSILON {\n                return a;\n            }\n        }\n    }\n}\n\n#[test]\nfn test_agm_12_6() {\n    use std::f32;\n\n    assert!((agm(12f32, 6f32) - 8.740746f32).abs() < f32::EPSILON);\n}\n",
    "path": "tasks/arithmetic-geometric-mean",
    "remote_code": "// Accepts two command line arguments\n// cargo run --name agm arg1 arg2\n\nfn main () {\n    let mut args = std::env::args();\n\n    let x = args.nth(1).expect(\"First argument not specified.\").parse::<f32>().unwrap();\n    let y = args.next().expect(\"Second argument not specified.\").parse::<f32>().unwrap();\n\n    let result = agm(x,y);\n    println!(\"The arithmetic-geometric mean is {}\", result);\n}\n\nfn agm (x: f32, y: f32) -> f32 {\n    let e: f32 = 0.000001;\n    let mut a = x;\n    let mut g = y;\n    let mut a1: f32;\n    let mut g1: f32;\n\n    if a * g < 0f32 { panic!(\"The arithmetric-geometric mean is undefined for numbers less than zero!\"); }\n    else {\n        loop {\n            a1 = (a + g) / 2.;\n            g1 = (a * g).sqrt();\n            a = a1;\n            g = g1;\n            if (a - g).abs() < e {  return a; }\n        }\n    }\n}",
    "title": "Arithmetic-geometric mean",
    "url": "http://rosettacode.org/wiki/Arithmetic-geometric_mean"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "/// calculate pi with algebraic/geometric mean\npub fn pi(n: usize) -> f64 {\n    let mut a : f64 = 1.0;\n    let two : f64= 2.0;\n    let mut g = 1.0 / two.sqrt();\n    let mut s = 0.0;\n    let mut k = 1;\n    while k<=n  {\n       \n        let a1 = (a+g)/two;\n        let g1 = (a*g).sqrt();\n        a = a1;\n        g = g1;\n        s += (a.powi(2)-g.powi(2)) * two.powi((k+1) as i32);\n        k += 1;\n         \n\n    }\n\n    4.0 * a.powi(2) / (1.0-s)\n}\n",
    "title": "Arithmetic-geometric mean/Calculate Pi",
    "url": "http://rosettacode.org/wiki/Arithmetic-geometric_mean/Calculate_Pi"
  },
  {
    "local_code": "extern crate num;\n\nuse num::complex::Complex;\n\nfn main() {\n    let a = Complex::new(-4.0f32, 5.0);\n    let b = Complex::new(1.0f32, 1.0);\n\n    println!(\"a = {}\", a);\n    println!(\"b = {}\", b);\n    println!(\"a + b = {}\", a + b);\n    println!(\"a * b = {}\", a * b);\n    println!(\"1 / a = {}\", Complex::new(1.0f32, 0.0) / a);\n    println!(\"-a = {}\", -a);\n    println!(\"conj a = {}\", a.conj());\n}\n",
    "path": "tasks/arithmetic/complex",
    "remote_code": "extern crate num;\nuse num::complex::Complex;\n\nfn main() {\n    // two valid forms of definition\n    let a = Complex {re:-4.0, im: 5.0};\n    let b = Complex::new(1.0, 1.0);\n\n    println!(\"   a    = {}\", a);\n    println!(\"   b    = {}\", b);\n    println!(\" a + b  = {}\", a + b);\n    println!(\" a * b  = {}\", a * b);\n    println!(\" 1 / a  = {}\", a.inv());\n    println!(\"  -a    = {}\", -a);\n    println!(\"conj(a) = {}\", a.conj());\n}",
    "title": "Arithmetic/Complex",
    "url": "http://rosettacode.org/wiki/Arithmetic/Complex"
  },
  {
    "local_code": "#![feature(slice_patterns)]\n\nuse std::io::stdin;\n\nfn main() {\n    let mut input = String::new();\n    let _ = stdin().read_line(&mut input).unwrap();\n    let words = input\n        .split_whitespace()\n        .take(2)\n        .map(|s| s.parse().ok())\n        .collect::<Vec<Option<i32>>>();\n\n    let (a, b) = match words[..] {\n        [Some(x), Some(y)] => (x, y),\n        _ => panic!(\"Please enter 2 integers\"),\n    };\n\n    println!(\"a + b = {}\", a + b);\n    println!(\"a - b = {}\", a - b);\n    println!(\"a * b = {}\", a * b);\n    println!(\"a / b = {}\", a / b);\n    println!(\"a % b = {}\", a % b);\n}\n",
    "path": "tasks/arithmetic/integer",
    "remote_code": "use std::env;\n\nfn main() {\n    let args: Vec<_> = env::args().collect();\n    let a = args[1].parse::<i32>().unwrap();\n    let b = args[2].parse::<i32>().unwrap();\n\n    println!(\"sum:              {}\", a + b);\n    println!(\"difference:       {}\", a - b);\n    println!(\"product:          {}\", a * b);\n    println!(\"integer quotient: {}\", a / b); // truncates towards zero\n    println!(\"remainder:        {}\", a % b); // same sign as first operand\n}",
    "title": "Arithmetic/Integer",
    "url": "http://rosettacode.org/wiki/Arithmetic/Integer"
  },
  {
    "local_code": "extern crate num;\n\nuse std::cmp::Ordering;\nuse std::fmt;\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\nuse num::{One, Zero};\n\nfn main() {\n    for p in perfect_numbers(1 << 19) {\n        println!(\"{} is perfect\", p);\n    }\n}\n\nfn perfect_numbers(max: i64) -> Vec<i64> {\n    let mut ret = Vec::new();\n    for candidate in 2..max {\n        let mut sum = Frac::secure_new(1, candidate).unwrap();\n        let max2 = ((candidate as f64).sqrt().floor()) as i64;\n\n        for factor in 2..max2 + 1 {\n            if candidate % factor == 0 {\n                sum = sum + Frac::new(1, factor) + Frac::new(factor, candidate);\n            }\n        }\n        if sum == Frac::new(1, 1) {\n            ret.push(candidate);\n        }\n    }\n    ret\n}\n\n#[derive(Copy, Clone)]\nstruct Frac {\n    num: i64,\n    den: i64,\n}\n\nfn gcd(m: i64, n: i64) -> i64 {\n    let mut t: i64;\n    let (mut m, mut n) = (m.abs(), n.abs());\n    while n > 0 {\n        t = n;\n        n = m % n;\n        m = t;\n    }\n    m\n}\n\nfn lcm(m: i64, n: i64) -> i64 {\n    m.abs() / gcd(m, n) * n.abs()\n}\n\nimpl Frac {\n    /// fails on den=0\n    fn new(num: i64, den: i64) -> Frac {\n        let (n, d) = match (num, den) {\n            (0, _) => (0, 0),\n            (n, d) if d < 0 => (-n, -d),\n            a => a,\n        };\n\n        Frac { num: n, den: d }\n    }\n\n    /// does not fail (returns Err on den=0)\n    fn secure_new(num: i64, den: i64) -> Result<Frac, String> {\n        if den == 0 {\n            Err(\"Error: Division by zero\".to_string())\n        } else {\n            Ok(Frac::new(num, den))\n        }\n    }\n\n    /// fails on den=0, returns frac already in its reduced form\n    fn new_reduced(num: i64, den: i64) -> Frac {\n        Frac::new(num, den).reduce()\n    }\n\n    /// reduces the fraction to lowest terms\n    fn reduce(mut self) -> Frac {\n        match self {\n            z @ Frac { num: 0, den: 0 } => z,\n            _ => {\n                let gcd = gcd(self.num, self.den);\n                self.num /= gcd;\n                self.den /= gcd;\n                self\n            }\n        }\n    }\n}\n\nimpl fmt::Debug for Frac {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match (self.num, self.den) {\n            (_, 1) | (0, 0) => write!(f, \"{}\", self.num),\n            (_, _) => write!(f, \"{}/{}\", self.num, self.den),\n        }\n    }\n}\n\nimpl PartialEq for Frac {\n    fn eq(&self, other: &Frac) -> bool {\n        let (red_a, red_b) = (self.reduce(), other.reduce());\n        red_a.num == red_b.num && red_a.den == red_b.den\n    }\n}\n\nimpl Eq for Frac {}\n\nimpl PartialOrd for Frac {\n    fn partial_cmp(&self, other: &Frac) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Frac {\n    fn cmp(&self, other: &Frac) -> Ordering {\n        (self.num * other.den).cmp(&(self.den * other.num))\n    }\n}\n\nimpl Neg for Frac {\n    type Output = Frac;\n\n    fn neg(self) -> Frac {\n        Frac {\n            num: -self.num,\n            den: self.den,\n        }\n    }\n}\n\nimpl Add for Frac {\n    type Output = Frac;\n    fn add(self, other: Frac) -> Frac {\n        let (a, b) = (self.reduce(), other.reduce());\n        let m = lcm(a.den, b.den);\n\n        let na = a.num * m / a.den;\n        let nb = b.num * m / b.den;\n        Frac::new_reduced(na + nb, m)\n    }\n}\n\nimpl Sub for Frac {\n    type Output = Frac;\n    fn sub(self, other: Frac) -> Frac {\n        self + (-other)\n    }\n}\n\nimpl Mul for Frac {\n    type Output = Frac;\n    fn mul(self, other: Frac) -> Frac {\n        Frac::new_reduced(self.num * other.num, self.den * other.den)\n    }\n}\n\nimpl Div for Frac {\n    type Output = Frac;\n    fn div(self, other: Frac) -> Frac {\n        Frac::new_reduced(self.num * other.den, self.den * other.num)\n    }\n}\n\nimpl Zero for Frac {\n    fn zero() -> Frac {\n        Frac::new(0, 1)\n    }\n\n    fn is_zero(&self) -> bool {\n        self.num == 0 && self.den != 0\n    }\n}\n\nimpl One for Frac {\n    fn one() -> Frac {\n        Frac::new(1, 1)\n    }\n}\n\n#[test]\nfn operators() {\n    let (a, b) = (Frac::new(1, 2), Frac::new(12, 15));\n    assert_eq!(a + b, Frac::secure_new(13, 10).unwrap());\n    assert_eq!(b - a, Frac::new(3, 10));\n    assert_eq!(a - b, Frac::new(-3, 10));\n    assert_eq!(a * b, Frac::new(2, 5));\n    assert_eq!(a / b, Frac::new(5, 8));\n\n    let (a, b) = (Frac::new(1, 2), Frac::new(1, 2));\n    assert_eq!(a + b, One::one());\n    assert_eq!(b - a, Zero::zero());\n    assert_eq!(a - b, Zero::zero());\n    assert_eq!(a * b, Frac::new(1, 4));\n    assert_eq!(a / b, Frac::new(1, 1));\n}\n\n#[test]\nfn first_perfect_numbers() {\n    assert_eq!(perfect_numbers(8150), vec![6, 28, 496, 8128]);\n}\n",
    "path": "tasks/arithmetic/rational",
    "remote_code": "use std::cmp::Ordering;\nuse std::ops::{Add, AddAssign, Sub, SubAssign, Mul, MulAssign, Div, DivAssign, Neg};\n\nfn gcd(a: i64, b: i64) -> i64 {\n    match b {\n        0 => a,\n        _ => gcd(b, a % b),\n    }\n}\n\nfn lcm(a: i64, b: i64) -> i64 {\n    a / gcd(a, b) * b\n}\n\n#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash, Ord)]\npub struct Rational {\n    numerator: i64,\n    denominator: i64,\n}\n\nimpl Rational {\n    fn new(numerator: i64, denominator: i64) -> Self {\n        let divisor = gcd(numerator, denominator);\n        Rational {\n            numerator: numerator / divisor,\n            denominator: denominator / divisor,\n        }\n    }\n}\n\nimpl Add for Rational {\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self {\n        let multiplier = lcm(self.denominator, other.denominator);\n        Rational::new(self.numerator * multiplier / self.denominator +\n                      other.numerator * multiplier / other.denominator,\n                      multiplier)\n    }\n}\n\nimpl AddAssign for Rational {\n    fn add_assign(&mut self, other: Self) {\n        *self = *self + other;\n    }\n}\n\nimpl Sub for Rational {\n    type Output = Self;\n\n    fn sub(self, other: Self) -> Self {\n        self + -other\n    }\n}\n\nimpl SubAssign for Rational {\n    fn sub_assign(&mut self, other: Self) {\n        *self = *self - other;\n    }\n}\n\nimpl Mul for Rational {\n    type Output = Self;\n\n    fn mul(self, other: Self) -> Self {\n        Rational::new(self.numerator * other.numerator,\n                      self.denominator * other.denominator)\n    }\n}\n\nimpl MulAssign for Rational {\n    fn mul_assign(&mut self, other: Self) {\n        *self = *self * other;\n    }\n}\n\nimpl Div for Rational {\n    type Output = Self;\n\n    fn div(self, other: Self) -> Self {\n        self *\n        Rational {\n            numerator: other.denominator,\n            denominator: other.numerator,\n        }\n    }\n}\n\nimpl DivAssign for Rational {\n    fn div_assign(&mut self, other: Self) {\n        *self = *self / other;\n    }\n}\n\nimpl Neg for Rational {\n    type Output = Self;\n\n    fn neg(self) -> Self {\n        Rational {\n            numerator: -self.numerator,\n            denominator: self.denominator,\n        }\n    }\n}\n\nimpl PartialOrd for Rational {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        (self.numerator * other.denominator).partial_cmp(&(self.denominator * other.numerator))\n    }\n}\n\nimpl<T: Into<i64>> From<T> for Rational {\n    fn from(value: T) -> Self {\n        Rational::new(value.into(), 1)\n    }\n}\n\nfn main() {\n    let max = 1 << 19;\n    for candidate in 2..max {\n        let mut sum = Rational::new(1, candidate);\n        for factor in 2..(candidate as f64).sqrt().ceil() as i64 {\n            if candidate % factor == 0 {\n                sum += Rational::new(1, factor);\n                sum += Rational::new(1, candidate / factor);\n            }\n        }\n\n        if sum == 1.into() {\n            println!(\"{} is perfect\", candidate);\n        }\n    }\n}\n",
    "title": "Arithmetic/Rational",
    "url": "http://rosettacode.org/wiki/Arithmetic/Rational"
  },
  {
    "local_code": "fn main() {\n    let a_vec: Vec<i32> = vec![1, 2, 3, 4, 5];\n    let b_vec: Vec<i32> = vec![6; 5];\n\n    let c_vec = concatenate_arrays::<i32>(a_vec.as_slice(), b_vec.as_slice());\n\n    println!(\"{:?} ~ {:?} => {:?}\", a_vec, b_vec, c_vec);\n}\n\nfn concatenate_arrays<T: Clone>(x: &[T], y: &[T]) -> Vec<T> {\n    let mut concat: Vec<T> = vec![x[0].clone(); x.len()];\n\n    concat.clone_from_slice(x);\n    concat.extend_from_slice(y);\n\n    concat\n}\n\n#[cfg(test)]\nmod tests {\n    use super::concatenate_arrays;\n\n    #[derive(Clone, Debug, PartialEq)]\n    struct Dummy {\n        a: f64,\n        b: &'static str,\n    }\n\n    #[test]\n    fn test_concatenation_int() {\n        let a_vec: Vec<u64> = vec![0, 1, 2, 3, 4];\n        let b_vec: Vec<u64> = vec![5; 5];\n        let c_vec = concatenate_arrays::<u64>(a_vec.as_slice(), b_vec.as_slice());\n\n        assert_eq!(c_vec, [0, 1, 2, 3, 4, 5, 5, 5, 5, 5]);\n    }\n\n    #[test]\n    fn test_concatenation_str() {\n        let a_vec: Vec<&str> = vec![\"hay\", \"ye\", \"eye\", \"owe\", \"you\"];\n        let b_vec: Vec<&str> = vec![\"why\"];\n        let c_vec = concatenate_arrays::<&str>(a_vec.as_slice(), b_vec.as_slice());\n\n        assert_eq!(c_vec, [\"hay\", \"ye\", \"eye\", \"owe\", \"you\", \"why\"]);\n    }\n\n    #[test]\n    fn test_concatenation_tuple() {\n        let a_vec: Vec<(i32, &str)> = vec![(0, \"hay\"), (1, \"ye\"), (2, \"eye\")];\n        let b_vec: Vec<(i32, &str)> = vec![(3, \"owe\"), (4, \"you\")];\n        let c_vec = concatenate_arrays::<(i32, &str)>(a_vec.as_slice(), b_vec.as_slice());\n\n        assert_eq!(\n            c_vec,\n            [(0, \"hay\"), (1, \"ye\"), (2, \"eye\"), (3, \"owe\"), (4, \"you\")]\n        );\n    }\n\n    #[test]\n    fn test_concatenation_struct() {\n        let a_vec: Vec<Dummy> = vec![\n            Dummy { a: 0.0, b: \"hay\" },\n            Dummy { a: 1.1, b: \"ye\" },\n            Dummy { a: 2.2, b: \"eye\" },\n        ];\n        let b_vec: Vec<Dummy> = vec![Dummy { a: 3.3, b: \"owe\" }, Dummy { a: 4.4, b: \"you\" }];\n\n        let c_vec = concatenate_arrays::<Dummy>(a_vec.as_slice(), b_vec.as_slice());\n\n        assert_eq!(\n            c_vec,\n            [\n                Dummy { a: 0.0, b: \"hay\" },\n                Dummy { a: 1.1, b: \"ye\" },\n                Dummy { a: 2.2, b: \"eye\" },\n                Dummy { a: 3.3, b: \"owe\" },\n                Dummy { a: 4.4, b: \"you\" },\n            ]\n        );\n    }\n}\n",
    "path": "tasks/array-concatenation",
    "remote_code": "fn main() {\n    let a_vec = vec![1, 2, 3, 4, 5];\n    let b_vec = vec![6; 5];\n\n    let c_vec = concatenate_arrays(&a_vec, &b_vec);\n\n    println!(\"{:?} ~ {:?} => {:?}\", a_vec, b_vec, c_vec);\n}\n\nfn concatenate_arrays<T: Clone>(x: &[T], y: &[T]) -> Vec<T> {\n    let mut concat = x.to_vec();\n    concat.extend_from_slice(y);\n\n    concat\n}\n",
    "title": "Array concatenation",
    "url": "http://rosettacode.org/wiki/Array_concatenation"
  },
  {
    "local_code": "fn main() {\n    let array = [\"foo\", \"bar\", \"baz\", \"biff\"];\n    println!(\"the array has {} elements\", array.len());\n}\n",
    "path": "tasks/array-length",
    "remote_code": "\nfn main() {\n    let array = [\"foo\", \"bar\", \"baz\", \"biff\"];\n    println!(\"the array has {} elements\", array.len());\n}\n",
    "title": "Array length",
    "url": "http://rosettacode.org/wiki/Array_length"
  },
  {
    "local_code": "fn main() {}\n\n#[test]\nfn create_array() {\n    let empty_vec: Vec<i32> = vec![];\n    assert!(empty_vec.len() == 0);\n\n    let prepopulated_vec = vec![1i32, 2, 3];\n    assert!(prepopulated_vec.len() == 3);\n\n    // Three string slices.\n    let string_vec = vec![\"Foo\", \"Bar\", \"Baz\"];\n    assert!(string_vec.len() == 3);\n}\n\n#[test]\nfn add_to_array() {\n    // Mutatable adding.\n    let mut a_vec = vec![];\n    a_vec.push(1i32);\n    assert_eq!(a_vec[0], 1);\n\n    // Immutable adding.\n    let b_vec = vec![2, 3, 4];\n    a_vec.extend(b_vec.into_iter());\n    assert_eq!(a_vec, [1, 2, 3, 4]);\n}\n\n#[test]\nfn retrieving_from_array() {\n    // Indexing.\n    let a_vec = vec![1i32, 2, 3];\n    assert!(a_vec[0] == 1i32);\n\n    // A full copy of the vector, but mutable.\n    let mut mut_vec = a_vec.clone();\n    assert_eq!(mut_vec.pop(), Some(3));\n    assert_eq!(mut_vec, [1, 2]);\n}\n",
    "path": "tasks/arrays",
    "remote_code": "let a = [1, 2, 3]; // immutable array\nlet mut m = [1, 2, 3]; // mutable array\nlet zeroes = [0; 200]; // creates an array of 200 zeroes",
    "title": "Arrays",
    "url": "http://rosettacode.org/wiki/Arrays"
  },
  {
    "local_code": "fn main() {\n    let my_number = 42;\n    assert!(my_number == 42);\n    assert_eq!(my_number, 42);\n}\n",
    "path": "tasks/assertions",
    "remote_code": "\nlet x = 42;\nassert!(x == 42);\nassert_eq!(x, 42);\n",
    "title": "Assertions",
    "url": "http://rosettacode.org/wiki/Assertions"
  },
  {
    "local_code": "use std::collections::HashMap;\n\nfn main() {\n    let mut olympic_medals = HashMap::new();\n    olympic_medals.insert(\"United States\", (1072, 859, 749));\n    olympic_medals.insert(\"Soviet Union\", (473, 376, 355));\n    olympic_medals.insert(\"Great Britain\", (246, 276, 284));\n    olympic_medals.insert(\"Germany\", (252, 260, 270));\n    println!(\"{:?}\", olympic_medals);\n}\n",
    "path": "tasks/associative-array/creation",
    "remote_code": "use std::collections::HashMap;\nfn main() {\n    let mut olympic_medals = HashMap::new();\n    olympic_medals.insert(\"United States\", (1072, 859, 749));\n    olympic_medals.insert(\"Soviet Union\", (473, 376, 355));\n    olympic_medals.insert(\"Great Britain\", (246, 276, 284));\n    olympic_medals.insert(\"Germany\", (252, 260, 270));\n    println!(\"{:?}\", olympic_medals);\n}",
    "title": "Associative array/Creation",
    "url": "http://rosettacode.org/wiki/Associative_array/Creation"
  },
  {
    "local_code": "use std::collections::HashMap;\n\nfn main() {\n    // Note that `HashMap` does not preserve order. If this is important,\n    // `std::collections::BTreeMap` is what you want.\n    let mut olympic_medals = HashMap::new();\n    olympic_medals.insert(\"United States\", (1072, 859, 749));\n    olympic_medals.insert(\"Soviet Union\", (473, 376, 355));\n    olympic_medals.insert(\"Great Britain\", (246, 276, 284));\n    olympic_medals.insert(\"Germany\", (252, 260, 270));\n    for (country, medals) in olympic_medals {\n        println!(\n            \"{} has had {} gold medals, {} silver medals, and {} bronze medals\",\n            country, medals.0, medals.1, medals.2\n        );\n    }\n}\n",
    "path": "tasks/associative-array/iteration",
    "remote_code": "use std::collections::HashMap;\nfn main() {\n    let mut olympic_medals = HashMap::new();\n    olympic_medals.insert(\"United States\", (1072, 859, 749));\n    olympic_medals.insert(\"Soviet Union\", (473, 376, 355));\n    olympic_medals.insert(\"Great Britain\", (246, 276, 284));\n    olympic_medals.insert(\"Germany\", (252, 260, 270));\n    for (country, medals) in olympic_medals {\n        println!(\"{} has had {} gold medals, {} silver medals, and {} bronze medals\", \n               country, medals.0, medals.1, medals.2);\n            \n    }\n}",
    "title": "Associative array/Iteration",
    "url": "http://rosettacode.org/wiki/Associative_array/Iteration"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Associative array/Merging",
    "url": "http://rosettacode.org/wiki/Associative_array/Merging"
  },
  {
    "local_code": "//! This is mostly a straight port of the D version.  Originally, the \"non-locking\" Go solution was\n//! tried, because it was supposed to be faster than the version with Mutexes, but my experience\n//! was that this was not the case.  Perhaps it is true with green threads.  D's version was much\n//! faster and this version seems to achieve parity with the benchmarks on the Rosetta Code site\n//! (at least on my machine).  I am pretty sure it could be made faster, though--for example, the\n//! Mutex type we're using here was the fourth type I tried but the first to produce acceptable\n//! performance (previously I tried, in order, `std::sync::RwLock`, `std::sync::Mutex`, and\n//! `std::sync::Semaphore`) and this type still appears to have quite a bit of overhead.\n\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::Arc;\nuse std::thread::{self, spawn};\nuse std::time::Duration;\n\nuse rand::distributions::Uniform;\nuse rand::{thread_rng, Rng};\n\n/// The reason I used a module here is simply to keep it clearer who can access what.  Rust\n/// protects against data races just fine, but it's not as good at protecting against deadlocks or\n/// other types of race conditions.\nmod buckets {\n    use std::sync::atomic::{AtomicUsize, Ordering};\n    use std::sync::Mutex;\n\n    /// We hardcode the number of buckets mostly for convenience.  Now that Rust has dynamically\n    /// sized types, this is possibly no longer a problem.\n    ///\n    /// To expand: in Rust, there are two special kinds, `Sync` and `Send`, used for concurrency.\n    ///\n    /// If `T` is `Sync`, and you take an immutable reference of type `&T`, then it's safe to share\n    /// between threads.  Most types are `Sync` unless they contain non-threadsafe interior\n    /// mutability: for example, `Cell` and `RefCell` are not Sync, because they can be modified\n    /// through a `&` reference in a non-threadsafe way.  On the other hand, atomic types are\n    /// `Sync` even though they can be modified this way.  So are types accessible through a\n    /// `Mutex`.\n    ///\n    /// The other type is `Send`.  `Send`'s semantic meaning is \"a type that can be sent between\n    /// tasks.\"  For most practical purposes, this means \"has no non-`'static` references\" (with a\n    /// very few exceptions, like the `Rc` type, which are non-`Send` anyway).  The idea is that it\n    /// is not safe to send a type between tasks if it has any non-static references, because one\n    /// doesn't know when the data it's referencing will be deallocated if it's on some other\n    /// task's stack.\n    ///\n    /// Usually, that's a reasonable assumption.  But it means that if we want to put a slice in a\n    /// structure and share it between tasks, it can't be a `&[T]`--it has to be a bare [T].  `Arc`\n    /// has `Send` + `Sync` bounds for this reason.  We could also use a `Vec`, but this would\n    /// introduce unnecessary indirection.  With dynamically sized types, this problem may be\n    /// solved--we can have a dynamically sized `struct` that doesn't contain explicit references.\n    /// But until that is fully baked, this seems like the sanest solution.\n    ///\n    /// Another way to solve this would be associated constants.\n    pub const N_BUCKETS: usize = 20;\n\n    /// We don't really have to hardcode the workers.  This is left over from the Go\n    /// implementation. All the counting statistics could be moved outside of buckets and probably\n    /// should, since they have no influence on the correctness of the algorithm.\n    pub const N_WORKERS: usize = 2;\n\n    struct Bucket {\n        /// The actual data.  It is atomic because it is read (not written) outside the `Mutex`,\n        /// unless a consistent snapshot is required.\n        data: AtomicUsize,\n\n        /// The mutex used to synchronize writes and snapshot reads of the\n        /// bucket.\n        /// As the D solution says, using a per-bucket `Mutex` dramatically\n        /// improves scalability compared to the alternatives.\n        mutex: Mutex<()>,\n    }\n\n    pub struct Buckets {\n        /// Buckets containing values to be transferred.\n        buckets: [Bucket; N_BUCKETS],\n\n        /// Statistics about total transfers this go-around.\n        transfers: [AtomicUsize; N_WORKERS],\n    }\n\n    impl Buckets {\n        /// Create a new Buckets instance.\n        pub fn new(buckets: [usize; N_BUCKETS]) -> Buckets {\n            Buckets {\n                buckets: array_init::from_iter(buckets.iter().map(|&val| Bucket {\n                    data: AtomicUsize::new(val),\n                    mutex: Mutex::new(()),\n                }))\n                .unwrap(),\n                transfers: array_init::array_init(|_| AtomicUsize::new(0)),\n            }\n        }\n\n        /// Get the value of the bucket at index i, or None if out of bounds.\n        pub fn get(&self, i: usize) -> Option<usize> {\n            // This is used as an estimate, and is used without the mutex lock, so there's no\n            // compelling reason to demand consistency here.\n            self.buckets.get(i).map(|b| b.data.load(Ordering::Relaxed))\n        }\n\n        /// Transfer at most `amount` from the bucket at index `from` to that at index `to`, and\n        /// increment the transfer count for worker `worker` (like I said, that last part can\n        /// likely be done elsewhere).\n        pub fn transfer(&self, from: usize, to: usize, amount: usize, worker: usize) {\n            // The from == to check is important so we don't deadlock, since Rust mutexes are\n            // non-reentrant.\n            if from == to || N_BUCKETS <= from || N_BUCKETS <= to || N_WORKERS <= worker {\n                return;\n            }\n            // We know this won't fail, and the compiler seems to know as well.  However, if it\n            // *did* fail, it wouldn't fail while we were holding mutexes (which can cause\n            // problems since they may need to poison other tasks).\n            let b1 = &self.buckets[from];\n            let b2 = &self.buckets[to];\n            // It's very important to lock our Mutexes in the same order everywhere to avoid\n            // deadlock.  We arbitrarily choose the convention that we lock in ascending index\n            // order.\n            let (low, high) = if from < to { (b1, b2) } else { (b2, b1) };\n            {\n                // The reason we introduce a new scope here is that we want to make it clear how\n                // long we're locking for.  Locks should be held as briefly as possible and\n                // anything that happens here should really *require* the locks.\n                let _s1 = low.mutex.lock();\n                let _s2 = high.mutex.lock();\n                // It is possible that SeqCst is too strong for this section, but it is hard to\n                // test on x86 because it has unusually strong consistency by default.\n                let v1 = b1.data.load(Ordering::SeqCst);\n                let real_amount = ::std::cmp::min(v1, amount);\n                b1.data.store(v1 - real_amount, Ordering::SeqCst);\n                b2.data.fetch_add(real_amount, Ordering::SeqCst);\n            }\n            // Doing this outside the critical section increases throughput substantially.  Since\n            // this is just a summary statistic, it's okay for it to be a few off.  That's also why\n            // we use Acquire semantics rather than AcqRel or SeqCst here--we only really care that\n            // we synchronize when the transfer count is set to 0.\n            self.transfers[worker].fetch_add(1, Ordering::Acquire);\n        }\n\n        /// Acquire a consistent snapshot of the state of the bucket list.  This should maintain\n        /// the invariant that total buckets are conserved.  Also returns the list of transfer\n        /// counts.\n        pub fn snapshot(&self) -> ([usize; N_BUCKETS], [usize; N_WORKERS]) {\n            // Since this method is called relatively rarely, we aren't too concerned about\n            // performance here.\n            let mut buckets = [0; N_BUCKETS];\n            let mut transfers = [0; N_WORKERS];\n            // We collect all the locks in order, being careful not to drop any until we're done\n            // (so as to preserve consistency of the snapshot).\n            let locks = buckets\n                .iter_mut()\n                .zip(self.buckets.iter())\n                .map(|(dest, src)| {\n                    let lock = src.mutex.lock();\n                    // Is SeqCst necessary here?  Maybe, maybe not, but when in doubt go with\n                    // SeqCst.\n                    *dest = src.data.load(Ordering::SeqCst);\n                    lock\n                })\n                .collect::<Vec<_>>();\n            for (dest, src) in transfers.iter_mut().zip(self.transfers.iter()) {\n                // We synchronize with the Acquire in transfer, making sure that our zeroing out\n                // gets noticed.\n                *dest = src.swap(0, Ordering::Release);\n            }\n            // We can drop the locks before we return.  This probably gets optimized out, but it's\n            // rarely a bad idea to drop locks explicitly.\n            drop(locks);\n            (buckets, transfers)\n        }\n    }\n}\n\n/// Convenience method to create a distribution of buckets summing to `initial_sum`.\nfn make_buckets(initial_sum: usize) -> buckets::Buckets {\n    let mut buckets = [0; buckets::N_BUCKETS];\n    let mut dist = initial_sum;\n    for (i, b) in buckets.iter_mut().enumerate() {\n        let v = dist / (buckets::N_BUCKETS - i);\n        *b = v;\n        dist -= v;\n    }\n    buckets::Buckets::new(buckets)\n}\n\n/// The equalize task--it chooses two random buckets and tries to make their values the same.\nfn equalize(bl: &buckets::Buckets, running: &AtomicBool, worker: usize) {\n    let mut rng = thread_rng();\n    // `Uniform` rather than `gen_range`'s `Uniform::sample_single` for speed\n    let range = Uniform::new(0, buckets::N_BUCKETS);\n    // Running is read Relaxed because it's not important that the task stop right away as long as\n    // it happens eventually.\n    while running.load(Ordering::Relaxed) {\n        let b1 = rng.sample(range);\n        let b2 = rng.sample(range);\n        let v1 = bl.get(b1).unwrap();\n        let v2 = bl.get(b2).unwrap();\n        if v1 > v2 {\n            bl.transfer(b1, b2, (v1 - v2) / 2, worker)\n        } else {\n            bl.transfer(b2, b1, (v2 - v1) / 2, worker)\n        }\n    }\n}\n\n/// The randomize task--it chooses two random buckets and randomly redistributes their values.\nfn randomize(bl: &buckets::Buckets, running: &AtomicBool, worker: usize) {\n    let mut rng = thread_rng();\n    let range = Uniform::new(0, buckets::N_BUCKETS);\n    // Running is read Relaxed because it's not important that the task stop right away as long as\n    // it happens eventually.\n    while running.load(Ordering::Relaxed) {\n        let b1 = rng.sample(range);\n        let b2 = rng.sample(range);\n        bl.transfer(b1, b2, rng.gen_range(0, bl.get(b1).unwrap() + 1), worker);\n    }\n}\n\n/// The display task--for a total time of `duration`, it displays information about the update\n/// process and checks to make sure that the invariant (that the total remains constant) is\n/// preserved.  It prints an update `nticks` times, evenly spaced.\nfn display(\n    bl: &buckets::Buckets,\n    running: &AtomicBool,\n    original_total: usize,\n    duration: Duration,\n    nticks: u32,\n) {\n    println!(\"transfers, N. transfers, buckets, buckets sum:\");\n\n    let duration = duration / nticks;\n    for _ in 0..nticks {\n        // Get a consistent snapshot\n        let (s, tc) = bl.snapshot();\n        // Sum up the buckets\n        let sum: usize = s.iter().sum();\n        // Sum up the transfers.\n        let n_transfers: usize = tc.iter().sum();\n        // Print the relevant information.\n        println!(\"{:?}, {}, {:?}, {}\", tc, n_transfers, s, sum);\n        // Check the invariant, failing if necessary.\n        assert_eq!(sum, original_total);\n        // Sleep before printing again.\n        thread::sleep(duration);\n    }\n    // We're done--cleanly exit the other update tasks.\n    running.store(false, Ordering::Relaxed);\n}\n\n/// Putting together all three tasks.\nfn perform_atomic_updates(duration: Duration, original_total: usize, num_ticks: u32) {\n    // Worker IDs for the two updater tasks.\n    const ID_EQUALIZE: usize = 0;\n    const ID_RANDOMIZE: usize = 1;\n\n    // `running` is an atomic boolean that we use to signal when to stop to the updater tasks.\n    let running = AtomicBool::new(true);\n    // We use an Arc here in order to share a reference to the buckets between threads.  Since the\n    // Buckets are already Sync, and we don't need &mut references to them, there's no need to\n    // create a Mutex here.\n    let arc = Arc::new((make_buckets(original_total), running));\n    // Cloning the arc bumps the reference count.\n    let arc_ = arc.clone();\n    // Start off the equalize task\n    spawn(move || equalize(&arc_.0, &arc_.1, ID_EQUALIZE));\n    let arc_ = arc.clone();\n    // Start off the randomize task\n    spawn(move || randomize(&arc_.0, &arc_.1, ID_RANDOMIZE));\n    let (ref bl, ref running) = *arc;\n    // Run the display task in the current thread, so failure propagates to the user.\n    display(bl, running, original_total, duration, num_ticks);\n}\n\nconst ORIGINAL_TOTAL: usize = 1000;\nconst NUM_TICKS: u32 = 10;\n\nfn main() {\n    perform_atomic_updates(Duration::from_secs(10), ORIGINAL_TOTAL, NUM_TICKS);\n}\n\n#[test]\nfn test_atomic_updates() {\n    perform_atomic_updates(Duration::from_secs(1) / 10, ORIGINAL_TOTAL, NUM_TICKS);\n}\n",
    "path": "tasks/atomic-updates",
    "remote_code": "extern crate rand;\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::cmp;\nuse std::time::Duration;\n\nuse rand::Rng;\nuse rand::distributions::{IndependentSample, Range};\n\ntrait Buckets {\n    fn equalize<R:Rng>(&mut self, rng: &mut R);\n    fn randomize<R:Rng>(&mut self, rng: &mut R);\n    fn print_state(&self);\n}\n\nimpl Buckets for [i32] {\n    fn equalize<R:Rng>(&mut self, rng: &mut R) {\n        let range = Range::new(0,self.len()-1);\n        let src = range.ind_sample(rng);\n        let dst = range.ind_sample(rng);\n        if dst != src {\n            let amount = cmp::min(((dst + src) / 2) as i32, self[src]);\n            let multiplier = if amount >= 0 { -1 } else { 1 };\n            self[src] += amount * multiplier;\n            self[dst] -= amount * multiplier;\n        }\n    }\n    fn randomize<R:Rng>(&mut self, rng: &mut R) {\n        let ind_range = Range::new(0,self.len()-1);\n        let src = ind_range.ind_sample(rng);\n        let dst = ind_range.ind_sample(rng);\n        if dst != src {\n            let amount = cmp::min(Range::new(0,20).ind_sample(rng), self[src]);\n            self[src] -= amount;\n            self[dst] += amount;\n\n        }\n    }\n    fn print_state(&self) {\n        println!(\"{:?} = {}\", self, self.iter().sum::<i32>());\n    }\n}\n\nfn main() {\n    let e_buckets = Arc::new(Mutex::new([10; 10]));\n    let r_buckets = e_buckets.clone();\n    let p_buckets = e_buckets.clone();\n\n    thread::spawn(move || { \n        let mut rng = rand::thread_rng();\n        loop {\n            let mut buckets = e_buckets.lock().unwrap();\n            buckets.equalize(&mut rng);\n        }\n    });\n    thread::spawn(move || {\n        let mut rng = rand::thread_rng();\n        loop {\n            let mut buckets = r_buckets.lock().unwrap();\n            buckets.randomize(&mut rng);\n        }\n    });\n\n    let sleep_time = Duration::new(1,0);\n    loop {\n        {\n            let buckets = p_buckets.lock().unwrap();\n            buckets.print_state();\n        }\n        thread::sleep(sleep_time);\n    }\n}",
    "title": "Atomic updates",
    "url": "http://rosettacode.org/wiki/Atomic_updates"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use primal::Primes;\n\nconst MAX: u64 = 120;\n\n/// Returns an Option with a tuple => Ok((smaller prime factor, num divided by that prime factor))\n/// If num is a prime number itself, returns None\nfn extract_prime_factor(num: u64) -> Option<(u64, u64)> {\n    let mut i = 0;\n    if primal::is_prime(num) {\n        None\n    } else {\n        loop {\n            let prime = Primes::all().nth(i).unwrap() as u64;\n            if num % prime == 0 {\n                return Some((prime, num / prime));\n            } else {\n                i += 1;\n            }\n        }\n    }\n}\n\n/// Returns a vector containing all the prime factors of num\nfn factorize(num: u64) -> Vec<u64> {\n    let mut factorized = Vec::new();\n    let mut rest = num;\n    while let Some((prime, factorizable_rest)) = extract_prime_factor(rest) {\n        factorized.push(prime);\n        rest = factorizable_rest;\n    }\n    factorized.push(rest);\n    factorized\n}\n\nfn main() {\n    let mut output: Vec<u64> = Vec::new();\n    for num in 4 ..= MAX {\n        if primal::is_prime(factorize(num).len() as u64) {\n            output.push(num);\n        }\n    }\n    println!(\"The attractive numbers up to and including 120 are\\n{:?}\", output);\n}",
    "title": "Attractive numbers",
    "url": "http://rosettacode.org/wiki/Attractive_numbers"
  },
  {
    "local_code": "//! Accepts two command-line arguments\n\nextern crate rand;\n\nuse std::collections::HashSet;\nuse std::env;\nuse std::process;\n\nuse rand::distributions::Uniform;\nuse rand::{thread_rng, Rng};\n\nfn help() {\n    println!(\"usage: average_loop_length <max_N> <trials>\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut max_n: u32 = 20;\n    let mut trials: u32 = 1000;\n\n    match args.len() {\n        1 => {}\n        3 => {\n            max_n = args[1].parse().unwrap();\n            trials = args[2].parse().unwrap();\n        }\n        _ => {\n            help();\n            process::exit(0);\n        }\n    }\n\n    let mut rng = thread_rng();\n\n    println!(\" N    average    analytical    (error)\");\n    println!(\"===  =========  ============  =========\");\n    for n in 1..(max_n + 1) {\n        let the_analytical = analytical(n);\n        let the_empirical = empirical(n, trials, &mut rng);\n        println!(\n            \" {:>2}     {:3.4}        {:3.4}  ( {:>+1.2}%)\",\n            n,\n            the_empirical,\n            the_analytical,\n            100.0 * (the_empirical / the_analytical - 1.0)\n        );\n    }\n}\n\nfn factorial(n: u32) -> f64 {\n    (1..n + 1).map(f64::from).product()\n}\n\nfn analytical(n: u32) -> f64 {\n    (1..(n + 1))\n        .map(|i| factorial(n) / f64::from(n).powi(i as i32) / factorial(n - i))\n        .sum()\n}\n\nfn empirical(n: u32, trials: u32, rng: &mut impl Rng) -> f64 {\n    let sum: f64 = (0..trials)\n        .map(|_trial| {\n            let mut seen = HashSet::new();\n            let range = Uniform::new_inclusive(1, n);\n\n            seen.insert(1);\n            for step in 1..n {\n                let item = rng.sample(range);\n                let inserted = seen.insert(item);\n                if !inserted {\n                    return f64::from(step);\n                }\n            }\n            f64::from(n)\n        })\n        .sum();\n    sum / f64::from(trials)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::f64;\n\n    #[test]\n    fn test_factorial() {\n        assert!((factorial(10) - 3628800f64).abs() < f64::EPSILON);\n    }\n\n    #[test]\n    fn test_analytical() {\n        assert!((analytical(10) - 3.6602).abs() < 0.0001);\n        assert!((analytical(20) - 5.2936).abs() < 0.0001);\n    }\n\n    #[test]\n    fn test_empirical() {\n        let mut rng = thread_rng();\n        let emp = empirical(20, 10000, &mut rng);\n        let ana = analytical(20);\n        assert!((emp / ana - 1.0).abs() < 0.05);\n    }\n}\n",
    "path": "tasks/average-loop-length",
    "remote_code": "extern crate rand;\n\nuse rand::{ThreadRng, thread_rng};\nuse rand::distributions::{IndependentSample, Range};\nuse std::collections::HashSet;\nuse std::env;\nuse std::process;\n\nfn help() {\n    println!(\"usage: average_loop_length <max_N> <trials>\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut max_n: u32 = 20;\n    let mut trials: u32 = 1000;\n\n    match args.len() {\n        1 => {}\n        3 => {\n            max_n = args[1].parse::<u32>().unwrap();\n            trials = args[2].parse::<u32>().unwrap();\n        }\n        _ => {\n            help();\n            process::exit(0);\n        }\n    }\n\n    let mut rng = thread_rng();\n\n    println!(\" N    average    analytical    (error)\");\n    println!(\"===  =========  ============  =========\");\n    for n in 1..(max_n + 1) {\n        let the_analytical = analytical(n);\n        let the_empirical = empirical(n, trials, &mut rng);\n        println!(\" {:>2}     {:3.4}        {:3.4}  ( {:>+1.2}%)\",\n                 n,\n                 the_empirical,\n                 the_analytical,\n                 100f64 * (the_empirical / the_analytical - 1f64));\n    }\n}\n\nfn factorial(n: u32) -> f64 {\n    (1..n + 1).fold(1f64, |p, n| p * n as f64)\n}\n\nfn analytical(n: u32) -> f64 {\n    let sum: f64 = (1..(n + 1))\n                       .map(|i| factorial(n) / (n as f64).powi(i as i32) / factorial(n - i))\n                       .fold(0f64, |a, v| a + v);\n    sum\n}\n\nfn empirical(n: u32, trials: u32, rng: &mut ThreadRng) -> f64 {\n    let sum: f64 = (0..trials)\n                       .map(|_t| {\n                           let mut item = 1u32;\n                           let mut seen = HashSet::new();\n                           let range = Range::new(1u32, n + 1);\n\n                           for step in 0..n {\n                               if seen.contains(&item) {\n                                   return step as f64;\n                               }\n                               seen.insert(item);\n                               item = range.ind_sample(rng);\n                           }\n                           n as f64\n                       })\n                       .fold(0f64, |a, v| a + v);\n    sum / trials as f64\n}\n\n\n",
    "title": "Average loop length",
    "url": "http://rosettacode.org/wiki/Average_loop_length"
  },
  {
    "local_code": "// The mean is not defined for an empty list, so we must return an Option\nfn mean(list: &[f64]) -> Option<f64> {\n    match list.len() {\n        0 => None,\n        n => {\n            let sum = list.iter().fold(0f64, |a, &b| a + b);\n            Some(sum / n as f64)\n        }\n    }\n}\n\nfn main() {\n    let input = [3.0, 1.0, 4.0, 1.0, 5.0, 9.0];\n\n    // This should be 3.833333\n    let mean = mean(&input).unwrap();\n    println!(\"{}\", mean);\n}\n\n#[test]\nfn simple_test() {\n    let nums = [1.0, 2.0, 3.0, 4.0, 5.0];\n    assert_eq!(mean(&nums), Some(3.0));\n}\n\n#[test]\nfn mean_empty_list() {\n    let no_nums = [];\n    assert_eq!(mean(&no_nums), None);\n}\n",
    "path": "tasks/averages/arithmetic-mean",
    "remote_code": "fn sum(arr: &[f64]) -> f64 {\n    arr.iter().fold(0.0, |p,&q| p + q)\n}\n\nfn mean(arr: &[f64]) -> f64 {\n    sum(arr) / arr.len() as f64\n}\n\nfn main() {\n    let v = &[2.0, 3.0, 5.0, 7.0, 13.0, 21.0, 33.0, 54.0];\n    println!(\"mean of {:?}: {:?}\", v, mean(v));\n\n    let w = &[];\n    println!(\"mean of {:?}: {:?}\", w, mean(w));\n}",
    "title": "Averages/Arithmetic mean",
    "url": "http://rosettacode.org/wiki/Averages/Arithmetic_mean"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Averages/Mean_angle\n\nuse std::f64::consts::PI;\n\nfn mean_angle(angles: &[f64]) -> f64 {\n    let (sum_cos, sum_sin) = angles\n        .iter()\n        .map(|&x| x * PI / 180.)\n        .map(|x| (x.cos(), x.sin()))\n        .fold((0., 0.), |(sc, ss), (c, s)| (sc + c, ss + s));\n\n    let mean_cos = sum_cos / angles.len() as f64;\n    let mean_sin = sum_sin / angles.len() as f64;\n\n    mean_sin.atan2(mean_cos) * 180. / PI\n}\n\nfn main() {\n    let set1 = &[350., 10.];\n    let set2 = &[90., 180., 270., 360.];\n    let set3 = &[10., 20., 30.];\n\n    println!(\"Mean angle of first set is {} degrees\", mean_angle(set1));\n    println!(\"Mean angle of second set is {} degrees\", mean_angle(set2));\n    println!(\"Mean angle of third set is {} degrees\", mean_angle(set3));\n}\n\n#[test]\nfn basic_tests() {\n    use std::f64;\n\n    let set1 = [350., 10.];\n    let set2 = [90., 180., 270., 360.];\n    let set3 = [10., 20., 30.];\n\n    // We need to round the numbers\n    assert!((mean_angle(&set1).round() - 0.).abs() < f64::EPSILON);\n    assert!((mean_angle(&set2).round() - -90.).abs() < f64::EPSILON);\n    assert!((mean_angle(&set3).round() - 20.).abs() < f64::EPSILON);\n}\nuse std::f64;\n\n// the macro is from\n// http://stackoverflow.com/questions/30856285/assert-eq-with-floating-\n// point-numbers-and-delta\nfn mean_angle(angles: &[f64]) -> f64 {\n    let length: f64 = angles.len() as f64;\n    let cos_mean: f64 = angles.iter().fold(0.0, |sum, i| sum + i.to_radians().cos()) / length;\n    let sin_mean: f64 = angles.iter().fold(0.0, |sum, i| sum + i.to_radians().sin()) / length;\n    (sin_mean).atan2(cos_mean).to_degrees()\n}\n\nfn main() {\n    let angles1 = [350.0_f64, 10.0];\n    let angles2 = [90.0_f64, 180.0, 270.0, 360.0];\n    let angles3 = [10.0_f64, 20.0, 30.0];\n    println!(\n        \"Mean Angle for {:?}  is {:.5} degrees\",\n        &angles1,\n        mean_angle(&angles1)\n    );\n    println!(\n        \"Mean Angle for {:?}  is {:.5} degrees\",\n        &angles2,\n        mean_angle(&angles2)\n    );\n    println!(\n        \"Mean Angle for {:?}  is {:.5} degrees\",\n        &angles3,\n        mean_angle(&angles3)\n    );\n}\n\n#[cfg(test)]\nmod tests {\n    use super::mean_angle;\n\n    macro_rules! assert_diff {\n        ($x:expr, $y:expr, $diff:expr) => {\n            if ($x - $y).abs() > $diff {\n                panic!(\"floating point difference is to big {}\", $x - $y);\n            }\n        };\n    }\n\n    #[test]\n    fn calculate() {\n        let angles1 = [350.0_f64, 10.0];\n        let angles2 = [90.0_f64, 180.0, 270.0, 360.0];\n        let angles3 = [10.0_f64, 20.0, 30.0];\n        assert_diff!(0.0, mean_angle(&angles1), 0.001);\n        assert_diff!(-90.0, mean_angle(&angles2), 0.001);\n        assert_diff!(20.0, mean_angle(&angles3), 0.001);\n    }\n}\n",
    "path": "tasks/averages/mean-angle",
    "remote_code": "\nuse std::f64;\n// the macro is from\n// http://stackoverflow.com/questions/30856285/assert-eq-with-floating-\n// point-numbers-and-delta\nfn mean_angle(angles: &[f64]) -> f64 {\n    let length: f64 = angles.len() as f64;\n    let cos_mean: f64 = angles.iter().fold(0.0, |sum, i| sum + i.to_radians().cos()) / length;\n    let sin_mean: f64 = angles.iter().fold(0.0, |sum, i| sum + i.to_radians().sin()) / length;\n    (sin_mean).atan2(cos_mean).to_degrees()\n}\n\nfn main() {\n    let angles1 = [350.0_f64, 10.0];\n    let angles2 = [90.0_f64, 180.0, 270.0, 360.0];\n    let angles3 = [10.0_f64, 20.0, 30.0];\n    println!(\"Mean Angle for {:?}  is {:.5} degrees\",\n             &angles1,\n             mean_angle(&angles1));\n    println!(\"Mean Angle for {:?}  is {:.5} degrees\",\n             &angles2,\n             mean_angle(&angles2));\n    println!(\"Mean Angle for {:?}  is {:.5} degrees\",\n             &angles3,\n             mean_angle(&angles3));\n}\n\nmacro_rules! assert_diff{\n    ($x: expr,$y : expr, $diff :expr)=>{\n        if ( $x - $y ).abs() > $diff {\n            panic!(\"floating point difference is to big {}\", $x - $y );\n        }\n    }\n}\n\n#[test]\nfn calculate() {\n    let angles1 = [350.0_f64, 10.0];\n    let angles2 = [90.0_f64, 180.0, 270.0, 360.0];\n    let angles3 = [10.0_f64, 20.0, 30.0];\n    assert_diff!(0.0, mean_angle(&angles1), 0.001);\n    assert_diff!(-90.0, mean_angle(&angles2), 0.001);\n    assert_diff!(20.0, mean_angle(&angles3), 0.001);\n}\n",
    "title": "Averages/Mean angle",
    "url": "http://rosettacode.org/wiki/Averages/Mean_angle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Averages/Mean time of day",
    "url": "http://rosettacode.org/wiki/Averages/Mean_time_of_day"
  },
  {
    "local_code": "fn median(samples: &[f64]) -> f64 {\n    let mut xs = samples.to_vec();\n    xs.sort_by(|x, y| x.partial_cmp(y).unwrap());\n\n    let n = xs.len();\n    if n % 2 == 0 {\n        (xs[n / 2] + xs[(n / 2) + 1]) / 2.0\n    } else {\n        xs[n / 2]\n    }\n}\n\nfn main() {\n    let nums = vec![2., 3., 5., 0., 9., 82., 353., 32., 12.];\n    println!(\"{:?}\", median(&nums))\n}\n\n#[cfg(test)]\nmod tests {\n    use std::f64;\n\n    #[test]\n    fn median() {\n        let nums = vec![2., 3., 5., 0., 9., 82., 353., 32., 12.];\n        assert!((super::median(&nums) - 9_f64).abs() < f64::EPSILON);\n    }\n}\n",
    "path": "tasks/averages/median",
    "remote_code": "fn median(mut xs: Vec<f64>) -> f64 {\n    // sort in ascending order, panic on f64::NaN\n    xs.sort_by(|x,y| x.partial_cmp(y).unwrap() );\n    let n = xs.len();\n    if n % 2 == 0 {\n        (xs[n/2] + xs[n/2 - 1]) / 2.0\n    } else {\n        xs[n/2]\n    }\n}\n\nfn main() {\n    let nums = vec![2.,3.,5.,0.,9.,82.,353.,32.,12.];\n    println!(\"{:?}\", median(nums))\n}",
    "title": "Averages/Median",
    "url": "http://rosettacode.org/wiki/Averages/Median"
  },
  {
    "local_code": "use std::collections::HashMap;\nuse std::hash::Hash;\n\n/// Returns the most common element a collection implementing\n/// `IntoIterator<Item=T>`, where `T` must implement the `Eq` and `Hash` traits\n///\n/// ```\n/// let v1 = vec![1,3,6,6,6,6,7,7,12,12,17];\n/// println!(\"{}\", mode(v1));\n/// ```\nfn mode<I>(items: I) -> Vec<I::Item>\nwhere\n    I: IntoIterator,\n    I::Item: Hash + Eq,\n{\n    // NOTE: Usually, you wouldn't need to explicitly call `into_iter()` before\n    // looping over a type implementing `IntoIterator`. However, we do it here\n    // because we need to call `size_hint()` on the iterator so we can\n    // preallocate the `HashMap`.\n    let items = items.into_iter();\n    let (lower_bound, _upper_bound) = items.size_hint();\n\n    // Allocate a new HashMap with enough space to fit the lower bound of the\n    // number of items in `items`.\n    //\n    // If the lower bound (`lower_bound`) is the same as the upper bound as\n    // will be the case for most collections (e.g. `Vec<T>`, `[T]`,\n    // `HashSet<T>`, etc.) it will be an overestimate on the number of unique\n    // elements in the collection. This means that, in the common case, we'll\n    // never have to grow the `HashMap`. While overestimating means we'll likely\n    // use more memory than necessary, the allocation size will usually be\n    // proportional to the size of the input collection (assuming it's not a\n    // lazy collection). This `HashMap` is short lived anyways.\n    let mut map = HashMap::with_capacity(lower_bound); // HashMap<I::Item, i32>\n\n    // Count the number of occurrences of each item.\n    for item in items {\n        *map.entry(item).or_insert(0) += 1;\n    }\n\n    // Iterate over the counts, and find the maximum or default to 0.\n    let max = map.values().cloned().max().unwrap_or(0);\n\n    // Iterate by (item, value) pairs and find all modes (there may be multiple).\n    map.into_iter()\n        .filter(|&(_, v)| v == max)\n        .map(|(k, _)| k)\n        .collect()\n}\n\nfn main() {\n    let items = vec![1, 2, 3, 1, 2, 4, 2, 6, 3, 3, 1, 3, 6];\n    println!(\"{:?}\", mode(&items));\n}\n\n#[test]\nfn simple_tests() {\n    let v1 = vec![1, 2, 3, 2, 1];\n    let mut m1 = mode(v1);\n    m1.sort();\n    assert_eq!(m1, vec![1, 2]);\n\n    let v2: &[u64] = &[0xdeadbeef, 0xba5eba11, 0xdeadbeef];\n    let mut m2 = mode(v2.iter().cloned());\n    m2.sort();\n    assert_eq!(m2, vec![0xdeadbeef]);\n\n    let v3 = \"Eneyi\\u{e4}n\";\n    let mut m3 = mode(v3.chars());\n    m3.sort();\n    assert_eq!(m3, vec!['n']);\n\n    let v4 = vec![1, 3, 6, 6, 7, 7, 12, 12, 17];\n    let mut m4 = mode(&v4);\n    m4.sort();\n    assert_eq!(m4, &[&6, &7, &12]);\n}\n",
    "path": "tasks/averages/mode",
    "remote_code": "use std::collections::HashMap;\n\nfn main() {\n    let mode_vec1 = mode(vec![ 1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17]);\n    let mode_vec2 = mode(vec![ 1, 1, 2, 4, 4]);\n\n    println!(\"Mode of vec1 is: {:?}\", mode_vec1);\n    println!(\"Mode of vec2 is: {:?}\", mode_vec2);\n\n    assert!( mode_vec1 == [6], \"Error in mode calculation\");\n    assert!( (mode_vec2 == [1, 4]) || (mode_vec2 == [4,1]), \"Error in mode calculation\" );\n}\n\nfn mode(vs: Vec<i32>) -> Vec<i32> {\n    let mut vec_mode = Vec::new();\n    let mut seen_map = HashMap::new();\n    let mut max_val = 0;\n    for i in vs{\n        let ctr = seen_map.entry(i).or_insert(0);\n        *ctr += 1;\n        if *ctr > max_val{\n            max_val = *ctr;\n        }\n    }\n    for (key, val) in seen_map {\n        if val == max_val{\n            vec_mode.push(key);\n        }\n    }\n    vec_mode\n}\n",
    "title": "Averages/Mode",
    "url": "http://rosettacode.org/wiki/Averages/Mode"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let mut sum = 0.0;\n    let mut prod = 1;\n    let mut recsum = 0.0;\n    for i in 1..11{\n        sum += i as f32;\n        prod *= i;\n        recsum += 1.0/(i as f32);\n    } \n    let avg = sum/10.0;\n    let gmean = (prod as f32).powf(0.1);\n    let hmean = 10.0/recsum;\n    println!(\"Average: {}, Geometric mean: {}, Harmonic mean: {}\", avg, gmean, hmean);\n    assert!( ( (avg >= gmean) && (gmean >= hmean) ), \"Incorrect calculation\");\n\n}\n",
    "title": "Averages/Pythagorean means",
    "url": "http://rosettacode.org/wiki/Averages/Pythagorean_means"
  },
  {
    "local_code": "/// The mean is not defined for an empty list, so we must return an Option\nfn rms(list: &[f64]) -> Option<f64> {\n    match list.len() {\n        0 => None,\n        n => {\n            let sum = list.iter().fold(0., |a, &b| a + b * b);\n            Some(f64::sqrt(sum / n as f64))\n        }\n    }\n}\n\nfn main() {\n    let input: Vec<_> = (1..11).map(f64::from).collect();\n\n    // 6.2048368229954285\n    let rms = rms(&input).unwrap();\n    println!(\"{}\", rms);\n}\n\n#[test]\nfn test() {\n    let arr = [5., 7., 2., 0., 0.5];\n    assert_eq!(rms(&arr), Some(3.9560080889704965));\n}\n\n#[test]\nfn rms_empty_array() {\n    let no_nums = [];\n    assert_eq!(rms(&no_nums), None);\n}\n",
    "path": "tasks/averages/root-mean-square",
    "remote_code": "fn root_mean_square(vec: Vec<i32>) -> f32 {\n    let sum_squares = vec.iter().fold(0, |acc, &x| acc + x.pow(2));\n    return ((sum_squares as f32)/(vec.len() as f32)).sqrt();\n}\n\nfn main() {\n    let vec = (1..11).collect();\n    println!(\"The root mean square is: {}\", root_mean_square(vec));\n}",
    "title": "Averages/Root mean square",
    "url": "http://rosettacode.org/wiki/Averages/Root_mean_square"
  },
  {
    "local_code": "struct MovingAverage {\n    period: u32,\n    list: Vec<f32>,\n}\n\n#[derive(Debug)]\nstruct MovingAverageError {\n    message: String,\n}\n\nimpl MovingAverage {\n    fn new(period: u32) -> MovingAverage {\n        if period > 0 {\n            MovingAverage {\n                period: period,\n                list: Vec::new(),\n            }\n        } else {\n            panic!(\"Cannot have a period less than or equal to 0\");\n        }\n    }\n\n    fn append(&mut self, value: f32) {\n        self.list.push(value);\n        if self.list.len() > self.period as usize {\n            self.list.remove(0);\n        }\n    }\n\n    fn calculate(&self) -> Result<f32, MovingAverageError> {\n        if self.list.len() < self.period as usize {\n            Err(MovingAverageError {\n                message: format!(\n                    \"Currently only have {} entries, period is {}\",\n                    self.list.len(),\n                    self.period\n                ),\n            })\n        } else {\n            Ok(self.list.iter().fold(0.0_f32, |l, r| l + r) / (self.period as f32))\n        }\n    }\n}\n\nfn main() {\n    let mut ma = MovingAverage::new(3);\n    ma.append(1.0);\n    ma.append(2.0);\n    ma.append(3.0);\n\n    println!(\"{:?}\", ma.calculate());\n}\n\n#[test]\nfn test_ma() {\n    let mut ma = MovingAverage::new(3);\n    assert!(ma.calculate().is_err());\n    ma.append(1.0);\n    assert!(ma.calculate().is_err());\n    ma.append(2.0);\n    assert!(ma.calculate().is_err());\n    ma.append(3.0);\n    assert_eq!(ma.calculate().unwrap(), 2.0);\n    ma.append(1.0);\n    assert_eq!(ma.calculate().unwrap(), 2.0);\n    ma.append(8.0);\n    assert_eq!(ma.calculate().unwrap(), 4.0);\n}\n",
    "path": "tasks/averages/simple-moving-average",
    "remote_code": "struct SimpleMovingAverage {\n    period: usize,\n    numbers: Vec<usize>\n}\n\nimpl SimpleMovingAverage {\n    fn new(p: usize) -> SimpleMovingAverage {\n        SimpleMovingAverage {\n            period: p,\n            numbers: Vec::new()\n        }\n    }\n\n    fn add_number(&mut self, number: usize) -> f64 {\n        self.numbers.push(number);\n        \n        if self.numbers.len() > self.period {\n            self.numbers.remove(0);\n        }\n        \n        if self.numbers.is_empty() {\n            return 0f64;\n        }else {\n            let sum = self.numbers.iter().fold(0, |acc, x| acc+x);\n            return sum as f64 / self.numbers.len() as f64;\n        }\n    }\n}\n\nfn main() {\n    for period in [3, 5].iter() {\n        println!(\"Moving average with period {}\", period);\n\n        let mut sma = SimpleMovingAverage::new(*period);\n        for i in [1, 2, 3, 4, 5, 5, 4, 3, 2, 1].iter() {\n            println!(\"Number: {} | Average: {}\", i, sma.add_number(*i));\n        }\n    }\n}",
    "title": "Averages/Simple moving average",
    "url": "http://rosettacode.org/wiki/Averages/Simple_moving_average"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let mut current = 0;\n    while (current * current) % 1_000_000 != 269_696 {\n        current += 1;\n    }\n    println!(\n        \"The smallest number whose square ends in 269696 is {}\",\n        current\n    );\n}",
    "title": "Babbage problem",
    "url": "http://rosettacode.org/wiki/Babbage_problem"
  },
  {
    "local_code": "extern crate rand;\n\ntrait Balanced {\n    /// Returns true if the brackets are balanced\n    fn is_balanced(&self) -> bool;\n}\n\nimpl<'a> Balanced for str {\n    fn is_balanced(&self) -> bool {\n        let mut count = 0;\n\n        for bracket in self.chars() {\n            let change = match bracket {\n                '[' => 1,\n                ']' => -1,\n                _ => panic!(\"Strings should only contain brackets\"),\n            };\n\n            count += change;\n            if count < 0 {\n                return false;\n            }\n        }\n\n        count == 0\n    }\n}\n\n/// Generates random brackets\nfn generate_brackets(num: usize) -> String {\n    use rand::{thread_rng, Rng};\n\n    let mut rng = thread_rng();\n    (0..num)\n        .map(|_| if rng.gen() { '[' } else { ']' })\n        .collect()\n}\n\nfn main() {\n    for i in 0..10 {\n        let brackets = generate_brackets(i);\n\n        println!(\"{}    {}\", brackets, brackets.is_balanced())\n    }\n}\n\n#[test]\nfn test_empty_string() {\n    assert!(\"\".is_balanced());\n}\n\n#[test]\nfn test_wrong_brackets() {\n    assert!(!\"][\".is_balanced());\n    assert!(!\"][][\".is_balanced());\n    assert!(!\"[]][[]\".is_balanced());\n}\n\n#[test]\nfn test_good_brackets() {\n    assert!(\"[]\".is_balanced());\n    assert!(\"[][]\".is_balanced());\n    assert!(\"[[][]]\".is_balanced());\n}\n",
    "path": "tasks/balanced-brackets",
    "remote_code": "extern crate rand;\n\ntrait Balanced {\n    /// Returns true if the brackets are balanced\n    fn is_balanced(&self) -> bool;\n}\n\nimpl<'a> Balanced for str {\n    fn is_balanced(&self) -> bool {\n        let mut count = 0;\n\n        for bracket in self.chars() {\n            let change = match bracket {\n                '[' => 1,\n                ']' => -1,\n                _ => panic!(\"Strings should only contain brackets\")\n            };\n\n            count += change;\n            if count < 0 { return false; }\n        }\n\n        count == 0\n    }\n}\n\n/// Generates random brackets\nfn generate_brackets(num: usize) -> String {\n    use rand::random;\n\n    (0..num).map(|_| if random() { '[' } else { ']' }).collect()\n}\n\nfn main() {\n    for i in (0..10) {\n        let brackets = generate_brackets(i);\n\n        println!(\"{}    {}\", brackets, brackets.is_balanced())\n    }\n}",
    "title": "Balanced brackets",
    "url": "http://rosettacode.org/wiki/Balanced_brackets"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Balanced ternary",
    "url": "http://rosettacode.org/wiki/Balanced_ternary"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate rand;\nextern crate raster;\n\nuse rand::Rng;\n\nfn main() {\n    let max_iterations = 200_000u32;\n    let height = 640i32;\n    let width = 640i32;\n\n    let mut rng = rand::thread_rng();\n    let mut image = raster::Image::blank(width, height);\n    raster::editor::fill(&mut image, raster::Color::white()).unwrap();\n\n    let mut x = 0.;\n    let mut y = 0.;\n    for _ in 0..max_iterations {\n        let r = rng.gen::<f32>();\n        let cx: f64;\n        let cy: f64;\n\n        if r <= 0.01 {\n            cx = 0f64;\n            cy = 0.16 * y as f64;\n        } else if r <= 0.08 {\n            cx = 0.2 * x as f64 - 0.26 * y as f64;\n            cy = 0.23 * x as f64 + 0.22 * y as f64 + 1.6;\n        } else if r <= 0.15 {\n            cx = -0.15 * x as f64 + 0.28 * y as f64;\n            cy = 0.26 * x as f64 + 0.26 * y as f64 + 0.44;\n        } else {\n            cx = 0.85 * x as f64 + 0.04 * y as f64;\n            cy = -0.04 * x as f64 + 0.85 * y as f64 + 1.6;\n        }\n        x = cx;\n        y = cy;\n\n        let _ = image.set_pixel(\n            ((width as f64) / 2. + x * (width as f64) / 11.).round() as i32,\n            ((height as f64) - y * (height as f64) / 11.).round() as i32,\n            raster::Color::rgb(50, 205, 50));\n    }\n\n    raster::save(&image, \"fractal.png\").unwrap();\n}",
    "title": "Barnsley fern",
    "url": "http://rosettacode.org/wiki/Barnsley_fern"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::str;\n\nconst INPUT: &str = \"VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZWVkIGEgY29tcHV0ZXIuCiAgICAtLVBhdWwgUi5FaHJsaWNo\";\nconst UPPERCASE_OFFSET: i8 = -65;\nconst LOWERCASE_OFFSET: i8 = 26 - 97;\nconst NUM_OFFSET: i8 = 52 - 48;\n\nfn main() {\n    println!(\"Input: {}\", INPUT);\n\n    let result = INPUT.chars()\n        .filter(|&ch| ch != '=')                                //Filter '=' chars\n        .map(|ch| {                                             //Map char values using Base64 Characters Table\n            let ascii = ch as i8;                           \n            let convert = match ch {\n                '0' ... '9' => ascii + NUM_OFFSET,\n                'a' ... 'z' => ascii + LOWERCASE_OFFSET,\n                'A' ... 'Z' => ascii + UPPERCASE_OFFSET,\n                '+' => 62,\n                '/' => 63,\n                _ => panic!(\"Not a valid base64 encoded string\")\n            };\n            format!(\"{:#08b}\", convert)[2..].to_string()        //convert indices to binary format and remove the two first digits\n        })\n        .collect::<String>()                                    //concatenate the resulting binary values\n        .chars()\n        .collect::<Vec<char>>()\n        .chunks(8)                                              //split into 8 character chunks\n        .map(|chunk| {\n            let num_str = chunk.iter().collect::<String>();\n            usize::from_str_radix(&num_str, 2).unwrap() as u8   //convert the binary string into its u8 value\n        })\n        .collect::<Vec<_>>();\n\n    let result = str::from_utf8(&result).unwrap();              //convert into UTF-8 string\n\n    println!(\"Output: {}\", result);\n}",
    "title": "Base64 decode data",
    "url": "http://rosettacode.org/wiki/Base64_decode_data"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bell numbers",
    "url": "http://rosettacode.org/wiki/Bell_numbers"
  },
  {
    "local_code": "//! Contributed by Gavin Baker <gavinb@antonym.org>\n\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\n/// Calculate the expected frequency of a digit according to Benford's Law\nfn benford_freq(d: u64) -> f32 {\n    assert!(d >= 1 && d <= 9);\n\n    (1.0 + 1.0 / (d as f32)).log10()\n}\n\n/// Returns the leading digit of any number\nfn first_digit_of(n: u64) -> usize {\n    let mut d = n;\n    while d > 9 {\n        d /= 10;\n    }\n    d as usize\n}\n\n/// Count frequency table using the first digit of each number in a vector\nfn benford_distrib(numbers: &[u64]) -> Vec<f32> {\n    // Counts\n\n    let mut counts = [0u64; 10];\n\n    for num in numbers {\n        let first = first_digit_of(*num);\n        counts[first] += 1;\n    }\n\n    // Frequencies\n\n    let mut freq = vec![0f32; 10];\n\n    for digit in 1..10 {\n        freq[digit] = counts[digit] as f32 / numbers.len() as f32;\n    }\n\n    freq\n}\n\nfn main() {\n    // Calculate expected frequencies of all digits according to Benford's Law\n    let mut expected_distrib = [0f32; 10];\n    for digit in &mut expected_distrib {\n        *digit = benford_freq(*digit as u64);\n    }\n\n    // Load data from the Fibonacci sequence\n    let file = BufReader::new(File::open(\"resources/fib1000.txt\").unwrap());\n\n    let fibs: Vec<u64> = file\n        .lines()\n        .map(|x| {\n            let s = x.unwrap();\n            s[0..1].parse::<u64>().unwrap()\n        })\n        .collect();\n\n    // Calculate freuencies of first digits in test data\n    let found_distrib = benford_distrib(&fibs[..]);\n\n    // Print the stats to compare actual vs expected\n    println!(\"\\nBenford's Law - Digit Distribution\");\n    println!(\"\\nFirst 1000 Numbers in the Fibonacci Sequence\\n\");\n    println!(\"digit    expect     found     delta\");\n    for digit in 1..10 {\n        let expected_pc = expected_distrib[digit] * 100.0;\n        let found_pc = found_distrib[digit] * 100.0;\n        let delta_pc = expected_pc - found_pc;\n\n        println!(\n            \"{}        {:>4.1}%      {:>4.1}%    {:>5.2}%\",\n            digit, expected_pc, found_pc, delta_pc\n        );\n    }\n}\n",
    "path": "tasks/benfords-law",
    "remote_code": "\nextern crate num_traits;\nextern crate num;\n\nuse num::bigint::{BigInt, ToBigInt};\nuse num_traits::{Zero, One};\nuse std::collections::HashMap;\n\n// Return a vector of all fibonacci results from fib(1) to fib(n)\nfn fib(n: usize) -> Vec<BigInt> {\n    let mut result = Vec::with_capacity(n);\n    let mut a = BigInt::zero();\n    let mut b = BigInt::one();\n\n    result.push(b.clone());\n\n    for i in 1..n {\n        let t = b.clone();\n        b = a+b;\n        a = t;\n        result.push(b.clone());\n    }\n\n    result\n}\n\n// Return the first digit of a `BigInt`\nfn first_digit(x: &BigInt) -> u8 {\n    let zero = BigInt::zero();\n    assert!(x > &zero);\n\n    let s = x.to_str_radix(10);\n\n    // parse the first digit of the stringified integer\n    *&s[..1].parse::<u8>().unwrap()\n}\n\nfn main() {\n    const N: usize = 1000;\n    let mut counter: HashMap<u8, u32> = HashMap::new();\n    for x in fib(N) {\n        let d = first_digit(&x);\n        *counter.entry(d).or_insert(0) += 1;\n    }\n\n    println!(\"{:>13}    {:>10}\", \"real\", \"predicted\");\n    for y in 1..10 {\n        println!(\"{}: {:10.3} v. {:10.3}\", y, *counter.get(&y).unwrap_or(&0) as f32 / N as f32,\n        (1.0 + 1.0 / (y as f32)).log10());\n    }\n\n}\n",
    "title": "Benford's law",
    "url": "http://rosettacode.org/wiki/Benford's_law"
  },
  {
    "local_code": "//! 2.5 implementations here:  naive, optimized, and an iterator using\n//! the optimized function. The speeds vary significantly: relative\n//! speeds of optimized:iterator:naive implementations is 625:25:1.\n\n#![feature(test)]\n\nextern crate num;\nextern crate test;\n\nuse num::bigint::{BigInt, ToBigInt};\nuse num::rational::BigRational;\nuse std::cmp::max;\nuse std::env;\nuse std::ops::{Mul, Sub};\nuse std::process;\n\nstruct Bn {\n    value: BigRational,\n    index: i32,\n}\n\nstruct Context {\n    bigone_const: BigInt,\n    a: Vec<BigRational>,\n    index: i32, // Counter for iterator implementation\n}\n\nimpl Context {\n    pub fn new() -> Context {\n        let bigone = 1.to_bigint().unwrap();\n        let a_vec: Vec<BigRational> = vec![];\n        Context {\n            bigone_const: bigone,\n            a: a_vec,\n            index: -1,\n        }\n    }\n}\n\nimpl Default for Context {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl Iterator for Context {\n    type Item = Bn;\n\n    fn next(&mut self) -> Option<Bn> {\n        self.index += 1;\n        Some(Bn {\n            value: bernoulli(self.index as usize, self),\n            index: self.index,\n        })\n    }\n}\n\nfn help() {\n    println!(\"Usage: bernoulli_numbers <up_to>\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut up_to: usize = 60;\n\n    match args.len() {\n        1 => {}\n        2 => {\n            up_to = args[1].parse::<usize>().unwrap();\n        }\n        _ => {\n            help();\n            process::exit(0);\n        }\n    }\n\n    let context = Context::new();\n    // Collect the solutions by using the Context iterator\n    // (this is not as fast as calling the optimized function directly).\n    let res = context.take(up_to + 1).collect::<Vec<_>>();\n    let width = res\n        .iter()\n        .fold(0, |a, r| max(a, r.value.numer().to_string().len()));\n\n    for r in res.iter().filter(|r| r.index % 2 == 0) {\n        println!(\n            \"B({:>2}) = {:>2$} / {denom}\",\n            r.index,\n            r.value.numer(),\n            width,\n            denom = r.value.denom()\n        );\n    }\n}\n\n// Implementation with no reused calculations.\nfn _bernoulli_naive(n: usize, c: &mut Context) -> BigRational {\n    for m in 0..n + 1 {\n        c.a.push(BigRational::new(\n            c.bigone_const.clone(),\n            (m + 1).to_bigint().unwrap(),\n        ));\n        for j in (1..m + 1).rev() {\n            c.a[j - 1] = (c.a[j - 1].clone().sub(c.a[j].clone())).mul(BigRational::new(\n                j.to_bigint().unwrap(),\n                c.bigone_const.clone(),\n            ));\n        }\n    }\n    c.a[0].reduced()\n}\n\n// Implementation with reused calculations (does not require sequential calls).\nfn bernoulli(n: usize, c: &mut Context) -> BigRational {\n    for i in 0..n + 1 {\n        if i >= c.a.len() {\n            c.a.push(BigRational::new(\n                c.bigone_const.clone(),\n                (i + 1).to_bigint().unwrap(),\n            ));\n            for j in (1..i + 1).rev() {\n                c.a[j - 1] = (c.a[j - 1].clone().sub(c.a[j].clone())).mul(BigRational::new(\n                    j.to_bigint().unwrap(),\n                    c.bigone_const.clone(),\n                ));\n            }\n        }\n    }\n    c.a[0].reduced()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{_bernoulli_naive, bernoulli, Bn, Context};\n    use num::rational::BigRational;\n    use std::str::FromStr;\n    use test::Bencher;\n\n    #[test]\n    fn test_bernoulli_naive() {\n        let mut context = Context::new();\n        assert_eq!(\n            _bernoulli_naive(60, &mut context),\n            BigRational::new(\n                FromStr::from_str(\"-1215233140483755572040304994079820246041491\").unwrap(),\n                FromStr::from_str(\"56786730\").unwrap()\n            )\n        );\n    }\n\n    #[test]\n    fn test_bernoulli() {\n        let mut context = Context::new();\n        assert_eq!(\n            bernoulli(60, &mut context),\n            BigRational::new(\n                FromStr::from_str(\"-1215233140483755572040304994079820246041491\").unwrap(),\n                FromStr::from_str(\"56786730\").unwrap()\n            )\n        );\n    }\n\n    #[test]\n    fn test_bernoulli_iter() {\n        let context = Context::new();\n        let res = context.take(60 + 1).collect::<Vec<_>>();\n        assert_eq!(\n            res.last().unwrap().value,\n            BigRational::new(\n                FromStr::from_str(\"-1215233140483755572040304994079820246041491\").unwrap(),\n                FromStr::from_str(\"56786730\").unwrap()\n            )\n        );\n    }\n\n    #[bench]\n    fn bench_bernoulli_naive(b: &mut Bencher) {\n        let mut context = Context::new();\n        b.iter(|| {\n            let mut res: Vec<Bn> = vec![];\n            for n in 0..30 + 1 {\n                let b = _bernoulli_naive(n, &mut context);\n                res.push(Bn {\n                    value: b.clone(),\n                    index: n as i32,\n                });\n            }\n        });\n    }\n\n    #[bench]\n    fn bench_bernoulli(b: &mut Bencher) {\n        let mut context = Context::new();\n        b.iter(|| {\n            let mut res: Vec<Bn> = vec![];\n            for n in 0..30 + 1 {\n                let b = bernoulli(n, &mut context);\n                res.push(Bn {\n                    value: b.clone(),\n                    index: n as i32,\n                });\n            }\n        });\n    }\n\n    #[bench]\n    fn bench_bernoulli_iter(b: &mut Bencher) {\n        b.iter(|| {\n            let context = Context::new();\n            let _res = context.take(30 + 1).collect::<Vec<_>>();\n        });\n    }\n}\n",
    "path": "tasks/bernoulli-numbers",
    "remote_code": "// 2.5 implementations presented here:  naive, optimized, and an iterator using\n// the optimized function. The speeds vary significantly: relative\n// speeds of optimized:iterator:naive implementations is 625:25:1.\n\n#![feature(test)]\n\nextern crate num;\nextern crate test;\n\nuse num::bigint::{BigInt, ToBigInt};\nuse num::rational::{BigRational};\nuse std::cmp::max;\nuse std::env;\nuse std::ops::{Mul, Sub};\nuse std::process;\n\nstruct Bn {\n    value: BigRational,\n    index: i32\n}\n\nstruct Context {\n    bigone_const: BigInt,\n    a: Vec<BigRational>,\n    index: i32              // Counter for iterator implementation\n}\n\nimpl Context {\n    pub fn new() -> Context {\n        let bigone = 1.to_bigint().unwrap();\n        let a_vec: Vec<BigRational> = vec![];\n        Context {\n            bigone_const: bigone,\n            a: a_vec,\n            index: -1\n        }\n    }\n}\n\nimpl Iterator for Context {\n    type Item = Bn;\n\n    fn next(&mut self) -> Option<Bn> {\n        self.index += 1;\n        Some(Bn { value: bernoulli(self.index as usize, self), index: self.index })\n    }\n}\n\nfn help() {\n    println!(\"Usage: bernoulli_numbers <up_to>\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut up_to: usize = 60;\n\n    match args.len() {\n        1 => {},\n        2 => {\n            up_to = args[1].parse::<usize>().unwrap();\n        },\n        _ => {\n            help();\n            process::exit(0);\n        }\n    }\n\n    let context = Context::new();\n    // Collect the solutions by using the Context iterator\n    // (this is not as fast as calling the optimized function directly).\n    let res = context.take(up_to + 1).collect::<Vec<_>>();\n    let width = res.iter().fold(0, |a, r| max(a, r.value.numer().to_string().len()));\n\n    for r in res.iter().filter(|r| *r.value.numer() != ToBigInt::to_bigint(&0).unwrap()) {\n        println!(\"B({:>2}) = {:>2$} / {denom}\", r.index, r.value.numer(), width,\n            denom = r.value.denom());\n    }\n}\n\n// Implementation with no reused calculations.\nfn _bernoulli_naive(n: usize, c: &mut Context) -> BigRational {\n    for m in 0..n + 1 {\n        c.a.push(BigRational::new(c.bigone_const.clone(), (m + 1).to_bigint().unwrap()));\n        for j in (1..m + 1).rev() {\n            c.a[j - 1] = (c.a[j - 1].clone().sub(c.a[j].clone())).mul(\n                BigRational::new(j.to_bigint().unwrap(), c.bigone_const.clone())\n            );\n        }\n    }\n    c.a[0].reduced()\n}\n\n// Implementation with reused calculations (does not require sequential calls).\nfn bernoulli(n: usize, c: &mut Context) -> BigRational {\n    for i in 0..n + 1 {\n        if i >= c.a.len() {\n            c.a.push(BigRational::new(c.bigone_const.clone(), (i + 1).to_bigint().unwrap()));\n            for j in (1..i + 1).rev() {\n                c.a[j - 1] = (c.a[j - 1].clone().sub(c.a[j].clone())).mul(\n                    BigRational::new(j.to_bigint().unwrap(), c.bigone_const.clone())\n                );\n            }\n        }\n    }\n    c.a[0].reduced()\n}\n\n\n#[cfg(test)]\nmod tests {\n    use super::{Bn, Context, bernoulli, _bernoulli_naive};\n    use num::rational::{BigRational};\n    use std::str::FromStr;\n    use test::Bencher;\n\n    // [tests elided]\n\n    #[bench]\n    fn bench_bernoulli_naive(b: &mut Bencher) {\n        let mut context = Context::new();\n        b.iter(|| {\n            let mut res: Vec<Bn> = vec![];\n            for n in 0..30 + 1 {\n                let b = _bernoulli_naive(n, &mut context);\n                res.push(Bn { value:b.clone(), index: n as i32});\n            }\n        });\n    }\n\n    #[bench]\n    fn bench_bernoulli(b: &mut Bencher) {\n        let mut context = Context::new();\n        b.iter(|| {\n            let mut res: Vec<Bn> = vec![];\n            for n in 0..30 + 1 {\n                let b = bernoulli(n, &mut context);\n                res.push(Bn { value:b.clone(), index: n as i32});\n            }\n        });\n    }\n\n    #[bench]\n    fn bench_bernoulli_iter(b: &mut Bencher) {\n        b.iter(|| {\n            let context = Context::new();\n            let _res = context.take(30 + 1).collect::<Vec<_>>();\n        });\n    }\n}\n",
    "title": "Bernoulli numbers",
    "url": "http://rosettacode.org/wiki/Bernoulli_numbers"
  },
  {
    "local_code": "extern crate permutohedron;\nextern crate rand;\n\nuse std::cmp::{min, Ordering};\nuse std::env;\nuse std::str;\n\nuse rand::prelude::*;\n\nconst WORDS: &[&str] = &[\"abracadabra\", \"seesaw\", \"elk\", \"grrrrrr\", \"up\", \"a\"];\n\n#[derive(Eq)]\nstruct Solution {\n    original: String,\n    shuffled: String,\n    score: usize,\n}\n\n// Ordering trait implementations are only needed for the permutations method\nimpl PartialOrd for Solution {\n    fn partial_cmp(&self, other: &Solution) -> Option<Ordering> {\n        self.score.partial_cmp(&other.score)\n    }\n}\n\nimpl PartialEq for Solution {\n    fn eq(&self, other: &Solution) -> bool {\n        self.score == other.score\n    }\n}\n\nimpl Ord for Solution {\n    fn cmp(&self, other: &Solution) -> Ordering {\n        self.score.cmp(&other.score)\n    }\n}\n\nfn _help() {\n    println!(\"Usage: best_shuffle <word1> <word2> ...\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n\n    let words = match args.len() {\n        1 => WORDS.iter().map(|s| s.to_string()).collect(),\n        _ => args[1..].to_vec(),\n    };\n\n    let solutions = words.iter().map(|w| best_shuffle(w));\n\n    for s in solutions {\n        println!(\"{}, {}, ({})\", s.original, s.shuffled, s.score);\n    }\n}\n\n// Implementation iterating over all permutations\nfn _best_shuffle_perm(w: &str) -> Solution {\n    let w = String::from(w);\n\n    let mut soln = Solution {\n        original: w.clone(),\n        shuffled: w.clone(),\n        score: w.len(),\n    };\n    let w_bytes: Vec<u8> = w.clone().into_bytes();\n    let mut permutocopy = w_bytes.clone();\n    let mut permutations = permutohedron::Heap::new(&mut permutocopy);\n    while let Some(p) = permutations.next_permutation() {\n        let hamm = hamming(&w_bytes, p);\n        soln = min(\n            soln,\n            Solution {\n                original: w.clone(),\n                shuffled: String::from(str::from_utf8(p).unwrap()),\n                score: hamm,\n            },\n        );\n        // Accept the solution if score 0 found\n        if hamm == 0 {\n            break;\n        }\n    }\n    soln\n}\n\n// Quadratic implementation\nfn best_shuffle(w: &str) -> Solution {\n    let w = String::from(w);\n\n    let w_bytes = w.clone().into_bytes();\n    let mut shuffled_bytes = w.clone().into_bytes();\n    shuffled_bytes.shuffle(&mut thread_rng());\n\n    // Swap wherever it doesn't decrease the score\n    for i in 0..shuffled_bytes.len() {\n        for j in 0..shuffled_bytes.len() {\n            if (i == j)\n                | (shuffled_bytes[i] == w_bytes[j])\n                | (shuffled_bytes[j] == w_bytes[i])\n                | (shuffled_bytes[i] == shuffled_bytes[j])\n            {\n                continue;\n            }\n            shuffled_bytes.swap(i, j);\n            break;\n        }\n    }\n\n    let res = String::from(str::from_utf8(&shuffled_bytes).unwrap());\n    let res_bytes: Vec<u8> = res.clone().into_bytes();\n    Solution {\n        original: w.clone(),\n        shuffled: res,\n        score: hamming(&w_bytes, &res_bytes),\n    }\n}\n\nfn hamming(w0: &[u8], w1: &[u8]) -> usize {\n    w0.iter().zip(w1.iter()).filter(|&(a, b)| a == b).count()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{_best_shuffle_perm, best_shuffle};\n\n    #[test]\n    fn test_best_shuffle_perm() {\n        let mut s0 = _best_shuffle_perm(\"seesaw\");\n        assert_eq!(s0.score, 0);\n\n        s0 = _best_shuffle_perm(\"elk\");\n        assert_eq!(s0.score, 0);\n\n        s0 = _best_shuffle_perm(\"grrrrrr\");\n        assert_eq!(s0.score, 5);\n\n        s0 = _best_shuffle_perm(\"up\");\n        assert_eq!(s0.shuffled, \"pu\");\n        assert_eq!(s0.score, 0);\n\n        s0 = _best_shuffle_perm(\"a\");\n        assert_eq!(s0.shuffled, \"a\");\n        assert_eq!(s0.score, 1);\n    }\n\n    #[test]\n    fn test_best_shuffle() {\n        let mut s0 = best_shuffle(\"abracadabra\");\n        assert_eq!(s0.score, 0);\n\n        s0 = best_shuffle(\"seesaw\");\n        assert_eq!(s0.score, 0);\n\n        s0 = best_shuffle(\"elk\");\n        assert_eq!(s0.score, 0);\n\n        s0 = best_shuffle(\"grrrrrr\");\n        assert_eq!(s0.score, 5);\n\n        s0 = best_shuffle(\"up\");\n        assert_eq!(s0.shuffled, \"pu\");\n        assert_eq!(s0.score, 0);\n\n        s0 = best_shuffle(\"a\");\n        assert_eq!(s0.shuffled, \"a\");\n        assert_eq!(s0.score, 1);\n    }\n}\n",
    "path": "tasks/best-shuffle",
    "remote_code": null,
    "title": "Best shuffle",
    "url": "http://rosettacode.org/wiki/Best_shuffle"
  },
  {
    "local_code": "trait BinaryString {\n    fn to_binary_string(&self) -> String;\n}\n\nimpl BinaryString for usize {\n    fn to_binary_string(&self) -> String {\n        format!(\"{:b}\", *self)\n    }\n}\n\nfn main() {\n    for s in 0..17 {\n        println!(\"{}\", s.to_binary_string());\n    }\n}\n\n#[test]\nfn test_digits() {\n    let expected = [\n        \"0\", \"1\", \"10\", \"11\", \"100\", \"101\", \"110\", \"111\", \"1000\", \"1001\", \"1010\", \"1011\", \"1100\",\n        \"1101\", \"1110\", \"1111\",\n    ];\n\n    for (n, expected) in (0..17).zip(expected.iter()) {\n        assert_eq!(n.to_binary_string(), *expected);\n    }\n}\n",
    "path": "tasks/binary-digits",
    "remote_code": "fn main() {\n    for i in 0..8 {\n        println!(\"{:b}\", i)\n    }\n}",
    "title": "Binary digits",
    "url": "http://rosettacode.org/wiki/Binary_digits"
  },
  {
    "local_code": "fn main() {\n    println!(\"{:?}\", binary_search(&[1, 2, 3, 4, 5, 6], &4));\n    println!(\"{:?}\", binary_search_rec(&[1, 2, 3, 4, 5, 6], &4));\n}\n\n/// iterative version\nfn binary_search<T: Ord>(haystack: &[T], needle: &T) -> Option<usize> {\n    let mut low = 0;\n    let mut high = haystack.len() - 1;\n\n    if high == 0 {\n        return None;\n    }\n\n    while low <= high {\n        // avoid overflow\n        let mid = (low + high) >> 1;\n\n        if haystack[mid] > *needle {\n            high = mid - 1\n        } else if haystack[mid] < *needle {\n            low = mid + 1\n        } else {\n            return Some(mid);\n        }\n    }\n    None\n}\n\n/// recursive version\nfn binary_search_rec<T: Ord>(haystack: &[T], needle: &T) -> Option<usize> {\n    fn recurse<T: Ord>(low: usize, high: usize, haystack: &[T], needle: &T) -> Option<usize> {\n        match (low + high) / 2 {\n            _ if high < low => None,\n            mid if haystack[mid] > *needle => recurse(low, mid - 1, haystack, needle),\n            mid if haystack[mid] < *needle => recurse(mid + 1, high, haystack, needle),\n            mid => Some(mid),\n        }\n    }\n    recurse::<T>(0, haystack.len() - 1, haystack, needle)\n}\n\n#[test]\nfn test_result() {\n    let haystack = &[1, 2, 3, 4, 5, 6];\n    let needle = 4;\n\n    assert_eq!(binary_search(haystack, &needle), Some(3));\n    assert_eq!(binary_search_rec(haystack, &needle), Some(3));\n}\n",
    "path": "tasks/binary-search",
    "remote_code": "let arr = [\"a\", \"bc\", \"def\", \"ghij\"];\narr.binary_search(&\"a\"); // Search lexicographically\narr.binary_search_by(|e| e.len().cmp(&1)); // Search by length",
    "title": "Binary search",
    "url": "http://rosettacode.org/wiki/Binary_search"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::str;\n\nfn main() {\n    // Create new string\n    let string = String::from(\"Hello world!\");\n    println!(\"{}\", string);\n    assert_eq!(string, \"Hello world!\", \"Incorrect string text\");\n\n    // Create and assign value to string\n    let mut assigned_str = String::new();\n    assert_eq!(assigned_str, \"\", \"Incorrect string creation\");\n    assigned_str += \"Text has been assigned!\";\n    println!(\"{}\", assigned_str);\n    assert_eq!(assigned_str, \"Text has been assigned!\",\"Incorrect string text\");\n\n    // String comparison, compared lexicographically byte-wise same as the asserts above\n    if string == \"Hello world!\" && assigned_str == \"Text has been assigned!\" {\n        println!(\"Strings are equal\");\n    }\n\n    // Cloning -> string can still be used after cloning\n    let clone_str = string.clone();\n    println!(\"String is:{}  and  Clone string is: {}\", string, clone_str);\n    assert_eq!(clone_str, string, \"Incorrect string creation\");\n\n    // Copying, string won't be usable anymore, accessing it will cause compiler failure\n    let copy_str = string;\n    println!(\"String copied now: {}\", copy_str);\n\n    // Check if string is empty\n    let empty_str = String::new();\n    assert!(empty_str.is_empty(), \"Error, string should be empty\");\n\n    // Append byte, Rust strings are a stream of UTF-8 bytes\n    let byte_vec = [65]; // contains A\n    let byte_str = str::from_utf8(&byte_vec).unwrap();\n    assert_eq!(byte_str, \"A\", \"Incorrect byte append\");\n\n    // Substrings can be accessed through slices\n    let test_str = \"Blah String\";\n    let mut sub_str = &test_str[0..11];\n    assert_eq!(sub_str, \"Blah String\", \"Error in slicing\");\n    sub_str = &test_str[1..5];\n    assert_eq!(sub_str, \"lah \", \"Error in slicing\");\n    sub_str = &test_str[3..];\n    assert_eq!(sub_str, \"h String\", \"Error in slicing\");\n    sub_str = &test_str[..2];\n    assert_eq!(sub_str, \"Bl\", \"Error in slicing\");\n\n    // String replace, note string is immutable\n    let org_str = \"Hello\";\n    assert_eq!(org_str.replace(\"l\", \"a\"), \"Heaao\", \"Error in replacement\");\n    assert_eq!(org_str.replace(\"ll\", \"r\"), \"Hero\", \"Error in replacement\");\n\n    // Joining strings requires a `String` and an &str or a two `String`s one of which needs an & for coercion\n    let str1 = \"Hi\";\n    let str2 = \" There\";\n    let fin_str = str1.to_string() + str2;\n    assert_eq!(fin_str, \"Hi There\", \"Error in concatenation\");\n\n    // Joining strings requires a `String` and an &str or two `Strings`s, one of which needs an & for coercion\n    let str1 = \"Hi\";\n    let str2 = \" There\";\n    let fin_str = str1.to_string() + str2;\n    assert_eq!(fin_str, \"Hi There\", \"Error in concatenation\");\n\n    // Splits -- note Rust supports passing patterns to splits\n    let f_str = \"Pooja and Sundar are up in Tumkur\";\n    let split_str: Vec<_> = f_str.split(' ').collect();\n    assert_eq!(split_str, [\"Pooja\", \"and\", \"Sundar\", \"are\", \"up\", \"in\", \"Tumkur\"], \"Error in string split\");\n}",
    "title": "Binary strings",
    "url": "http://rosettacode.org/wiki/Binary_strings"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bioinformatics/Sequence mutation",
    "url": "http://rosettacode.org/wiki/Bioinformatics/Sequence_mutation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bioinformatics/base count",
    "url": "http://rosettacode.org/wiki/Bioinformatics/base_count"
  },
  {
    "local_code": "extern crate ring;\n\nuse ring::digest::{digest, SHA256};\n\n/// Decodes a base58-encoded string into an array of bytes.\nfn decode_base58(address: &str) -> Result<Vec<u8>, &'static str> {\n    const ALPHABET: &str = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n    const BASE: usize = 58;\n\n    let mut result = vec![0; 25];\n\n    for c in address.chars() {\n        let mut value = match ALPHABET.find(c) {\n            Some(index) => index,\n            None => return Err(\"invalid character\"),\n        };\n\n        for byte in &mut result {\n            value += BASE * (*byte as usize);\n            *byte = (value % 256) as u8;\n            value /= 256;\n        }\n\n        if value > 0 {\n            return Err(\"address too long\");\n        }\n    }\n\n    Ok(result.iter().rev().map(|&byte| byte as u8).collect())\n}\n\n/// Hashed the input with the SHA-256 algorithm twice, and returns the output.\nfn double_sha256(bytes: &[u8]) -> Vec<u8> {\n    let digest_1 = digest(&SHA256, bytes);\n\n    let digest_2 = digest(&SHA256, digest_1.as_ref());\n    digest_2.as_ref().to_vec()\n}\n\n/// Validates a bitcoin address.\n///\n/// Returns `Ok` if the address validates.\n/// Returns `Err` with the reason if the address is invalid.\nfn validate(address: &str) -> Result<(), &'static str> {\n    let bytes = decode_base58(address)?;\n\n    // A bitcoin address encodes 25 bytes:\n    if bytes.len() != 25 {\n        return Err(\"invalid length\");\n    }\n\n    // The first byte is the version number, which will be zero for this task\n    if bytes[0] != 0 {\n        return Err(\"unknown version encountered\");\n    }\n\n    // The next twenty bytes are a RIPEMD-160 digest, but you don't have to know that for this\n    // task: you can consider them a pure arbitrary data\n    let _ = &bytes[1..21];\n\n    // The last four bytes are a checksum check. They are the first four bytes of a double SHA-256\n    // digest of the previous 21 bytes.\n    let checksum = &bytes[21..];\n    let result = double_sha256(&bytes[..21]);\n    if &result[..4] != checksum {\n        return Err(\"checksum did not validate\");\n    }\n\n    Ok(())\n}\n\nfn main() {\n    use std::env;\n\n    let result = match env::args().nth(2) {\n        Some(address) => validate(&address),\n        None => Err(\"no address supplied\"),\n    };\n\n    match result {\n        Ok(()) => println!(\"address is valid.\"),\n        Err(reason) => println!(\"address is invalid: {}\", reason),\n    }\n}\n\n#[test]\nfn test_valid() {\n    assert!(validate(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62i\").is_ok());\n}\n\n#[test]\nfn test_invalid() {\n    assert!(\n        validate(\"1AGNa15ZQXAZUgFiqJ2i7Z2DPU2J6hW62j\").unwrap_err() == \"checksum did not validate\"\n    )\n}\n",
    "path": "tasks/bitcoin/address-validation",
    "remote_code": null,
    "title": "Bitcoin/address validation",
    "url": "http://rosettacode.org/wiki/Bitcoin/address_validation"
  },
  {
    "local_code": "use ring::digest::{digest, SHA256};\nuse ripemd160::{Digest, Ripemd160};\n\nuse hex::FromHex;\n\nstatic X: &'static str = \"50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352\";\nstatic Y: &'static str = \"2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6\";\nstatic ALPHABET: [char; 58] = [\n    '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K',\n    'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e',\n    'f', 'g', 'h', 'i', 'j', 'k', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y',\n    'z',\n];\n\nfn base58_encode(bytes: &mut [u8]) -> String {\n    let base = ALPHABET.len();\n    if bytes.is_empty() {\n        return String::from(\"\");\n    }\n    let mut output: Vec<u8> = Vec::new();\n    let mut num: usize;\n    for _ in 0..33 {\n        num = 0;\n        for byte in bytes.iter_mut() {\n            num = num * 256 + *byte as usize;\n            *byte = (num / base) as u8;\n            num %= base;\n        }\n        output.push(num as u8);\n    }\n    let mut string = String::new();\n    for b in output.iter().rev() {\n        string.push(ALPHABET[*b as usize]);\n    }\n    string\n}\n\n// stolen from address-validation/src/main.rs\n/// Hashes the input with the SHA-256 algorithm twice, and returns the output.\nfn double_sha256(bytes: &[u8]) -> Vec<u8> {\n    let digest_1 = digest(&SHA256, bytes);\n\n    let digest_2 = digest(&SHA256, digest_1.as_ref());\n    digest_2.as_ref().to_vec()\n}\n\nfn point_to_address(x: &str, y: &str) -> String {\n    let mut addrv: Vec<u8> = Vec::with_capacity(65);\n    addrv.push(4u8);\n    addrv.append(&mut <Vec<u8>>::from_hex(x).unwrap());\n    addrv.append(&mut <Vec<u8>>::from_hex(y).unwrap());\n    // hash the addresses first using SHA256\n    let sha_digest = digest(&SHA256, &addrv);\n    let mut ripemd_digest = Ripemd160::digest(&sha_digest.as_ref()).as_slice().to_vec();\n    // prepend a 0 to the vector\n    ripemd_digest.insert(0, 0);\n    // calculate checksum of extended ripemd digest\n    let checksum = double_sha256(&ripemd_digest);\n    ripemd_digest.extend_from_slice(&checksum[..4]);\n    base58_encode(&mut ripemd_digest)\n}\n\nfn main() {\n    println!(\"{}\", point_to_address(X, Y));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{point_to_address, X, Y};\n\n    #[test]\n    fn bitcoin_address() {\n        assert_eq!(point_to_address(X, Y), \"16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM\");\n    }\n}\n",
    "path": "tasks/bitcoin/public-point-to-address",
    "remote_code": null,
    "title": "Bitcoin/public point to address",
    "url": "http://rosettacode.org/wiki/Bitcoin/public_point_to_address"
  },
  {
    "local_code": "extern crate bitmap;\n\nuse bitmap::{Color, Image};\nuse std::fs::File;\nuse std::io;\nuse std::io::prelude::*;\n\ntrait PPMWritable {\n    fn write_ppm(&self, filename: &str) -> Result<(), io::Error>;\n}\n\nimpl PPMWritable for Image {\n    fn write_ppm(&self, filename: &str) -> Result<(), io::Error> {\n        let mut writer = File::create(filename)?;\n        // let mut writer = BufWriter::new(file);\n        writeln!(&mut writer, \"P6\")?;\n        writeln!(&mut writer, \"{} {} 255\", self.width, self.height)?;\n        for color in &(self.data) {\n            for &channel in &[color.red, color.green, color.blue] {\n                let ch = channel as u8;\n                writer.write_all(&[ch])?;\n            }\n        }\n        Ok(())\n    }\n}\n\npub fn main() {\n    // write a PPM image, the left side of which is red, and the right side\n    // of which is blue\n    let mut image = Image::new(64, 64);\n    image.fill(Color {\n        red: 255,\n        green: 0,\n        blue: 0,\n    });\n    for y in 0..64 {\n        for x in 32..64 {\n            image[(x, y)] = Color {\n                red: 0,\n                green: 0,\n                blue: 255,\n            };\n        }\n    }\n    image.write_ppm(\"./test_image.ppm\").unwrap();\n}\n\n#[cfg(test)]\nmod tests {\n    extern crate rand;\n\n    use super::*;\n    use io::BufReader;\n    use std::env;\n\n    #[test]\n    fn write_ppm() {\n        let mut image = Image::new(2, 1);\n        image[(0, 0)] = Color {\n            red: 1,\n            green: 2,\n            blue: 3,\n        };\n        image[(1, 0)] = Color {\n            red: 4,\n            green: 5,\n            blue: 6,\n        };\n        let fname = format!(\n            \"{}/test-{}.ppm\",\n            env::temp_dir().to_str().unwrap(),\n            self::rand::random::<i32>(),\n        );\n        // Can't use try! macro because we want to panic, not return.\n        image.write_ppm(&fname).unwrap_or_else(|e| panic!(e));\n\n        let file = File::open(&fname).unwrap();\n        let mut reader = BufReader::new(file);\n        let mut line = String::new();\n        reader.read_line(&mut line).unwrap();\n        assert_eq!(line, \"P6\\n\");\n        line = String::new();\n        reader.read_line(&mut line).unwrap();\n        assert_eq!(line, \"2 1 255\\n\");\n        let mut bytes = reader.bytes();\n        assert_eq!(bytes.next().unwrap().unwrap(), 49);\n        assert_eq!(bytes.next().unwrap().unwrap(), 50);\n        assert_eq!(bytes.next().unwrap().unwrap(), 51);\n        assert_eq!(bytes.next().unwrap().unwrap(), 52);\n        assert_eq!(bytes.next().unwrap().unwrap(), 53);\n        assert_eq!(bytes.next().unwrap().unwrap(), 54);\n        assert!(bytes.next().is_none());\n    }\n}\nuse std::default::Default;\nuse std::fs::File;\nuse std::io::{BufWriter, Error, Write};\nuse std::ops::{Index, IndexMut};\n\n#[derive(Copy, Clone, Default, PartialEq, Debug)]\npub struct Color {\n    pub red: u8,\n    pub green: u8,\n    pub blue: u8,\n}\n\npub struct Image {\n    pub width: usize,\n    pub height: usize,\n    pub data: Vec<Color>,\n}\n\nimpl Image {\n    pub fn new(width: usize, height: usize) -> Self {\n        Self {\n            width,\n            height,\n            data: vec![Color::default(); width * height],\n        }\n    }\n\n    pub fn fill(&mut self, color: Color) {\n        for elem in &mut self.data {\n            *elem = color;\n        }\n    }\n\n    pub fn write_ppm(&self, filename: &str) -> Result<(), Error> {\n        let file = File::create(filename)?;\n        let mut writer = BufWriter::new(file);\n        writeln!(&mut writer, \"P6\")?;\n        writeln!(&mut writer, \"{} {} 255\", self.width, self.height)?;\n        for color in &self.data {\n            for &channel in &[color.red, color.green, color.blue] {\n                write!(&mut writer, \"{}\", channel as u8)?;\n            }\n        }\n        Ok(())\n    }\n}\n\nimpl Index<(usize, usize)> for Image {\n    type Output = Color;\n\n    fn index(&self, (x, y): (usize, usize)) -> &Color {\n        &self.data[x + y * self.width]\n    }\n}\n\nimpl IndexMut<(usize, usize)> for Image {\n    fn index_mut(&mut self, (x, y): (usize, usize)) -> &mut Color {\n        &mut self.data[x + y * self.width]\n    }\n}\n\n#[allow(dead_code)]\npub fn main() {\n    let mut image = Image::new(10, 10);\n\n    for y in 0..10 {\n        for x in 5..10 {\n            image[(x, y)] = Color {\n                red: 255,\n                green: 255,\n                blue: 255,\n            };\n        }\n    }\n\n    for y in 0..10 {\n        for x in 0..10 {\n            let color = image[(x, y)];\n            let ch = if color.red + color.green + color.blue == 0 {\n                '#'\n            } else {\n                '.'\n            };\n            print!(\"{}\", ch);\n        }\n        println!();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn out_of_bounds() {\n        let image = Image::new(10, 10);\n        image[(10, 11)];\n    }\n\n    #[test]\n    fn getting() {\n        let image = Image::new(3, 4);\n        for x in 0..3 {\n            for y in 0..4 {\n                assert_eq!(image[(x, y)], Default::default());\n            }\n        }\n    }\n\n    #[test]\n    fn setting() {\n        let mut image = Image::new(3, 3);\n        image[(0, 0)] = Color {\n            red: 1,\n            green: 1,\n            blue: 1,\n        };\n        assert_eq!(\n            image[(0, 0)],\n            Color {\n                red: 1,\n                green: 1,\n                blue: 1,\n            }\n        );\n    }\n\n    #[test]\n    fn filling() {\n        let mut image = Image::new(4, 3);\n        let fill = Color {\n            red: 3,\n            green: 2,\n            blue: 5,\n        };\n        image.fill(fill);\n        for x in 0..4 {\n            for y in 0..3 {\n                assert_eq!(image[(x, y)], fill);\n            }\n        }\n    }\n}\nextern crate bitmap;\n\nuse bitmap::{Color, Image};\n\nfn main() {\n    let mut image = Image::new(10, 10);\n\n    for y in 0..10 {\n        for x in 5..10 {\n            image[(x, y)] = Color {\n                red: 255,\n                green: 255,\n                blue: 255,\n            };\n        }\n    }\n\n    for y in 0..10 {\n        for x in 0..10 {\n            let color = image[(x, y)];\n            let ch = if color.red.wrapping_add(color.green).wrapping_add(color.blue) == 0 {\n                '#'\n            } else {\n                '.'\n            };\n            print!(\"{}\", ch);\n        }\n        println!();\n    }\n}\n",
    "path": "tasks/bitmap",
    "remote_code": null,
    "title": "Bitmap",
    "url": "http://rosettacode.org/wiki/Bitmap"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bitmap/Bresenham's line algorithm",
    "url": "http://rosettacode.org/wiki/Bitmap/Bresenham's_line_algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bitmap/Bézier curves/Cubic",
    "url": "http://rosettacode.org/wiki/Bitmap/B%C3%A9zier_curves/Cubic"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bitmap/Bézier curves/Quadratic",
    "url": "http://rosettacode.org/wiki/Bitmap/B%C3%A9zier_curves/Quadratic"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n/* Naive Rust implementation of RosettaCode's Bitmap/Flood fill excercise.\n *\n * For the sake of simplicity this code reads PPM files (format specification can be found here: http://netpbm.sourceforge.net/doc/ppm.html ).\n * The program assumes that the image has been created by GIMP in PPM ASCII mode and panics at any error.\n *\n * Also this program expects the input file to be in the same directory as the executable and named\n * \"input.ppm\" and outputs a file in the same directory under the name \"output.ppm\".\n *\n */\n\nuse std::fs::File; // Used for creating/opening files.\nuse std::io::{BufReader, BufRead, Write}; // Used for reading/writing files.\n\nfn read_image(filename: String) -> Vec<Vec<(u8,u8,u8)>> {\n    let file = File::open(filename).unwrap();\n    let reader = BufReader::new(file);\n    let mut lines = reader.lines();\n\n    let _ = lines.next().unwrap(); // Skip P3 signature.\n    let _ = lines.next().unwrap(); // Skip GIMP comment.\n\n    let dimensions: (usize, usize) = {\n        let line = lines.next().unwrap().unwrap();\n        let values = line.split_whitespace().collect::<Vec<&str>>();\n\n        // We turn the &str vector that holds the width & height of the image into an usize tuplet.\n        (values[0].parse::<usize>().unwrap(),values[1].parse::<usize>().unwrap())\n    };\n\n    let _ = lines.next().unwrap(); // Skip maximum color value (we assume 255).\n\n    let mut image_data = Vec::with_capacity(dimensions.1);\n\n    for y in 0..dimensions.1 {\n        image_data.push(Vec::new());\n        for _ in 0..dimensions.0 {\n            // We read the R, G and B components and put them in the image_data vector.\n            image_data[y].push((lines.next().unwrap().unwrap().parse::<u8>().unwrap(),\n                                lines.next().unwrap().unwrap().parse::<u8>().unwrap(),\n                                lines.next().unwrap().unwrap().parse::<u8>().unwrap()));\n        }\n    }\n\n    image_data\n}\n\nfn write_image(image_data: Vec<Vec<(u8,u8,u8)>>) {\n    let mut file = File::create(format!(\"./output.ppm\")).unwrap();\n\n    // Signature, then width and height, then 255 as max color value.\n    write!(file, \"P3\\n{} {}\\n255\\n\", image_data.len(), image_data[0].len()).unwrap();\n\n    for row in &image_data {\n        // For performance reasons, we reserve a String with the necessary length for a line and\n        // fill that up before writing it to the file.\n\n        let mut line = String::with_capacity(row.len()*6); // 6 = r(space)g(space)b(space)\n        for (r,g,b) in row {\n\n            // &* is used to turn a String into a &str as needed by push_str.\n            line.push_str(&*format!(\"{} {} {} \", r,g,b));\n        }\n\n        write!(file, \"{}\", line).unwrap();\n    }\n\n}\n\nfn flood_fill(x: usize, y: usize, target: &(u8,u8,u8), replacement: &(u8,u8,u8), image_data: &mut Vec<Vec<(u8,u8,u8)>>) {\n    if &image_data[y][x] == target {\n        image_data[y][x] = *replacement;\n\n        if y > 0 {flood_fill(x,y-1, &target, &replacement, image_data);}\n        if x > 0 {flood_fill(x-1,y, &target, &replacement, image_data);}\n        if y < image_data.len()-1 {flood_fill(x,y+1, &target, &replacement, image_data);}\n        if x < image_data[0].len()-1 {flood_fill(x+1,y, &target, &replacement, image_data);}\n    }\n}\n\nfn main() {\n    let mut data = read_image(String::from(\"./input.ppm\"));\n\n    flood_fill(1,50, &(255,255,255), &(0,255,0), &mut data); // Fill the big white circle with green.\n    flood_fill(40,35, &(0,0,0), &(255,0,0), &mut data); // Fill the small black circle with red.\n\n    write_image(data);\n\n}",
    "title": "Bitmap/Flood fill",
    "url": "http://rosettacode.org/wiki/Bitmap/Flood_fill"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bitmap/Histogram",
    "url": "http://rosettacode.org/wiki/Bitmap/Histogram"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bitmap/Midpoint circle algorithm",
    "url": "http://rosettacode.org/wiki/Bitmap/Midpoint_circle_algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bitmap/PPM conversion through a pipe",
    "url": "http://rosettacode.org/wiki/Bitmap/PPM_conversion_through_a_pipe"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bitmap/Read a PPM file",
    "url": "http://rosettacode.org/wiki/Bitmap/Read_a_PPM_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bitmap/Read an image through a pipe",
    "url": "http://rosettacode.org/wiki/Bitmap/Read_an_image_through_a_pipe"
  },
  {
    "local_code": "extern crate bitmap;\n\nuse bitmap::{Color, Image};\nuse std::fs::File;\nuse std::io;\nuse std::io::prelude::*;\n\ntrait PPMWritable {\n    fn write_ppm(&self, filename: &str) -> Result<(), io::Error>;\n}\n\nimpl PPMWritable for Image {\n    fn write_ppm(&self, filename: &str) -> Result<(), io::Error> {\n        let mut writer = File::create(filename)?;\n        // let mut writer = BufWriter::new(file);\n        writeln!(&mut writer, \"P6\")?;\n        writeln!(&mut writer, \"{} {} 255\", self.width, self.height)?;\n        for color in &(self.data) {\n            for &channel in &[color.red, color.green, color.blue] {\n                let ch = channel as u8;\n                writer.write_all(&[ch])?;\n            }\n        }\n        Ok(())\n    }\n}\n\npub fn main() {\n    // write a PPM image, the left side of which is red, and the right side\n    // of which is blue\n    let mut image = Image::new(64, 64);\n    image.fill(Color {\n        red: 255,\n        green: 0,\n        blue: 0,\n    });\n    for y in 0..64 {\n        for x in 32..64 {\n            image[(x, y)] = Color {\n                red: 0,\n                green: 0,\n                blue: 255,\n            };\n        }\n    }\n    image.write_ppm(\"./test_image.ppm\").unwrap();\n}\n\n#[cfg(test)]\nmod tests {\n    extern crate rand;\n\n    use super::*;\n    use io::BufReader;\n    use std::env;\n\n    #[test]\n    fn write_ppm() {\n        let mut image = Image::new(2, 1);\n        image[(0, 0)] = Color {\n            red: 1,\n            green: 2,\n            blue: 3,\n        };\n        image[(1, 0)] = Color {\n            red: 4,\n            green: 5,\n            blue: 6,\n        };\n        let fname = format!(\n            \"{}/test-{}.ppm\",\n            env::temp_dir().to_str().unwrap(),\n            self::rand::random::<i32>(),\n        );\n        // Can't use try! macro because we want to panic, not return.\n        image.write_ppm(&fname).unwrap_or_else(|e| panic!(e));\n\n        let file = File::open(&fname).unwrap();\n        let mut reader = BufReader::new(file);\n        let mut line = String::new();\n        reader.read_line(&mut line).unwrap();\n        assert_eq!(line, \"P6\\n\");\n        line = String::new();\n        reader.read_line(&mut line).unwrap();\n        assert_eq!(line, \"2 1 255\\n\");\n        let mut bytes = reader.bytes();\n        assert_eq!(bytes.next().unwrap().unwrap(), 49);\n        assert_eq!(bytes.next().unwrap().unwrap(), 50);\n        assert_eq!(bytes.next().unwrap().unwrap(), 51);\n        assert_eq!(bytes.next().unwrap().unwrap(), 52);\n        assert_eq!(bytes.next().unwrap().unwrap(), 53);\n        assert_eq!(bytes.next().unwrap().unwrap(), 54);\n        assert!(bytes.next().is_none());\n    }\n}\n",
    "path": "tasks/bitmap/write-a-ppm-file",
    "remote_code": "use std::path::Path;\nuse std::io::Write;\nuse std::fs::File;\n\npub struct RGB {\n    r: u8,\n    g: u8,\n    b: u8,\n}\n\npub struct PPM {\n    height: u32,\n    width: u32,\n    data: Vec<u8>,\n}\n\nimpl PPM {\n    pub fn new(height: u32, width: u32) -> PPM {\n        let size = 3 * height * width;\n        let buffer = vec![0; size as usize];\n        PPM { height: height, width: width, data: buffer }\n    }\n\n    fn buffer_size(&self) -> u32 {\n        3 * self.height * self.width\n    }\n\n    fn get_offset(&self, x: u32, y: u32) -> Option<usize> {\n        let offset = (y * self.width * 3) + (x * 3);\n        if offset < self.buffer_size() {\n            Some(offset as usize)\n        } else {\n            None\n        }\n    }\n\n    pub fn get_pixel(&self, x: u32, y: u32) -> Option<RGB> {\n        match self.get_offset(x, y) {\n            Some(offset) => {\n                let r = self.data[offset];\n                let g = self.data[offset + 1];\n                let b = self.data[offset + 2];\n                Some(RGB {r: r, g: g, b: b})\n            },\n            None => None\n        }\n    }\n\n    pub fn set_pixel(&mut self, x: u32, y: u32, color: RGB) -> bool {\n        match self.get_offset(x, y) {\n            Some(offset) => {\n                self.data[offset] = color.r;\n                self.data[offset + 1] = color.g;\n                self.data[offset + 2] = color.b;\n                true\n            },\n            None => false\n        }\n    }\n\n    pub fn write_file(&self, filename: &str) -> std::io::Result<()> {\n        let path = Path::new(filename);\n        let mut file = try!(File::create(&path));\n        let header = format!(\"P6 {} {} 255\\n\", self.width, self.height);\n        try!(file.write(header.as_bytes()));\n        try!(file.write(&self.data));\n        Ok(())\n    }\n}",
    "title": "Bitmap/Write a PPM file",
    "url": "http://rosettacode.org/wiki/Bitmap/Write_a_PPM_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bitwise IO",
    "url": "http://rosettacode.org/wiki/Bitwise_IO"
  },
  {
    "local_code": "fn main() {\n    let a: u8 = 105;\n    let b: u8 = 91;\n    println!(\"a      = {:0>8}\", a);\n    println!(\"b      = {:0>8}\", b);\n    println!(\"a | b  = {:0>8}\", a | b);\n    println!(\"a & b  = {:0>8}\", a & b);\n    println!(\"a ^ b  = {:0>8}\", a ^ b);\n    println!(\"!a     = {:0>8}\", !a);\n    println!(\"a << 3 = {:0>8}\", a >> 3);\n    println!(\"a >> 3 = {:0>8}\", a << 3);\n}\n",
    "path": "tasks/bitwise-operations",
    "remote_code": "fn main() {\n    let a: u8 = 105;\n    let b: u8 = 91;\n    println!(\"a      = {:0>8b}\", a);\n    println!(\"b      = {:0>8b}\", b);\n    println!(\"a | b  = {:0>8b}\", a | b);\n    println!(\"a & b  = {:0>8b}\", a & b);\n    println!(\"a ^ b  = {:0>8b}\", a ^ b);\n    println!(\"!a     = {:0>8b}\", !a);\n    println!(\"a << 3 = {:0>8b}\", a << 3);\n    println!(\"a >> 3 = {:0>8b}\", a >> 3);\n}",
    "title": "Bitwise operations",
    "url": "http://rosettacode.org/wiki/Bitwise_operations"
  },
  {
    "local_code": "fn main() {\n    // Rust contains a single boolean type: `bool`, represented by the keywords `true` and `false`.\n    // Expressions inside `if` and `while` statements must result in type `bool`. There is no\n    // automatic conversion to the boolean type.\n\n    let true_value = true;\n    if true_value {\n        println!(\"foo is {}.\", true_value);\n    }\n\n    let false_value = false;\n    if !false_value {\n        println!(\"bar is {}.\", false_value);\n    }\n}\n",
    "path": "tasks/boolean-values",
    "remote_code": null,
    "title": "Boolean values",
    "url": "http://rosettacode.org/wiki/Boolean_values"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Box the compass",
    "url": "http://rosettacode.org/wiki/Box_the_compass"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "const OPEN_CHAR: char = '{';\nconst CLOSE_CHAR: char = '}';\nconst SEPARATOR: char = ',';\nconst ESCAPE: char = '\\\\';\n\n#[derive(Debug, PartialEq, Clone)]\nenum Token {\n    Open,\n    Close,\n    Separator,\n    Payload(String),\n    Branches(Branches),\n}\n\nimpl From<char> for Token {\n    fn from(ch: char) -> Token {\n        match ch {\n            OPEN_CHAR => Token::Open,\n            CLOSE_CHAR => Token::Close,\n            SEPARATOR => Token::Separator,\n            _ => panic!(\"Non tokenizable char!\"),\n        }\n    }\n}\n\n#[derive(Debug, PartialEq, Clone)]\nstruct Branches {\n    tokens: Vec<Vec<Token>>,\n}\n\nimpl Branches {\n    fn new() -> Branches {\n        Branches{\n            tokens: Vec::new(),\n        }\n    }\n\n    fn add_branch(&mut self, branch: Vec<Token>) {\n        self.tokens.push(branch);\n    }\n\n    fn from(tokens: &Vec<Token>) -> Branches {\n        let mut branches = Branches::new();\n        let mut tail = tokens.clone();\n        while let Some(pos) = tail.iter().position(|token| { *token == Token::Separator }) {\n            let mut rest = tail.split_off(pos);\n            branches.add_branch(tail);\n            rest.remove(0);\n            tail = rest;\n        }\n        branches.add_branch(tail);\n        branches\n    }\n}\n\nimpl From<Branches> for Token {\n    fn from(branches: Branches) -> Token {\n        Token::Branches(branches)\n    }\n}\n\nimpl From<Vec<Token>> for Branches {\n    fn from(tokens: Vec<Token>) -> Branches {\n        Branches::from(&tokens)\n    }\n}\n\nimpl From<Token> for String {\n    fn from(token: Token) -> String {\n        match token {\n            Token::Branches(_) => panic!(\"Cannot convert to String!\"),\n            Token::Payload(text) => text,\n            Token::Open => OPEN_CHAR.to_string(),\n            Token::Close => CLOSE_CHAR.to_string(),\n            Token::Separator => SEPARATOR.to_string(),\n        }\n    }\n}\n\nimpl From<Branches> for Vec<String> {\n    fn from(branches: Branches) -> Vec<String> {\n        let Branches{ tokens: token_lines } = branches;\n        let mut vec: Vec<String> = Vec::new();\n        let braces = { if token_lines.len() == 1 { true } else { false } };\n        for tokens in token_lines {\n            let mut vec_string = output(tokens);\n            vec.append(&mut vec_string);\n        }\n        if braces {\n            vec.iter()\n                .map(|line| {\n                    format!(\"{}{}{}\", OPEN_CHAR, line, CLOSE_CHAR)\n                }).\n                collect::<Vec<String>>()\n        } else {\n            vec\n        }\n    }\n}\n\nimpl From<Token> for Vec<String> {\n    fn from(token: Token) -> Vec<String> {\n        match token {\n            Token::Branches(branches) => {\n                branches.into()\n            },\n            _ => {\n                let frag: String = token.into();\n                vec![frag]\n            },\n        }\n    }\n}\n\nfn tokenize(string: &str) -> Vec<Token> {\n    let mut tokens: Vec<Token> = Vec::new();\n    let mut chars = string.chars();\n    let mut payload = String::new();\n    while let Some(ch) = chars.next() {\n        match ch {\n            OPEN_CHAR | SEPARATOR | CLOSE_CHAR => {\n                if payload.len() > 0 {\n                    tokens.push(Token::Payload(payload));\n                }\n                payload = String::new();\n                if ch == CLOSE_CHAR {\n                    let pos = tokens.iter().rposition(|token| *token == Token::Open);\n                    if let Some(pos) = pos {\n                        let branches: Branches = {\n                            let mut to_branches = tokens.split_off(pos);\n                            to_branches.remove(0);\n                            to_branches\n                        }.into();\n                        tokens.push(branches.into());\n                    } else {\n                        tokens.push(ch.into());\n                    }\n                } else {\n                    tokens.push(ch.into());\n                }\n            },\n            ESCAPE => {\n                payload.push(ch);\n                if let Some(next_char) = chars.next() {\n                    payload.push(next_char);\n                }\n            },\n            _ => payload.push(ch),\n        }\n    }\n    let payload = payload.trim_end();\n    if payload.len() > 0 {\n        tokens.push(Token::Payload(payload.into()));\n    }\n    tokens\n}\n\nfn output(tokens: Vec<Token>) -> Vec<String> {\n    let mut output: Vec<String> = vec![String::new()];\n    for token in tokens {\n        let mut aux: Vec<String> = Vec::new();\n        let strings: Vec<String> = token.into();\n        for root in &output {\n            for string in &strings {\n                aux.push({format!(\"{}{}\", root, string)});\n            }\n        }\n        output = aux;\n    }\n    output\n}\n\nfn main() {\n    let mut input: String = String::new();\n    std::io::stdin().read_line(&mut input).unwrap();\n\n    let tokens: Vec<Token> = tokenize(&input);\n    // println!(\"Tokens:\\n{:#?}\", tokens);\n\n    let output = output(tokens);\n    for line in &output {\n        println!(\"{}\", line);\n    }\n}",
    "title": "Brace expansion",
    "url": "http://rosettacode.org/wiki/Brace_expansion"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Brazilian numbers",
    "url": "http://rosettacode.org/wiki/Brazilian_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Break OO privacy",
    "url": "http://rosettacode.org/wiki/Break_OO_privacy"
  },
  {
    "local_code": "extern crate image;\nextern crate rand;\n\nuse std::cmp::min;\nuse std::env;\nuse std::path::Path;\nuse std::process;\n\nuse image::ColorType;\nuse rand::distributions::Uniform;\nuse rand::{thread_rng, Rng};\n\nfn help() {\n    println!(\"Usage: brownian_tree <output_path> <mote_count> <edge_length>\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut output_path = Path::new(\"out.png\");\n    let mut mote_count: u32 = 10_000;\n    let mut width: usize = 512;\n    let mut height: usize = 512;\n\n    match args.len() {\n        1 => {}\n        4 => {\n            output_path = Path::new(&args[1]);\n            mote_count = args[2].parse::<u32>().unwrap();\n            width = args[3].parse::<usize>().unwrap();\n            height = width;\n        }\n        _ => {\n            help();\n            process::exit(0);\n        }\n    }\n\n    assert!(width >= 2);\n\n    // Base 1d array\n    let mut field_raw = vec![0u8; width * height];\n    populate_tree(&mut field_raw, width, height, mote_count);\n\n    // Balance image for 8-bit grayscale\n    let our_max = field_raw.iter().max().unwrap();\n    let fudge = u8::max_value() / our_max;\n    let balanced: Vec<u8> = field_raw.iter().map(|e| e * fudge).collect();\n\n    match image::save_buffer(\n        output_path,\n        &balanced,\n        width as u32,\n        height as u32,\n        ColorType::Gray(8),\n    ) {\n        Err(e) => println!(\"Error writing output image:\\n{}\", e),\n        Ok(_) => println!(\"Output written to:\\n{}\", output_path.to_str().unwrap()),\n    }\n}\n\nfn populate_tree(raw: &mut Vec<u8>, width: usize, height: usize, mc: u32) {\n    // Vector of 'width' elements slices\n    let mut field_base: Vec<_> = raw.chunks_mut(width).collect();\n    // Addressable 2d vector\n    let field = field_base.as_mut_slice();\n\n    // Seed mote\n    field[width / 2][height / 2] = 1;\n\n    let x_spawn_range = Uniform::new(1, width - 1);\n    let y_spawn_range = Uniform::new(1, height - 1);\n    let mut rng = thread_rng();\n\n    for i in 0..mc {\n        if i % 100 == 0 {\n            println!(\"{}\", i)\n        }\n\n        // Spawn mote\n        let mut x = rng.sample(x_spawn_range);\n        let mut y = rng.sample(y_spawn_range);\n\n        // Increment field value when motes spawn on top of the structure\n        if field[x][y] > 0 {\n            field[x][y] = min(field[x][y] + 1, u8::max_value()) as u8;\n            continue;\n        }\n\n        loop {\n            let contacts = field[x - 1][y - 1]\n                + field[x][y - 1]\n                + field[x + 1][y - 1]\n                + field[x - 1][y]\n                + field[x + 1][y]\n                + field[x - 1][y + 1]\n                + field[x][y + 1]\n                + field[x + 1][y + 1];\n\n            if contacts > 0 {\n                field[x][y] = min(field[x][y] + 1, u8::max_value()) as u8;\n                break;\n            } else {\n                let range = Uniform::new(-1, 2);\n                let xw = rng.sample(range) + x as i32;\n                let yw = rng.sample(range) + y as i32;\n                if xw < 1 || xw >= (width as i32 - 1) || yw < 1 || yw >= (height as i32 - 1) {\n                    // println!(\"wandered off\");\n                    break;\n                }\n                x = xw as usize;\n                y = yw as usize;\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::populate_tree;\n\n    #[test]\n    fn test_brownian_tree() {\n        let width = 128;\n        let height = 128;\n        let mote_count = 1000;\n        let mut field_raw = vec![0u8; width * height];\n        populate_tree(&mut field_raw, width, height, mote_count);\n        let our_max = field_raw.iter().max().unwrap();\n        assert!(*our_max >= 1);\n    }\n}\n",
    "path": "tasks/brownian-tree",
    "remote_code": "\nextern crate image;\nextern crate rand;\n\nuse image::ColorType;\nuse rand::distributions::{IndependentSample, Range};\nuse std::cmp::{min, max};\nuse std::env;\nuse std::path::Path;\nuse std::process;\n\nfn help() {\n    println!(\"Usage: brownian_tree <output_path> <mote_count> <edge_length>\");\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut output_path = Path::new(\"out.png\");\n    let mut mote_count: u32 = 10000;\n    let mut width: usize = 512;\n    let mut height: usize = 512;\n\n    match args.len() {\n        1 => {}\n        4 => {\n            output_path = Path::new(&args[1]);\n            mote_count = args[2].parse::<u32>().unwrap();\n            width = args[3].parse::<usize>().unwrap();\n            height = width;\n        }\n        _ => {\n            help();\n            process::exit(0);\n        }\n    }\n\n    assert!(width >= 2);\n\n    // Base 1d array\n    let mut field_raw = vec![0u8; width * height];\n    populate_tree(&mut field_raw, width, height, mote_count);\n\n    // Balance image for 8-bit grayscale\n    let our_max = field_raw.iter().fold(0u8, |champ, e| max(champ, *e));\n    let fudge = std::u8::MAX / our_max;\n    let balanced: Vec<u8> = field_raw.iter().map(|e| e * fudge).collect();\n\n    match image::save_buffer(output_path,\n                             &balanced,\n                             width as u32,\n                             height as u32,\n                             ColorType::Gray(8)) {\n        Err(e) => println!(\"Error writing output image:\\n{}\", e),\n        Ok(_) => println!(\"Output written to:\\n{}\", output_path.to_str().unwrap()),\n    }\n}\n\n\nfn populate_tree(raw: &mut Vec<u8>, width: usize, height: usize, mc: u32) {\n    // Vector of 'width' elements slices\n    let mut field_base: Vec<_> = raw.as_mut_slice().chunks_mut(width).collect();\n    // Addressable 2d vector\n    let mut field: &mut [&mut [u8]] = field_base.as_mut_slice();\n\n    // Seed mote\n    field[width / 2][height / 2] = 1;\n\n    let walk_range = Range::new(-1i32, 2i32);\n    let x_spawn_range = Range::new(1usize, width - 1);\n    let y_spawn_range = Range::new(1usize, height - 1);\n    let mut rng = rand::thread_rng();\n\n    for i in 0..mc {\n        if i % 100 == 0 {\n            println!(\"{}\", i)\n        }\n\n        // Spawn mote\n        let mut x = x_spawn_range.ind_sample(&mut rng);\n        let mut y = y_spawn_range.ind_sample(&mut rng);\n\n        // Increment field value when motes spawn on top of the structure\n        if field[x][y] > 0 {\n            field[x][y] = min(field[x][y] as u32 + 1, std::u8::MAX as u32) as u8;\n            continue;\n        }\n\n        loop {\n            let contacts = field[x - 1][y - 1] + field[x][y - 1] + field[x + 1][y - 1] +\n                           field[x - 1][y] + field[x + 1][y] +\n                           field[x - 1][y + 1] + field[x][y + 1] +\n                           field[x + 1][y + 1];\n\n            if contacts > 0 {\n                field[x][y] = 1;\n                break;\n            } else {\n                let xw = walk_range.ind_sample(&mut rng) + x as i32;\n                let yw = walk_range.ind_sample(&mut rng) + y as i32;\n                if xw < 1 || xw >= (width as i32 - 1) || yw < 1 || yw >= (height as i32 - 1) {\n                    break;\n                }\n                x = xw as usize;\n                y = yw as usize;\n            }\n        }\n    }\n}",
    "title": "Brownian tree",
    "url": "http://rosettacode.org/wiki/Brownian_tree"
  },
  {
    "local_code": "extern crate rand;\n\nuse std::fmt::{self, Display};\n\nuse rand::prelude::*;\n\nconst NUMBER_OF_DIGITS: usize = 4;\n\n/// Generates `NUMBER_OF_DIGITS` random unique digits.\nfn generate_digits(rng: &mut impl Rng) -> Vec<u32> {\n    (1..=9).choose_multiple(rng, NUMBER_OF_DIGITS)\n}\n\n/// types of errors we can have when parsing a malformed guess\nenum ParseError {\n    NotValidDigit,\n    ExpectedNumberOfDigits(usize),\n    NoDuplicates,\n}\n\n/// printable description for each `ParseError`\nimpl fmt::Display for ParseError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match *self {\n            ParseError::NotValidDigit => Display::fmt(\"only digits from 1 to 9, please\", f),\n            ParseError::ExpectedNumberOfDigits(exp) => {\n                write!(f, \"you need to guess with {} digits\", exp)\n            }\n            ParseError::NoDuplicates => Display::fmt(\"no duplicates, please\", f),\n        }\n    }\n}\n\n/// a well-formed guess string should be like \"1543\", with `NUMBER_OF_DIGITS` digits, no\n/// repetitions, no separators or other characters. Parse the guess string as a `Vec<usize>` or\n/// return a `ParseError`. This could trivially return a `[usize; NUMBER_OF_DIGITS]` instead of a\n/// `Vec<usize>` and avoid dynamic allocations. However, in the more general case,\n/// `NUMBER_OF_DIGITS` would not be a constant, but a runtime configuration (which would make using\n/// a stack-allocated array more difficult)\nfn parse_guess_string(guess: &str) -> Result<Vec<u32>, ParseError> {\n    let mut ret = Vec::with_capacity(NUMBER_OF_DIGITS);\n\n    for (i, c) in guess.char_indices() {\n        // check that our guess contains the right number of digits\n        if i >= NUMBER_OF_DIGITS {\n            return Err(ParseError::ExpectedNumberOfDigits(NUMBER_OF_DIGITS));\n        }\n        match c.to_digit(10) {\n            Some(d) if d > 0 => {\n                // the guess should not contain duplicate digits\n                if ret.contains(&d) {\n                    return Err(ParseError::NoDuplicates);\n                }\n                ret.push(d);\n            }\n            _ => return Err(ParseError::NotValidDigit),\n        }\n    }\n\n    Ok(ret)\n}\n\n/// returns a tuple with the count of Bulls and Cows in the guess\nfn calculate_score(given_digits: &[u32], guessed_digits: &[u32]) -> (usize, usize) {\n    let mut bulls = 0;\n    let mut cows = 0;\n    for (i, given_digit) in given_digits.iter().enumerate().take(NUMBER_OF_DIGITS) {\n        let pos = guessed_digits.iter().position(|a| a == given_digit);\n\n        match pos {\n            None => (),\n            Some(p) if p == i => bulls += 1,\n            Some(_) => cows += 1,\n        }\n    }\n    (bulls, cows)\n}\n\nfn main() {\n    let reader = std::io::stdin();\n    let mut rng = rand::thread_rng();\n\n    loop {\n        let given_digits = generate_digits(&mut rng);\n        println!(\n            \"I have chosen my {} digits. Please guess what they are\",\n            NUMBER_OF_DIGITS\n        );\n        loop {\n            let mut guess_string = String::new();\n            let _ = reader.read_line(&mut guess_string).unwrap();\n            let digits_maybe = parse_guess_string(guess_string.trim());\n            match digits_maybe {\n                Err(msg) => {\n                    println!(\"{}\", msg);\n                }\n                Ok(guess_digits) => match calculate_score(&given_digits, &guess_digits) {\n                    (NUMBER_OF_DIGITS, _) => {\n                        println!(\"you win!\");\n                        break;\n                    }\n                    (bulls, cows) => println!(\"bulls: {}, cows: {}\", bulls, cows),\n                },\n            }\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::ParseError;\n\n    /// test we generate `NUMBER_OF_DIGITS` unique digits between 1 and 9\n    #[test]\n    fn generate_digits() {\n        let mut rng = super::rand::thread_rng();\n        let mut digits = super::generate_digits(&mut rng);\n        assert!(digits.iter().all(|&d| d > 0));\n        digits.sort_unstable();\n        digits.dedup();\n        assert_eq!(digits.len(), super::NUMBER_OF_DIGITS)\n    }\n\n    #[test]\n    fn parse_guess_string() {\n        match super::parse_guess_string(\"1234\") {\n            Ok(p) => assert_eq!(p, vec![1, 2, 3, 4]),\n            _ => panic!(\"Failed parsing a valid string\"),\n        }\n\n        match super::parse_guess_string(\"0123\") {\n            Ok(_) => panic!(\"parsed a string containing a 0\"),\n            Err(err) => {\n                if let ParseError::NotValidDigit = err {\n                    ()\n                } else {\n                    panic!(\"Expected a NotValidDigit error\")\n                }\n            }\n        }\n\n        match super::parse_guess_string(\"1213\") {\n            Ok(_) => panic!(\"parsed a string containing a repeated digit\"),\n            Err(err) => {\n                if let ParseError::NoDuplicates = err {\n                    ()\n                } else {\n                    panic!(\"Expected a NoDuplicates error\")\n                }\n            }\n        }\n\n        match super::parse_guess_string(\"12354\") {\n            Ok(_) => panic!(\"parsed a string longer than 4 digits\"),\n            Err(err) => {\n                if let ParseError::ExpectedNumberOfDigits(4) = err {\n                    ()\n                } else {\n                    panic!(\"Expected a ExpectedNumberOfDigits error\")\n                }\n            }\n        }\n    }\n\n    #[test]\n    fn calculate_score() {\n        assert_eq!(super::calculate_score(&[1, 2, 3, 4], &[1, 2, 3, 4]), (4, 0));\n        assert_eq!(super::calculate_score(&[1, 2, 3, 4], &[1, 2, 4, 3]), (2, 2));\n        assert_eq!(super::calculate_score(&[1, 2, 3, 4], &[5, 6, 7, 8]), (0, 0));\n    }\n}\n",
    "path": "tasks/bulls-and-cows",
    "remote_code": "use std::io;\nuse rand::{Rng,thread_rng};\n\nextern crate rand;\n\nconst NUMBER_OF_DIGITS: usize = 4;\n\nstatic DIGITS: [char; 9] = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];\n\nfn generate_digits() -> Vec<char> {\n    let mut temp_digits: Vec<_> = (&DIGITS[..]).into();\n    thread_rng().shuffle(&mut temp_digits);\n    return temp_digits.iter().take(NUMBER_OF_DIGITS).map(|&a| a).collect();\n}\n\nfn parse_guess_string(guess: &str) -> Result<Vec<char>, String> {\n    let chars: Vec<char> = (&guess).chars().collect();\n\n    if !chars.iter().all(|c| DIGITS.contains(c)) {\n        return Err(\"only digits, please\".to_string());\n    }\n\n    if chars.len() != NUMBER_OF_DIGITS {\n        return Err(format!(\"you need to guess with {} digits\", NUMBER_OF_DIGITS));\n    }\n\n    let mut uniques: Vec<char> = chars.clone();\n    uniques.dedup();\n    if uniques.len() != chars.len() {\n        return Err(\"no duplicates, please\".to_string());\n    }\n\n    return Ok(chars);\n}\n\nfn calculate_score(given_digits: &[char], guessed_digits: &[char]) -> (usize, usize) {\n    let mut bulls = 0;\n    let mut cows = 0;\n    for i in 0..NUMBER_OF_DIGITS {\n        let pos: Option<usize> = guessed_digits.iter().position(|&a| -> bool {a == given_digits[i]});\n        match pos {\n            None              => (),\n            Some(p) if p == i => bulls += 1,\n            Some(_)           => cows += 1\n        }\n    }\n    return (bulls, cows);\n}\n\nfn main() {\n    let reader = io::stdin();\n\n    loop {\n        let given_digits = generate_digits();\n        println!(\"I have chosen my {} digits. Please guess what they are\", NUMBER_OF_DIGITS);\n\n        loop {\n            let guess_string: String = {\n                let mut buf = String::new();\n                reader.read_line(&mut buf).unwrap();\n                buf.trim().into()\n            };\n\n            let digits_maybe = parse_guess_string(&guess_string);\n            match digits_maybe {\n                Err(msg) => {\n                    println!(\"{}\", msg);\n                    continue;\n                },\n                Ok(guess_digits) => {\n                    match calculate_score(&given_digits, &guess_digits) {\n                        (NUMBER_OF_DIGITS, _) => {\n                            println!(\"you win!\");\n                            break;\n                        },\n                        (bulls, cows) => println!(\"bulls: {}, cows: {}\", bulls, cows)\n                    }\n                }\n            }\n        }\n    }\n}",
    "title": "Bulls and cows",
    "url": "http://rosettacode.org/wiki/Bulls_and_cows"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Bulls and cows/Player",
    "url": "http://rosettacode.org/wiki/Bulls_and_cows/Player"
  },
  {
    "local_code": "fn main() {\n    let s = \"The quick brown fox jumps over the lazy dog\";\n    println!(\"{:X}\", crc(s.as_bytes()));\n}\n\nfn crc(bytes: &[u8]) -> u32 {\n    // Store the CRC of all possible 256 one byte values in table\n    let mut table: [u32; 256] = [0; 256];\n    for (i, value) in table.iter_mut().enumerate() {\n        let mut word = i as u32;\n        for _ in 0..8 {\n            if word & 1 == 1 {\n                word = (word >> 1) ^ 0xedb8_8320\n            } else {\n                word >>= 1;\n            }\n        }\n        *value = word;\n    }\n\n    let mut crc: u32 = 0xffff_ffff;\n    for byte in bytes {\n        crc = table[(crc as u8 ^ *byte) as usize] ^ (crc >> 8);\n    }\n    crc ^ 0xffff_ffff\n}\n\n#[test]\nfn test() {\n    let s = \"The quick brown fox jumps over the lazy dog\";\n    assert_eq!(crc(s.as_bytes()), 0x414F_A339);\n}\n",
    "path": "tasks/crc-32",
    "remote_code": "\nfn crc32_compute_table() -> [u32; 256] {\n    let mut crc32_table = [0; 256];\n\n    for n in 0..256 {\n        crc32_table[n as usize] = (0..8).fold(n as u32, |acc, _| {\n            match acc & 1 {\n                1 => 0xedb88320 ^ (acc >> 1),\n                _ => acc >> 1,\n            }\n        });\n    }\n\n    crc32_table\n}\n\nfn crc32(buf: &str) -> u32 {\n    let crc_table = crc32_compute_table();\n\n    !buf.bytes().fold(!0, |acc, octet| {\n        (acc >> 8) ^ crc_table[((acc & 0xff) ^ octet as u32) as usize]\n    })\n}\n\nfn main() {\n    println!(\"{:x}\", crc32(\"The quick brown fox jumps over the lazy dog\"));\n}\n",
    "title": "CRC-32",
    "url": "http://rosettacode.org/wiki/CRC-32"
  },
  {
    "local_code": "use std::vec::Vec;\n\nfn check_csv_length(values: &[Vec<String>], line_length: usize) -> Result<(), String> {\n    if values.iter().all(|line| line.len() == line_length) {\n        Ok(())\n    } else {\n        Err(\"Values have inconsistent number of columns\".to_string())\n    }\n}\n\nfn csv_sum(csv: &str) -> Result<Vec<Vec<String>>, String> {\n    let mut lines: Vec<Vec<String>> = csv\n        .split('\\n')\n        .map(|line| {\n            // Split each line into subparts, and convert them into owned strings.\n            line.split(',')\n                .map(|value| value.trim().to_string())\n                .collect::<Vec<String>>()\n        })\n        .filter(|line| {\n            // Filter empty lines\n            let (string, slice) = line.split_first().unwrap();\n            !(slice.is_empty() && string.trim().is_empty())\n        })\n        .collect(); // transform the iterator over lines into a vector\n    match lines.split_first_mut() {\n        None => Err(\"The CSV file is empty !\".to_string()),\n        Some((_, ref values)) if values.is_empty() => {\n            Err(\"The CSV file has no values !\".to_string())\n        }\n        Some((ref mut headers, ref mut values)) => {\n            let columns_number = headers.len();\n            check_csv_length(values, columns_number).and_then(|_| {\n                // if check_csv_length is already an error, return it,\n                // otherwise do something with result (which in this case is '()', but we will\n                // rather use 'headers' and 'values' for our stuff' )\n\n                headers.push(\"SUM\".to_string());\n                // Since every line has the correct number of columns, add a \"SUM\" column\n\n                let mut global_result = Ok(());\n                'lines: for (line_number, ref mut line) in values.iter_mut().enumerate() {\n                    let line_number = line_number + 2;\n                    // + 1 because enumerate is 0 indexed, and usually lines start from line 1;\n                    // and another + 1 because this enumerate counts the line values,\n                    // not all the lines. Note that it will not display the correct line if\n                    // the file has some empty lines\n                    let sum = {\n                        // let's calculate the sum of a line\n                        let f64_values = line.iter().map(|value| value.parse::<f64>());\n                        // map all the values of a line py parsing them as f64\n                        // if it fails, it maps as an Err, otherwise an Ok( value )\n                        let mut sum: Result<f64, _> = Ok(0.0);\n                        'sum: for value in f64_values {\n                            match value {\n                                Ok(v) => {\n                                    sum = sum.and_then(|f64_value| Ok(f64_value + v));\n                                }\n                                Err(e) => {\n                                    use std::error::Error;\n                                    sum = Err(format!(\n                                        \"Error \\\"{error}\\\" at line {line}\",\n                                        error = e.description(),\n                                        line = line_number\n                                    ));\n                                    // a parsing error has been found\n                                    break 'sum; // break the 'sum' loop, pointless to keep it going\n                                }\n                            };\n                        }\n                        sum\n                    };\n                    match sum {\n                        Ok(value) => {\n                            line.push(value.to_string());\n                        }\n                        Err(err) => {\n                            global_result = Err(err);\n                            break 'lines;\n                        }\n                    };\n                }\n                global_result\n            })\n        }\n    }\n    .and_then(|_| Ok(lines))\n}\n\nfn vec_csv_to_string(csv: &[Vec<String>]) -> String {\n    let mut string = String::new();\n    for line in csv.iter() {\n        string.push_str(&line.join(\",\"));\n        string.push('\\n');\n    }\n    string\n}\n\nfn main() {\n    let example_file: &'static str = \"C1,C2,C3,C4,C5\\n\\\n                                      1,5,9,13,17\\n\\\n                                      2,6,10,14,18\\n\\\n                                      3,7,11,15,19\\n\\\n                                      4,8,12,16,20\";\n    println!(\"INPUT : \");\n    println!(\"{}\", example_file);\n    println!(\"--------\");\n    println!(\"OUTPUT : \");\n    match csv_sum(example_file) {\n        Ok(csv) => {\n            println!(\"{}\", vec_csv_to_string(&csv));\n        }\n        Err(err_string) => {\n            println!(\"An error occured : {desc}\", desc = err_string);\n        }\n    };\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{csv_sum, vec_csv_to_string};\n    #[test]\n    fn check_empty_csv() {\n        let empty_file: &'static str = \"\";\n        let no_values_file: &'static str = \"C1,C2,C3,C4,C5\\n\";\n        assert!(csv_sum(empty_file).is_err());\n        assert!(csv_sum(no_values_file).is_err());\n    }\n\n    #[test]\n    fn check_correct_csv() {\n        let correct_file: &'static str = \"C1,C2,C3,C4,C5\\n\\\n                                          1,5,9,13,17\\n\\\n                                          2,6,10,14,18\\n\\\n                                          3,7,11,15,19\\n\\\n                                          4,8,12,16,20\";\n        let whitespace_file: &'static str = \"C1,C2,C3,C4,C5\\n\\\n                                             1,5,9,13,17\\n\\\n                                             2,6,10,14,18\\n\\\n                                             \\n\\\n                                             3,7,11,15,19\\n\\\n                                             4,8,12,16,20\";\n        assert!(csv_sum(correct_file).is_ok());\n        let csv = csv_sum(correct_file);\n        assert!(csv.is_ok());\n        assert_eq!(\n            vec_csv_to_string(&csv.unwrap()),\n            \"C1,C2,C3,C4,C5,SUM\\n\\\n             1,5,9,13,17,45\\n\\\n             2,6,10,14,18,50\\n\\\n             3,7,11,15,19,55\\n\\\n             4,8,12,16,20,60\\n\"\n                .to_string()\n        );\n        assert!(csv_sum(whitespace_file).is_ok());\n    }\n\n    #[test]\n    fn check_incomplete_csv() {\n        let incomplete_file: &'static str = \"C1,C2,C3,C4,C5\\n\\\n                                             1,5,9,13,17\\n\\\n                                             2,6,18\\n\\\n                                             3,7,11,15,19\\n\\\n                                             4\";\n        assert!(csv_sum(incomplete_file).is_err());\n    }\n\n    #[test]\n    fn check_wrong_csv() {\n        let wrong_file: &'static str = \"C1,C2,C3,C4,C5\\n\\\n                                        1,5,9,13,17\\n\\\n                                        2,6,error,14,18\\n\\\n                                        3,7,11,15,19\\n\\\n                                        4,8,12,16,20\";\n        assert!(csv_sum(wrong_file).is_err());\n    }\n}\n",
    "path": "tasks/csv-data-manipulation",
    "remote_code": "use std::error::Error;\nuse std::num::ParseIntError;\nuse csv::{Reader, Writer};\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let mut reader = Reader::from_path(\"data.csv\")?;\n    let mut writer = Writer::from_path(\"output.csv\")?;\n\n    // headers() returns an immutable reference, so clone() before appending\n    let mut headers = reader.headers()?.clone();\n    headers.push_field(\"SUM\");\n    writer.write_record(headers.iter())?;\n\n    for row in reader.records() {\n        let mut row = row?;\n\n        // `sum` needs the type annotation so that `parse::<i64>` knows what error type to return\n        let sum: Result<_, ParseIntError> = row.iter().try_fold(0, |accum, s| {\n            Ok(accum + s.parse::<i64>()?)\n        });\n\n        row.push_field(&sum?.to_string());\n        writer.write_record(row.iter())?;\n    }\n\n    writer.flush()?;\n    Ok(())\n}",
    "title": "CSV data manipulation",
    "url": "http://rosettacode.org/wiki/CSV_data_manipulation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "static INPUT : &'static str  =\n\"Character,Speech\nThe multitude,The messiah! Show us the messiah!\nBrians mother,<angry>Now you listen here! He's not the messiah; he's a very naughty boy! Now go away!</angry>\nThe multitude,Who are you?\nBrians mother,I'm his mother; that's who!\nThe multitude,Behold his mother! Behold his mother!\";\n\nfn main() {\n    print!(\"<table>\\n<tr><td>\");\n    for c in INPUT.chars() {\n        match c {\n            '\\n' => print!(\"</td></tr>\\n<tr><td>\"),\n            ','  => print!(\"</td><td>\"),\n            '<'  => print!(\"&lt;\"),\n            '>'  => print!(\"&gt;\"),\n            '&'  => print!(\"&amp;\"),\n            _    => print!(\"{}\", c)\n        }\n    }\n    println!(\"</td></tr>\\n</table>\");\n}\n",
    "title": "CSV to HTML translation",
    "url": "http://rosettacode.org/wiki/CSV_to_HTML_translation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn cusip_check(cusip: &str) -> bool {\n    if cusip.len() != 9 {\n        return false;\n    }\n\n    let mut v = 0;\n    let capital_cusip = cusip.to_uppercase();\n    let char_indices = capital_cusip.as_str().char_indices().take(7);\n\n    let total = char_indices.fold(0, |total, (i, c)| {\n        v = match c {\n            '*' => 36,\n            '@' => 37,\n            '#' => 38,\n            _ if c.is_digit(10) => c.to_digit(10).unwrap() as u8,\n            _ if c.is_alphabetic() => (c as u8) - b'A' + 1 + 9,\n            _ => v,\n        };\n\n        if i % 2 != 0 {\n            v *= 2\n        }\n        total + (v / 10) + v % 10\n    });\n\n    let check = (10 - (total % 10)) % 10;\n    (check.to_string().chars().nth(0).unwrap()) == cusip.chars().nth(cusip.len() - 1).unwrap()\n}\n\nfn main() {\n    let codes = [\n        \"037833100\",\n        \"17275R102\",\n        \"38259P508\",\n        \"594918104\",\n        \"68389X106\",\n        \"68389X105\",\n    ];\n    for code in &codes {\n        println!(\"{} -> {}\", code, cusip_check(code))\n    }\n}",
    "title": "CUSIP",
    "url": "http://rosettacode.org/wiki/CUSIP"
  },
  {
    "local_code": "use std::fmt::Display;\nuse std::io::{self, Write};\nuse std::{env, process};\n\nfn main() {\n    let shift = env::args()\n        .nth(1)\n        .unwrap_or_else(|| exit_err(\"No shift provided\", 2))\n        .parse::<u8>()\n        .unwrap_or_else(|e| exit_err(e, 3));\n\n    let plain = get_input().unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)));\n\n    let cipher = cipher(&plain, shift);\n\n    println!(\"Cipher text: {}\", cipher.trim());\n}\n\nfn cipher(input: &str, shift: u8) -> String {\n    input\n        .chars()\n        .map(|c| {\n            let case = if c.is_uppercase() { b'A' } else { b'a' };\n\n            if c.is_alphabetic() {\n                (((c as u8 - case + shift) % 26) + case) as char\n            } else {\n                c\n            }\n        })\n        .collect()\n}\n\nfn get_input() -> io::Result<String> {\n    print!(\"Plain text:  \");\n    io::stdout().flush()?;\n\n    let mut buf = String::new();\n    io::stdin().read_line(&mut buf)?;\n    Ok(buf)\n}\n\nfn exit_err<T: Display>(msg: T, code: i32) -> ! {\n    writeln!(&mut io::stderr(), \"ERROR: {}\", msg).unwrap();\n    process::exit(code);\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn encode() {\n        let original = \"The five boxing wizards jump quickly\";\n        let encoded = \"Wkh ilyh eralqj zlcdugv mxps txlfnob\";\n        assert_eq!(super::cipher(original, 3), encoded);\n    }\n}\n",
    "path": "tasks/caesar-cipher",
    "remote_code": "use std::io::{self, Write};\nuse std::fmt::Display;\nuse std::{env, process};\n\nfn main() {\n    let shift: u8 = env::args().nth(1)\n        .unwrap_or_else(|| exit_err(\"No shift provided\", 2))\n        .parse()\n        .unwrap_or_else(|e| exit_err(e, 3));\n\n    let plain = get_input()\n        .unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)));\n\n    let cipher = plain.chars()\n        .map(|c| {\n            let case = if c.is_uppercase() {'A'} else {'a'} as u8;\n            if c.is_alphabetic() { (((c as u8 - case + shift) % 26) + case) as char } else { c }\n        }).collect::<String>();\n\n    println!(\"Cipher text: {}\", cipher.trim());\n}\n\n\nfn get_input() -> io::Result<String> {\n    print!(\"Plain text:  \");\n    try!(io::stdout().flush());\n\n    let mut buf = String::new();\n    try!(io::stdin().read_line(&mut buf));\n    Ok(buf)\n}\n\nfn exit_err<T: Display>(msg: T, code: i32) -> ! {\n    let _ = writeln!(&mut io::stderr(), \"ERROR: {}\", msg);\n    process::exit(code);\n}",
    "title": "Caesar cipher",
    "url": "http://rosettacode.org/wiki/Caesar_cipher"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Calculating the value of e",
    "url": "http://rosettacode.org/wiki/Calculating_the_value_of_e"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// Assume your binary name is 'calendar'.\n// Command line:\n// >>$ calendar 2019 150\n// First argument: year number.\n// Second argument (optional): text area width (in characters).\n\nextern crate chrono;\n\nuse std::{env, cmp};\nuse chrono::{NaiveDate, Datelike};\n\nconst MONTH_WIDTH: usize = 22;\n\nfn print_header(months: &[&str]) {\n    const DAYS_OF_WEEK: &str = \"SU MO TU WE TH FR SA  \";\n    println!();\n    for m in months {\n        print!(\"{:^20}  \", m);\n    }\n    println!(\"\\n{}\", DAYS_OF_WEEK.repeat(months.len()));\n}\n\nfn get_week_str(days: i32, week_num: i32, start_day_of_week: i32) -> Option<String> {\n    let start = week_num * 7 - start_day_of_week + 1;\n    let end = (week_num + 1) * 7 - start_day_of_week;\n    let mut ret = String::with_capacity(MONTH_WIDTH);\n    if start > days {\n        None\n    } else {\n        for i in start..(end + 1) {\n            if i <= 0 || i > days {\n                ret.push_str(\"  \");\n            } else {\n                if i < 10 {\n                    ret.push_str(\" \");\n                }\n                ret.push_str(&i.to_string());\n            }\n            ret.push_str(\" \");\n        }\n        ret.push_str(\" \");\n        Some(ret)\n    }\n}\n\nfn main() {\n    const MONTH_NAMES: [&str; 12] = [\"JANUARY\", \"FEBRUARY\", \"MARCH\", \"APRIL\", \"MAY\", \"JUNE\", \"JULY\",\n                                     \"AUGUST\", \"SEPTEMBER\", \"OCTOBER\", \"NOVEMBER\", \"DECEMBER\"];\n    const DEFAULT_TEXT_WIDTH: usize = 100;\n\n    let args: Vec<String> = env::args().collect();\n    let year: i32 = args[1].parse().expect(\"The first argument must be a year\");\n    let width: usize = if args.len() > 2 {\n        cmp::max(MONTH_WIDTH, args[2].parse().expect(\"The second argument should be text width\"))\n    } else {\n        DEFAULT_TEXT_WIDTH\n    };\n    let months_in_row = width / MONTH_WIDTH;\n    let month_rows = if MONTH_NAMES.len() % months_in_row == 0 {\n        MONTH_NAMES.len() / months_in_row\n    } else {\n        MONTH_NAMES.len() / months_in_row + 1\n    };\n\n    let start_days_of_week: Vec<i32> =\n        (1..13).map(|x| NaiveDate::from_ymd(year, x, 1).weekday().num_days_from_sunday() as i32).collect();\n\n    let month_days: [i32; 12] = if NaiveDate::from_ymd_opt(year, 2, 29).is_some() {\n        [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    } else {\n        [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    };\n\n    println!(\"{year:^w$}\", w=width, year=year.to_string());\n    for i in 0..month_rows {\n        let start = i * months_in_row;\n        let end = cmp::min((i + 1) * months_in_row, MONTH_NAMES.len());\n        print_header(&MONTH_NAMES[start..end]);\n        let mut count = 0;\n        let mut row_num = 0;\n        while count < months_in_row {\n            let mut row_str = String::with_capacity(width);\n            for j in start..end {\n                match get_week_str(month_days[j], row_num, start_days_of_week[j]) {\n                    None => {\n                        count += 1;\n                        row_str.push_str(&\" \".repeat(MONTH_WIDTH));\n                    },\n                    Some(week_str) => row_str.push_str(&week_str)\n                }\n            }\n            if count < months_in_row {\n                println!(\"{}\", row_str);\n            }\n            row_num += 1;\n        }\n    }\n}\n",
    "title": "Calendar",
    "url": "http://rosettacode.org/wiki/Calendar"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Calendar - for \"REAL\" programmers",
    "url": "http://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers"
  },
  {
    "local_code": "extern crate libc;\n\nuse libc::c_char;\nuse std::ffi::CString;\n\n/// C functions are declared in an `extern \"C\"` block.\nextern \"C\" {\n    fn strcmp(a: *const c_char, b: *const c_char) -> i32;\n}\n\nfn main() {\n    let a = CString::new(\"a\").unwrap();\n    let b = CString::new(\"b\").unwrap();\n\n    println!(\"{}\", unsafe { strcmp(a.as_ptr(), b.as_ptr()) });\n}\n\n#[test]\nfn test_strcmp() {\n    let a = CString::new(\"a\").unwrap();\n    let b = CString::new(\"b\").unwrap();\n\n    assert_eq!(unsafe { strcmp(a.as_ptr(), b.as_ptr()) }, -1);\n}\n",
    "path": "tasks/call-a-foreign-language-function",
    "remote_code": "extern crate libc;\n\n//c function that returns the sum of two integers\nextern {\n    fn add_input(in1: libc::c_int, in2: libc::c_int) -> libc::c_int;\n}\n\nfn main() {\n    let (in1, in2) = (5, 4);\n    let output = unsafe {\n        add_input(in1, in2) };\n    assert!( (output == (in1 + in2) ),\"Error in sum calculation\") ;\n}",
    "title": "Call a foreign-language function",
    "url": "http://rosettacode.org/wiki/Call_a_foreign-language_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    // Rust has a lot of neat things you can do with functions: let's go over the basics first\n    fn no_args() {}\n    // Run function with no arguments\n    no_args();\n\n    // Calling a function with fixed number of arguments.\n    // adds_one takes a 32-bit signed integer and returns a 32-bit signed integer\n    fn adds_one(num: i32) -> i32 {\n        // the final expression is used as the return value, though `return` may be used for early returns\n        num + 1\n    }\n    adds_one(1);\n\n    // Optional arguments\n    // The language itself does not support optional arguments, however, you can take advantage of\n    // Rust's algebraic types for this purpose\n    fn prints_argument(maybe: Option<i32>) {\n        match maybe {\n            Some(num) => println!(\"{}\", num),\n            None => println!(\"No value given\"),\n        };\n    }\n    prints_argument(Some(3));\n    prints_argument(None);\n\n    // You could make this a bit more ergonomic by using Rust's Into trait\n    fn prints_argument_into<I>(maybe: I)\n        where I: Into<Option<i32>>\n    {\n        match maybe.into() {\n            Some(num) => println!(\"{}\", num),\n            None => println!(\"No value given\"),\n        };\n    }\n    prints_argument_into(3);\n    prints_argument_into(None);\n\n    // Rust does not support functions with variable numbers of arguments. Macros fill this niche\n    // (println! as used above is a macro for example)\n\n    // Rust does not support named arguments\n\n    // We used the no_args function above in a no-statement context\n\n    // Using a function in an expression context\n    adds_one(1) + adds_one(5); // evaluates to eight\n\n    // Obtain the return value of a function.\n    let two = adds_one(1);\n\n    // In Rust there are no real built-in functions (save compiler intrinsics but these must be\n    // manually imported)\n\n    // In rust there are no such thing as subroutines\n\n    // In Rust, there are three ways to pass an object to a function each of which have very important\n    // distinctions when it comes to Rust's ownership model and move semantics. We may pass by\n    // value, by immutable reference, or mutable reference.\n\n    let mut v = vec![1, 2, 3, 4, 5, 6];\n\n    // By mutable reference\n    fn add_one_to_first_element(vector: &mut Vec<i32>) {\n        vector[0] += 1;\n    }\n    add_one_to_first_element(&mut v);\n    // By immutable reference\n    fn print_first_element(vector: &Vec<i32>) {\n        println!(\"{}\", vector[0]);\n    }\n    print_first_element(&v);\n\n    // By value\n    fn consume_vector(vector: Vec<i32>) {\n        // We can do whatever we want to vector here\n    }\n    consume_vector(v);\n    // Due to Rust's move semantics, v is now inaccessible because it was moved into consume_vector\n    // and was then dropped when it went out of scope\n\n    // Partial application is not possible in rust without wrapping the function in another\n    // function/closure e.g.:\n    fn average(x: f64, y: f64) -> f64 {\n        (x + y) / 2.0\n    }\n    let average_with_four = |y| average(4.0, y);\n    average_with_four(2.0);\n\n\n}",
    "title": "Call a function",
    "url": "http://rosettacode.org/wiki/Call_a_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#![allow(unused_unsafe)]\nextern crate libc;\n\nuse std::io::{self,Write};\nuse std::{mem,ffi,process};\n\nuse libc::{c_double, RTLD_NOW};\n\n// Small macro which wraps turning a string-literal into a c-string.\n// This is always safe to call, and the resulting pointer has 'static lifetime\nmacro_rules! to_cstr {\n    ($s:expr) => {unsafe {ffi::CStr::from_bytes_with_nul_unchecked(concat!($s, \"\\0\").as_bytes()).as_ptr()}}\n}\n\nmacro_rules! from_cstr {\n    ($p:expr) => {ffi::CStr::from_ptr($p).to_string_lossy().as_ref() }\n}\n\nfn main() {\n    unsafe {\n        let handle = libc::dlopen(to_cstr!(\"libm.so.6\"), RTLD_NOW);\n\n        if handle.is_null() {\n            writeln!(&mut io::stderr(), \"{}\", from_cstr!(libc::dlerror())).unwrap();\n            process::exit(1);\n        }\n\n        let extern_cos = libc::dlsym(handle, to_cstr!(\"cos\"))\n                .as_ref()\n                .map(mem::transmute::<_,fn (c_double) -> c_double)\n                .unwrap_or(builtin_cos);\n        println!(\"{}\", extern_cos(4.0));\n    }\n}\n\nfn builtin_cos(x: c_double) -> c_double {\n    x.cos()\n}",
    "title": "Call a function in a shared library",
    "url": "http://rosettacode.org/wiki/Call_a_function_in_a_shared_library"
  },
  {
    "local_code": "#![cfg_attr(feature = \"cargo-clippy\", allow(blacklisted_name))]\n\nstruct Foo;\n\nimpl Foo {\n    // implementation of an instance method for struct Foo\n    // returning the answer to life\n    fn get_the_answer_to_life(&self) -> i32 {\n        42\n    }\n\n    // implementation of a static method for struct Foo\n    // returning a new instance object\n    fn new() -> Foo {\n        println!(\"Hello, world!\");\n        Foo // returning the new Foo object\n    }\n}\n\nimpl Default for Foo {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nfn main() {\n    // create the instance object foo,\n    // by calling the static method new of struct Foo\n    let foo = Foo::new();\n\n    // get the answer to life\n    // by calling the instance method of object foo\n    println!(\"The answer to life is {}.\", foo.get_the_answer_to_life());\n}\n",
    "path": "tasks/call-an-object-method",
    "remote_code": "struct Foo;\n\nimpl Foo {\n    // implementation of an instance method for struct Foo\n    // returning the answer to life\n    fn get_the_answer_to_life(&self) -> i32 {\n        42\n    }\n\n    // implementation of a static method for struct Foo\n    // returning a new instance object\n    fn new() -> Foo {\n        println!(\"Hello, world!\");\n        Foo // returning the new Foo object\n    }\n}\n\nfn main() {\n    // create the instance object foo,\n    // by calling the static method new of struct Foo\n    let foo = Foo::new();\n\n    // get the answer to life \n    // by calling the instance method of object foo\n    println!(\"The answer to life is {}.\", foo.get_the_answer_to_life());\n    \n    // Note that in Rust, methods still work on references to the object.\n    // Rust will automatically do the appropriate dereferencing to get the method to work:\n    let lots_of_references = &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&foo;\n    println!(\"The answer to life is still {}.\" lots_of_references.get_the_answer_to_life());\n}",
    "title": "Call an object method",
    "url": "http://rosettacode.org/wiki/Call_an_object_method"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Canny edge detector",
    "url": "http://rosettacode.org/wiki/Canny_edge_detector"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Cantor set",
    "url": "http://rosettacode.org/wiki/Cantor_set"
  },
  {
    "local_code": "fn is_prime(n: i64) -> bool {\n    if n > 1 {\n        (2..((n / 2) + 1)).all(|x| n % x != 0)\n    } else {\n        false\n    }\n}\n\n// The module operator actually calculates the remainder.\nfn modulo(n: i64, m: i64) -> i64 {\n    ((n % m) + m) % m\n}\n\nfn carmichael(p1: i64) -> Vec<(i64, i64, i64)> {\n    let mut results = Vec::new();\n    if !is_prime(p1) {\n        return results;\n    }\n\n    for h3 in 2..p1 {\n        for d in 1..(h3 + p1) {\n            if (h3 + p1) * (p1 - 1) % d != 0 || modulo(-p1 * p1, h3) != d % h3 {\n                continue;\n            }\n\n            let p2 = 1 + ((p1 - 1) * (h3 + p1) / d);\n            if !is_prime(p2) {\n                continue;\n            }\n\n            let p3 = 1 + (p1 * p2 / h3);\n            if !is_prime(p3) || ((p2 * p3) % (p1 - 1) != 1) {\n                continue;\n            }\n\n            results.push((p1, p2, p3));\n        }\n    }\n\n    results\n}\n\nfn main() {\n    (1..62)\n        .filter(|&x| is_prime(x))\n        .map(carmichael)\n        .filter(|x| !x.is_empty())\n        .flat_map(|x| x)\n        .inspect(|x| println!(\"{:?}\", x))\n        .count(); // Evaluate entire iterator\n}\n\n#[cfg(test)]\nmod tests {\n    use super::carmichael;\n\n    #[test]\n    fn test_primes() {\n        assert_eq!(carmichael(59), [(59, 1451, 2089)]);\n        assert_eq!(carmichael(19), [(19, 43, 409), (19, 199, 271)]);\n    }\n\n    #[test]\n    fn test_non_primes() {\n        assert_eq!(carmichael(20).len(), 0);\n        assert_eq!(carmichael(99).len(), 0);\n    }\n}\n",
    "path": "tasks/carmichael-3-strong-pseudoprimes",
    "remote_code": "\nfn is_prime(n: i64) -> bool {\n    if n > 1 {\n        (2..((n / 2) + 1)).all(|x| n % x != 0)\n    } else {\n        false\n    }\n}\n\n// The modulo operator actually calculates the remainder.\nfn modulo(n: i64, m: i64) -> i64 {\n    ((n % m) + m) % m\n}\n\nfn carmichael(p1: i64) -> Vec<(i64, i64, i64)> {\n    let mut results = Vec::new();\n    if !is_prime(p1) {\n        return results;\n    }\n\n    for h3 in 2..p1 {\n        for d in 1..(h3 + p1) {\n            if (h3 + p1) * (p1 - 1) % d != 0 || modulo(-p1 * p1, h3) != d % h3 {\n                continue;\n            }\n\n            let p2 = 1 + ((p1 - 1) * (h3 + p1) / d);\n            if !is_prime(p2) {\n                continue;\n            }\n\n            let p3 = 1 + (p1 * p2 / h3);\n            if !is_prime(p3) || ((p2 * p3) % (p1 - 1) != 1) {\n                continue;\n            }\n\n            results.push((p1, p2, p3));\n        }\n    }\n\n    results\n}\n\nfn main() {\n    (1..62)\n        .filter(|&x| is_prime(x))\n        .map(carmichael)\n        .filter(|x| !x.is_empty())\n        .flat_map(|x| x)\n        .inspect(|x| println!(\"{:?}\", x))\n        .count(); // Evaluate entire iterator\n}\n",
    "title": "Carmichael 3 strong pseudoprimes",
    "url": "http://rosettacode.org/wiki/Carmichael_3_strong_pseudoprimes"
  },
  {
    "local_code": "//! # Cartesian product of lists\n//!\n//! Solution for the \"cartesian product of two or more lists\" entry in rosetta code\n\nuse std::collections::VecDeque;\n\n/// Computes the cartesian product of two or more lists of clonable elements.\n///\n/// Uses a queue to iterate over the elements (Breadth-First-Search).\n///\nfn cartesian_product<T: Clone>(lists: &[&[T]]) -> Vec<Vec<T>> {\n    // If there are no lists, just returns an empty list.\n    if lists.is_empty() {\n        return vec![];\n    }\n    // Fills the queue with the first list.\n    let mut queue = lists[0]\n        .iter()\n        .map(|value| vec![value.clone()])\n        .collect::<VecDeque<Vec<T>>>();\n\n    let mut result = vec![];\n\n    while let Some(next) = queue.pop_front() {\n        // find the index of the next list to multiply with.\n        let next_list = next.len();\n\n        if lists.len() == next_list {\n            // If there are no more lists to multiply with, save the result.\n            result.push(next)\n        } else {\n            // Else add the products to the queue.\n            for value_to_add in lists[next_list] {\n                let mut nouv = next.clone();\n                nouv.push(value_to_add.clone());\n                queue.push_back(nouv);\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    println!(\"\\n{:?}\", cartesian_product(&[&[1, 2], &[3, 4]]));\n    println!(\"\\n{:?}\", cartesian_product(&[&[3, 4], &[1, 2]]));\n    /*\n        This will print :\n\n        [[1, 3], [1, 4], [2, 3], [2, 4]]\n\n        [[3, 1], [3, 2], [4, 1], [4, 2]]\n    */\n}\n\n#[cfg(test)]\nmod tests {\n    use super::cartesian_product;\n    #[test]\n    fn basic_test() {\n        assert_eq!(\n            cartesian_product(&[&[1, 2], &[3, 4]]),\n            vec![vec![1, 3], vec![1, 4], vec![2, 3], vec![2, 4]]\n        );\n    }\n\n    #[test]\n    fn empty_list() {\n        assert_eq!(\n            cartesian_product(&[&[1, 2], &[], &[3, 4]]),\n            Vec::<Vec<i32>>::new()\n        );\n    }\n\n    #[test]\n    fn many_lists_different_length() {\n        assert_eq!(\n            cartesian_product(&[&[1, 2], &[4], &[3, 4, 7]]),\n            vec![\n                vec![1, 4, 3],\n                vec![1, 4, 4],\n                vec![1, 4, 7],\n                vec![2, 4, 3],\n                vec![2, 4, 4],\n                vec![2, 4, 7],\n            ]\n        );\n    }\n\n    #[test]\n    fn different_types() {\n        assert_eq!(\n            cartesian_product(&[&[true, false], &[true], &[false, true]]),\n            vec![\n                vec![true, true, false],\n                vec![true, true, true],\n                vec![false, true, false],\n                vec![false, true, true],\n            ]\n        );\n    }\n\n    #[test]\n    fn no_list() {\n        assert_eq!(cartesian_product::<i32>(&[]), Vec::<Vec<i32>>::new());\n    }\n}\n",
    "path": "tasks/cartesian-product-of-two-or-more-lists",
    "remote_code": "type List = Vec<Vec<u32>>;\n\nfn cartesian_product(lists: &List) -> List {\n    let mut res: List = vec![];\n    if lists.len() < 2 || lists.iter().any(|x| x.len() == 0) {\n        return res\n    }\n\n    let mut list_iter = lists.iter();\n    if let Some(first_list) = list_iter.next() {\n        for &i in first_list {\n            res.push(vec![i]);\n        }\n    }\n    for l in list_iter {\n        let mut tmp: List = List::new();\n        for r in res {\n            for &el in l {\n                let mut tmp_el = r.clone();\n                tmp_el.push(el);\n                tmp.push(tmp_el);\n            }\n        }\n        res = tmp;\n    }\n    res\n}\n\nfn print_list(list: &List) {\n    print!(\"{{ \");\n    for inner_list in list {\n        print!(\"( \");\n        for el in inner_list {\n            print!(\"{} \", el);\n        }\n        print!(\") \");\n    }\n    println!(\"}}\");\n}\n\nfn main() {\n    println!(\"{{1, 2}} x {{3, 4}}\");\n    print_list(&cartesian_product(&vec![vec![1, 2], vec![3, 4]]));\n    println!(\"\\n{{3, 4}} x {{1, 2}}\");\n    print_list(&cartesian_product(&vec![vec![3, 4], vec![1, 2]]));\n    println!(\"\\n{{1, 2}} x {{}}\");\n    print_list(&cartesian_product(&vec![vec![1, 2], vec![]]));\n    println!(\"\\n{{}} x {{1, 2}}\");\n    print_list(&cartesian_product(&vec![vec![], vec![1, 2]]));\n    println!(\"\\n{{1776, 1789}} × {{7, 12}} × {{4, 14, 23}} × {{0, 1}}\");\n    print_list(&cartesian_product(&vec![vec![1776, 1789], vec![7, 12], vec![4, 14, 23], vec![0, 1]]));\n    println!(\"\\n{{1, 2, 3}} × {{30}} × {{500, 100}}\");\n    print_list(&cartesian_product(&vec![vec![1, 2, 3], vec![30], vec![500, 100]]));\n    println!(\"\\n{{1, 2, 3}} × {{}} × {{500, 100}}\");\n    print_list(&cartesian_product(&vec![vec![1, 2, 3], vec![], vec![500, 100]]));\n}\n",
    "title": "Cartesian product of two or more lists",
    "url": "http://rosettacode.org/wiki/Cartesian_product_of_two_or_more_lists"
  },
  {
    "local_code": "#![allow(non_snake_case)]\n\nfn main() {\n    let dog = \"Benjamin\";\n    let Dog = \"Samba\";\n    let DOG = \"Bernie\";\n    println!(\"The three dogs are named {}, {} and {}.\", dog, Dog, DOG);\n}\n",
    "path": "tasks/case-sensitivity-of-identifiers",
    "remote_code": "fn main() {\n    let dog = \"Benjamin\";\n    let Dog = \"Samba\";\n    let DOG = \"Bernie\";\n    println!(\"The three dogs are named {}, {} and {}.\", dog, Dog, DOG);\n}",
    "title": "Case-sensitivity of identifiers",
    "url": "http://rosettacode.org/wiki/Case-sensitivity_of_identifiers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Casting out nines",
    "url": "http://rosettacode.org/wiki/Casting_out_nines"
  },
  {
    "local_code": "fn c_n(n: u64) -> u64 {\n    match n {\n        0 => 1,\n        _ => c_n(n - 1) * 2 * (2 * n - 1) / (n + 1),\n    }\n}\n\nfn main() {\n    for i in 1..16 {\n        println!(\"c_n({}) = {}\", i, c_n(i));\n    }\n}\n",
    "path": "tasks/catalan-numbers",
    "remote_code": "fn c_n(n: u64) -> u64 {\n    match n {\n        0 => 1,\n        _ => c_n(n - 1) * 2 * (2 * n - 1) / (n + 1)\n    }\n}\n\nfn main() {\n    for i in 1..16 {\n        println!(\"c_n({}) = {}\", i, c_n(i));\n    }\n}",
    "title": "Catalan numbers",
    "url": "http://rosettacode.org/wiki/Catalan_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n\nfn main()\n{let n=15usize;\n let mut t= [0; 17];\n t[1]=1;\n let mut j:usize;\n for i in 1..n+1\n {\n\tj=i;\n\tloop{\n\t    if j==1{\n\t\t      break; \n\t\t}\n\t\tt[j]=t[j] + t[j-1];\n\t\tj=j-1;\n\t}\n\tt[i+1]= t[i];\n\tj=i+1;\n\tloop{\n\t\tif j==1{\n\t\tbreak;\n\t\t}\n\t\tt[j]=t[j] + t[j-1];\n\t\tj=j-1;\n\t}\n\tprint!(\"{} \", t[i+1]-t[i]);\n }\n}\n",
    "title": "Catalan numbers/Pascal's triangle",
    "url": "http://rosettacode.org/wiki/Catalan_numbers/Pascal's_triangle"
  },
  {
    "local_code": "fn main() {\n    let numbers = [1, 2, 3, 4, 5];\n    let sum = numbers.iter().fold(0, |a, n| a + n);\n    println!(\"{}\", sum);\n    let product = numbers.iter().fold(1, |a, n| a * n);\n    println!(\"{}\", product);\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_sum() {\n        let sum = [1, 2, 3, 4, 5].iter().fold(0, |a, n| a + n);\n        assert_eq!(sum, 15);\n    }\n    #[test]\n    fn test_product() {\n        let product = [1, 2, 3, 4, 5].iter().fold(1, |a, n| a * n);\n        assert_eq!(product, 120);\n    }\n}\n",
    "path": "tasks/catamorphism",
    "remote_code": "fn main() {\n    println!(\"Sum: {}\", (1..10).fold(0, |acc, n| acc + n));\n    println!(\"Product: {}\", (1..10).fold(1, |acc, n| acc * n));\n    let chars = ['a', 'b', 'c', 'd', 'e'];\n    println!(\"Concatenation: {}\",\n             chars.iter().map(|&c| (c as u8 + 1) as char).collect::<String>());\n}",
    "title": "Catamorphism",
    "url": "http://rosettacode.org/wiki/Catamorphism"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Catmull–Clark subdivision surface",
    "url": "http://rosettacode.org/wiki/Catmull%E2%80%93Clark_subdivision_surface"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "const LEFT_ALPHABET_CT: &str = \"HXUCZVAMDSLKPEFJRIGTWOBNYQ\";\nconst RIGHT_ALPHABET_PT: &str = \"PTLNBQDEOYSFAVZKGJRIHWXUMC\";\nconst ZENITH: usize = 0;\nconst NADIR: usize = 12;\nconst SEQUENCE: &str = \"WELLDONEISBETTERTHANWELLSAID\";\n\nfn cipher(letter: &char, left: &String, right: &String) -> (usize, char) {\n    let pos = right.find(*letter).unwrap();\n    let cipher = left.chars().nth(pos).unwrap();\n    (pos, cipher)\n}\n\nfn main() {\n    let mut left = LEFT_ALPHABET_CT.to_string();\n    let mut right = RIGHT_ALPHABET_PT.to_string();\n\n    let ciphertext = SEQUENCE.chars()\n        .map(|letter| {\n            let (pos, cipher_char) = cipher(&letter, &left, &right);\n            left = format!(\"{}{}\", &left[pos..], &left[..pos]);\n            left = format!(\"{}{}{}{}\", &left[ZENITH..1], &left[2..NADIR+2], &left[1..2], &left[NADIR+2..]);\n            if pos != right.len() - 1 {\n                right = format!(\"{}{}\", &right[pos + 1..], &right[..pos + 1]);\n            }\n            right = format!(\"{}{}{}{}\", &right[ZENITH..2], &right[3..NADIR+2], &right[2..3], &right[NADIR+2..]);\n            cipher_char\n        })\n        .collect::<String>();\n\n    println!(\"Plaintext: {}\", SEQUENCE);\n    println!(\"Ciphertext: {}\", ciphertext);\n}",
    "title": "Chaocipher",
    "url": "http://rosettacode.org/wiki/Chaocipher"
  },
  {
    "local_code": "extern crate image;\nextern crate rand;\n\nuse std::f32::consts::PI;\n\nuse rand::prelude::*;\n\nfn main() {\n    let max_iterations = 50_000;\n    let img_side = 800;\n    let tri_size = 400.0;\n\n    // Create a new ImgBuf\n    let mut imgbuf = image::ImageBuffer::new(img_side, img_side);\n\n    // Create triangle vertices\n    let mut vertices = [(0.0, 0.0); 3];\n    for (i, (x, y)) in vertices.iter_mut().enumerate() {\n        *x = (img_side as f32 / 2.) + (tri_size / 2.) * (PI * i as f32 * 2. / 3.).cos();\n        *y = (img_side as f32 / 2.) + (tri_size / 2.) * (PI * i as f32 * 2. / 3.).sin();\n    }\n    for &(x, y) in &vertices {\n        imgbuf.put_pixel(x as u32, y as u32, image::Luma([255]));\n    }\n\n    // Iterate chaos game\n    let mut rng = thread_rng();\n    let mut x = img_side as f32 / 2.0;\n    let mut y = img_side as f32 / 2.0;\n    for _ in 0..max_iterations {\n        let (choice_x, choice_y) = vertices.choose(&mut rng).unwrap();\n        x = (x + choice_x) / 2.0;\n        y = (y + choice_y) / 2.0;\n\n        imgbuf.put_pixel(x as u32, y as u32, image::Luma([255]));\n    }\n\n    image::ImageLuma8(imgbuf).save(\"fractal.png\").unwrap();\n}\n",
    "path": "tasks/chaos-game",
    "remote_code": "extern crate image;\nextern crate rand;\n\nuse std::fs::File;\nuse rand::Rng;\nuse std::f32;\n\nfn main() {\n    let max_iterations = 50_000u32;\n    let img_side = 800u32;\n    let tri_size = 400f32;\n\n    // Create a new ImgBuf\n    let mut imgbuf = image::ImageBuffer::new(img_side, img_side);\n\n    // Create triangle vertices\n    let mut vertices: [[f32; 2]; 3] = [[0f32, 0f32]; 3];\n    for i in 0..vertices.len() {\n        vertices[i][0] =\n            (img_side as f32 / 2.) + (tri_size / 2.) * (f32::consts::PI * i as f32 * 2. / 3.).cos();\n        vertices[i][1] =\n            (img_side as f32 / 2.) + (tri_size / 2.) * (f32::consts::PI * i as f32 * 2. / 3.).sin();\n    }\n    for v in &vertices {\n        imgbuf.put_pixel(v[0] as u32, v[1] as u32, image::Luma([255u8]));\n    }\n\n    // Iterate chaos game\n    let mut rng = rand::weak_rng();\n    let mut x = img_side as f32 / 2.;\n    let mut y = img_side as f32 / 2.;\n    for _ in 0..max_iterations {\n        let choice = rng.gen_range(0, vertices.len());\n        x = (x + vertices[choice][0]) / 2.;\n        y = (y + vertices[choice][1]) / 2.;\n\n        imgbuf.put_pixel(x as u32, y as u32, image::Luma([255u8]));\n    }\n\n    // Save image\n    let fout = &mut File::create(\"fractal.png\").unwrap();\n    image::ImageLuma8(imgbuf).save(fout, image::PNG).unwrap();\n}",
    "title": "Chaos game",
    "url": "http://rosettacode.org/wiki/Chaos_game"
  },
  {
    "local_code": "use std::char;\n\nfn main() {\n    // ascii char\n    println!(\"{}\", b'a');\n    println!(\"{}\", 97 as char);\n\n    // unicode char\n    println!(\"{}\", 'π' as u32);\n    println!(\"{}\", char::from_u32(960).unwrap());\n}\n",
    "path": "tasks/character-codes",
    "remote_code": "use std::char::from_u32;\n\nfn main() {\n    //ascii char\n    println!(\"{}\", 'a' as u8);\n    println!(\"{}\", 97 as char);\n\n    //unicode char\n    println!(\"{}\", 'π' as u32);\n    println!(\"{}\", from_u32(960).unwrap());\n}",
    "title": "Character codes",
    "url": "http://rosettacode.org/wiki/Character_codes"
  },
  {
    "local_code": "use std::collections::HashMap;\nuse std::io;\nuse std::io::prelude::*;\nuse std::io::BufReader;\nuse std::net::{TcpListener, TcpStream};\nuse std::sync::{Arc, RwLock};\nuse std::thread;\n\ntype Username = String;\n\n/// Sends a message to all clients except the sending client.\nfn broadcast_message(\n    user: &str,\n    clients: &mut HashMap<String, TcpStream>,\n    message: &str,\n) -> io::Result<()> {\n    for (client, stream) in clients.iter_mut() {\n        if client != user {\n            writeln!(stream, \"{}\", message)?;\n        }\n    }\n\n    Ok(())\n}\n\nfn chat_loop(listener: &TcpListener) -> io::Result<()> {\n    let local_clients: Arc<RwLock<HashMap<Username, TcpStream>>> =\n        Arc::new(RwLock::new(HashMap::new()));\n\n    println!(\"Accepting connections on {}\", listener.local_addr()?.port());\n\n    for stream in listener.incoming() {\n        match stream {\n            Ok(stream) => {\n                let client_clients = Arc::clone(&local_clients);\n                thread::spawn(move || -> io::Result<()> {\n                    let mut reader = BufReader::new(stream.try_clone()?);\n                    let mut writer = stream;\n\n                    let mut name = String::new();\n                    loop {\n                        write!(writer, \"Please enter a username: \")?;\n                        reader.read_line(&mut name)?;\n                        name = name.trim().to_owned();\n\n                        let clients = client_clients.read().unwrap();\n                        if !clients.contains_key(&name) {\n                            writeln!(writer, \"Welcome, {}!\", &name)?;\n                            break;\n                        }\n\n                        writeln!(writer, \"That username is taken.\")?;\n                        name.clear();\n                    }\n\n                    {\n                        let mut clients = client_clients.write().unwrap();\n                        clients.insert(name.clone(), writer);\n                        broadcast_message(\n                            &name,\n                            &mut *clients,\n                            &format!(\"{} has joined the chat room.\", &name),\n                        )?;\n                    }\n\n                    for line in reader.lines() {\n                        let mut clients = client_clients.write().unwrap();\n                        broadcast_message(&name, &mut *clients, &format!(\"{}: {}\", &name, line?))?;\n                    }\n\n                    {\n                        let mut clients = client_clients.write().unwrap();\n                        clients.remove(&name);\n                        broadcast_message(\n                            &name,\n                            &mut *clients,\n                            &format!(\"{} has left the chat room.\", &name),\n                        )?;\n                    }\n\n                    Ok(())\n                });\n            }\n            Err(e) => {\n                println!(\"Connection failed: {}\", e);\n            }\n        }\n    }\n\n    Ok(())\n}\n\nfn main() {\n    let listener = TcpListener::bind((\"localhost\", 7000)).unwrap();\n    chat_loop(&listener).unwrap();\n}\n\n#[cfg(test)]\nmod tests {\n    use std::io::prelude::*;\n    use std::io::{BufReader, BufWriter};\n    use std::net::{TcpListener, TcpStream, ToSocketAddrs};\n    use std::thread;\n\n    fn create_client<A>(addr: A) -> (BufReader<TcpStream>, BufWriter<TcpStream>)\n    where\n        A: ToSocketAddrs,\n    {\n        let client = TcpStream::connect(addr).unwrap();\n        let reader = BufReader::new(client.try_clone().unwrap());\n        let writer = BufWriter::new(client.try_clone().unwrap());\n\n        (reader, writer)\n    }\n\n    /// In this test, a single client logs into the chat server. They should obtain a greeting once\n    /// they enter their name.\n    #[test]\n    fn single_client() {\n        let listener = TcpListener::bind((\"localhost\", 7000)).unwrap();\n        let _ = thread::spawn(move || {\n            super::chat_loop(&listener).unwrap();\n        });\n\n        let (mut reader, mut writer) = create_client(\"localhost:7000\");\n\n        writeln!(writer, \"client\").unwrap();\n        writer.flush().unwrap();\n\n        let mut line = String::new();\n        reader.read_line(&mut line).unwrap();\n        assert_eq!(\"Please enter a username: Welcome, client!\\n\", line);\n        line.clear();\n\n        // Send a message.\n        writeln!(writer, \"Hello, world!\").unwrap();\n        writer.flush().unwrap();\n    }\n\n    /// In this test, there are two clients. One client will log in successfully. Then, a second\n    /// client will log in. The first client should see a message notifying them that the second\n    /// client has logged in. The first client will then send a chat message, which the second\n    /// client should see. Finally, the second client will close their connection, which should\n    /// generate a message for the first client indicating that the second client has logged out.\n    #[test]\n    fn multi_client() {\n        let listener = TcpListener::bind((\"localhost\", 8000)).unwrap();\n        let _ = thread::spawn(move || {\n            super::chat_loop(&listener).unwrap();\n        });\n\n        let (mut reader1, mut writer1) = create_client(\"localhost:8000\");\n\n        writeln!(writer1, \"client_1\").unwrap();\n        writer1.flush().unwrap();\n\n        let mut line = String::new();\n        reader1.read_line(&mut line).unwrap();\n        assert_eq!(\"Please enter a username: Welcome, client_1!\\n\", line);\n        line.clear();\n\n        let (mut reader2, mut writer2) = create_client(\"localhost:8000\");\n        writeln!(writer2, \"client_2\").unwrap();\n        writer2.flush().unwrap();\n\n        reader2.read_line(&mut line).unwrap();\n        assert_eq!(\"Please enter a username: Welcome, client_2!\\n\", line);\n        line.clear();\n\n        reader1.read_line(&mut line).unwrap();\n        assert_eq!(\"client_2 has joined the chat room.\\n\", line);\n        line.clear();\n\n        writeln!(writer1, \"Hello, world!\").unwrap();\n        writer1.flush().unwrap();\n\n        reader2.read_line(&mut line).unwrap();\n        assert_eq!(\"client_1: Hello, world!\\n\", line);\n        line.clear();\n\n        drop(writer2);\n        drop(reader2);\n\n        reader1.read_line(&mut line).unwrap();\n        assert_eq!(\"client_2 has left the chat room.\\n\", line);\n    }\n\n    /// Ensures that a user cannot have the username of a user already in the chat room.\n    #[test]\n    fn existing_name() {\n        let listener = TcpListener::bind((\"localhost\", 9000)).unwrap();\n        let _ = thread::spawn(move || {\n            super::chat_loop(&listener).unwrap();\n        });\n\n        let (mut reader1, mut writer1) = create_client(\"localhost:9000\");\n\n        writeln!(writer1, \"client\").unwrap();\n        writer1.flush().unwrap();\n\n        let mut line = String::new();\n        reader1.read_line(&mut line).unwrap();\n        assert_eq!(\"Please enter a username: Welcome, client!\\n\", line);\n        line.clear();\n\n        let (mut reader2, mut writer2) = create_client(\"localhost:9000\");\n\n        writeln!(writer2, \"client\").unwrap();\n        writer2.flush().unwrap();\n\n        reader2.read_line(&mut line).unwrap();\n        assert_eq!(\"Please enter a username: That username is taken.\\n\", line);\n        line.clear();\n    }\n}\n",
    "path": "tasks/chat-server",
    "remote_code": null,
    "title": "Chat server",
    "url": "http://rosettacode.org/wiki/Chat_server"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Check Machin-like formulas",
    "url": "http://rosettacode.org/wiki/Check_Machin-like_formulas"
  },
  {
    "local_code": "extern crate libc;\n\n#[cfg(unix)]\nfn main() {\n    let istty = unsafe { libc::isatty(libc::STDIN_FILENO as i32) } != 0;\n    if istty {\n        println!(\"stdin is tty\");\n    } else {\n        println!(\"stdin is not tty\");\n    }\n}\n\n#[cfg(not(unix))]\nfn main() {\n    unimplemented!();\n}\n",
    "path": "tasks/check-input-device-is-a-terminal",
    "remote_code": "/* Uses C library interface */\n\nextern crate libc;\n\nfn main() {\n    let istty = unsafe { libc::isatty(libc::STDIN_FILENO as i32) } != 0;\n    if istty {\n        println!(\"stdout is tty\");\n    } else {\n        println!(\"stdout is not tty\");\n    }\n}",
    "title": "Check input device is a terminal",
    "url": "http://rosettacode.org/wiki/Check_input_device_is_a_terminal"
  },
  {
    "local_code": "extern crate libc;\n\n#[cfg(unix)]\nfn main() {\n    let istty = unsafe { libc::isatty(libc::STDOUT_FILENO as i32) } != 0;\n    if istty {\n        println!(\"stdout is tty\");\n    } else {\n        println!(\"stdout is not tty\");\n    }\n}\n\n#[cfg(not(unix))]\nfn main() {\n    unimplemented!();\n}\n",
    "path": "tasks/check-output-device-is-a-terminal",
    "remote_code": "/* Uses C library interface */\n\nextern crate libc;\n\nfn main() {\n    let istty = unsafe { libc::isatty(libc::STDOUT_FILENO as i32) } != 0;\n    if istty {\n        println!(\"stdout is tty\");\n    } else {\n        println!(\"stdout is not tty\");\n    }\n}",
    "title": "Check output device is a terminal",
    "url": "http://rosettacode.org/wiki/Check_output_device_is_a_terminal"
  },
  {
    "local_code": "use std::path::Path;\n\nfn main() {\n    let paths = [\"input.txt\", \"docs\"];\n    for path in paths.iter().map(|&x| Path::new(x)) {\n        let msg = if path.exists() {\n            \"exists\"\n        } else {\n            \"does not exist\"\n        };\n\n        println!(\"{} {}.\", path.display(), msg);\n    }\n}\n",
    "path": "tasks/check-that-file-exists",
    "remote_code": "use std::fs;\n\nfn main() {\n    for file in [\"input.txt\", \"docs\", \"/input.txt\", \"/docs\"].iter() {\n        match fs::metadata(file) {\n            Ok(attr) => {\n                if attr.is_dir() {\n                    println!(\"{} is a directory\", file);\n                }else {\n                    println!(\"{} is a file\", file);\n                }\n            },\n            Err(_) => {\n                println!(\"{} does not exist\", file);\n            }\n        };\n    }\n}\n",
    "title": "Check that file exists",
    "url": "http://rosettacode.org/wiki/Check_that_file_exists"
  },
  {
    "local_code": "//! We implement this task using Rust's Barriers.  Barriers are simply thread synchronization\n//! points--if a task waits at a barrier, it will not continue until the number of tasks for which\n//! the variable was initialized are also waiting at the barrier, at which point all of them will\n//! stop waiting.  This can be used to allow threads to do asynchronous work and guarantee\n//! properties at checkpoints.\n\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::mpsc::channel;\nuse std::sync::{Arc, Barrier};\nuse std::thread::spawn;\n\nuse array_init::array_init;\n\npub fn checkpoint() {\n    const NUM_TASKS: usize = 10;\n    const NUM_ITERATIONS: u8 = 10;\n\n    let barrier = Barrier::new(NUM_TASKS);\n    let events: [AtomicBool; NUM_TASKS] = array_init(|_| AtomicBool::new(false));\n\n    // Arc for sharing between tasks\n    let arc = Arc::new((barrier, events));\n    // Channel for communicating when tasks are done\n    let (tx, rx) = channel();\n    for i in 0..NUM_TASKS {\n        let arc = Arc::clone(&arc);\n        let tx = tx.clone();\n        // Spawn a new worker\n        spawn(move || -> () {\n            let (ref barrier, ref events) = *arc;\n            // Assign an event to this task\n            let event = &events[i];\n            // Start processing events\n            for _ in 0..NUM_ITERATIONS {\n                // Between checkpoints 4 and 1, turn this task's event on.\n                event.store(true, Ordering::Release);\n                // Checkpoint 1\n                barrier.wait();\n                // Between checkpoints 1 and 2, all events are on.\n                assert!(events.iter().all(|e| e.load(Ordering::Acquire)));\n                // Checkpoint 2\n                barrier.wait();\n                // Between checkpoints 2 and 3, turn this task's event off.\n                event.store(false, Ordering::Release);\n                // Checkpoint 3\n                barrier.wait();\n                // Between checkpoints 3 and 4, all events are off.\n                assert!(events.iter().all(|e| !e.load(Ordering::Acquire)));\n                // Checkpoint 4\n                barrier.wait();\n            }\n            // Finish processing events.\n            tx.send(()).unwrap();\n        });\n    }\n    drop(tx);\n    // The main thread will not exit until all tasks have exited.\n    for _ in 0..NUM_TASKS {\n        rx.recv().unwrap();\n    }\n}\n\nfn main() {\n    checkpoint();\n}\n\n#[test]\nfn test_checkpoint() {\n    checkpoint();\n}\n",
    "path": "tasks/checkpoint-synchronization",
    "remote_code": null,
    "title": "Checkpoint synchronization",
    "url": "http://rosettacode.org/wiki/Checkpoint_synchronization"
  },
  {
    "local_code": "fn main() {\n    let l = [(2, 3), (3, 5), (2, 7)];\n    println!(\"{:?}\", chinese_remainder(&l));\n}\n\nfn chinese_remainder(l: &[(i32, i32)]) -> Option<i32> {\n    let product = l.iter().fold(1, |prod, &(_, n)| prod * n);\n\n    let mut sum = 0;\n    for &(a, n) in l {\n        let mut term = product / n;\n\n        let inv = match mul_inv(term, n) {\n            Some(inv) => inv,\n            None => return None,\n        };\n\n        term *= inv;\n        term *= a;\n        sum += term;\n    }\n    Some(sum % product)\n}\n\nfn mul_inv(a: i32, b: i32) -> Option<i32> {\n    let (gcd, mut x, _) = egcd(a, b);\n    if gcd != 1 {\n        // No multiplicative inverse exists\n        return None;\n    }\n    if x < 0 {\n        x += b;\n    }\n    Some(x % b)\n}\n\n#[cfg_attr(feature = \"cargo-clippy\", allow(many_single_char_names))]\nfn egcd(a: i32, b: i32) -> (i32, i32, i32) {\n    if a == 0 {\n        return (b, 0, 1);\n    }\n\n    let (g, y, x) = egcd(b % a, a);\n    (g, x - (b / a) * y, y)\n}\n\n#[test]\nfn test() {\n    let l = [(2, 3), (3, 5), (2, 7)];\n    assert_eq!(chinese_remainder(&l), Some(23));\n\n    let l = [(10, 11), (4, 22), (9, 19)];\n    assert_eq!(chinese_remainder(&l), None);\n}\n",
    "path": "tasks/chinese-remainder-theorem",
    "remote_code": "fn egcd(a: i64, b: i64) -> (i64, i64, i64) {\n    if a == 0 {\n        (b, 0, 1)\n    } else {\n        let (g, x, y) = egcd(b % a, a);\n        (g, y - (b / a) * x, x)\n    }\n}\n\nfn mod_inv(x: i64, n: i64) -> Option<i64> {\n    let (g, x, _) = egcd(x, n);\n    if g == 1 {\n        Some((x % n + n) % n)\n    } else {\n        None\n    }\n}\n\nfn chinese_remainder(residues: &[i64], modulii: &[i64]) -> Option<i64> {\n    let prod = modulii.iter().product::<i64>();\n\n    let mut sum = 0;\n\n    for (&residue, &modulus) in residues.iter().zip(modulii) {\n        let p = prod / modulus;\n        sum += residue * mod_inv(p, modulus)? * p\n    }\n\n    Some(sum % prod)\n}\n\nfn main() {\n    let modulii = [3,5,7];\n    let residues = [2,3,2];\n\n    match chinese_remainder(&residues, &modulii) {\n        Some(sol) => println!(\"{}\", sol),\n        None      => println!(\"modulii not pairwise coprime\")\n    }\n\n}",
    "title": "Chinese remainder theorem",
    "url": "http://rosettacode.org/wiki/Chinese_remainder_theorem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Chinese zodiac",
    "url": "http://rosettacode.org/wiki/Chinese_zodiac"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn cholesky(mat: Vec<f64>, n: usize) -> Vec<f64> {\n    let mut res = vec![0.0; mat.len()];\n    for i in 0..n {\n        for j in 0..(i+1){\n            let mut s = 0.0;\n            for k in 0..j {\n                s += res[i * n + k] * res[j * n + k];\n            }\n            res[i * n + j] = if i == j { (mat[i * n + i] - s).sqrt() } else { (1.0 / res[j * n + j] * (mat[i * n + j] - s)) };\n        }\n    }\n    res\n}\n\nfn show_matrix(matrix: Vec<f64>, n: usize){\n    for i in 0..n {\n        for j in 0..n {\n            print!(\"{:.4}\\t\", matrix[i * n + j]);\n        }\n        println!(\"\");\n    }\n    println!(\"\");\n}\n\nfn main(){\n    let dimension = 3 as usize;\n    let m1 = vec![25.0, 15.0, -5.0,\n                  15.0, 18.0,  0.0,\n                  -5.0,  0.0, 11.0];\n    let res1 = cholesky(m1, dimension);\n    show_matrix(res1, dimension);\n\n    let dimension = 4 as usize;\n    let m2 = vec![18.0, 22.0,  54.0,  42.0,\n                  22.0, 70.0,  86.0,  62.0,\n                  54.0, 86.0, 174.0, 134.0,\n                  42.0, 62.0, 134.0, 106.0];\n    let res2 = cholesky(m2, dimension);\n    show_matrix(res2, dimension);\n}\n",
    "title": "Cholesky decomposition",
    "url": "http://rosettacode.org/wiki/Cholesky_decomposition"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Chowla numbers",
    "url": "http://rosettacode.org/wiki/Chowla_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::rc::Rc;\nuse std::ops::{Add, Mul};\n\n#[derive(Clone)]\nstruct Church<'a, T: 'a> {\n    runner: Rc<dyn Fn(Rc<dyn Fn(T) -> T + 'a>) -> Rc<dyn Fn(T) -> T + 'a> + 'a>,\n}\n\nimpl<'a, T> Church<'a, T> {\n    fn zero() -> Self {\n        Church {\n            runner: Rc::new(|_f| {\n                Rc::new(|x| x)\n            })\n        }\n    }\n\n    fn succ(self) -> Self {\n        Church {\n            runner: Rc::new(move |f| {\n                let g = self.runner.clone();\n                Rc::new(move |x| f(g(f.clone())(x)))\n            })\n        }\n    }\n\n    fn run(&self, f: impl Fn(T) -> T + 'a) -> Rc<dyn Fn(T) -> T + 'a> {\n        (self.runner)(Rc::new(f))\n    }\n\n    fn exp(self, rhs: Church<'a, Rc<dyn Fn(T) -> T + 'a>>) -> Self\n    {\n        Church {\n            runner: (rhs.runner)(self.runner)\n        }\n    }\n}\n\nimpl<'a, T> Add for Church<'a, T> {\n    type Output = Church<'a, T>;\n\n    fn add(self, rhs: Church<'a, T>) -> Church<T> {\n        Church {\n            runner: Rc::new(move |f| {\n                let self_runner = self.runner.clone();\n                let rhs_runner = rhs.runner.clone();\n                Rc::new(move |x| (self_runner)(f.clone())((rhs_runner)(f.clone())(x)))\n            })\n        }\n    }\n}\n\nimpl<'a, T> Mul for Church<'a, T> {\n    type Output = Church<'a, T>;\n\n    fn mul(self, rhs: Church<'a, T>) -> Church<T> {\n        Church {\n            runner: Rc::new(move |f| {\n                (self.runner)((rhs.runner)(f))\n            })\n        }\n    }\n}\n\nimpl<'a, T> From<i32> for Church<'a, T> {\n    fn from(n: i32) -> Church<'a, T> {\n        let mut ret = Church::zero();\n        for _ in 0..n {\n            ret = ret.succ();\n        }\n        ret\n    }\n}\n\nimpl<'a> From<&Church<'a, i32>> for i32  {\n    fn from(c: &Church<'a, i32>) -> i32 {\n        c.run(|x| x + 1)(0)\n    }\n}\n\nfn three<'a, T>() -> Church<'a, T> {\n    Church::zero().succ().succ().succ()\n}\n\nfn four<'a, T>() -> Church<'a, T> {\n    Church::zero().succ().succ().succ().succ()\n}\n\nfn main() {\n    println!(\"three =\\t{}\", i32::from(&three()));\n    println!(\"four =\\t{}\", i32::from(&four()));\n\n    println!(\"three + four =\\t{}\", i32::from(&(three() + four())));\n    println!(\"three * four =\\t{}\", i32::from(&(three() * four())));\n\n    println!(\"three ^ four =\\t{}\", i32::from(&(three().exp(four()))));\n    println!(\"four ^ three =\\t{}\", i32::from(&(four().exp(three()))));\n}",
    "title": "Church Numerals",
    "url": "http://rosettacode.org/wiki/Church_Numerals"
  },
  {
    "local_code": "//! Translation of C.\n\nuse std::f64;\nuse std::fmt;\n\n#[derive(Clone, Copy)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\nfn distance(p1: Point, p2: Point) -> f64 {\n    ((p1.x - p2.x).powi(2) + (p1.y - p2.y).powi(2)).sqrt()\n}\n\nimpl fmt::Display for Point {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"({:.4}, {:.4})\", self.x, self.y)\n    }\n}\n\nfn describe_circle(p1: Point, p2: Point, r: f64) {\n    let sep = distance(p1, p2);\n\n    if (sep - 0.).abs() < f64::EPSILON {\n        if r == 0. {\n            println!(\"No circles can be drawn through {}\", p1);\n        } else {\n            println!(\"Infinitely many circles can be drawn through {}\", p1);\n        }\n    } else if (sep - 2.0 * r).abs() < f64::EPSILON {\n        println!(\n            \"Given points are opposite ends of a diameter of the circle with center \\\n             ({:.4},{:.4}) and r {:.4}\",\n            (p1.x + p2.x) / 2.0,\n            (p1.y + p2.y) / 2.0,\n            r\n        );\n    } else if (sep - 2.0 * r).abs() < f64::EPSILON {\n        println!(\n            \"Given points are farther away from each other than a diameter of a circle with \\\n             r {:.4}\",\n            r\n        );\n    } else {\n        let mirror_dist = (r.powi(2) - (sep / 2.0).powi(2)).sqrt();\n\n        println!(\"Two circles are possible.\");\n        println!(\n            \"Circle C1 with center ({:.4}, {:.4}), r {:.4} and Circle C2 with center \\\n             ({:.4}, {:.4}), r {:.4}\",\n            ((p1.x + p2.x) / 2.0) + mirror_dist * (p1.y - p2.y) / sep,\n            (p1.y + p2.y) / 2.0 + mirror_dist * (p2.x - p1.x) / sep,\n            r,\n            (p1.x + p2.x) / 2.0 - mirror_dist * (p1.y - p2.y) / sep,\n            (p1.y + p2.y) / 2.0 - mirror_dist * (p2.x - p1.x) / sep,\n            r\n        );\n    }\n}\n\nfn main() {\n    let points = vec![\n        (\n            Point {\n                x: 0.1234,\n                y: 0.9876,\n            },\n            Point {\n                x: 0.8765,\n                y: 0.2345,\n            },\n        ),\n        (\n            Point {\n                x: 0.0000,\n                y: 2.0000,\n            },\n            Point {\n                x: 0.0000,\n                y: 0.0000,\n            },\n        ),\n        (\n            Point {\n                x: 0.1234,\n                y: 0.9876,\n            },\n            Point {\n                x: 0.1234,\n                y: 0.9876,\n            },\n        ),\n        (\n            Point {\n                x: 0.1234,\n                y: 0.9876,\n            },\n            Point {\n                x: 0.8765,\n                y: 0.2345,\n            },\n        ),\n        (\n            Point {\n                x: 0.1234,\n                y: 0.9876,\n            },\n            Point {\n                x: 0.1234,\n                y: 0.9876,\n            },\n        ),\n    ];\n    let radii: Vec<f64> = vec![2.0, 1.0, 2.0, 0.5, 0.0];\n\n    for (p, r) in points.into_iter().zip(radii.into_iter()) {\n        println!(\"\\nPoints: ({}, {}), Radius: {:.4}\", p.0, p.1, r);\n        describe_circle(p.0, p.1, r);\n    }\n}\n",
    "path": "tasks/circles-of-given-radius-through-two-points",
    "remote_code": "use std::fmt;\n\n#[derive(Clone,Copy)]\nstruct Point {\n    x: f64,\n    y: f64\n}\n\nfn distance (p1: Point, p2: Point) -> f64 {\n    ((p1.x - p2.x).powi(2) + (p1.y - p2.y).powi(2)).sqrt()\n}\n\nimpl fmt::Display for Point {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"({:.4}, {:.4})\", self.x, self.y)\n    }\n}\n\nfn describe_circle(p1: Point, p2: Point, r: f64) {\n    let sep = distance(p1, p2);\n\n    if sep == 0. {\n        if r == 0. {\n            println!(\"No circles can be drawn through {}\", p1);\n        } else {\n            println!(\"Infinitely many circles can be drawn through {}\", p1);\n        }\n    } else if sep == 2.0 * r {\n        println!(\"Given points are opposite ends of a diameter of the circle with center ({:.4},{:.4}) and r {:.4}\",\n                (p1.x+p2.x) / 2.0, (p1.y+p2.y) / 2.0, r);\n    } else if sep > 2.0 * r {\n        println!(\"Given points are farther away from each other than a diameter of a circle with r {:.4}\", r);\n    } else {\n        let mirror_dist = (r.powi(2) - (sep / 2.0).powi(2)).sqrt();\n\n        println!(\"Two circles are possible.\");\n        println!(\"Circle C1 with center ({:.4}, {:.4}), r {:.4} and Circle C2 with center ({:.4}, {:.4}), r {:.4}\",\n                ((p1.x + p2.x) / 2.0) + mirror_dist * (p1.y-p2.y)/sep, (p1.y+p2.y) / 2.0 + mirror_dist*(p2.x-p1.x)/sep,\n                r,\n                (p1.x+p2.x) / 2.0 - mirror_dist*(p1.y-p2.y)/sep, (p1.y+p2.y) / 2.0 - mirror_dist*(p2.x-p1.x)/sep, r);\n    }\n}\n\nfn main() {\n    let points: Vec<(Point, Point)> = vec![\n        (Point { x: 0.1234, y: 0.9876 }, Point { x: 0.8765, y: 0.2345 }),\n        (Point { x: 0.0000, y: 2.0000 }, Point { x: 0.0000, y: 0.0000 }),\n        (Point { x: 0.1234, y: 0.9876 }, Point { x: 0.1234, y: 0.9876 }),\n        (Point { x: 0.1234, y: 0.9876 }, Point { x: 0.8765, y: 0.2345 }),\n        (Point { x: 0.1234, y: 0.9876 }, Point { x: 0.1234, y: 0.9876 })\n    ];\n    let radii: Vec<f64> = vec![2.0, 1.0, 2.0, 0.5, 0.0];\n\n    for (p, r) in points.into_iter().zip(radii.into_iter()) {\n        println!(\"\\nPoints: ({}, {}), Radius: {:.4}\", p.0, p.1, r);\n        describe_circle(p.0, p.1, r);\n    }\n}",
    "title": "Circles of given radius through two points",
    "url": "http://rosettacode.org/wiki/Circles_of_given_radius_through_two_points"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nstruct MyClass {\n    variable: i32, // member variable = instance variable\n}\n\nimpl MyClass {\n    // member function = method, with its implementation\n    fn some_method(&mut self) {\n        self.variable = 1;\n    }\n\n    // constructor, with its implementation\n    fn new() -> MyClass {\n        // Here could be more code.\n        MyClass { variable: 0 }\n    }\n}\n\nfn main () {\n    // Create an instance in the stack.\n    let mut instance = MyClass::new();\n\n    // Create an instance in the heap.\n    let mut p_instance = Box::<_>::new(MyClass::new());\n\n    // Invoke method on both istances,\n    instance.some_method();\n    p_instance.some_method();\n\n    // Both instances are automatically deleted when their scope ends.\n}\n",
    "title": "Classes",
    "url": "http://rosettacode.org/wiki/Classes"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Closest-pair_problem\n\n//! We interpret complex numbers as points in the Cartesian plane, here. We also use the\n//! [sweepline/plane sweep closest pairs algorithm][algorithm] instead of the divide-and-conquer\n//! algorithm, since it's (arguably) easier to implement, and an efficient implementation does not\n//! require use of unsafe.\n//!\n//! [algorithm]: http://www.cs.mcgill.ca/~cs251/ClosestPair/ClosestPairPS.html\nextern crate num;\n\nuse num::complex::Complex;\nuse std::cmp::{Ordering, PartialOrd};\nuse std::collections::BTreeSet;\ntype Point = Complex<f32>;\n\n/// Wrapper around `Point` (i.e. `Complex<f32>`) so that we can use a `TreeSet`\n#[derive(PartialEq)]\nstruct YSortedPoint {\n    point: Point,\n}\n\nimpl PartialOrd for YSortedPoint {\n    fn partial_cmp(&self, other: &YSortedPoint) -> Option<Ordering> {\n        (self.point.im, self.point.re).partial_cmp(&(other.point.im, other.point.re))\n    }\n}\n\nimpl Ord for YSortedPoint {\n    fn cmp(&self, other: &YSortedPoint) -> Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\n\nimpl Eq for YSortedPoint {}\n\nfn closest_pair(points: &mut [Point]) -> Option<(Point, Point)> {\n    if points.len() < 2 {\n        return None;\n    }\n\n    points.sort_by(|a, b| (a.re, a.im).partial_cmp(&(b.re, b.im)).unwrap());\n\n    let mut closest_pair = (points[0], points[1]);\n    let mut closest_distance_sqr = (points[0] - points[1]).norm_sqr();\n    let mut closest_distance = closest_distance_sqr.sqrt();\n\n    // the strip that we inspect for closest pairs as we sweep right\n    let mut strip: BTreeSet<YSortedPoint> = BTreeSet::new();\n    strip.insert(YSortedPoint { point: points[0] });\n    strip.insert(YSortedPoint { point: points[1] });\n\n    // index of the leftmost point on the strip (on points)\n    let mut leftmost_idx = 0;\n\n    // Start the sweep!\n    for (idx, point) in points.iter().enumerate().skip(2) {\n        // Remove all points farther than `closest_distance` away from `point`\n        // along the x-axis\n        while leftmost_idx < idx {\n            let leftmost_point = &points[leftmost_idx];\n            if (leftmost_point.re - point.re).powi(2) < closest_distance_sqr {\n                break;\n            }\n            strip.remove(&YSortedPoint {\n                point: *leftmost_point,\n            });\n            leftmost_idx += 1;\n        }\n\n        // Compare to points in bounding box\n        {\n            let low_bound = YSortedPoint {\n                point: Point {\n                    re: ::std::f32::INFINITY,\n                    im: point.im - closest_distance,\n                },\n            };\n            let mut strip_iter = strip.iter().skip_while(|&p| p < &low_bound);\n            loop {\n                let point2 = match strip_iter.next() {\n                    None => break,\n                    Some(p) => p.point,\n                };\n                if point2.im - point.im >= closest_distance {\n                    // we've reached the end of the box\n                    break;\n                }\n                let dist_sqr = (*point - point2).norm_sqr();\n                if dist_sqr < closest_distance_sqr {\n                    closest_pair = (point2, *point);\n                    closest_distance_sqr = dist_sqr;\n                    closest_distance = dist_sqr.sqrt();\n                }\n            }\n        }\n\n        // Insert point into strip\n        strip.insert(YSortedPoint { point: *point });\n    }\n\n    Some(closest_pair)\n}\n\npub fn main() {\n    let mut test_data = [\n        Complex::new(0.654682, 0.925557),\n        Complex::new(0.409382, 0.619391),\n        Complex::new(0.891663, 0.888594),\n        Complex::new(0.716629, 0.996200),\n        Complex::new(0.477721, 0.946355),\n        Complex::new(0.925092, 0.818220),\n        Complex::new(0.624291, 0.142924),\n        Complex::new(0.211332, 0.221507),\n        Complex::new(0.293786, 0.691701),\n        Complex::new(0.839186, 0.728260),\n    ];\n    let (p1, p2) = closest_pair(&mut test_data[..]).unwrap();\n    println!(\"Closest pair: {} and {}\", p1, p2);\n    println!(\"Distance: {}\", (p1 - p2).norm_sqr().sqrt());\n}\n\n#[cfg(test)]\nmod tests {\n    use super::closest_pair;\n    use num::complex::Complex;\n\n    #[test]\n    fn random_floats() {\n        let mut test_data = [\n            Complex::new(0.654682, 0.925557),\n            Complex::new(0.409382, 0.619391),\n            Complex::new(0.891663, 0.888594),\n            Complex::new(0.716629, 0.996200),\n            Complex::new(0.477721, 0.946355),\n            Complex::new(0.925092, 0.818220),\n            Complex::new(0.624291, 0.142924),\n            Complex::new(0.211332, 0.221507),\n            Complex::new(0.293786, 0.691701),\n            Complex::new(0.839186, 0.728260),\n        ];\n        let (p1, p2) = closest_pair(&mut test_data[..]).unwrap();\n        assert!((p1.re - 0.891663).abs() < 1e-6f32);\n        assert!((p1.im - 0.888594).abs() < 1e-6f32);\n        assert!((p2.re - 0.925092).abs() < 1e-6f32);\n        assert!((p2.im - 0.818220).abs() < 1e-6f32);\n        assert!(((p1 - p2).norm_sqr() - 0.0779102f32.powi(2)).abs() < 1e-6f32);\n    }\n}\n",
    "path": "tasks/closest-pair-problem",
    "remote_code": null,
    "title": "Closest-pair problem",
    "url": "http://rosettacode.org/wiki/Closest-pair_problem"
  },
  {
    "local_code": "use std::iter::Map;\nuse std::ops::RangeFrom;\n\n#[allow(dead_code)]\nfn simple_unboxed() {\n    // simple usage when unboxed closures will do\n    let mut v = Vec::new();\n    for i in 0..10 {\n        v.push(move || i * i);\n    }\n    println!(\"7th val: {}\", v[7]());\n}\n\n// given a number x, return the (boxed) closure that\n// computes x squared\nfn closure_gen<'a>(x: u32) -> Box<dyn Fn() -> f64 + 'a> {\n    Box::new(move || f64::from(x).powi(2))\n}\n\n// type alias for the closure iterator\ntype ClosureIter<'a> = Map<RangeFrom<u32>, fn(u32) -> Box<dyn Fn() -> f64 + 'a>>;\n\n// return an iterator that on every iteration returns\n// a closure computing the index of the iteration squared\nfn closures_iterator<'a>() -> ClosureIter<'a> {\n    let cl_gen: fn(u32) -> Box<dyn Fn() -> f64 + 'a> = closure_gen;\n    (0..).map(cl_gen)\n}\n\nfn main() {\n    // Take the first 9 closures from the iterator and call them\n    for c in closures_iterator().take(9) {\n        println!(\"{}\", c())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{closure_gen, closures_iterator};\n\n    use std::f64;\n\n    #[test]\n    fn closure_generator() {\n        let five_squarer = closure_gen(5);\n        assert!((five_squarer() - 25f64).abs() < f64::EPSILON);\n    }\n\n    #[test]\n    fn closure_iterator() {\n        for (idx, f) in closures_iterator().take(9).enumerate() {\n            assert!((f() - (idx as f64).powi(2)).abs() < f64::EPSILON);\n        }\n    }\n}\n",
    "path": "tasks/closures/value-capture",
    "remote_code": "fn main() {\n    let fs: Vec<_> = (0..10).map(|i| {move || i*i} ).collect();\n    println!(\"7th val: {}\", fs[7]());\n}",
    "title": "Closures/Value capture",
    "url": "http://rosettacode.org/wiki/Closures/Value_capture"
  },
  {
    "local_code": "//! Examples of various Rust collections. Contains both original examples and those taken from the\n//! standard API documentation.\n\nuse std::collections::{BTreeMap, BinaryHeap, HashMap, HashSet, LinkedList, VecDeque};\n\nfn main() {\n    // Stack-allocated collections\n    // ---------------------------\n\n    // Array\n    //\n    // Arrays ([T]) are stack allocated, fixed size collections of items of the same type.\n    let a = [1u8, 2, 3, 4, 5]; // a is of type [u8; 5];\n    let b = [0; 256]; // Equivalent to `let b = [0, 0, 0, 0, 0, 0... repeat 256 times]`\n    assert_eq!(a.len(), 5);\n    assert_eq!(b.len(), 256);\n\n    // Slice\n    //\n    // Slices (&[T]) are dynamically sized views into contiguous sequences (arrays, vectors,\n    // strings)\n    let array = [1, 2, 3, 4, 5];\n    let slice = &array[0..2];\n    println!(\"{:?}\", slice); // Output: [1, 2]\n\n    // String slice\n    //\n    // String slices are (str) are slices of Unicode characters. Plain strs are almost never seen\n    // in Rust. Instead either heap-allocated Strings or borrowed string slices (&str which is\n    // basically equivalent to a slice of bytes: &[u8]) are more often used. It should be noted\n    // that strings are not indexable as they are UTF-8 (meaning that characters are not\n    // necessarily of a fixed size) however iterators can be created over codepoints or graphemes.\n    let string = \"this is a string slice\";\n    println!(\"{}\", string);\n\n    // Heap-allocated collections\n    // --------------------------\n\n    // Vector\n    //\n    // Vectors (Vec<T>) are a growable list type. According to the Rust documentation, you want to\n    // use a Vector if:\n    // - You want to collect items up to be processed or sent elsewhere later, and don't care about\n    //   any properties of the actual values being stored.\n    // - You want a sequence of elements in a particular order, and will only be appending to (or\n    //   near) the end.\n    // - You want a stack.\n    // - You want a resizable array.\n    // - You want a heap-allocated array.\n    let mut v1 = Vec::new();\n    v1.push(1);\n    v1.push(2);\n    v1.push(3);\n\n    // Or (mostly) equivalently via a convenient macro in the standard library,\n    let v2 = vec![1, 2, 3];\n    assert_eq!(v1, v2);\n\n    // String\n    //\n    // Strings are growable strings stored as a UTF-8 buffer which are just Vec<u8>s under the\n    // hood. Like strs, they are not indexable (for the same reasons) but iterators can be created\n    // over the graphemes, codepoints or bytes therein.\n    let x = \"abc\"; // x is of type &str (a borrowed string slice)\n    let s1 = String::from(x);\n    assert_eq!(x, &s1);\n\n    // or alternatively,\n    let s2 = x.to_owned();\n    assert_eq!(s1, s2);\n\n    // VecDequeue\n    //\n    // A growable ring buffer. According to the Rust documentation you should use VecDequeue<T>\n    // when:\n    // - You want a Vec that supports efficient insertion at both ends of the sequence.\n    // - You want a queue.\n    // - You want a double-ended queue (deque).\n    let mut deque = VecDeque::new();\n    deque.push_back(3);\n    deque.push_back(4);\n    deque.push_back(5);\n    assert_eq!(deque.get(1), Some(&4));\n\n    // Linked List\n    //\n    // A doubly-linked list. According to the Rust documentation, you should use it when:\n    // - You want a Vec or VecDeque of unknown size, and can't tolerate amortization.\n    // - You want to efficiently split and append lists.\n    // - You are absolutely certain you really, truly, want a doubly linked list.\n    let mut a = LinkedList::new();\n    let mut b = LinkedList::new();\n    a.push_back(1);\n    a.push_back(2);\n    b.push_back(3);\n    b.push_back(4);\n\n    // A constant-time and -memory operation.\n    a.append(&mut b);\n\n    for e in &a {\n        println!(\"{}\", e); // prints 1, then 2, then 3, then 4\n    }\n\n    // HashMap\n    //\n    // A hash map implementation which uses linear probing with Robin Hood bucket stealing.\n    // According to the Rust documentation, you should use it when:\n    // - You want to associate arbitrary keys with an arbitrary value.\n    // - You want a cache.\n    // - You want a map, with no extra functionality.\n    let mut map = HashMap::new();\n    map.insert(1, \"a\");\n    map.insert(2, \"b\");\n    map.insert(3, \"c\");\n    for (key, value) in map {\n        println!(\"key: {}, value: {}\", key, value);\n    }\n\n    // BTreeMap\n    //\n    // A map based on a B-Tree. According to the Rust documentation, you should use it when:\n    // - You're interested in what the smallest or largest key-value pair is.\n    // - You want to find the largest or smallest key that is smaller or larger than something.\n    // - You want to be able to get all of the entries in order on-demand.\n    // - You want a sorted map.\n    let mut map = BTreeMap::new();\n    map.insert(1, \"a\");\n    map.insert(2, \"b\");\n    map.insert(3, \"c\");\n    assert_eq!(map.get(&1), Some(&\"a\"));\n\n    // HashSet/BTreeSet\n    //\n    // Set implementations that use an empty tuple () as the value of their respective maps (and\n    // implement different methods). They should be used when:\n    // - You just want to remember which keys you've seen.\n    // - There is no meaningful value to associate with your keys.\n    // - You just want a set.\n    let mut set = HashSet::new();\n    set.insert(1);\n    set.insert(2);\n    set.insert(3);\n    set.insert(2);\n    assert_eq!(set.len(), 3);\n\n    // BinaryHeap\n    //\n    // A priority queue implemented with a binary heap. You should use it when\n    // - You want to store a bunch of elements, but only ever want to process the \"biggest\" or\n    //   \"most important\" one at any given time.\n    // - You want a priority queue.\n    let mut heap = BinaryHeap::new();\n    heap.push(1);\n    heap.push(5);\n    heap.push(2);\n    assert_eq!(heap.peek(), Some(&5));\n}\n",
    "path": "tasks/collections",
    "remote_code": "let a = [1u8,2,3,4,5]; // a is of type [u8; 5];\nlet b = [0;256] // Equivalent to `let b = [0,0,0,0,0,0... repeat 256 times]`",
    "title": "Collections",
    "url": "http://rosettacode.org/wiki/Collections"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Color of a screen pixel",
    "url": "http://rosettacode.org/wiki/Color_of_a_screen_pixel"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Color quantization",
    "url": "http://rosettacode.org/wiki/Color_quantization"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Colour bars/Display",
    "url": "http://rosettacode.org/wiki/Colour_bars/Display"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Colour pinstripe/Display",
    "url": "http://rosettacode.org/wiki/Colour_pinstripe/Display"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Colour pinstripe/Printer",
    "url": "http://rosettacode.org/wiki/Colour_pinstripe/Printer"
  },
  {
    "local_code": "use std::fmt::Display;\n\nfn comb<T>(arr: &[T], n: u32)\nwhere\n    T: Display,\n{\n    let mut incl_arr = vec![false; arr.len()];\n    comb_intern(arr, n as usize, &mut incl_arr, 0);\n}\n\nfn comb_intern<T>(arr: &[T], n: usize, incl_arr: &mut [bool], index: usize)\nwhere\n    T: Display,\n{\n    if arr.len() < n + index {\n        return;\n    }\n    if n == 0 {\n        let it = arr.iter().zip(incl_arr.iter()).filter_map(\n            |(val, incl)| {\n                if *incl {\n                    Some(val)\n                } else {\n                    None\n                }\n            },\n        );\n        for val in it {\n            print!(\"{} \", *val);\n        }\n        println!();\n        return;\n    }\n\n    incl_arr[index] = true;\n    comb_intern(arr, n - 1, incl_arr, index + 1);\n    incl_arr[index] = false;\n\n    comb_intern(arr, n, incl_arr, index + 1);\n}\n\nfn main() {\n    let vec1 = vec![1, 2, 3, 4, 5];\n    comb(&vec1, 3);\n\n    let vec2 = vec![\"A\", \"B\", \"C\", \"D\", \"E\"];\n    comb(&vec2, 3);\n}\n",
    "path": "tasks/combinations",
    "remote_code": "\nfn comb<T: std::fmt::Default>(arr: &[T], n: uint) {\n  let mut incl_arr: ~[bool] = std::vec::from_elem(arr.len(), false);\n  comb_intern(arr, n, incl_arr, 0);\n}\n\nfn comb_intern<T: std::fmt::Default>(arr: &[T], n: uint, incl_arr: &mut [bool], index: uint) {\n  if (arr.len() < n + index) { return; }\n  if (n == 0) {\n    let mut it = arr.iter().zip(incl_arr.iter()).filter_map(|(val, incl)|\n      if (*incl) { Some(val) } else { None }\n    );\n    for val in it { print!(\"{} \", *val); }\n    print(\"\\n\");\n    return;\n  }\n\n  incl_arr[index] = true;\n  comb_intern(arr, n-1, incl_arr, index+1);\n  incl_arr[index] = false;\n\n  comb_intern(arr, n, incl_arr, index+1);\n}\n\nfn main() {\n  let arr1 = ~[1, 2, 3, 4, 5];\n  comb(arr1, 3);\n\n  let arr2 = ~[\"A\", \"B\", \"C\", \"D\", \"E\"];\n  comb(arr2, 3);\n}\n",
    "title": "Combinations",
    "url": "http://rosettacode.org/wiki/Combinations"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Combinations and permutations",
    "url": "http://rosettacode.org/wiki/Combinations_and_permutations"
  },
  {
    "local_code": "// Iterator for the combinations of `arr` with `k` elements with repetitions.\n// Yields the combinations in lexicographical order.\nstruct CombinationsWithRepetitions<'a, T: 'a> {\n    // source array to get combinations from\n    arr: &'a [T],\n    // length of the combinations\n    k: u32,\n    // current counts of each object that represent the next combination\n    counts: Vec<u32>,\n    // whether there are any combinations left\n    remaining: bool,\n}\n\nimpl<'a, T> CombinationsWithRepetitions<'a, T> {\n    fn new(arr: &[T], k: u32) -> CombinationsWithRepetitions<T> {\n        let mut counts = vec![0; arr.len()];\n        counts[arr.len() - 1] = k;\n        CombinationsWithRepetitions {\n            arr: arr,\n            k: k,\n            counts: counts,\n            remaining: true,\n        }\n    }\n}\n\nimpl<'a, T> Iterator for CombinationsWithRepetitions<'a, T> {\n    type Item = Vec<&'a T>;\n\n    fn next(&mut self) -> Option<Vec<&'a T>> {\n        if !self.remaining {\n            return None;\n        }\n        let mut comb = Vec::new();\n        for (count, item) in self.counts.iter().zip(self.arr.iter()) {\n            for _ in 0..*count {\n                comb.push(item);\n            }\n        }\n        // this is lexicographically largest, and thus the last combination\n        if self.counts[0] == self.k {\n            self.remaining = false;\n        } else {\n            let n = self.counts.len();\n            for i in (1..n).rev() {\n                if self.counts[i] > 0 {\n                    let original_value = self.counts[i];\n                    self.counts[i - 1] += 1;\n                    for j in i..(n - 1) {\n                        self.counts[j] = 0;\n                    }\n                    self.counts[n - 1] = original_value - 1;\n                    break;\n                }\n            }\n        }\n        Some(comb)\n    }\n}\n\nfn main() {\n    let collection = vec![\"iced\", \"jam\", \"plain\"];\n    for comb in CombinationsWithRepetitions::new(&collection, 2) {\n        for item in &comb {\n            print!(\"{} \", item)\n        }\n        println!()\n    }\n}\n",
    "path": "tasks/combinations-with-repetitions",
    "remote_code": null,
    "title": "Combinations with repetitions",
    "url": "http://rosettacode.org/wiki/Combinations_with_repetitions"
  },
  {
    "local_code": "fn quibble(seq: &[&str]) -> String {\n    match seq.len() {\n        0 => \"{}\".to_string(),\n        1 => format!(\"{{{}}}\", seq[0]),\n        _ => format!(\n            \"{{{} and {}}}\",\n            seq[..seq.len() - 1].join(\", \"),\n            seq.last().unwrap()\n        ),\n    }\n}\n\nfn main() {\n    println!(\"{}\", quibble(&[]));\n    println!(\"{}\", quibble(&[\"ABC\"]));\n    println!(\"{}\", quibble(&[\"ABC\", \"DEF\"]));\n    println!(\"{}\", quibble(&[\"ABC\", \"DEF\", \"G\", \"H\"]));\n}\n\n#[test]\nfn output() {\n    assert_eq!(quibble(&[]), \"{}\");\n    assert_eq!(quibble(&[\"ABC\"]), \"{ABC}\");\n    assert_eq!(quibble(&[\"ABC\", \"DEF\"]), \"{ABC and DEF}\");\n    assert_eq!(quibble(&[\"ABC\", \"DEF\", \"G\", \"H\"]), \"{ABC, DEF, G and H}\");\n}\n",
    "path": "tasks/comma-quibbling",
    "remote_code": "\nfn quibble(seq: &[&str]) -> String {\n    match seq.len() {\n        0 => \"{}\".to_string(),\n        1 => format!(\"{{{}}}\", seq[0]),\n        _ => {\n            format!(\"{{{} and {}}}\",\n                    seq[..seq.len() - 1].join(\", \"),\n                    seq.last().unwrap())\n        }\n    }\n}\n\nfn main() {\n    println!(\"{}\", quibble(&[]));\n    println!(\"{}\", quibble(&[\"ABC\"]));\n    println!(\"{}\", quibble(&[\"ABC\", \"DEF\"]));\n    println!(\"{}\", quibble(&[\"ABC\", \"DEF\", \"G\", \"H\"]));\n}\n",
    "title": "Comma quibbling",
    "url": "http://rosettacode.org/wiki/Comma_quibbling"
  },
  {
    "local_code": "use std::env;\n\nfn main() {\n    for arg in env::args() {\n        println!(\"{}\", arg);\n    }\n}\n",
    "path": "tasks/command-line-arguments",
    "remote_code": "use std::env;\n\nfn main(){\n    let args: Vec<_> = env::args().collect();\n    println!(\"{:?}\", args);\n}",
    "title": "Command-line arguments",
    "url": "http://rosettacode.org/wiki/Command-line_arguments"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Commatizing numbers",
    "url": "http://rosettacode.org/wiki/Commatizing_numbers"
  },
  {
    "local_code": "//! A module level comment\n\n// A single line comment\n\n/*\n *  This is a multi-line (aka block) comment\n *\n *  /*\n *   *  containing nested multi-line comment\n *   *  (nesting supported since 0.9-pre https://github.com/rust-lang/rust/issues/9468)\n *   */\n*/\n\n/// Outer single line Rustdoc comments apply to the next item.\n\n/**\n *  Outer multi-line Rustdoc comments.\n *\n *  Leading asterisk (*) in multi-line Rustdoc comments\n *  is not considered to be part of the comment text,\n *  blanks and tabs preceding the initial asterisk (*) are also stripped.\n */\nfn example1() {\n    //! Inner single line Rustdoc comments apply to their enclosing item.\n\n    /*!\n     *  Inner multi-line Rustdoc comments.\n     *  See also https://doc.rust-lang.org/book/documentation.html\n     */\n}\n\n#[doc = \"Unsugared outer Rustdoc comments.\n        (outer attributes are not terminated by a semi-colon)\"]\nfn example2() {\n    #![doc = \"Unsugared inner Rustdoc comments.\n              See also https://doc.rust-lang.org/book/documentation.html\"]\n}\n\nfn main() {\n    example1();\n    example2();\n}\n",
    "path": "tasks/comments",
    "remote_code": "// A single line comment\n\n/*\n    This is a multi-line (aka block) comment\n\n    /*\n        containing nested multi-line comment\n        (nesting supported since 0.9-pre https://github.com/mozilla/rust/issues/9468)\n    */\n*/\n\n\n/// Outer single line Rustdoc comments apply to the next item.\n\n/**\n    Outer multi-line Rustdoc comments.\n\n *  Leading asterisk (*) in multi-line Rustdoc comments\n *  is not considered to be part of the comment text,\n *  blanks and tabs preceding the initial asterisk (*) are also stripped.\n*/\n\nfn example() {\n\n    //! Inner single line Rustdoc comments apply to their enclosing item.\n\n    /*!\n        Inner multi-line Rustdoc comments.\n        See also https://github.com/mozilla/rust/wiki/Doc-using-rustdoc\n    */\n}\n\n#[doc = \"Unsugared outer Rustdoc comments.\n        (outer attributes are not terminated by a semi-colon)\"]\nfn example() {\n    #[doc = \"Unsugared inner Rustdoc comments.\n            (inner attributes are terminated by a semi-colon)\n            See also https://github.com/mozilla/rust/blob/master/doc/rust.md#attributes\"];\n}",
    "title": "Comments",
    "url": "http://rosettacode.org/wiki/Comments"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// Note that this solution uses the feature 'slice_patterns' which is available Rust nightly!\n#![feature(slice_patterns)]\n\nfn strings_are_equal(seq: &[&str]) -> bool {\n    match seq {\n        &[] | &[_] => true,\n        &[x, y, ref tail..] if x == y => strings_are_equal(&[&[y], tail].concat()),\n        _ => false\n    }\n}\n\nfn asc_strings(seq: &[&str]) -> bool {\n    match seq {\n        &[] | &[_] => true,\n        &[x, y, ref tail..] if x < y => asc_strings(&[&[y], tail].concat()),\n        _ => false\n    }\n}",
    "title": "Compare a list of strings",
    "url": "http://rosettacode.org/wiki/Compare_a_list_of_strings"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Compare sorting algorithms' performance",
    "url": "http://rosettacode.org/wiki/Compare_sorting_algorithms'_performance"
  },
  {
    "local_code": "#![feature(proc_macro_hygiene)]\n\nextern crate factorial_macro;\n\nuse factorial_macro::factorial;\n\nfn main() {\n    // we can invoke factorial_10! as a regular macro\n    println!(\"{}\", factorial!(10));\n}\n\n#[test]\nfn output() {\n    // just testing the output\n    // I can't prove programmatically that factorial_10 is actually\n    // calculated at compile time\n    assert_eq!(factorial!(10), 3628800);\n}\nextern crate proc_macro;\n#[macro_use]\nextern crate quote;\nextern crate syn;\n\nuse proc_macro::TokenStream;\nuse syn::{ExprLit, Lit};\n\n#[proc_macro]\npub fn factorial(input: TokenStream) -> TokenStream {\n    match syn::parse(input) {\n        Ok(ExprLit {\n            lit: Lit::Int(lit), ..\n        }) => {\n            let result: u64 = (1..=lit.value()).product();\n            result.to_string().parse().unwrap()\n        }\n        _ => quote!(compile_error!(\"argument must be an integer literal\")).into(),\n    }\n}\n",
    "path": "tasks/compile-time-calculation",
    "remote_code": "fn factorial(n: i64) -> i64 {\n    let mut total = 1;\n    for i in 1..n+1 {\n        total *= i;\n    }\n    return total;\n}\n\nfn main() {\n    println!(\"Factorial of 10 is {}.\", factorial(10));\n}",
    "title": "Compile-time calculation",
    "url": "http://rosettacode.org/wiki/Compile-time_calculation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Compiler/AST interpreter",
    "url": "http://rosettacode.org/wiki/Compiler/AST_interpreter"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Compiler/code generator",
    "url": "http://rosettacode.org/wiki/Compiler/code_generator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Compiler/lexical analyzer",
    "url": "http://rosettacode.org/wiki/Compiler/lexical_analyzer"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Compiler/syntax analyzer",
    "url": "http://rosettacode.org/wiki/Compiler/syntax_analyzer"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Compiler/virtual machine interpreter",
    "url": "http://rosettacode.org/wiki/Compiler/virtual_machine_interpreter"
  },
  {
    "local_code": "//! There are three kinds of `structs` in Rust, two of which would be suitable to represent a\n//! point.\n\n/// C-like struct.\n///\n/// Defines a generic struct where x and y can be of any type `T`.\nstruct Point<T> {\n    x: T,\n    y: T,\n}\n\n/// Tuple struct\n///\n/// These are basically just named tuples.\nstruct TuplePoint<T>(T, T);\n\nfn main() {\n    let p1 = Point { x: 1.0, y: 2.5 }; // p is of type Point<f64>\n    println!(\"{}, {}\", p1.x, p1.y);\n\n    let p2 = TuplePoint(1.0, 2.5);\n    println!(\"{}, {}\", p2.0, p2.1);\n\n    // A plain tuple may also be used.\n    let p3 = (1.0, 2.5);\n    println!(\"{}, {}\", p3.0, p3.1)\n}\n",
    "path": "tasks/compound-data-type",
    "remote_code": " // Defines a generic struct where x and y can be of any type T\nstruct Point<T> {\n    x: T,\n    y: T,\n}\nfn main() {\n    let p = Point { x: 1.0, y: 2.5 }; // p is of type Point<f64>\n    println!(\"{}, {}\", p.x, p.y);\n} ",
    "title": "Compound data type",
    "url": "http://rosettacode.org/wiki/Compound_data_type"
  },
  {
    "local_code": "extern crate rand;\n\nuse std::thread;\nuse std::time::Duration;\n\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut thread_spawn = |string| {\n        // We use a random u8 (so an integer from 0 to 255)\n        let duration = u64::from(rng.gen::<u8>());\n        thread::spawn(move || {\n            thread::sleep(Duration::from_millis(duration));\n            println!(\"{}\", string);\n        })\n    };\n\n    let children = vec![\n        thread_spawn(\"Enjoy\"),\n        thread_spawn(\"Rosetta\"),\n        thread_spawn(\"Code\"),\n    ];\n\n    for child in children {\n        child.join().unwrap();\n    }\n}\n",
    "path": "tasks/concurrent-computing",
    "remote_code": "extern crate rand;\nuse std::thread;\nuse rand::thread_rng;\nuse rand::distributions::{Range, IndependentSample};\n\nfn main() {\n    let mut rng = thread_rng();\n    let rng_range = Range::new(0u32, 100);\n    for word in \"Enjoy Rosetta Code\".split_whitespace() {\n        let snooze_time = rng_range.ind_sample(&mut rng);\n        let local_word = word.to_owned();\n        std::thread::spawn(move || {\n            thread::sleep_ms(snooze_time);\n            println!(\"{}\", local_word);\n        });\n    }\n    thread::sleep_ms(1000);\n}",
    "title": "Concurrent computing",
    "url": "http://rosettacode.org/wiki/Concurrent_computing"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// This function will only be compiled if we are compiling on Linux\n#[cfg(target_os = \"linux\")]\nfn running_linux() {\n    println!(\"This is linux\");\n}\n#[cfg(not(target_os = \"linux\"))]\nfn running_linux() {\n    println!(\"This is not linux\");\n}\n\n// If we are on linux, we must be using glibc\n#[cfg_attr(target_os = \"linux\", target_env = \"gnu\")]\n// We must either be compiling for ARM or on a little endian machine that doesn't have 32-bit pointers pointers, on a\n// UNIX like OS and only if we are doing a test build\n#[cfg(all(\n        any(target_arch = \"arm\", target_endian = \"little\"),\n        not(target_pointer_width = \"32\"),\n        unix,\n        test\n        ))]\nfn highly_specific_function() {}\n",
    "title": "Conditional structures",
    "url": "http://rosettacode.org/wiki/Conditional_structures"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nextern crate num; // crate for complex numbers\n\nuse num::complex::Complex;\nuse std::ops::Mul;\nuse std::fmt;\n\n\n#[derive(Debug, PartialEq)]\nstruct Matrix<f32> {\n    grid: [[Complex<f32>; 2]; 2], // used to represent matrix\n}\n\n\nimpl Matrix<f32> { // implements a method call for calculating the conjugate transpose\n    fn conjugate_transpose(&self) -> Matrix<f32> {\n        Matrix {grid: [[self.grid[0][0].conj(), self.grid[1][0].conj()],\n        [self.grid[0][1].conj(), self.grid[1][1].conj()]]}\n    }\n}\n\nimpl Mul for Matrix<f32> { // implements '*' (multiplication) for the matrix\n    type Output = Matrix<f32>;\n\n    fn mul(self, other: Matrix<f32>) -> Matrix<f32> {\n        Matrix {grid: [[self.grid[0][0]*other.grid[0][0] + self.grid[0][1]*other.grid[1][0],\n            self.grid[0][0]*other.grid[0][1] + self.grid[0][1]*other.grid[1][1]],\n            [self.grid[1][0]*other.grid[0][0] + self.grid[1][1]*other.grid[1][0],\n            self.grid[1][0]*other.grid[1][0] + self.grid[1][1]*other.grid[1][1]]]}\n    }\n}\n\nimpl Copy for Matrix<f32> {} // implemented to prevent 'moved value' errors in if statements below\nimpl Clone for Matrix<f32> {\n    fn clone(&self) -> Matrix<f32> {\n        *self\n    }\n}\n\nimpl fmt::Display for Matrix<f32> { // implemented to make output nicer\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"({}, {})\\n({}, {})\", self.grid[0][0], self.grid[0][1], self.grid[1][0], self.grid[1][1])\n    }\n}\n\nfn main() {\n    let a = Matrix {grid: [[Complex::new(3.0, 0.0), Complex::new(2.0, 1.0)],\n        [Complex::new(2.0, -1.0), Complex::new(1.0, 0.0)]]};\n\n    let b = Matrix {grid: [[Complex::new(0.5, 0.5), Complex::new(0.5, -0.5)],\n        [Complex::new(0.5, -0.5), Complex::new(0.5, 0.5)]]};\n\n    test_type(a);\n    test_type(b);\n}\n\nfn test_type(mat: Matrix<f32>) {\n    let identity = Matrix {grid: [[Complex::new(1.0, 0.0), Complex::new(0.0, 0.0)],\n        [Complex::new(0.0, 0.0), Complex::new(1.0, 0.0)]]};\n    let mat_conj = mat.conjugate_transpose();\n\n    println!(\"Matrix: \\n{}\\nConjugate transpose: \\n{}\", mat, mat_conj);\n\n    if mat == mat_conj {\n        println!(\"Hermitian?: TRUE\");\n    } else {\n        println!(\"Hermitian?: FALSE\");\n    }\n\n    if mat*mat_conj == mat_conj*mat {\n        println!(\"Normal?: TRUE\");\n    } else {\n        println!(\"Normal?: FALSE\");\n    }\n\n    if mat*mat_conj == identity {\n        println!(\"Unitary?: TRUE\");\n    } else {\n        println!(\"Unitary?: FALSE\");\n    }\n}",
    "title": "Conjugate transpose",
    "url": "http://rosettacode.org/wiki/Conjugate_transpose"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n// This declares the \"Eatable\" constraint. It could contain no function.\ntrait Eatable {\n    fn eat();\n}\n\n// This declares the generic \"FoodBox\" type,\n// whose parameter must satisfy the \"Eatable\" constraint.\n// The objects of this type contain a vector of eatable objects.\nstruct FoodBox<T: Eatable> {\n    _data: Vec<T>,\n}\n\n// This implements the functions associated with the \"FoodBox\" type.\n// This statement is not required, but here it is used\n// to declare a handy \"new\" constructor.\nimpl<T: Eatable> FoodBox<T> {\n    fn new() -> FoodBox<T> {\n        FoodBox::<T> { _data: Vec::<T>::new() }\n    }\n}\n\n// This declares a simple type.\nstruct Banana {}\n\n// This makes the \"Banana\" type satisfy the \"Eatable\" constraint.\n// For that, every declaration inside the declaration of \"Eatable\"\n// must be implemented here.\nimpl Eatable for Banana {\n    fn eat() {}\n}\n\n// This makes also the primitive \"char\" type satisfy the \"Eatable\" constraint.\nimpl Eatable for char {\n    fn eat() {}\n}\n\nfn main() {\n    // This instantiate a \"FoodBox\" parameterized by the \"Banana\" type.\n    // It is allowed as \"Banana\" implements \"Eatable\".\n    let _fb1 = FoodBox::<Banana>::new();\n\n    // This instantiate a \"FoodBox\" parameterized by the \"char\" type.\n    // It is allowed, as \"char\" implements \"Eatable\".\n    let _fb2 = FoodBox::<char>::new();\n\n    // This instantiate a \"FoodBox\" parameterized by the \"bool\" type.\n    // It is NOT allowed, as \"bool\" does not implement \"Eatable\".\n    //let _fb3 = FoodBox::<bool>::new();\n}\n",
    "title": "Constrained genericity",
    "url": "http://rosettacode.org/wiki/Constrained_genericity"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::distributions::Uniform;\nuse rand::prelude::*;\n\nconst POINTS_N: usize = 100;\n\nfn generate_point<R: Rng>(rng: &mut R) -> (i32, i32) {\n    // `Uniform` rather than `gen_range`'s `Uniform::sample_single` for speed\n    let range = Uniform::new_inclusive(-15, 15);\n    loop {\n        let x = rng.sample(range); // exclusive\n        let y = rng.sample(range);\n\n        let r2 = x * x + y * y;\n        if r2 >= 100 && r2 <= 225 {\n            return (x, y);\n        }\n    }\n}\n\nfn filtering_method<R: Rng>(rng: &mut R) {\n    let mut rows = [[\" \"; 62]; 31];\n\n    // Generate points\n    for _ in 0..POINTS_N {\n        let (x, y) = generate_point(rng);\n        rows[(y + 15) as usize][(x + 15) as usize * 2] = \"*\";\n    }\n\n    // draw the points\n    for row in &rows {\n        println!(\"{}\", row.concat());\n    }\n}\n\nfn precalculating_method<R: Rng>(rng: &mut R) {\n    // Generate all possible points\n    let mut possible_points = Vec::with_capacity(404);\n    for y in -15..=15 {\n        for x in -15..=15 {\n            let r2 = x * x + y * y;\n            if r2 >= 100 && r2 <= 225 {\n                possible_points.push((x, y));\n            }\n        }\n    }\n\n    // A truncated Fisher-Yates shuffle\n    let len = possible_points.len();\n    for i in (len - POINTS_N..len).rev() {\n        let j = rng.gen_range(0, i + 1);\n        possible_points.swap(i, j);\n    }\n\n    // turn the selected points into \"pixels\"\n    let mut rows = [[\" \"; 62]; 31];\n    for &(x, y) in &possible_points[len - POINTS_N..] {\n        rows[(y + 15) as usize][(x + 15) as usize * 2] = \"*\";\n    }\n\n    // draw the \"pixels\"\n    for row in &rows {\n        println!(\"{}\", row.concat());\n    }\n}\n\nfn main() {\n    let mut rng = thread_rng();\n\n    filtering_method(&mut rng);\n\n    precalculating_method(&mut rng);\n}\n",
    "path": "tasks/constrained-random-points-on-a-circle",
    "remote_code": null,
    "title": "Constrained random points on a circle",
    "url": "http://rosettacode.org/wiki/Constrained_random_points_on_a_circle"
  },
  {
    "local_code": "struct R2cf {\n    n1: i64,\n    n2: i64,\n}\n\n// This iterator generates the continued fraction representation from the\n// specified rational number.\nimpl Iterator for R2cf {\n    type Item = i64;\n\n    fn next(&mut self) -> Option<i64> {\n        if self.n2 == 0 {\n            None\n        } else {\n            let t1 = self.n1 / self.n2;\n            let t2 = self.n2;\n            self.n2 = self.n1 - t1 * t2;\n            self.n1 = t2;\n            Some(t1)\n        }\n    }\n}\n\nfn r2cf(n1: i64, n2: i64) -> R2cf {\n    R2cf { n1: n1, n2: n2 }\n}\n\nmacro_rules! printcf {\n    ($x:expr, $y:expr) => {\n        println!(\"{:?}\", r2cf($x, $y).collect::<Vec<_>>())\n    };\n}\n\nfn main() {\n    printcf!(1, 2);\n    printcf!(3, 1);\n    printcf!(23, 8);\n    printcf!(13, 11);\n    printcf!(22, 7);\n    printcf!(-152, 77);\n\n    printcf!(14_142, 10_000);\n    printcf!(141_421, 100_000);\n    printcf!(1_414_214, 1_000_000);\n    printcf!(14_142_136, 10_000_000);\n\n    printcf!(31, 10);\n    printcf!(314, 100);\n    printcf!(3142, 1000);\n    printcf!(31_428, 10_000);\n    printcf!(314_285, 100_000);\n    printcf!(3_142_857, 1_000_000);\n    printcf!(31_428_571, 10_000_000);\n    printcf!(314_285_714, 100_000_000);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::r2cf;\n    use std::iter::Iterator;\n\n    #[test]\n    fn test_misc() {\n        assert!(Iterator::eq(r2cf(-151, 77), vec![-1, -1, -24, -1, -2]));\n        assert!(Iterator::eq(r2cf(22, 7), vec![3, 7]));\n        assert!(Iterator::eq(r2cf(23, 8), vec![2, 1, 7]));\n    }\n\n    #[test]\n    fn test_sqrt2() {\n        assert!(Iterator::eq(\n            r2cf(14_142, 10_000),\n            vec![1, 2, 2, 2, 2, 2, 1, 1, 29]\n        ));\n        assert!(Iterator::eq(\n            r2cf(14_142_136, 10_000_000),\n            vec![1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 1, 2, 4, 1, 1, 2]\n        ));\n    }\n\n    #[test]\n    fn test_pi() {\n        assert!(Iterator::eq(r2cf(31, 10), vec![3, 10]));\n        assert!(Iterator::eq(r2cf(314, 100), vec![3, 7, 7]));\n        assert!(Iterator::eq(r2cf(3_142, 1_000), vec![3, 7, 23, 1, 2]));\n    }\n}\nuse std::iter;\n\n// Calculating a continued fraction is quite easy with iterators, however\n// writing a proper iterator adapter is less so. We settle for a macro which\n// for most purposes works well enough.\n//\n// One limitation with this iterator based approach is that we cannot reverse\n// input iterators since they are not usually DoubleEnded. To circumvent this\n// we can collect the elements and then reverse them, however this isn't ideal\n// as we now have to store elements equal to the number of iterations.\n//\n// Another is that iterators cannot be resused once consumed, so it is often\n// required to make many clones of iterators.\nmacro_rules! continued_fraction {\n    ($a:expr, $b:expr; $iterations:expr) => {\n        ($a).zip($b)\n            .take($iterations)\n            .collect::<Vec<_>>()\n            .iter()\n            .rev()\n            .fold(0f64, |acc: f64, &(x, y)| {\n                f64::from(x) + (f64::from(y) / acc)\n            })\n    };\n\n    ($a:expr, $b:expr) => {\n        continued_fraction!($a, $b ; 1000)\n    };\n}\n\nfn main() {\n    // Sqrt(2)\n    let sqrt2_a = (1..2).chain(iter::repeat(2));\n    let sqrt2_b = iter::repeat(1);\n    println!(\"{}\", continued_fraction!(sqrt2_a, sqrt2_b));\n\n    // Napier's Constant\n    let napier_a = (2..3).chain(1..);\n    let napier_b = (1..2).chain(1..);\n    println!(\"{}\", continued_fraction!(napier_a, napier_b));\n\n    // Pi\n    let pi_a = (3..4).chain(iter::repeat(6));\n    let pi_b = (1i32..).map(|x| (2 * x - 1).pow(2));\n    println!(\"{}\", continued_fraction!(pi_a, pi_b));\n}\n\n#[cfg_attr(feature = \"cargo-clippy\", allow(float_cmp, approx_constant))]\n#[cfg(test)]\nmod tests {\n    use std::iter;\n\n    #[test]\n    fn test_sqrt2() {\n        let sqrt2_a = (1..2).chain(iter::repeat(2));\n        let sqrt2_b = iter::repeat(1);\n\n        // Note that we must clone the iterator here if we want to reuse\n        assert_eq!(\n            continued_fraction!(sqrt2_a.clone(), sqrt2_b.clone() ; 10),\n            1.4142131979695431f64\n        );\n\n        assert_eq!(\n            continued_fraction!(sqrt2_a.clone(), sqrt2_b.clone()),\n            continued_fraction!(sqrt2_a.clone(), sqrt2_b.clone() ; 1000)\n        );\n\n        assert_eq!(\n            continued_fraction!(sqrt2_a, sqrt2_b ; 73),\n            1.4142135623730951f64\n        );\n    }\n}\n",
    "path": "tasks/continued-fraction",
    "remote_code": "\nuse std::iter;\n\n// Calculating a continued fraction is quite easy with iterators, however\n// writing a proper iterator adapter is less so. We settle for a macro which\n// for most purposes works well enough.\n//\n// One limitation with this iterator based approach is that we cannot reverse\n// input iterators since they are not usually DoubleEnded. To circumvent this\n// we can collect the elements and then reverse them, however this isn't ideal\n// as we now have to store elements equal to the number of iterations.\n//\n// Another is that iterators cannot be resused once consumed, so it is often\n// required to make many clones of iterators.\nmacro_rules! continued_fraction {\n    ($a:expr, $b:expr ; $iterations:expr) => (\n        ($a).zip($b)\n            .take($iterations)\n            .collect::<Vec<_>>().iter()\n            .rev()\n            .fold(0 as f64, |acc: f64, &(x, y)| {\n                x as f64 + (y as f64 / acc)\n            })\n    );\n\n    ($a:expr, $b:expr) => (continued_fraction!($a, $b ; 1000));\n}\n\nfn main() {\n    // Sqrt(2)\n    let sqrt2a = (1..2).chain(iter::repeat(2));\n    let sqrt2b = iter::repeat(1);\n    println!(\"{}\", continued_fraction!(sqrt2a, sqrt2b));\n\n\n    // Napier's Constant\n    let napiera = (2..3).chain(1..);\n    let napierb = (1..2).chain(1..);\n    println!(\"{}\", continued_fraction!(napiera, napierb));\n\n\n    // Pi\n    let pia = (3..4).chain(iter::repeat(6));\n    let pib = (1i64..).map(|x| (2 * x - 1).pow(2));\n    println!(\"{}\", continued_fraction!(pia, pib));\n}\n",
    "title": "Continued fraction",
    "url": "http://rosettacode.org/wiki/Continued_fraction"
  },
  {
    "local_code": "struct R2cf {\n    n1: i64,\n    n2: i64,\n}\n\n// This iterator generates the continued fraction representation from the\n// specified rational number.\nimpl Iterator for R2cf {\n    type Item = i64;\n\n    fn next(&mut self) -> Option<i64> {\n        if self.n2 == 0 {\n            None\n        } else {\n            let t1 = self.n1 / self.n2;\n            let t2 = self.n2;\n            self.n2 = self.n1 - t1 * t2;\n            self.n1 = t2;\n            Some(t1)\n        }\n    }\n}\n\nfn r2cf(n1: i64, n2: i64) -> R2cf {\n    R2cf { n1: n1, n2: n2 }\n}\n\nmacro_rules! printcf {\n    ($x:expr, $y:expr) => {\n        println!(\"{:?}\", r2cf($x, $y).collect::<Vec<_>>())\n    };\n}\n\nfn main() {\n    printcf!(1, 2);\n    printcf!(3, 1);\n    printcf!(23, 8);\n    printcf!(13, 11);\n    printcf!(22, 7);\n    printcf!(-152, 77);\n\n    printcf!(14_142, 10_000);\n    printcf!(141_421, 100_000);\n    printcf!(1_414_214, 1_000_000);\n    printcf!(14_142_136, 10_000_000);\n\n    printcf!(31, 10);\n    printcf!(314, 100);\n    printcf!(3142, 1000);\n    printcf!(31_428, 10_000);\n    printcf!(314_285, 100_000);\n    printcf!(3_142_857, 1_000_000);\n    printcf!(31_428_571, 10_000_000);\n    printcf!(314_285_714, 100_000_000);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::r2cf;\n    use std::iter::Iterator;\n\n    #[test]\n    fn test_misc() {\n        assert!(Iterator::eq(r2cf(-151, 77), vec![-1, -1, -24, -1, -2]));\n        assert!(Iterator::eq(r2cf(22, 7), vec![3, 7]));\n        assert!(Iterator::eq(r2cf(23, 8), vec![2, 1, 7]));\n    }\n\n    #[test]\n    fn test_sqrt2() {\n        assert!(Iterator::eq(\n            r2cf(14_142, 10_000),\n            vec![1, 2, 2, 2, 2, 2, 1, 1, 29]\n        ));\n        assert!(Iterator::eq(\n            r2cf(14_142_136, 10_000_000),\n            vec![1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 1, 2, 4, 1, 1, 2]\n        ));\n    }\n\n    #[test]\n    fn test_pi() {\n        assert!(Iterator::eq(r2cf(31, 10), vec![3, 10]));\n        assert!(Iterator::eq(r2cf(314, 100), vec![3, 7, 7]));\n        assert!(Iterator::eq(r2cf(3_142, 1_000), vec![3, 7, 23, 1, 2]));\n    }\n}\n",
    "path": "tasks/continued-fraction/arithmetic/construct-from-rational-number",
    "remote_code": "\nstruct R2cf {\n    n1: i64,\n    n2: i64\n}\n\n// This iterator generates the continued fraction representation from the\n// specified rational number.\nimpl Iterator for R2cf {\n    type Item = i64;\n\n    fn next(&mut self) -> Option<i64> {\n        if self.n2 == 0 {\n            None\n        }\n        else {\n            let t1 = self.n1 / self.n2;\n            let t2 = self.n2;\n            self.n2 = self.n1 - t1 * t2;\n            self.n1 = t2;\n            Some(t1)\n        }\n    }\n}\n\nfn r2cf(n1: i64, n2: i64) -> R2cf {\n    R2cf { n1: n1, n2: n2 }\n}\n\nmacro_rules! printcf {\n    ($x:expr, $y:expr) => (println!(\"{:?}\", r2cf($x, $y).collect::<Vec<_>>()));\n}\n\nfn main() {\n    printcf!(1, 2);\n    printcf!(3, 1);\n    printcf!(23, 8);\n    printcf!(13, 11);\n    printcf!(22, 7);\n    printcf!(-152, 77);\n\n    printcf!(14_142, 10_000);\n    printcf!(141_421, 100_000);\n    printcf!(1_414_214, 1_000_000);\n    printcf!(14_142_136, 10_000_000);\n\n    printcf!(31, 10);\n    printcf!(314, 100);\n    printcf!(3142, 1000);\n    printcf!(31_428, 10_000);\n    printcf!(314_285, 100_000);\n    printcf!(3_142_857, 1_000_000);\n    printcf!(31_428_571, 10_000_000);\n    printcf!(314_285_714, 100_000_000);\n}\n",
    "title": "Continued fraction/Arithmetic/Construct from rational number",
    "url": "http://rosettacode.org/wiki/Continued_fraction/Arithmetic/Construct_from_rational_number"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Convert decimal number to rational",
    "url": "http://rosettacode.org/wiki/Convert_decimal_number_to_rational"
  },
  {
    "local_code": "fn seconds_to_compound(secs: u32) -> String {\n    let part = |comps: &mut String, c: &str, one: u32, secs: &mut u32| {\n        if *secs >= one {\n            let div = *secs / one;\n            comps.push_str(&(div.to_string() + c));\n            *secs -= one * div;\n            if *secs > 0 {\n                comps.push_str(\", \");\n            }\n        }\n    };\n\n    let mut secs = secs;\n    let mut comps = String::new();\n    part(&mut comps, \" wk\", 60 * 60 * 24 * 7, &mut secs);\n    part(&mut comps, \" d\", 60 * 60 * 24, &mut secs);\n    part(&mut comps, \" hr\", 60 * 60, &mut secs);\n    part(&mut comps, \" min\", 60, &mut secs);\n    part(&mut comps, \" sec\", 1, &mut secs);\n    comps\n}\n\n#[test]\nfn hours_and_seconds() {\n    assert_eq!(seconds_to_compound(7259), \"2 hr, 59 sec\");\n}\n\n#[test]\nfn one_day() {\n    assert_eq!(seconds_to_compound(86_400), \"1 d\");\n}\n\n#[test]\nfn six_million_seconds() {\n    assert_eq!(seconds_to_compound(6_000_000), \"9 wk, 6 d, 10 hr, 40 min\");\n}\n\nfn main() {\n    println!(\"7,259 seconds = {}\", seconds_to_compound(7259));\n    println!(\"86,400 seconds = {}\", seconds_to_compound(86_400));\n    println!(\"6,000,000 seconds = {}\", seconds_to_compound(6_000_000));\n}\n",
    "path": "tasks/convert-seconds-to-compound-duration",
    "remote_code": "use std::fmt;\n\n\nstruct CompoundTime {\n    w: usize,\n    d: usize,\n    h: usize,\n    m: usize,\n    s: usize,\n}\n\nmacro_rules! reduce {\n    ($s: ident, $(($from: ident, $to: ident, $factor: expr)),+) => {{\n        $(\n            $s.$to += $s.$from / $factor;\n            $s.$from %= $factor;\n        )+\n    }}\n}\n\nimpl CompoundTime {\n    #[inline]\n    fn new(w: usize, d: usize, h: usize, m: usize, s: usize) -> Self{\n        CompoundTime { w: w, d: d, h: h, m: m, s: s, }\n    }\n\n    #[inline]\n    fn balance(&mut self) {\n        reduce!(self, (s, m, 60), (m, h, 60),\n                      (h, d, 24), (d, w, 7));\n    }\n}\n\nimpl fmt::Display for CompoundTime {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}w {}d {}h {}m {}s\", \n               self.w, self.d, self.h, self.m, self.s)\n    }\n}\n\nfn main() {\n    let mut ct = CompoundTime::new(0,3,182,345,2412);\n    println!(\"Before: {}\", ct);\n    ct.balance();\n    println!(\"After: {}\", ct);\n}",
    "title": "Convert seconds to compound duration",
    "url": "http://rosettacode.org/wiki/Convert_seconds_to_compound_duration"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Convex hull",
    "url": "http://rosettacode.org/wiki/Convex_hull"
  },
  {
    "local_code": "use std::mem;\nuse std::thread;\nuse std::time::Duration;\n\n#[derive(Copy, Clone)]\nenum Cell {\n    Empty(char),\n    Alive,\n    Dead,\n}\nimpl Cell {\n    fn from_char(c: char) -> Cell {\n        match c {\n            ' ' => Cell::Dead,\n            '#' => Cell::Alive,\n            c => Cell::Empty(c),\n        }\n    }\n    fn to_char(&self) -> char {\n        match *self {\n            Cell::Dead => ' ',\n            Cell::Alive => '#',\n            Cell::Empty(c) => c,\n        }\n    }\n}\n\n#[cfg_attr(feature = \"cargo-clippy\", allow(match_same_arms))]\nfn next_world(input: &[Cell], output: &mut [Cell], w: usize, h: usize) {\n    for i in 0..(w * h) {\n        match input[i] {\n            Cell::Empty(c) => output[i] = Cell::Empty(c),\n            cell => {\n                let live = vec![\n                    input.get(i - w - 1),\n                    input.get(i - w),\n                    input.get(i - w + 1),\n                    input.get(i - 1),\n                    input.get(i + 1),\n                    input.get(i + w - 1),\n                    input.get(i + w),\n                    input.get(i + w + 1),\n                ]\n                .iter()\n                .fold(0, |sum, &o| {\n                    if let Some(&Cell::Alive) = o {\n                        sum + 1\n                    } else {\n                        sum\n                    }\n                });\n                output[i] = match (cell, live) {\n                    (Cell::Alive, 0..=1) => Cell::Dead,  // Lonely\n                    (Cell::Alive, 4..=8) => Cell::Dead,  // Overcrowded\n                    (Cell::Alive, 2..=3) => Cell::Alive, // Lives\n                    (Cell::Dead, 3) => Cell::Alive,      // It takes three to give birth!\n                    _ => Cell::Dead,                     // Barren\n                }\n            }\n        }\n    }\n}\n\nfn main() {\n    let (w, h) = (100usize, 9usize);\n    let mut world: Vec<Cell> = r\"\n+-------------------------------------------------------------------------------------------------+\n|                                                                                                 |\n|                                                                                        #  #     |\n|                                                                                       #         |\n|                                                                                       #   #     |\n|                                                                                       ####      |\n|                                                                                                 |\n|                                                                                                 |\n+-------------------------------------------------------------------------------------------------+\n\"\n    .chars()\n    .map(Cell::from_char)\n    .collect();\n    let mut next: Vec<Cell> = world.clone();\n\n    loop {\n        for cell in &world {\n            print!(\"{}\", cell.to_char());\n        }\n        println!();\n        next_world(&world, &mut next, w, h);\n        mem::swap(&mut world, &mut next);\n\n        // Use VT100 cursor control sequences to animate in-place.\n        print!(\"\\x1b[{}A\", h + 1);\n        print!(\"\\x1b[{}D\", w + 1);\n        thread::sleep(Duration::from_millis(100));\n    }\n}\n\n#[test]\nfn test() {\n    let (w, h) = (14usize, 7usize);\n    let mut world: Vec<Cell> = r\"\n+-----------+\n|           |\n|     #     |\n|     #     |\n|     #     |\n|           |\n+-----------+\n\"\n    .chars()\n    .map(Cell::from_char)\n    .collect();\n    let mut next: Vec<Cell> = world.clone();\n\n    next_world(&world, &mut next, w, h);\n    mem::swap(&mut world, &mut next);\n\n    let result: String = world.iter().map(|c| c.to_char()).collect();\n    let correct = r\"\n+-----------+\n|           |\n|           |\n|    ###    |\n|           |\n|           |\n+-----------+\n\";\n    assert_eq!(result, correct);\n}\n",
    "path": "tasks/conways-game-of-life",
    "remote_code": "\nuse std::collections::HashMap;\nuse std::collections::HashSet;\n\ntype Cell = (i32, i32);\ntype Colony = HashSet<Cell>;\n\nfn print_colony(col: &Colony, width: i32, height: i32) {\n    for y in 0..height {\n        for x in 0..width {\n            print!(\"{} \",\n                if col.contains(&(x, y)) {\"O\"}\n                else {\".\"}\n            );\n        }\n        println!();\n    }\n}\n\nfn neighbours(&(x,y): &Cell) -> Vec<Cell> {\n    vec![\n        (x-1,y-1), (x,y-1), (x+1,y-1),\n        (x-1,y),            (x+1,y),\n        (x-1,y+1), (x,y+1), (x+1,y+1),\n    ]\n}\n\nfn neighbour_counts(col: &Colony) -> HashMap<Cell, i32> {\n    let mut ncnts = HashMap::new();\n    for cell in col.iter().flat_map(neighbours) {\n        *ncnts.entry(cell).or_insert(0) += 1;\n    }\n    ncnts\n}\n\nfn generation(col: Colony) -> Colony {\n    neighbour_counts(&col)\n        .into_iter()\n        .filter_map(|(cell, cnt)|\n            match (cnt, col.contains(&cell)) {\n                (2, true) |\n                (3, ..) => Some(cell),\n                _ => None\n        })\n        .collect()\n}\n\nfn life(init: Vec<Cell>, iters: i32, width: i32, height: i32) {\n    let mut col: Colony = init.into_iter().collect(); \n    for i in 0..iters+1\n    {\n        println!(\"({})\", &i);\n        if i != 0 {\n            col = generation(col);\n        }\n        print_colony(&col, width, height);\n    }\n}\n\nfn main() {\n    let blinker = vec![\n        (1,0),\n        (1,1),\n        (1,2)];\n\n    life(blinker, 3, 3, 3);\n\n    let glider = vec![\n                (1,0),\n                        (2,1),\n        (0,2),  (1,2),  (2,2)];\n\n    life(glider, 20, 8, 8);\n}\n",
    "title": "Conway's Game of Life",
    "url": "http://rosettacode.org/wiki/Conway's_Game_of_Life"
  },
  {
    "local_code": "fn main() {\n    let s1 = \"A String\";\n\n    // Create an additional reference to \"A String\".\n    let s2: &str = s1;\n\n    // Create a copy of \"A String\"\n    let s3: String = s1.to_string();\n\n    println!(\"s1 = {}, s2 = {}, s3 = {}\", s1, s2, s3);\n}\n",
    "path": "tasks/copy-a-string",
    "remote_code": "fn main() {\n    let s1 = \"A String\";\n    let mut s2 = s1;\n\n    s2 = \"Another String\";\n\n    println!(\"s1 = {}, s2 = {}\", s1, s2);\n}",
    "title": "Copy a string",
    "url": "http://rosettacode.org/wiki/Copy_a_string"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::env;\n\nfn main() {\n    let args: Vec<_> = env::args().collect();\n    let n = if args.len() > 1 {\n        args[1].parse().expect(\"Not a valid number to count to\")\n    }\n    else {\n        20\n    };\n    count_in_factors_to(n);\n}\n\nfn count_in_factors_to(n: u64) {\n    println!(\"1\");\n    let mut primes = vec![];\n    for i in 2..=n {\n        let fs = factors(&primes, i);\n        if fs.len() <= 1 {\n            primes.push(i);\n            println!(\"{}\", i);\n        }\n        else {\n            println!(\"{} = {}\", i, fs.iter().map(|f| f.to_string()).collect::<Vec<String>>().join(\" x \"));\n        }\n    }\n}\n\nfn factors(primes: &[u64], mut n: u64) -> Vec<u64> {\n    let mut result = Vec::new();\n    for p in primes {\n        while n % p == 0 {\n            result.push(*p);\n            n /= p;\n        }\n        if n == 1 {\n            return result;\n        }\n    }\n    vec![n]\n}",
    "title": "Count in factors",
    "url": "http://rosettacode.org/wiki/Count_in_factors"
  },
  {
    "local_code": "use std::u8;\n\nfn main() {\n    // We count from 0 to 255 (377 in octal)\n    for i in 0..=u8::MAX {\n        println!(\"{:o}\", i);\n    }\n}\n",
    "path": "tasks/count-in-octal",
    "remote_code": "fn main() {\n    for i in 0..std::usize::MAX {\n        println!(\"{:o}\", i);\n    }\n}",
    "title": "Count in octal",
    "url": "http://rosettacode.org/wiki/Count_in_octal"
  },
  {
    "local_code": "// Author : Rahul Sharma\n// Github : github.com/creativcoder\n\n// The rest of the `Pattern` and `split` APIs could make this much more powerful\nfn count_sub_string(src: &str, target: &str) -> usize {\n    src.split(target).count() - 1\n}\n\nfn main() {\n    let text = \"this is three of the four\";\n    let sub_str = \"th\";\n    println!(\"{:?}\", count_sub_string(text, sub_str));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trailing() {\n        assert_eq!(count_sub_string(\"adssdadaadaddaadad\", \"ad\"), 6);\n    }\n\n    #[test]\n    fn none() {\n        assert_eq!(count_sub_string(\"rustisawesome\", \"zz\"), 0);\n    }\n}\n",
    "path": "tasks/count-occurrences-of-a-substring",
    "remote_code": null,
    "title": "Count occurrences of a substring",
    "url": "http://rosettacode.org/wiki/Count_occurrences_of_a_substring"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn make_change(coins: &[usize], cents: usize) -> usize {\n    let size = cents + 1;\n    let mut ways = vec![0; size];\n    ways[0] = 1;\n    for &coin in coins {\n        for amount in coin..size {\n            ways[amount] += ways[amount - coin];\n        }\n    }\n    ways[cents]\n}\n\nfn main() {\n    println!(\"{}\", make_change(&[1,5,10,25], 100));\n    println!(\"{}\", make_change(&[1,5,10,25,50,100], 100_000));\n}",
    "title": "Count the coins",
    "url": "http://rosettacode.org/wiki/Count_the_coins"
  },
  {
    "local_code": "use std::ops::{Index, IndexMut};\n\nfn main() {\n    let m = matrix(\n        vec![\n            2., -1., 5., 1., 3., 2., 2., -6., 1., 3., 3., -1., 5., -2., -3., 3.,\n        ],\n        4,\n    );\n    let mm = m.solve(&vec![-3., -32., -47., 49.]);\n    println!(\"{:?}\", mm);\n}\n\n#[derive(Clone)]\nstruct Matrix {\n    elts: Vec<f64>,\n    dim: usize,\n}\n\nimpl Matrix {\n    // Compute determinant using cofactor method\n    // Using Gaussian elimination would have been more efficient, but it also solves the linear\n    // system, so…\n    fn det(&self) -> f64 {\n        match self.dim {\n            0 => 0.,\n            1 => self[0][0],\n            2 => self[0][0] * self[1][1] - self[0][1] * self[1][0],\n            d => {\n                let mut acc = 0.;\n                let mut signature = 1.;\n                for k in 0..d {\n                    acc += signature * self[0][k] * self.comatrix(0, k).det();\n                    signature *= -1.\n                }\n                acc\n            }\n        }\n    }\n\n    // Solve linear systems using Cramer's method\n    fn solve(&self, target: &Vec<f64>) -> Vec<f64> {\n        let mut solution: Vec<f64> = vec![0.; self.dim];\n        let denominator = self.det();\n        for j in 0..self.dim {\n            let mut mm = self.clone();\n            for i in 0..self.dim {\n                mm[i][j] = target[i]\n            }\n            solution[j] = mm.det() / denominator\n        }\n        solution\n    }\n\n    // Compute the cofactor matrix for determinant computations\n    fn comatrix(&self, k: usize, l: usize) -> Matrix {\n        let mut v: Vec<f64> = vec![];\n        for i in 0..self.dim {\n            for j in 0..self.dim {\n                if i != k && j != l {\n                    v.push(self[i][j])\n                }\n            }\n        }\n        matrix(v, self.dim - 1)\n    }\n}\n\nfn matrix(elts: Vec<f64>, dim: usize) -> Matrix {\n    assert_eq!(elts.len(), dim * dim);\n    Matrix { elts, dim }\n}\n\nimpl Index<usize> for Matrix {\n    type Output = [f64];\n\n    fn index(&self, i: usize) -> &Self::Output {\n        let m = self.dim;\n        &self.elts[m * i..m * (i + 1)]\n    }\n}\n\nimpl IndexMut<usize> for Matrix {\n    fn index_mut(&mut self, i: usize) -> &mut Self::Output {\n        let m = self.dim;\n        &mut self.elts[m * i..m * (i + 1)]\n    }\n}\n\n#[test]\nfn test_create_and_access() {\n    let m = matrix(vec![1., 2., 3., 4.], 2);\n    assert_eq!(m[0][0], 1.);\n    assert_eq!(m[0][1], 2.);\n    assert_eq!(m[1][0], 3.);\n    assert_eq!(m[1][1], 4.);\n}\n\n#[test]\nfn test_determinant() {\n    let dim = 5;\n    let mut m = matrix(vec![0.; dim * dim], dim);\n    (0..dim).for_each(|i| (0..=i).for_each(|j| m[i][j] = 1.));\n    assert_eq!(m.det(), 1.);\n    let m = matrix(\n        vec![\n            1., -5., 2., 1., -5., -7., 0., 3., 0., 3., 4., 1., 41., 0., -1., 0.,\n        ],\n        4,\n    );\n    assert_eq!(m.det(), -2680.);\n}\n\n#[test]\nfn test_solve() {\n    let m = matrix(\n        vec![\n            1., -5., 2., 1., -5., -7., 0., 3., 0., 3., 4., 1., 41., 0., -1., 0.,\n        ],\n        4,\n    );\n    let b = vec![153., 219., -94., -41.];\n    assert_eq!(m.solve(&b), vec![-1., -31., 0., -1.])\n}\n",
    "path": "tasks/cramers-rule",
    "remote_code": null,
    "title": "Cramer's rule",
    "url": "http://rosettacode.org/wiki/Cramer's_rule"
  },
  {
    "local_code": "use std::fs::{self, File};\nuse std::io::Write;\n\nfn main() {\n    // Create a new file.  We get a `Result` object from `File::create`. We could check if there is\n    // an error by using `.is_err()` or by using pattern matching. We choose here to ignore the\n    // possibility of an error and just unwrap the value contained in the `Result` object.  This\n    // means that an error will cause the program to fail at runtime.\n    let mut new_file = File::create(\"build/output.txt\").unwrap();\n\n    // Write something trivial to the file. Now we are handling a possible error by using pattern\n    // matching.\n    match new_file.write_all(b\"Nothing here...\") {\n        Ok(()) => (),\n        Err(e) => println!(\"Failed to write to file: {}\", e),\n    }\n\n    // Create a directory. Here we handle a possible error by using the functions provided by\n    // result.  The second argument sets the file permissions\n    let result = fs::create_dir(\"build/docs\");\n    if result.is_err() {\n        println!(\"Failed to create a directory: {}\", result.err().unwrap());\n    }\n}\n\n#[test]\nfn test_create_file() {\n    use std::fs;\n    use std::path::Path;\n\n    let build_dir = Path::new(\"build-tests\");\n    if !(build_dir.exists() && build_dir.is_dir()) {\n        let r = fs::create_dir(&build_dir);\n        assert!(r.is_ok());\n    }\n\n    let file_path = Path::new(\"build-tests/create_file_test.txt\");\n    if file_path.exists() && file_path.is_file() {\n        let r = fs::remove_file(&file_path);\n        assert!(r.is_ok());\n    }\n    match File::create(&file_path) {\n        Ok(_) => assert!(true),\n        Err(e) => panic!(\n            \"failed to create_file at {}, error: {}\",\n            file_path.display(),\n            e\n        ),\n    }\n\n    // Remove the build dir, but only after making sure there's only one file in it.\n    let contents = build_dir\n        .read_dir()\n        .unwrap()\n        .collect::<Result<Vec<_>, _>>()\n        .unwrap();\n\n    assert!(contents.len() == 1);\n    assert!(contents[0].path() == file_path);\n\n    fs::remove_dir_all(build_dir).unwrap();\n}\n",
    "path": "tasks/create-a-file",
    "remote_code": "use std::io::{self, Write};\nuse std::fs::{DirBuilder, File};\nuse std::path::Path;\nuse std::{process,fmt};\n\nconst FILE_NAME: &'static str = \"output.txt\";\nconst DIR_NAME : &'static str = \"docs\";\n\nfn main() {\n    create(\".\").and(create(\"/\"))\n               .unwrap_or_else(|e| error_handler(e,1));\n}\n\n\nfn create<P>(root: P) -> io::Result<File>\n    where P: AsRef<Path>\n{\n    let f_path = root.as_ref().join(FILE_NAME);\n    let d_path = root.as_ref().join(DIR_NAME);\n    DirBuilder::new().create(d_path).and(File::create(f_path))\n}\n\nfn error_handler<E: fmt::Display>(error: E, code: i32) -> ! {\n    let _ = writeln!(&mut io::stderr(), \"Error: {}\", error);\n    process::exit(code)\n}",
    "title": "Create a file",
    "url": "http://rosettacode.org/wiki/Create_a_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Create a file on magnetic tape",
    "url": "http://rosettacode.org/wiki/Create_a_file_on_magnetic_tape"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::env;\n\nfn main() {\n    let mut args = env::args().skip(1).flat_map(|num| num.parse());\n    let rows = args.next().expect(\"Expected number of rows as first argument\");\n    let cols = args.next().expect(\"Expected number of columns as second argument\");\n\n    assert_ne!(rows, 0, \"rows were zero\");\n    assert_ne!(cols, 0, \"cols were zero\");\n\n    // Creates a vector of vectors with all elements initialized to 0.\n    let mut v = vec![vec![0; cols]; rows];\n    v[0][0] = 1;\n    println!(\"{}\", v[0][0]);\n}",
    "title": "Create a two-dimensional array at runtime",
    "url": "http://rosettacode.org/wiki/Create_a_two-dimensional_array_at_runtime"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate rand;\n\nuse rand::Rng;\n\nfn random_cell<R: Rng>(rng: &mut R) -> u32 {\n    // Anything between 0 and 10_000 (exclusive) has 4 digits or fewer. Using `gen_range::<u32>`\n    // is faster for smaller RNGs.  Because the parameters are constant, the compiler can do all\n    // the range construction at compile time, removing the need for\n    // `rand::distributions::range::Range`\n    rng.gen_range(0, 10_000)\n}\n\nfn main() {\n    let mut rng = rand::thread_rng(); // Cache the RNG for reuse\n\n    println!(\"<table><thead><tr><th></th><td>X</td><td>Y</td><td>Z</td></tr></thead>\");\n\n    for row in 0..3 {\n        let x = random_cell(&mut rng);\n        let y = random_cell(&mut rng);\n        let z = random_cell(&mut rng);\n        println!(\"<tr><th>{}</th><td>{}</td><td>{}</td><td>{}</td></tr>\", row, x, y, z);\n    }\n\n    println!(\"</table>\");\n}",
    "title": "Create an HTML table",
    "url": "http://rosettacode.org/wiki/Create_an_HTML_table"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::{mem,ptr};\n\nfn main() {\n    let mut data: i32;\n\n    // Rust does not allow us to use uninitialized memory but the STL provides an `unsafe`\n    // function to override this protection.\n    unsafe {data = mem::uninitialized()}\n\n    // Construct a raw pointer (perfectly safe)\n    let address = &mut data as *mut _;\n\n    unsafe {ptr::write(address, 5)}\n    println!(\"{0:p}: {0}\", &data);\n\n    unsafe {ptr::write(address, 6)}\n    println!(\"{0:p}: {0}\", &data);\n\n}",
    "title": "Create an object at a given address",
    "url": "http://rosettacode.org/wiki/Create_an_object_at_a_given_address"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::time::Instant;\nuse separator::Separatable;\n\nconst NUMBER_OF_CUBAN_PRIMES: usize = 200;\nconst COLUMNS: usize = 10;\nconst LAST_CUBAN_PRIME: usize = 100_000;\n\nfn main() {\n    println!(\"Calculating the first {} cuban primes and the {}th cuban prime...\", NUMBER_OF_CUBAN_PRIMES, LAST_CUBAN_PRIME);\n    let start = Instant::now();\n\n    let mut i: u64 = 0;\n    let mut j: u64 = 1;\n    let mut index: usize = 0;\n    let mut cuban_primes = Vec::new();\n    let mut cuban: u64 = 0;\n    while index < 100_000 {\n        cuban = {j += 1; j}.pow(3) - {i += 1; i}.pow(3);\n        if primal::is_prime(cuban) {\n            if index < NUMBER_OF_CUBAN_PRIMES {\n                cuban_primes.push(cuban);\n            }\n            index += 1;\n        }\n    }\n\n    let elapsed = start.elapsed();\n    println!(\"THE {} FIRST CUBAN PRIMES:\", NUMBER_OF_CUBAN_PRIMES);\n    cuban_primes\n        .chunks(COLUMNS)\n        .map(|chunk| {\n            chunk.iter()\n                .map(|item| {\n                    print!(\"{}\\t\", item)\n                })\n                .for_each(drop);\n            println!(\"\");\n        })\n        .for_each(drop);\n    println!(\"The {}th cuban prime number is {}\", LAST_CUBAN_PRIME, cuban.separated_string());\n    println!(\"Elapsed time: {:?}\", elapsed);\n}",
    "title": "Cuban primes",
    "url": "http://rosettacode.org/wiki/Cuban_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "pub struct CumulativeStandardDeviation {\n    n: f64,\n    sum: f64,\n    sum_sq: f64\n}\n\nimpl CumulativeStandardDeviation {\n    pub fn new() -> Self {\n        CumulativeStandardDeviation {\n            n: 0.,\n            sum: 0.,\n            sum_sq: 0.\n        }\n    }\n\n    fn push(&mut self, x: f64) -> f64 {\n        self.n += 1.;\n        self.sum += x;\n        self.sum_sq += x * x;\n\n        (self.sum_sq / self.n - self.sum * self.sum / self.n / self.n).sqrt()\n    }\n}\n\nfn main() {\n    let nums = [2, 4, 4, 4, 5, 5, 7, 9];\n\n    let mut cum_stdev = CumulativeStandardDeviation::new();\n    for num in nums.iter() {\n        println!(\"{}\", cum_stdev.push(*num as f64));\n    }\n}",
    "title": "Cumulative standard deviation",
    "url": "http://rosettacode.org/wiki/Cumulative_standard_deviation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Currency",
    "url": "http://rosettacode.org/wiki/Currency"
  },
  {
    "local_code": "/// `add_n` returns a boxed closure.\n///\n/// TODO: Once \"unboxed, abstract return types\" are\n/// supported it can be done without the\n/// heap allocation/trait object indirection\nfn add_n(n: i32) -> Box<dyn Fn(i32) -> i32> {\n    Box::new(move |x| n + x)\n}\n\nfn main() {\n    let adder = add_n(40);\n    println!(\"The answer to life is {}.\", adder(2));\n}\n",
    "path": "tasks/currying",
    "remote_code": "fn add_n(n : i32) -> impl Fn(i32) -> i32 {\n    move |x| n + x\n}\n\nfn main() {\n    let adder = add_n(40);\n    println!(\"The answer to life is {}.\", adder(2));\n}",
    "title": "Currying",
    "url": "http://rosettacode.org/wiki/Currying"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nfn cwalk(mut vis: &mut Vec<Vec<bool>>, count: &mut isize, w: usize, h: usize, y: usize, x: usize, d: usize) {\n    if x == 0 || y == 0 || x == w || y == h {\n        *count += 1;\n        return;\n    }\n \n    vis[y][x] = true;\n    vis[h - y][w - x] = true;\n\n    if x != 0 && ! vis[y][x - 1] {\n        cwalk(&mut vis, count, w, h, y, x - 1, d | 1);\n    }\n    if d & 1 != 0 && x < w && ! vis[y][x+1] {\n        cwalk(&mut vis, count, w, h, y, x + 1, d | 1);\n    }\n    if y != 0 && ! vis[y - 1][x] {\n        cwalk(&mut vis, count, w, h, y - 1, x, d | 2);\n    }\n    if d & 2 != 0 && y < h && ! vis[y + 1][x] {\n        cwalk(&mut vis, count, w, h, y + 1, x, d | 2);\n    }\n\n    vis[y][x] = false;\n    vis[h - y][w - x] = false;\n}\n\nfn count_only(x: usize, y: usize) -> isize {\n    let mut count = 0;\n    let mut w = x;\n    let mut h = y;\n \n    if (h * w) & 1 != 0 {\n        return count;\n    }\n    if h & 1 != 0 {\n        std::mem::swap(&mut w, &mut h);\n    }\n \n    let mut vis = vec![vec![false; w + 1]; h + 1];\n    vis[h / 2][w / 2] = true;\n \n    if w & 1 != 0 {\n        vis[h / 2][w / 2 + 1] = true;\n    }\n    let mut res;\n    if w > 1 {\n        cwalk(&mut vis, &mut count, w, h, h / 2, w / 2 - 1, 1);\n        res = 2 * count - 1;\n        count = 0;\n        if w != h {\n            cwalk(&mut vis, &mut count, w, h, h / 2 + 1, w / 2, if w & 1 != 0 { 3 } else { 2 });\n        } \n        res += 2 * count - if w & 1 == 0 { 1 } else { 0 };\n    }\n    else {\n        res = 1;\n    }\n \n    if w == h {\n        res = 2 * res + 2;\n    }\n    res\n}\n\nfn main() {\n    for y in 1..10 {\n        for x in 1..y + 1 {\n            if x & 1 == 0 || y & 1 == 0 {\n                println!(\"{} x {}: {}\", y, x, count_only(x, y));\n            }\n        }\n    }\n}\n",
    "title": "Cut a rectangle",
    "url": "http://rosettacode.org/wiki/Cut_a_rectangle"
  },
  {
    "local_code": "use std::io;\nuse std::net::{IpAddr, SocketAddr, ToSocketAddrs};\n\nfn get_ips(host: &str) -> io::Result<impl Iterator<Item = IpAddr>> {\n    let hosts = host.to_socket_addrs().unwrap();\n    let ips = hosts.map(|h| match h {\n        SocketAddr::V4(s_v4) => IpAddr::V4(*s_v4.ip()),\n        SocketAddr::V6(s_v6) => IpAddr::V6(*s_v6.ip()),\n    });\n    Ok(ips)\n}\n\nfn main() -> io::Result<()> {\n    for ip in get_ips(\"www.kame.net:80\")? {\n        match ip {\n            IpAddr::V4(ip) => println!(\"ip v4: {}\", ip),\n            IpAddr::V6(ip) => println!(\"ip v6: {}\", ip),\n        }\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ipv4() {\n        let host = \"203.178.141.194:80\";\n        if let SocketAddr::V4(addr) = host.to_socket_addrs().unwrap().next().unwrap() {\n            let ip = IpAddr::V4(*addr.ip());\n            assert!(get_ips(\"www.kame.net:80\").unwrap().any(|x| x == ip));\n        } else {\n            panic!();\n        }\n    }\n\n    #[test]\n    #[ignore]\n    fn ipv6() {\n        let host = \"2001:200:dff:fff1:216:3eff:feb1:44d7:80\";\n        if let SocketAddr::V6(addr) = host.to_socket_addrs().unwrap().next().unwrap() {\n            let ip = IpAddr::V6(*addr.ip());\n            assert!(get_ips(\"www.kame.net:80\").unwrap().any(|x| x == ip));\n        } else {\n            panic!();\n        }\n    }\n}\n",
    "path": "tasks/dns-query",
    "remote_code": "use std::net::ToSocketAddrs;\n\nfn main() {\n    let host = \"www.kame.net\";\n    // Ideally, we would want to use std::net::lookup_host to resolve the host ips,\n    // but at time of writing this, it is still unstable. Fortunately, we can\n    // still resolve using the ToSocketAddrs trait, but we need to add a port,\n    // so we use the dummy port 0.\n    let host_port = (host, 0);\n    let ip_iter = host_port.to_socket_addrs().unwrap();\n\n\n    for ip_port in ip_iter {\n        println!(\"{}\", ip_port.ip());\n    }\n}",
    "title": "DNS query",
    "url": "http://rosettacode.org/wiki/DNS_query"
  },
  {
    "local_code": "extern crate chrono;\n\nuse chrono::*;\n\nfn main() {\n    let now = Utc::now();\n    println!(\"{}\", now.format(\"%Y-%m-%d\").to_string());\n    println!(\"{}\", now.format(\"%A, %B %d, %Y\").to_string());\n}\n",
    "path": "tasks/date-format",
    "remote_code": "fn main() {\n    let now = chrono::Utc::now();\n    println!(\"{}\", now.format(\"%Y-%m-%d\"));\n    println!(\"{}\", now.format(\"%A, %B %d, %Y\"));\n}",
    "title": "Date format",
    "url": "http://rosettacode.org/wiki/Date_format"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Date manipulation",
    "url": "http://rosettacode.org/wiki/Date_manipulation"
  },
  {
    "local_code": "extern crate chrono;\n\nuse chrono::*;\n\nfn main() {\n    for i in 2008..2121 {\n        let dt = Utc.ymd(i, 12, 25);\n        if dt.weekday() == Weekday::Sun {\n            println!(\"{} is a Sunday.\", dt.format(\"%Y-%m-%d\"));\n        }\n    }\n}\n",
    "path": "tasks/day-of-the-week",
    "remote_code": "extern crate chrono;\n\nuse chrono::prelude::*;\n\nfn main() {\n    let years = (2008..2121).filter(|&y| Local.ymd(y, 12, 25).weekday() == Weekday::Sun).collect::<Vec<i32>>();\n    println!(\"Years = {:?}\", years);\n}",
    "title": "Day of the week",
    "url": "http://rosettacode.org/wiki/Day_of_the_week"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "De Bruijn sequences",
    "url": "http://rosettacode.org/wiki/De_Bruijn_sequences"
  },
  {
    "local_code": "// Code available at https://rosettacode.org/wiki/Linear_congruential_generator#Rust\nextern crate linear_congruential_generator;\nextern crate rand;\n\nuse linear_congruential_generator::MsLcg;\nuse rand::prelude::*;\n\n// We can't use `rand::Rng::shuffle` because it uses the more uniform\n// `rand::Rng::gen_range` (`% range` is subject to modulo bias).  If an exact match\n// of the old dealer is not needed, `rand::Rng::shuffle` should be used. Though you also\n// likely should use a better PRNG, `rand` offers a few.\nfn shuffle<T>(rng: &mut MsLcg, deck: &mut [T]) {\n    let len = deck.len() as u32;\n    for i in (1..len).rev() {\n        let j = rng.gen::<u32>() % (i + 1);\n        deck.swap(i as usize, j as usize);\n    }\n}\n\nfn gen_deck() -> Vec<String> {\n    const RANKS: [char; 13] = [\n        'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K',\n    ];\n    const SUITS: [char; 4] = ['C', 'D', 'H', 'S'];\n\n    let render_card = |card: usize| {\n        let (suit, rank) = (card % 4, card / 4);\n        format!(\"{}{}\", RANKS[rank], SUITS[suit])\n    };\n\n    (0..52).map(render_card).collect()\n}\n\nfn deal_ms_fc_board(seed: u32) -> Vec<String> {\n    let mut rng = MsLcg::from_seed_u32(seed);\n    let mut deck = gen_deck();\n\n    shuffle(&mut rng, &mut deck);\n    deck.reverse();\n\n    deck.chunks(8).map(|row| row.join(\" \")).collect::<Vec<_>>()\n}\n\nfn main() {\n    let seed = std::env::args()\n        .nth(1)\n        .and_then(|n| n.parse().ok())\n        .expect(\"A 32-bit seed is required\");\n\n    for row in deal_ms_fc_board(seed) {\n        println!(\": {}\", row);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn seed_one() {\n        assert_eq!(\n            deal_ms_fc_board(1),\n            [\n                \"JD 2D 9H JC 5D 7H 7C 5H\",\n                \"KD KC 9S 5S AD QC KH 3H\",\n                \"2S KS 9D QD JS AS AH 3C\",\n                \"4C 5C TS QH 4H AC 4D 7S\",\n                \"3S TD 4S TH 8H 2C JH 7D\",\n                \"6D 8S 8D QS 6C 3D 8C TC\",\n                \"6S 9C 2H 6H\",\n            ]\n        );\n    }\n\n    #[test]\n    fn seed_617() {\n        assert_eq!(\n            deal_ms_fc_board(617),\n            [\n                \"7D AD 5C 3S 5S 8C 2D AH\",\n                \"TD 7S QD AC 6D 8H AS KH\",\n                \"TH QC 3H 9D 6S 8D 3D TC\",\n                \"KD 5H 9S 3C 8S 7H 4D JS\",\n                \"4C QS 9C 9H 7C 6H 2C 2S\",\n                \"4S TS 2H 5D JC 6C JH QH\",\n                \"JD KS KC 4H\",\n            ]\n        );\n    }\n}\n",
    "path": "tasks/deal-cards-for-freecell",
    "remote_code": "// Code available at https://rosettacode.org/wiki/Linear_congruential_generator#Rust\nextern crate linear_congruential_generator;\n\nuse linear_congruential_generator::{MsLcg, Rng, SeedableRng};\n\n// We can't use `rand::Rng::shuffle` because it uses the more uniform `rand::Rng::gen_range`\n// (`% range` is subject to modulo bias).  If an exact match of the old dealer is not needed,\n// `rand::Rng::shuffle` should be used.\nfn shuffle<T>(rng: &mut MsLcg, deck: &mut [T]) {\n    let len = deck.len() as u32;\n    for i in (1..len).rev() {\n        let j = rng.next_u32() % (i + 1);\n        deck.swap(i as usize, j as usize);\n    }\n}\n\nfn gen_deck() -> Vec<String> {\n    const RANKS: [char; 13] = ['A','2','3','4','5','6','7','8','9','T','J','Q','K'];\n    const SUITS: [char; 4] = ['C', 'D', 'H', 'S'];\n\n    let render_card = |card: usize| {\n        let (suit, rank) = (card % 4, card / 4);\n        format!(\"{}{}\", RANKS[rank], SUITS[suit])\n    };\n\n    (0..52).map(render_card).collect()\n}\n\nfn deal_ms_fc_board(seed: u32) -> Vec<String> {\n    let mut rng = MsLcg::from_seed(seed);\n    let mut deck = gen_deck();\n\n    shuffle(&mut rng, &mut deck);\n    deck.reverse();\n\n    deck.chunks(8).map(|row| row.join(\" \")).collect::<Vec<_>>()\n}\n\nfn main() {\n    let seed = std::env::args()\n        .nth(1)\n        .and_then(|n| n.parse().ok())\n        .expect(\"A 32-bit seed is required\");\n\n    for row in deal_ms_fc_board(seed) {\n        println!(\": {}\", row);\n    }\n}\n",
    "title": "Deal cards for FreeCell",
    "url": "http://rosettacode.org/wiki/Deal_cards_for_FreeCell"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Death Star",
    "url": "http://rosettacode.org/wiki/Death_Star"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Deconvolution/1D",
    "url": "http://rosettacode.org/wiki/Deconvolution/1D"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Deconvolution/2D+",
    "url": "http://rosettacode.org/wiki/Deconvolution/2D%2B"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// The compiler can automatically implement Clone on structs (assuming all members have implemented Clone).\n#[derive(Clone)]\nstruct Tree<T> {\n    left: Leaf<T>,\n    data: T,\n    right: Leaf<T>,\n}\n\ntype Leaf<T> = Option<Box<Tree<T>>>;\n\nimpl<T> Tree<T> {\n    fn root(data: T) -> Self {\n        Self { left: None, data, right: None }\n    }\n\n    fn leaf(d: T) -> Leaf<T> {\n        Some(Box::new(Self::root(d)))\n    }\n}\n\nfn main() {\n    let mut tree = Tree::root([4, 5, 6]);\n    tree.right = Tree::leaf([1, 2, 3]);\n    tree.left = Tree::leaf([7, 8, 9]);\n\n    let newtree = tree.clone();\n}",
    "title": "Deepcopy",
    "url": "http://rosettacode.org/wiki/Deepcopy"
  },
  {
    "local_code": "//! Implements a custom type named `CustomInt`.\n//! This type only implements a subset of all traits within `std::ops`.\n\nuse std::ops;\n\n#[derive(Eq, PartialEq, Ord, PartialOrd, Debug, Copy, Clone)]\nstruct CustomInt {\n    value: i8,\n}\n\n#[derive(Debug)]\nenum CustomIntError {\n    OutOfBoundsAssn,\n}\n\nimpl CustomInt {\n    fn new(v: u8) -> Result<CustomInt, CustomIntError> {\n        if v < 1 || v > 10 {\n            Err(CustomIntError::OutOfBoundsAssn)\n        } else {\n            Ok(CustomInt { value: v as i8 })\n        }\n    }\n}\n\n// custom trait to specify bounds\ntrait Bounded {\n    fn in_bounds(&self);\n}\n\nimpl Bounded for CustomInt {\n    fn in_bounds(&self) {\n        if self.value < 1 || self.value > 10 {\n            panic(self.value);\n        }\n        #[cold]\n        #[inline(never)]\n        fn panic(v: i8) -> ! {\n            panic!(\"CustomInt is out of bounds! {} was value\", v);\n        }\n    }\n}\n\nimpl ops::Add for CustomInt {\n    type Output = CustomInt;\n    fn add(self, rhs: CustomInt) -> CustomInt {\n        let rval = CustomInt {\n            value: (self.value + rhs.value),\n        };\n        rval.in_bounds();\n        rval\n    }\n}\n\nimpl ops::Sub for CustomInt {\n    type Output = CustomInt;\n    fn sub(self, rhs: CustomInt) -> CustomInt {\n        let rval = CustomInt {\n            value: (self.value - rhs.value),\n        };\n        rval.in_bounds();\n        rval\n    }\n}\n\nimpl ops::Mul for CustomInt {\n    type Output = CustomInt;\n    fn mul(self, rhs: CustomInt) -> CustomInt {\n        let rval = CustomInt {\n            value: (self.value * rhs.value),\n        };\n        rval.in_bounds();\n        rval\n    }\n}\n\nimpl ops::Div for CustomInt {\n    type Output = CustomInt;\n    fn div(self, rhs: CustomInt) -> CustomInt {\n        let rval = CustomInt {\n            value: (self.value / rhs.value),\n        };\n        rval.in_bounds();\n        rval\n    }\n}\n\nimpl ops::BitAnd for CustomInt {\n    type Output = CustomInt;\n    fn bitand(self, rhs: CustomInt) -> CustomInt {\n        let rval = CustomInt {\n            value: (self.value & rhs.value),\n        };\n        rval.in_bounds();\n        rval\n    }\n}\n\nimpl ops::BitOr for CustomInt {\n    type Output = CustomInt;\n    fn bitor(self, rhs: CustomInt) -> CustomInt {\n        let rval = CustomInt {\n            value: (self.value | rhs.value),\n        };\n        rval.in_bounds();\n        rval\n    }\n}\n\nimpl ops::BitXor for CustomInt {\n    type Output = CustomInt;\n    fn bitxor(self, rhs: CustomInt) -> CustomInt {\n        let rval = CustomInt {\n            value: (self.value ^ rhs.value),\n        };\n        rval.in_bounds();\n        rval\n    }\n}\n\nfn main() {\n    let cint_2: CustomInt = CustomInt::new(2).unwrap();\n    let cint_3: CustomInt = CustomInt::new(3).unwrap();\n    let cint_4: CustomInt = CustomInt::new(4).unwrap();\n    assert_eq!(cint_2 + cint_4, CustomInt { value: 6 });\n    assert_eq!(cint_4 - cint_2, CustomInt { value: 2 });\n    assert_eq!(cint_4 * cint_2, CustomInt { value: 8 });\n    assert_eq!(cint_4 / cint_2, CustomInt { value: 2 });\n    assert_eq!(cint_3 & cint_2, CustomInt { value: 2 });\n    assert_eq!(cint_3 | cint_2, CustomInt { value: 3 });\n    assert_eq!(cint_3 ^ cint_2, CustomInt { value: 1 });\n}\n\n#[cfg(test)]\nmod tests {\n    use super::CustomInt;\n\n    #[test]\n    fn add_test() {\n        let cint_2: CustomInt = CustomInt::new(2).unwrap();\n        let cint_4: CustomInt = CustomInt::new(4).unwrap();\n        assert_eq!(CustomInt::new(6).unwrap(), cint_2 + cint_4);\n    }\n\n    #[test]\n    fn sub_test() {\n        let cint_2: CustomInt = CustomInt::new(2).unwrap();\n        let cint_4: CustomInt = CustomInt::new(4).unwrap();\n        assert_eq!(CustomInt::new(2).unwrap(), cint_4 - cint_2);\n    }\n\n    #[test]\n    fn mul_test() {\n        let cint_2: CustomInt = CustomInt::new(2).unwrap();\n        let cint_4: CustomInt = CustomInt::new(4).unwrap();\n        assert_eq!(CustomInt::new(8).unwrap(), cint_4 * cint_2);\n    }\n\n    #[test]\n    fn div_test() {\n        let cint_2: CustomInt = CustomInt::new(2).unwrap();\n        let cint_4: CustomInt = CustomInt::new(4).unwrap();\n        assert_eq!(CustomInt::new(2).unwrap(), cint_4 / cint_2);\n    }\n\n    #[test]\n    fn and_test() {\n        let cint_2: CustomInt = CustomInt::new(2).unwrap();\n        let cint_3: CustomInt = CustomInt::new(3).unwrap();\n        assert_eq!(CustomInt::new(2).unwrap(), cint_3 & cint_2);\n    }\n\n    #[test]\n    fn or_test() {\n        let cint_2: CustomInt = CustomInt::new(2).unwrap();\n        let cint_3: CustomInt = CustomInt::new(3).unwrap();\n        assert_eq!(CustomInt::new(3).unwrap(), cint_3 | cint_2);\n    }\n\n    #[test]\n    fn xor_test() {\n        let cint_2: CustomInt = CustomInt::new(2).unwrap();\n        let cint_3: CustomInt = CustomInt::new(3).unwrap();\n        assert_eq!(CustomInt::new(1).unwrap(), cint_3 ^ cint_2);\n    }\n\n    #[test]\n    fn assn_out_of_bounds_test() {\n        let cint_error = CustomInt::new(0);\n        assert!(cint_error.is_err());\n    }\n\n    #[test]\n    #[should_panic(expected = \"CustomInt is out of bounds! 11 was value\")]\n    fn above_out_of_bounds_test() {\n        let cint_10: CustomInt = CustomInt::new(10).unwrap();\n        let cint_1: CustomInt = CustomInt::new(1).unwrap();\n        let _ = cint_10 + cint_1; // should panic here\n    }\n\n    #[test]\n    #[should_panic(expected = \"CustomInt is out of bounds! -9 was value\")]\n    fn below_out_of_bounds_test() {\n        let cint_1: CustomInt = CustomInt::new(1).unwrap();\n        let cint_10: CustomInt = CustomInt::new(10).unwrap();\n        let _ = cint_1 - cint_10; // should panic here\n    }\n}\n",
    "path": "tasks/define-a-primitive-data-type",
    "remote_code": "use std::convert::TryFrom;\n\nmod test_mod {\n    use std::convert::TryFrom;\n    use std::fmt;\n\n    // Because the `i8` is not `pub` this cannot be directly constructed\n    // by code outside this module\n    #[derive(Copy, Clone, Debug)]\n    pub struct TwoDigit(i8);\n\n    impl TryFrom<i8> for TwoDigit {\n        type Error = &'static str;\n\n        fn try_from(value: i8) -> Result<Self, Self::Error> {\n            if value < -99 || value > 99 {\n                Err(\"Number cannot fit into two decimal digits\")\n            } else {\n                Ok(TwoDigit(value))\n            }\n        }\n    }\n\n    impl Into<i8> for TwoDigit {\n        fn into(self) -> i8 { self.0 }\n    }\n\n    // This powers `println!`'s `{}` token.\n    impl fmt::Display for TwoDigit {\n        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n            write!(f, \"{}\", self.0)\n        }\n    }\n}\n\npub fn main() {\n    let foo = test_mod::TwoDigit::try_from(50).unwrap();\n    let bar: i8 = foo.into();\n    println!(\"{} == {}\", foo, bar);\n}",
    "title": "Define a primitive data type",
    "url": "http://rosettacode.org/wiki/Define_a_primitive_data_type"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Delegates",
    "url": "http://rosettacode.org/wiki/Delegates"
  },
  {
    "local_code": "use std::fs;\n\nfn main() {\n    fs::remove_file(\"input.txt\").unwrap();\n    fs::remove_file(\"/input.txt\").unwrap();\n    fs::remove_dir_all(\"docs\").unwrap();\n    fs::remove_dir_all(\"/docs\").unwrap();\n}\n",
    "path": "tasks/delete-a-file",
    "remote_code": "use std::io::{self, Write};\nuse std::fs::{remove_file,remove_dir};\nuse std::path::Path;\nuse std::{process,display};\n \nconst FILE_NAME: &'static str = \"output.txt\";\nconst DIR_NAME : &'static str = \"docs\";\n \nfn main() {\n    delete(\".\").and(delete(\"/\"))\n               .unwrap_or_else(|e| error_handler(e,1));\n}\n \n \nfn delete<P>(root: P) -> io::Result<()>\n    where P: AsRef<Path>\n{\n    remove_file(root.as_ref().join(FILE_NAME))\n        .and(remove_dir(root.as_ref().join(DIR_NAME)))\n}\n \nfn error_handler<E: fmt::Display>(error: E, code: i32) -> ! {\n    let _ = writeln!(&mut io::stderr(), \"{:?}\", error);\n    process::exit(code)\n}",
    "title": "Delete a file",
    "url": "http://rosettacode.org/wiki/Delete_a_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Deming's Funnel",
    "url": "http://rosettacode.org/wiki/Deming's_Funnel"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nextern crate num_iter;\n\nfn main()\n{\n\tprintln!(\"Police Sanitation Fire\");\n\tprintln!(\"----------------------\");\n\n\tfor police in num_iter::range_step(2,7,2){\n\t\tfor sanitation in 1..8 {\n\t\t\tfor fire in 1..8 {\n\t\t\t\tif police!=sanitation && sanitation!=fire && fire!=police && police+fire+sanitation==12 {\n\t\t\t\t\tprintln!(\"{:6}{:11}{:4}\",police,sanitation,fire);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n",
    "title": "Department Numbers",
    "url": "http://rosettacode.org/wiki/Department_Numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn test_division(numerator: u32, denominator: u32) {\n    match numerator.checked_div(denominator) {\n        Some(result) => println!(\"{} / {} = {}\", numerator, denominator, result),\n        None => println!(\"{} / {} results in a division by zero\", numerator, denominator)\n    }\n}\n\nfn main() {\n    test_division(5, 4);\n    test_division(4, 0);\n}",
    "title": "Detect division by zero",
    "url": "http://rosettacode.org/wiki/Detect_division_by_zero"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Determinant and permanent",
    "url": "http://rosettacode.org/wiki/Determinant_and_permanent"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn test_string(input: &str) {\n    println!(\"Checking string {:?} of length {}:\", input, input.chars().count());\n\n    let mut chars = input.chars();\n\n    match chars.next() {\n        Some(first) => {\n            if let Some((character, pos)) = chars.zip(2..).filter(|(c, _)| *c != first).next() {\n                println!(\"\\tNot all characters are the same.\");\n                println!(\"\\t{:?} (0x{:X}) at position {} differs.\", character, character as u32, pos);\n\n                return;\n            }\n        },\n        None => {}\n    }\n\n    println!(\"\\tAll characters in the string are the same\");\n}\n\nfn main() {\n    let tests = [\"\", \"   \", \"2\", \"333\", \".55\", \"tttTTT\", \"4444 444k\", \"pépé\", \"🐶🐶🐺🐶\", \"🎄🎄🎄🎄\"];\n\n    for string in &tests {\n        test_string(string);\n    }\n}",
    "title": "Determine if a string has all the same characters",
    "url": "http://rosettacode.org/wiki/Determine_if_a_string_has_all_the_same_characters"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Determine if a string has all unique characters",
    "url": "http://rosettacode.org/wiki/Determine_if_a_string_has_all_unique_characters"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn collapse_string(val: &str) -> String {\n    let mut output = String::new();\n    let mut chars = val.chars().peekable();\n\n    while let Some(c) = chars.next() {\n        while let Some(&b) = chars.peek() {\n            if b == c {\n                chars.next();\n            } else {\n                break;\n            }\n        }\n\n        output.push(c);\n    }\n\n    output\n}\n\nfn main() {\n    let tests = [\n        \"122333444455555666666777777788888888999999999\",\n        \"\",\n        \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \",\n        \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n        \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n        \"                                                    --- Harry S Truman  \",\n        \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n        \"headmistressship\",\n    ];\n\n    for s in &tests {\n        println!(\"Old: {:>3} <<<{}>>>\", s.len(), s);\n        let collapsed = collapse_string(s);\n        println!(\"New: {:>3} <<<{}>>>\", collapsed.len(), collapsed);\n\n        println!();\n    }\n}",
    "title": "Determine if a string is collapsible",
    "url": "http://rosettacode.org/wiki/Determine_if_a_string_is_collapsible"
  },
  {
    "local_code": "fn is_numeric(s: &str) -> bool {\n    s.parse::<f64>().is_ok()\n}\n\nfn main() {\n    println!(\"{}\", is_numeric(\"4.034\"));\n}\n\n#[test]\nfn test_isize() {\n    assert!(is_numeric(\"4\"));\n    assert!(is_numeric(\"-4\"));\n}\n\n#[test]\nfn test_str() {\n    assert!(!is_numeric(\"j\"));\n}\n\n#[test]\nfn test_float() {\n    assert!(is_numeric(\"1.034\"));\n    assert!(is_numeric(\"-1.034\"));\n}\n",
    "path": "tasks/determine-if-a-string-is-numeric",
    "remote_code": "// This function is not limited to just numeric types but rather anything that implements the FromStr trait.\nfn parsable<T: FromStr>(s: &str) -> bool {\n    s.parse::<T>().is_ok()\n}",
    "title": "Determine if a string is numeric",
    "url": "http://rosettacode.org/wiki/Determine_if_a_string_is_numeric"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Determine if a string is squeezable",
    "url": "http://rosettacode.org/wiki/Determine_if_a_string_is_squeezable"
  },
  {
    "local_code": "use std::net::TcpListener;\n\nfn create_app_lock(port: u16) -> TcpListener {\n    match TcpListener::bind((\"0.0.0.0\", port)) {\n        Ok(socket) => socket,\n        Err(e) => {\n            panic!(\n                \"Couldn't lock port {}: another instance already running? ({})\",\n                port, e\n            );\n        }\n    }\n}\n\nfn remove_app_lock(socket: TcpListener) {\n    drop(socket);\n}\n\nfn main() {\n    #[cfg_attr(feature = \"cargo-clippy\", allow(unreadable_literal))]\n    let lock_socket = create_app_lock(12345);\n    // ...\n    // your code here\n    // ...\n    remove_app_lock(lock_socket);\n}\n",
    "path": "tasks/determine-if-only-one-instance-is-running",
    "remote_code": "use std::net::TcpListener;\n\nfn create_app_lock(port: u16) -> TcpListener {\n    match TcpListener::bind((\"0.0.0.0\", port)) {\n        Ok(socket) => {\n            socket\n        },\n        Err(_) => {\n            panic!(\"Couldn't lock port {}: another instance already running?\", port);\n        }\n    }\n}\n\nfn remove_app_lock(socket: TcpListener) {\n    drop(socket);\n}\n\nfn main() {\n    let lock_socket = create_app_lock(12345);\n    // ...\n    // your code here\n    // ...\n    remove_app_lock(lock_socket);\n}",
    "title": "Determine if only one instance is running",
    "url": "http://rosettacode.org/wiki/Determine_if_only_one_instance_is_running"
  },
  {
    "local_code": "fn sum_digits(mut n: u64, base: u64) -> u64 {\n    let mut sum = 0u64;\n    while n > 0 {\n        sum += n % base;\n        n /= base;\n    }\n    sum\n}\n\n// Returns tuple of (additive-persistence, digital-root)\nfn digital_root(mut num: u64, base: u64) -> (u64, u64) {\n    let mut pers = 0;\n    while num >= base {\n        pers += 1;\n        num = sum_digits(num, base);\n    }\n    (pers, num)\n}\n\nfn main() {\n    // Test base 10\n    let values = [627_615u64, 39_390u64, 588_225u64, 393_900_588_225u64];\n    for &value in &values {\n        let (pers, root) = digital_root(value, 10);\n        println!(\n            \"{} has digital root {} and additive persistance {}\",\n            value, root, pers\n        );\n    }\n\n    println!();\n\n    // Test base 16\n    let values_base16 = [0x7e0, 0x14_e344, 0xd6_0141, 0x1234_3210];\n    for &value in &values_base16 {\n        let (pers, root) = digital_root(value, 16);\n        println!(\n            \"0x{:x} has digital root 0x{:x} and additive persistance 0x{:x}\",\n            value, root, pers\n        );\n    }\n}\n\n#[test]\nfn test_sum_digits() {\n    let sum = sum_digits(15u64, 10u64);\n    assert_eq!(sum, 6);\n}\n\n#[test]\nfn test_base_ten() {\n    // Test tuples: (value, root, pers)\n    let test_pairs = [\n        (627_615u64, 9, 2),\n        (39_390u64, 6, 2),\n        (588_225u64, 3, 2),\n        (393_900_588_225u64, 9, 2),\n    ];\n\n    for &(value, result_root, result_pers) in test_pairs.iter() {\n        let (pers, root) = digital_root(value, 10u64);\n        println!(\n            \"{} has digital root {} and additive persistance {}\",\n            value, root, pers\n        );\n        assert_eq!(pers, result_pers);\n        assert_eq!(root, result_root);\n    }\n}\n\n#[test]\nfn test_base_16() {\n    // Test tuples: (value, root, pers)\n    let test_pairs = [\n        (0x7e0, 0x6, 0x2),\n        (0x14e344, 0xf, 0x2),\n        (0xd60141, 0xa, 0x2),\n        (0x12343210, 0x1, 0x2),\n    ];\n\n    for &(value, result_root, result_pers) in test_pairs.iter() {\n        let (pers, root) = digital_root(value, 16u64);\n        println!(\n            \"{:x} has digital root {:x} and additive persistance {:x}\",\n            value, root, pers\n        );\n        assert_eq!(pers, result_pers);\n        assert_eq!(root, result_root);\n    }\n}\n",
    "path": "tasks/digital-root",
    "remote_code": "fn sum_digits(mut n: u64, base: u64) -> u64 {\n    let mut sum = 0u64;\n    while n > 0 {\n        sum = sum + (n % base);\n        n = n / base;\n    }\n    sum\n}\n\n// Returns tuple of (additive-persistence, digital-root)\nfn digital_root(mut num: u64, base: u64) -> (u64, u64) {\n    let mut pers = 0;\n    while num >= base {\n        pers = pers + 1;\n        num = sum_digits(num, base);\n    }\n    (pers, num)\n}\n\nfn main() {\n\n    // Test base 10\n    let values = [627615u64, 39390u64, 588225u64, 393900588225u64];\n    for &value in values.iter() {\n        let (pers, root) = digital_root(value, 10);\n        println!(\"{} has digital root {} and additive persistance {}\",\n                 value,\n                 root,\n                 pers);\n    }\n\n    println!(\"\");\n\n    // Test base 16\n    let values_base16 = [0x7e0, 0x14e344, 0xd60141, 0x12343210];\n    for &value in values_base16.iter() {\n        let (pers, root) = digital_root(value, 16);\n        println!(\"0x{:x} has digital root 0x{:x} and additive persistance 0x{:x}\",\n                 value,\n                 root,\n                 pers);\n    }\n}",
    "title": "Digital root",
    "url": "http://rosettacode.org/wiki/Digital_root"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Digital root/Multiplicative digital root",
    "url": "http://rosettacode.org/wiki/Digital_root/Multiplicative_digital_root"
  },
  {
    "local_code": "use std::cmp::Ordering;\nuse std::collections::{BinaryHeap, HashMap, VecDeque};\nuse std::usize;\n\ntype Node = usize;\ntype Cost = usize;\ntype Edge = (Node, Node);\n\n/// The `DistPair` struct is for the priority queue.\n#[derive(Eq, PartialEq, PartialOrd)]\nstruct DistPair(Node, Cost);\nimpl Ord for DistPair {\n    fn cmp(&self, other: &DistPair) -> Ordering {\n        let DistPair(_, dist_a) = *self;\n        let DistPair(_, dist_b) = *other;\n        dist_b.cmp(&dist_a) // Intentionally reversed\n    }\n}\n\n/// Graph structure, represented as an adjacency List.\nstruct Graph<'a> {\n    vertices: Vec<&'a str>,\n    adj_list: Vec<Vec<Node>>,\n    costs: HashMap<Edge, Cost>,\n}\n\nimpl<'a> Graph<'a> {\n    fn new() -> Graph<'a> {\n        Graph {\n            vertices: Vec::new(),\n            adj_list: Vec::new(),\n            costs: HashMap::new(),\n        }\n    }\n\n    /// Returns the index of the vertex, or `None` if vertex not found.\n    fn vertex_index(&self, vertex: &str) -> Option<Node> {\n        self.vertices.iter().position(|&v| v == vertex)\n    }\n\n    /// Returns the index of the vertex. If vertex is not found, inserts the vertex.\n    fn get_or_insert_vertex(&mut self, vertex: &'a str) -> Node {\n        self.vertex_index(vertex).unwrap_or_else(|| {\n            self.adj_list.push(Vec::new());\n            self.vertices.push(vertex);\n            self.vertices.len() - 1\n        })\n    }\n\n    /// Adds the given edge to the graph.\n    fn add_edge(&mut self, from: &'a str, to: &'a str, cost: usize) {\n        let from_idx = self.get_or_insert_vertex(from);\n        let to_idx = self.get_or_insert_vertex(to);\n\n        // Insert, and then if the insertion added a new key-value pair...\n        if self.costs.insert((from_idx, to_idx), cost).is_none() {\n            self.adj_list[from_idx].push(to_idx);\n        }\n    }\n\n    /// Implements Dijkstra's algorithm. This uses a priority queue to determine which vertex to\n    /// visit first. Terminates on discovering the target vertex.\n    ///\n    /// Returns vector of vertices representing the path, or an empty vector if there's no path, or\n    /// if the source or target is not in the graph.\n    fn dijkstra(&self, source: &str, target: &str) -> Vec<&str> {\n        let num_vert = self.vertices.len();\n        let mut dist = vec![usize::MAX; num_vert]; // Close enough to infinity\n        let mut prev: HashMap<Node, Node> = HashMap::new();\n        let mut queue: BinaryHeap<DistPair> = BinaryHeap::new();\n\n        let source_idx = match self.vertex_index(source) {\n            Some(idx) => idx,\n            None => return Vec::new(), // Source not in graph, return empty path.\n        };\n\n        let target_idx = match self.vertex_index(target) {\n            Some(idx) => idx,\n            None => return Vec::new(), // Target not in graph, return empty path.\n        };\n\n        dist[source_idx] = 0;\n        queue.push(DistPair(source_idx, dist[source_idx]));\n\n        while let Some(DistPair(u, dist_u)) = queue.pop() {\n            for &v in &(self.adj_list[u]) {\n                let cost_uv = self.costs.get(&(u, v)).unwrap_or(&usize::MAX);\n                let alt = dist_u + cost_uv;\n                if alt < dist[v] {\n                    prev.insert(v, u);\n                    dist[v] = alt;\n                    queue.push(DistPair(v, dist[v]));\n                }\n                if v == target_idx {\n                    break;\n                }\n            }\n        }\n\n        let mut temp_path: VecDeque<&str> = VecDeque::new();\n        let mut curr = target_idx;\n        temp_path.push_front(self.vertices[curr]);\n        while let Some(&parent) = prev.get(&curr) {\n            curr = parent;\n            temp_path.push_front(self.vertices[curr]);\n            if curr == source_idx {\n                return Vec::from(temp_path);\n            }\n        }\n        Vec::new()\n    }\n}\n\nimpl<'a> Default for Graph<'a> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nfn main() {\n    let mut graph = Graph::new();\n    graph.add_edge(\"a\", \"b\", 7);\n    graph.add_edge(\"a\", \"c\", 9);\n    graph.add_edge(\"a\", \"f\", 14);\n    graph.add_edge(\"b\", \"c\", 10);\n    graph.add_edge(\"b\", \"d\", 15);\n    graph.add_edge(\"c\", \"d\", 11);\n    graph.add_edge(\"c\", \"f\", 2);\n    graph.add_edge(\"d\", \"e\", 6);\n    graph.add_edge(\"e\", \"f\", 9);\n\n    let path = graph.dijkstra(\"a\", \"e\");\n    println!(\"Path is: {:?}\", path);\n}\n\n#[test]\nfn test_dijkstras() {\n    let mut graph = Graph::new();\n    graph.add_edge(\"a\", \"b\", 7);\n    graph.add_edge(\"b\", \"c\", 10);\n    graph.add_edge(\"c\", \"d\", 5);\n    graph.add_edge(\"a\", \"d\", 30);\n    graph.add_edge(\"y\", \"z\", 10); //Disconnected from the rest\n\n    assert_eq!(graph.dijkstra(\"a\", \"d\"), [\"a\", \"b\", \"c\", \"d\"]);\n    assert!(graph.dijkstra(\"a\", \"y\").is_empty());\n    assert!(graph.dijkstra(\"e\", \"y\").is_empty());\n    assert!(graph.dijkstra(\"a\", \"e\").is_empty());\n\n    let mut graph = Graph::new();\n    graph.add_edge(\"a\", \"b\", 7);\n    graph.add_edge(\"a\", \"c\", 9);\n    graph.add_edge(\"a\", \"f\", 14);\n    graph.add_edge(\"b\", \"c\", 10);\n    graph.add_edge(\"b\", \"d\", 15);\n    graph.add_edge(\"c\", \"d\", 11);\n    graph.add_edge(\"c\", \"f\", 2);\n    graph.add_edge(\"d\", \"e\", 6);\n    graph.add_edge(\"e\", \"f\", 9);\n\n    assert_eq!(graph.dijkstra(\"a\", \"e\"), [\"a\", \"c\", \"d\", \"e\"]);\n}\n",
    "path": "tasks/dijkstras-algorithm",
    "remote_code": "use std::cmp::Ordering;\nuse std::collections::BinaryHeap;\nuse std::usize;\n\n\nstruct Grid<T> {\n    nodes: Vec<Node<T>>,\n}\n\nstruct Node<T> {\n    data: T,\n    edges: Vec<(usize,usize)>,\n}\n\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct State {\n    node: usize,\n    cost: usize,\n}\n\n// Manually implement Ord so we get a min-heap instead of a max-heap\nimpl Ord for State {\n    fn cmp(&self, other: &Self) -> Ordering {\n        other.cost.cmp(&self.cost)\n    }\n}\n\nimpl PartialOrd for State {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\ntype WeightedEdge = (usize, usize, usize);\n\nimpl<T> Grid<T> {\n    fn new() -> Self {\n        Grid { nodes: Vec::new() }\n    }\n\n    fn add_node(&mut self, data: T) -> usize {\n        let node = Node {\n            edges: Vec::new(),\n            data: data,\n        };\n        self.nodes.push(node);\n        self.nodes.len() - 1\n    }\n\n    fn create_edges<'a, I>(&mut self, iterator: I) where I: IntoIterator<Item=&'a WeightedEdge> {\n        for &(start,end,weight) in iterator.into_iter() {\n            self.nodes[start].edges.push((end,weight));\n            self.nodes[end].edges.push((start,weight));\n        }\n    \n    }\n\n    fn find_path(&self, start: usize, end: usize) -> Option<(Vec<usize>, usize)> {\n        let mut dist = vec![(usize::MAX, None); self.nodes.len()];\n\n        let mut heap = BinaryHeap::new();\n        dist[start] = (0, None);\n        heap.push(State {\n            node: start,\n            cost: 0,\n        });\n\n        while let Some(State { node, cost }) = heap.pop() {\n            if node == end {\n                let mut path = Vec::with_capacity(dist.len() / 2);\n                let mut current_dist = dist[end];\n                path.push(end);\n                while let Some(prev) = current_dist.1 {\n                    path.push(prev);\n                    current_dist = dist[prev];\n                }\n                path.reverse();\n                return Some((path, cost));\n            }\n\n            if cost > dist[node].0 {\n                continue;\n            }\n            for edge in &self.nodes[node].edges {\n                let next = State {\n                    node: edge.0,\n                    cost: cost + edge.1,\n                };\n                if next.cost < dist[next.node].0 {\n                    dist[next.node] = (next.cost, Some(node));\n                    heap.push(next);\n                }\n            }\n        }\n        None\n    }\n}\n\nfn main() {\n    let mut grid = Grid::new();\n    let (a,b,c,d,e,f) = (grid.add_node(\"a\"), grid.add_node(\"b\"),\n                         grid.add_node(\"c\"), grid.add_node(\"d\"),\n                         grid.add_node(\"e\"), grid.add_node(\"f\"));\n\n    grid.create_edges(&[\n        (a,b,7) ,(a,c,9) ,(a,f,14),\n        (b,c,10),(b,d,15),(c,d,11),\n        (c,f,2) ,(d,e,6) ,(e,f,9) ,\n    ]);\n\n    let (path, cost) = grid.find_path(a,e).unwrap();\n\n    print!(\"{}\", grid.nodes[path[0]].data);\n    for i in path.iter().skip(1) {\n        print!(\" -> {}\", grid.nodes[*i].data);\n    }\n    println!(\"\\nCost: {}\", cost);\n\n}",
    "title": "Dijkstra's algorithm",
    "url": "http://rosettacode.org/wiki/Dijkstra's_algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Dinesman's multiple-dwelling problem",
    "url": "http://rosettacode.org/wiki/Dinesman's_multiple-dwelling_problem"
  },
  {
    "local_code": "//! A Rust implementation of a solution for the Dining Philosophers Problem. We prevent a deadlock\n//! by using Dijkstra's solution of making a single diner \"left-handed.\" That is, all diners except\n//! one pick up the chopstick \"to their left\" and then the chopstick \"to their right.\" The\n//! remaining diner performs this in reverse.\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nstruct Philosopher {\n    name: String,\n    left: usize,\n    right: usize,\n}\n\nimpl Philosopher {\n    fn new(name: &str, left: usize, right: usize) -> Philosopher {\n        Philosopher {\n            name: name.to_string(),\n            left: left,\n            right: right,\n        }\n    }\n\n    fn eat(&self, table: &Table) {\n        let _left = table.forks[self.left].lock().unwrap();\n        let _right = table.forks[self.right].lock().unwrap();\n\n        println!(\"{} is eating.\", self.name);\n\n        thread::sleep(Duration::from_secs(1));\n\n        println!(\"{} is done eating.\", self.name);\n    }\n}\n\nstruct Table {\n    forks: Vec<Mutex<()>>,\n}\n\nfn main() {\n    let table = Arc::new(Table {\n        forks: vec![\n            Mutex::new(()),\n            Mutex::new(()),\n            Mutex::new(()),\n            Mutex::new(()),\n            Mutex::new(()),\n        ],\n    });\n\n    let philosophers = vec![\n        Philosopher::new(\"Baruch Spinoza\", 0, 1),\n        Philosopher::new(\"Gilles Deleuze\", 1, 2),\n        Philosopher::new(\"Karl Marx\", 2, 3),\n        Philosopher::new(\"Friedrich Nietzsche\", 3, 4),\n        Philosopher::new(\"Michel Foucault\", 0, 4),\n    ];\n\n    let handles: Vec<_> = philosophers\n        .into_iter()\n        .map(|p| {\n            let table = Arc::clone(&table);\n\n            thread::spawn(move || {\n                p.eat(&table);\n            })\n        })\n        .collect();\n\n    for h in handles {\n        h.join().unwrap();\n    }\n}\n",
    "path": "tasks/dining-philosophers",
    "remote_code": "use std::thread;\nuse std::sync::{Mutex, Arc};\n\nstruct Philosopher {\n    name: String,\n    left: usize,\n    right: usize,\n}\n\nimpl Philosopher {\n    fn new(name: &str, left: usize, right: usize) -> Philosopher {\n        Philosopher {\n            name: name.to_string(),\n            left: left,\n            right: right,\n        }\n    }\n\n    fn eat(&self, table: &Table) {\n        let _left = table.forks[self.left].lock().unwrap();\n        let _right = table.forks[self.right].lock().unwrap();\n\n        println!(\"{} is eating.\", self.name);\n\n        thread::sleep_ms(1000);\n\n        println!(\"{} is done eating.\", self.name);\n    }\n}\n\nstruct Table {\n    forks: Vec<Mutex<()>>,\n}\n\nfn main() {\n    let table = Arc::new(Table { forks: vec![\n        Mutex::new(()),\n        Mutex::new(()),\n        Mutex::new(()),\n        Mutex::new(()),\n        Mutex::new(()),\n    ]});\n\n    let philosophers = vec![\n        Philosopher::new(\"Baruch Spinoza\", 0, 1),\n        Philosopher::new(\"Gilles Deleuze\", 1, 2),\n        Philosopher::new(\"Karl Marx\", 2, 3),\n        Philosopher::new(\"Friedrich Nietzsche\", 3, 4),\n        Philosopher::new(\"Michel Foucault\", 0, 4),\n    ];\n\n    let handles: Vec<_> = philosophers.into_iter().map(|p| {\n        let table = table.clone();\n\n        thread::spawn(move || {\n            p.eat(&table);\n        })\n    }).collect();\n\n    for h in handles {\n        h.join().unwrap();\n    }\n}",
    "title": "Dining philosophers",
    "url": "http://rosettacode.org/wiki/Dining_philosophers"
  },
  {
    "local_code": "extern crate chrono;\n\nuse chrono::*;\n\nconst SEASONS: [&str; 5] = [\n    \"Chaos\",\n    \"Discord\",\n    \"Confusion\",\n    \"Bureaucracy\",\n    \"The Aftermath\",\n];\nconst WEEKDAYS: [&str; 5] = [\n    \"Sweetmorn\",\n    \"Boomtime\",\n    \"Pungenday\",\n    \"Prickle-Prickle\",\n    \"Setting Orange\",\n];\nconst YEAR_OFFSET: i32 = 1166;\n\nfn discordian_day(day: usize, leap: bool) -> String {\n    if day == 59 && leap {\n        return String::from(\"St. Tib's Day\");\n    }\n    let offset = if day > 59 && leap { 1 } else { 0 };\n    let day_off = day - offset;\n    let day_num = day_off % 73 + 1;\n    let season = SEASONS[day_off / 73];\n    let weekday = WEEKDAYS[day_off % 5];\n    format!(\"{}, {} {}\", weekday, season, day_num)\n}\n\nfn discordian_date<T: Datelike>(date: &T) -> String {\n    let dday = discordian_day(date.ordinal0() as usize, is_leap_year(date.year()));\n    let year = date.year() + YEAR_OFFSET;\n    format!(\"{}, YOLD {}\", dday, year)\n}\n\n// implementation from https://en.wikipedia.org/wiki/Leap_year#Algorithm\n#[cfg_attr(feature = \"cargo-clippy\", allow(if_same_then_else, needless_bool))]\nfn is_leap_year(year: i32) -> bool {\n    if year % 4 != 0 {\n        false\n    } else if year % 100 != 0 {\n        true\n    } else if year % 400 != 0 {\n        false\n    } else {\n        true\n    }\n}\n\nfn main() {\n    // sample date\n    let utc = Utc::now();\n    println!(\"{} in the Discordian Calendar is:\", utc);\n    println!(\"{}\", discordian_date(&utc));\n    let local: DateTime<Local> = Local::now();\n    println!(\"{} in the Discordian Calendar is:\", local);\n    println!(\"{}\", discordian_date(&local));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::discordian_date;\n    use chrono::*;\n\n    #[test]\n    fn curse_of_greyface_test() {\n        let dt = Utc.ymd(-1166, 1, 1);\n        assert_eq!(\"Sweetmorn, Chaos 1, YOLD 0\", discordian_date(&dt));\n    }\n\n    #[test]\n    fn before_leap_day_test() {\n        let dt = Utc.ymd(2016, 2, 28);\n        assert_eq!(\"Prickle-Prickle, Chaos 59, YOLD 3182\", discordian_date(&dt));\n    }\n\n    #[test]\n    fn leap_day_test() {\n        let dt = Utc.ymd(2016, 2, 29);\n        assert_eq!(\"St. Tib's Day, YOLD 3182\", discordian_date(&dt));\n    }\n\n    #[test]\n    fn after_leap_day_test() {\n        let dt = Utc.ymd(2016, 3, 1);\n        assert_eq!(\"Setting Orange, Chaos 60, YOLD 3182\", discordian_date(&dt));\n    }\n\n    #[test]\n    fn before_not_leap_day_test() {\n        let dt = Utc.ymd(2015, 2, 28);\n        assert_eq!(\"Prickle-Prickle, Chaos 59, YOLD 3181\", discordian_date(&dt));\n    }\n\n    #[test]\n    fn not_leap_day_test() {\n        let dt = Utc.ymd(2015, 3, 1);\n        assert_eq!(\"Setting Orange, Chaos 60, YOLD 3181\", discordian_date(&dt));\n    }\n\n    #[test]\n    fn birthday_test() {\n        let dt = Utc.ymd(1994, 5, 14);\n        assert_eq!(\n            \"Prickle-Prickle, Discord 61, YOLD 3160\",\n            discordian_date(&dt)\n        );\n    }\n\n    #[test]\n    fn magna_carta_test() {\n        let dt = Utc.ymd(1215, 6, 15);\n        assert_eq!(\"Sweetmorn, Confusion 20, YOLD 2381\", discordian_date(&dt));\n    }\n}\n",
    "path": "tasks/discordian-date",
    "remote_code": "extern crate chrono;\n\nuse chrono::NaiveDate;\nuse std::str::FromStr;\n\nfn main() {\n    let date = std::env::args().nth(1).expect(\"Please provide a YYYY-MM-DD date.\");\n    println!(\"{} is {}\", date, NaiveDate::from_str(&date).unwrap().to_poee());\n}\n\n// The necessary constants for the seasons, weekdays, and holydays.\nconst APOSTLES: [&str; 5] = [\"Mungday\", \"Mojoday\", \"Syaday\", \"Zaraday\", \"Maladay\"];\nconst HOLYDAYS: [&str; 5] = [\"Chaoflux\", \"Discoflux\", \"Confuflux\", \"Bureflux\", \"Afflux\"];\nconst SEASONS: [&str; 5] = [\"Chaos\", \"Discord\", \"Confusion\", \"Bureaucracy\", \"The Aftermath\"];\nconst WEEKDAYS: [&str; 5] = [\"Sweetmorn\", \"Boomtime\", \"Pungenday\", \"Prickle-Prickle\", \"Setting Orange\"];\n\n// The necessary constants for the conversion.\nconst APOSTLE_HOLYDAY: usize = 5;\nconst CURSE_OF_GREYFACE: i32 = 1166;\nconst SEASON_DAYS: usize = 73;\nconst SEASON_HOLYDAY: usize = 50;\nconst ST_TIBS_DAY: usize = 59;\nconst WEEK_DAYS: usize = 5;\n\n// This extends the `Datelike` trait of Rust's Chrono crate with a method that\n// prints any Datelike type as a String.\nimpl<T: Datelike> DiscordianDate for T {}\npub trait DiscordianDate: Datelike {\n    fn to_poee(&self) -> String {\n        let day = self.ordinal0() as usize;\n        let leap = self.year() % 4 == 0 && self.year() % 100 != 0 || self.year() % 400 == 0;\n        let year = self.year() + CURSE_OF_GREYFACE;\n\n        if leap && day == ST_TIBS_DAY { return format!(\"St. Tib's Day, in the YOLD {}\", year); }\n\n        let day_offset = if leap && day > ST_TIBS_DAY { day - 1 } else { day };\n\n        let day_of_season = day_offset % SEASON_DAYS + 1;\n\n        let season = SEASONS[day_offset / SEASON_DAYS];\n        let weekday = WEEKDAYS[day_offset % WEEK_DAYS];\n\n        let holiday = if day_of_season == APOSTLE_HOLYDAY {\n            format!(\"\\nCelebrate {}\", APOSTLES[day_offset / SEASON_DAYS])\n        } else if day_of_season == SEASON_HOLYDAY {\n            format!(\"\\nCelebrate {}\", HOLYDAYS[day_offset / SEASON_DAYS])\n        } else {\n            String::with_capacity(0)\n        };\n\n        format!(\"{}, the {} day of {} in the YOLD {}{}\",\n            weekday, ordinalize(day_of_season), season, year, holiday)\n    }\n}\n\n/// A helper function to ordinalize a numeral.\nfn ordinalize(num: usize) -> String {\n    let s = format!(\"{}\", num);\n\n    let suffix = if s.ends_with('1') && !s.ends_with(\"11\") {\n        \"st\"\n    } else if s.ends_with('2') && !s.ends_with(\"12\") {\n        \"nd\"\n    } else if s.ends_with('3') && !s.ends_with(\"13\") {\n        \"rd\"\n    } else {\n        \"th\"\n    };\n\n    format!(\"{}{}\", s, suffix)\n}\n",
    "title": "Discordian date",
    "url": "http://rosettacode.org/wiki/Discordian_date"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Distributed programming",
    "url": "http://rosettacode.org/wiki/Distributed_programming"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "//! Documentation for the module\n//!\n//! **Lorem ipsum** dolor sit amet, consectetur adipiscing elit. Aenean a\n//! sagittis sapien, eu pellentesque ex. Nulla facilisi. Praesent eget sapien\n//! sollicitudin, laoreet ipsum at, fringilla augue. In hac habitasse platea\n//! dictumst. Nunc in neque sed magna suscipit mattis sed quis mi. Curabitur\n//! quis mi a ante mollis commodo. Sed tincidunt ut metus vel accumsan.\n#![doc(html_favicon_url = \"https://example.com/favicon.ico\")]\n#![doc(html_logo_url = \"https://example.com/logo.png\")]\n\n/// Documentation for a constant\npub const THINGY: u32 = 42;\n\n/// Documentation for a Rust `enum` (tagged union)\npub enum Whatsit {\n    /// Documentation for the `Yo` variant\n    Yo(Whatchamabob),\n    /// Documentation for the `HoHo` variant\n    HoHo,\n}\n\n/// Documentation for a data structure\npub struct Whatchamabob {\n    /// Doodads do dad\n    pub doodad: f64,\n    /// Whether or not this is a thingamabob\n    pub thingamabob: bool\n}\n\n/// Documentation for a trait (interface)\npub trait Frobnify {\n    /// `Frobnify` something\n    fn frob(&self);\n}\n\n/// Documentation specific to this struct's implementation of `Frobnify`\nimpl Frobnify for Whatchamabob {\n    /// `Frobnify` the `Whatchamabob`\n    fn frob(&self) {\n        println!(\"Frobbed: {}\", self.doodad);\n    }\n}\n\n/// Documentation for a function\n///\n/// Pellentesque sodales lacus nisi, in malesuada lectus vestibulum eget.\n/// Integer rhoncus imperdiet justo. Pellentesque egestas sem ac\n/// consectetur suscipit. Maecenas tempus dignissim purus, eu tincidunt mi\n/// tincidunt id. Morbi ac laoreet erat, eu ultricies neque. Fusce molestie\n/// urna quis nisl condimentum, sit amet fringilla nunc ornare. Pellentesque\n/// vestibulum ac nibh eu accumsan. In ornare orci at rhoncus finibus. Donec\n/// sed ipsum ex. Pellentesque ante nisl, pharetra id purus auctor, euismod\n/// semper erat. Nunc sit amet eros elit.\npub fn main() {\n    let foo = Whatchamabob{ doodad: 1.2, thingamabob: false };\n    foo.frob();\n}",
    "title": "Documentation",
    "url": "http://rosettacode.org/wiki/Documentation"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Dot_product\nextern crate num;\n\nuse num::traits::Zero;\nuse std::ops::Mul;\n\nfn dotp<T: Zero + Mul<Output = T> + Copy>(this: &[T], other: &[T]) -> T {\n    assert!(this.len() == other.len(), \"The dimensions must be equal\");\n\n    let zero: T = Zero::zero();\n    this.iter()\n        .zip(other.iter())\n        .map(|(&a, &b)| a * b)\n        .fold(zero, |sum, n| sum + n)\n}\n\nfn main() {\n    let a = &[1.0f32, 3.0, -5.0];\n    let b = &[4.0f32, -2.0, -1.0];\n    println!(\"{}\", dotp(a, b));\n}\n\n#[test]\nfn test_dotp() {\n    let result = dotp(&[1i32, 3, -5], &[4i32, -2, -1]);\n    assert_eq!(result, 3);\n}\n",
    "path": "tasks/dot-product",
    "remote_code": "// alternatively, fn dot_product(a: &Vec<u32>, b: &Vec<u32>)\n// but using slices is more general and rustic\nfn dot_product(a: &[i32], b: &[i32]) -> Option<i32> {\n    if a.len() != b.len() { return None }\n    Some(\n        a.iter()\n            .zip( b.iter() )\n            .fold(0, |sum, (el_a, el_b)| sum + el_a*el_b)\n    )\n}\n\n\nfn main() {\n    let v1 = vec![1, 3, -5];\n    let v2 = vec![4, -2, -1];\n\n    println!(\"{}\", dot_product(&v1, &v2).unwrap());\n}",
    "title": "Dot product",
    "url": "http://rosettacode.org/wiki/Dot_product"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Doubly-linked list/Definition",
    "url": "http://rosettacode.org/wiki/Doubly-linked_list/Definition"
  },
  {
    "local_code": "//! Doubly linked lists present a problem in Rust due to its ownership model. There cannot be two\n//! mutable references to the same object, so what are we to do? Below are the relevant lines (with\n//! added comments) from the `std` implementation ([Documentation][doc] [Source][src]).\n//!\n//! In order to circumvent the multiple mutable references, raw C-like pointers are used. Note that\n//! these cannot be dereferenced with guaranteed safety and thus dereferencing is relegated to\n//! `unsafe {}` blocks.\n//!\n//! [doc]: https://doc.rust-lang.org/std/collections/struct.LinkedList.html\n//! [src]: https://github.com/rust-lang/rust/blob/master/src/libcollections/linked_list.rs\n\n#![allow(dead_code)]\n\nuse std::ptr;\n\n/// User-facing implementation\npub struct LinkedList<T> {\n    length: usize,\n    list_head: Link<T>,\n    list_tail: Rawlink<Node<T>>,\n}\n\nimpl<T> LinkedList<T> {\n    pub fn new() -> LinkedList<T> {\n        LinkedList {\n            length: 0,\n            list_head: None,\n            list_tail: Rawlink { p: ptr::null_mut() },\n        }\n    }\n}\n\nimpl<T> Default for LinkedList<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Type definition\ntype Link<T> = Option<Box<Node<T>>>;\n\n/// Pointer is wrapped in struct so that Option-like methods can be added to it later (wrappers\n/// around NULL checks)\nstruct Rawlink<T> {\n    /// Raw mutable pointer\n    p: *mut T,\n}\n\nstruct Node<T> {\n    next: Link<T>,\n    prev: Rawlink<Node<T>>,\n    value: T,\n}\n\nfn main() {\n    // Note: you can just import the standard definition.\n    use std::collections;\n\n    // Doubly linked list containing 32-bit integers\n    let list1 = collections::LinkedList::<i32>::new();\n\n    // Doubly linked list containing 32-bit integers\n    let list2 = self::LinkedList::<i32>::new();\n\n    drop(list1);\n    drop(list2);\n}\n",
    "path": "tasks/doubly-linked-list/element-definition",
    "remote_code": "use std::collections::LinkedList;\nfn main() {\n     // Doubly linked list containing 32-bit integers\n     let list = LinkedList::<i32>::new();\n}",
    "title": "Doubly-linked list/Element definition",
    "url": "http://rosettacode.org/wiki/Doubly-linked_list/Element_definition"
  },
  {
    "local_code": "//! This expands upon the implementation defined on [Rosetta Code][element definition] and consists\n//! of the relevant lines from the `LinkedList` implementation in the Rust standard library.\n//!\n//! [element definition]: http://rosettacode.org/wiki/Doubly-linked_list/Element_definition\n\n#![allow(dead_code)]\n\nuse std::mem;\nuse std::ptr;\n\npub struct LinkedList<T> {\n    length: usize,\n    list_head: Link<T>,\n    list_tail: Rawlink<Node<T>>,\n}\n\ntype Link<T> = Option<Box<Node<T>>>;\n\nstruct Rawlink<T> {\n    p: *mut T,\n}\n\nstruct Node<T> {\n    next: Link<T>,\n    prev: Rawlink<Node<T>>,\n    value: T,\n}\n\nimpl<T> Node<T> {\n    fn new(v: T) -> Node<T> {\n        Node {\n            value: v,\n            next: None,\n            prev: Rawlink::none(),\n        }\n    }\n}\n\nimpl<T> Rawlink<T> {\n    fn none() -> Self {\n        Rawlink { p: ptr::null_mut() }\n    }\n\n    fn some(n: &mut T) -> Rawlink<T> {\n        Rawlink { p: n }\n    }\n}\n\nimpl<'a, T> From<&'a mut Link<T>> for Rawlink<Node<T>> {\n    fn from(node: &'a mut Link<T>) -> Self {\n        match node.as_mut() {\n            None => Rawlink::none(),\n            Some(ptr) => Rawlink::some(ptr),\n        }\n    }\n}\n\nfn link_no_prev<T>(mut next: Box<Node<T>>) -> Link<T> {\n    next.prev = Rawlink::none();\n    Some(next)\n}\n\nimpl<T> LinkedList<T> {\n    pub fn new() -> LinkedList<T> {\n        LinkedList {\n            length: 0,\n            list_head: None,\n            list_tail: Rawlink { p: ptr::null_mut() },\n        }\n    }\n\n    #[inline]\n    fn push_front_node(&mut self, mut new_head: Box<Node<T>>) {\n        match self.list_head {\n            None => {\n                self.list_head = link_no_prev(new_head);\n                self.list_tail = Rawlink::from(&mut self.list_head);\n            }\n            Some(ref mut head) => {\n                new_head.prev = Rawlink::none();\n                head.prev = Rawlink::some(&mut *new_head);\n                mem::swap(head, &mut new_head);\n                head.next = Some(new_head);\n            }\n        }\n        self.length += 1;\n    }\n    pub fn push_front(&mut self, elt: T) {\n        self.push_front_node(Box::new(Node::new(elt)));\n    }\n}\n\nimpl<T> Default for LinkedList<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nfn main() {\n    use std::collections;\n    let mut list1 = collections::LinkedList::new();\n    list1.push_front(8);\n\n    let mut list2 = LinkedList::new();\n    list2.push_front(8);\n}\n",
    "path": "tasks/doubly-linked-list/element-insertion",
    "remote_code": "use std::collections::LinkedList;\nfn main() {\n    let mut list = LinkedList::new();\n    list.push_front(8);\n}",
    "title": "Doubly-linked list/Element insertion",
    "url": "http://rosettacode.org/wiki/Doubly-linked_list/Element_insertion"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Doubly-linked list/Traversal",
    "url": "http://rosettacode.org/wiki/Doubly-linked_list/Traversal"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Dragon curve",
    "url": "http://rosettacode.org/wiki/Dragon_curve"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// cargo-deps: time=\"0.1\"\nextern crate time;\n\nuse std::thread;\nuse std::time::Duration;\n\nconst TOP: &str = \" ⡎⢉⢵ ⠀⢺⠀ ⠊⠉⡱ ⠊⣉⡱ ⢀⠔⡇ ⣏⣉⡉ ⣎⣉⡁ ⠊⢉⠝ ⢎⣉⡱ ⡎⠉⢱ ⠀⠶⠀\";\nconst BOT: &str = \" ⢗⣁⡸ ⢀⣸⣀ ⣔⣉⣀ ⢄⣀⡸ ⠉⠉⡏ ⢄⣀⡸ ⢇⣀⡸ ⢰⠁⠀ ⢇⣀⡸ ⢈⣉⡹ ⠀⠶⠀\";\n\nfn main() {\n    let top: Vec<&str> = TOP.split_whitespace().collect();\n    let bot: Vec<&str> = BOT.split_whitespace().collect();\n\n    loop {\n        let tm = &time::now().rfc822().to_string()[17..25];\n        let top_str: String = tm.chars().map(|x| top[x as usize - '0' as usize]).collect();\n        let bot_str: String = tm.chars().map(|x| bot[x as usize - '0' as usize]).collect();\n\n        clear_screen();\n        println!(\"{}\", top_str);\n        println!(\"{}\", bot_str);\n\n        thread::sleep(Duration::from_secs(1));\n    }\n}\n\nfn clear_screen() {\n    println!(\"{}[H{}[J\", 27 as char, 27 as char);\n}",
    "title": "Draw a clock",
    "url": "http://rosettacode.org/wiki/Draw_a_clock"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Draw a cuboid",
    "url": "http://rosettacode.org/wiki/Draw_a_cuboid"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate piston_window;\nextern crate image;\n\nuse piston_window::*;\n\nfn main() {\n    let (width, height) = (320, 240);\n    \n    let mut window: PistonWindow =\n        WindowSettings::new(\"Red Pixel\", [width, height])\n        .exit_on_esc(true).build().unwrap();\n\n    // Since we cant manipulate pixels directly, we need to manipulate the pixels on a canvas.\n    // Only issue is that sub-pixels exist (which is probably why the red pixel looks like a smear on the output image)\n    let mut canvas = image::ImageBuffer::new(width, height);\n    canvas.put_pixel(100, 100, image::Rgba([0xff, 0, 0, 0xff]));\n\n    // Transform into a texture so piston can use it.\n    let texture: G2dTexture = Texture::from_image(\n        &mut window.factory,\n        &canvas,\n        &TextureSettings::new()\n    ).unwrap();\n\n    // The window event loop.\n    while let Some(event) = window.next() {\n        window.draw_2d(&event, |context, graphics| {\n            clear([1.0; 4], graphics);\n            image(&texture,\n            context.transform,\n            graphics);\n        });\n    }\n}\n",
    "title": "Draw a pixel",
    "url": "http://rosettacode.org/wiki/Draw_a_pixel"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Draw a rotating cube",
    "url": "http://rosettacode.org/wiki/Draw_a_rotating_cube"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Draw a sphere",
    "url": "http://rosettacode.org/wiki/Draw_a_sphere"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::Rng;\n\n// if you use an enum you will have to implement a lot of traits for it before you can\n// iterate and sort it my proposal is to just use u8 and image a C like enum thus\n// 0 = red\n// 1 = white\n// 2 = blue\n//\n// look up table\nconst COLOR: &[&str] = &[\"Red\", \"White\", \"Blue\"];\n\nfn check_sorted(color_array: &[u8]) -> bool {\n    let mut test_color = 0;\n    for color in color_array {\n        if *color < test_color {\n            return false;\n        }\n        test_color = *color;\n    }\n    true\n}\n\nfn color_to_string(color_array: &[u8]) -> String {\n    color_array\n        .iter()\n        .fold(\"\".to_string(), |string, &x| string + COLOR[x as usize])\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut color_array = [0u8; 20];\n\n    for color in &mut color_array {\n        *color = rng.gen_range(0, 3);\n    }\n\n    if check_sorted(&color_array) {\n        println!(\n            \"oops i generated a sorted array {}\",\n            color_to_string(&color_array)\n        );\n    } else {\n        println!(\"random flag {}\", color_to_string(&color_array));\n    }\n\n    color_array.sort();\n    println!(\"a dutch flag {}\", color_to_string(&color_array));\n}\n\n#[test]\nfn test_dutch_national_flag() {\n    let flag_array = [0, 1, 2];\n    assert_eq!(true, check_sorted(&flag_array));\n\n    let mut color_array = [2, 0, 1];\n    assert_eq!(false, check_sorted(&color_array));\n    color_array.sort();\n    assert_eq!(flag_array, color_array);\n}\n",
    "path": "tasks/dutch-national-flag-problem",
    "remote_code": "extern crate rand;\n\nuse rand::Rng;\n\n// Color enums will be sorted by their top-to-bottom declaration order\n#[derive(Eq,Ord,PartialOrd,PartialEq,Debug)]\nenum Color {\n    Red,\n    White,\n    Blue\n}\n\nfn is_sorted(list: &Vec<Color>) -> bool {\n    let mut state = &Color::Red;\n    for current in list.iter() {\n        if current < state { return false; }\n        if current > state { state = current; }\n    }\n    true\n}\n\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    let mut colors: Vec<Color> = Vec::new();\n\n    for _ in 1..10 {\n        let r = rng.gen_range(0, 3);\n        if      r == 0 { colors.push(Color::Red); }\n        else if r == 1 { colors.push(Color::White); }\n        else if r == 2 { colors.push(Color::Blue); }\n    }\n\n    while is_sorted(&colors) {\n        rng.shuffle(&mut colors);\n    }\n\n    println!(\"Before: {:?}\", colors);\n    colors.sort();\n    println!(\"After:  {:?}\", colors);\n    if !is_sorted(&colors) {\n        println!(\"Oops, did not sort colors correctly!\");\n    }\n}",
    "title": "Dutch national flag problem",
    "url": "http://rosettacode.org/wiki/Dutch_national_flag_problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Dynamic variable names",
    "url": "http://rosettacode.org/wiki/Dynamic_variable_names"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "EKG sequence convergence",
    "url": "http://rosettacode.org/wiki/EKG_sequence_convergence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Eban numbers",
    "url": "http://rosettacode.org/wiki/Eban_numbers"
  },
  {
    "local_code": "use std::io::{self, BufRead, BufReader, Write};\nuse std::net::{TcpListener, TcpStream};\nuse std::thread;\n\n// The actual echo server\nfn echo_server(host: &'static str, port: u16) -> io::Result<()> {\n    // Create a new TCP listener at host:port.\n    let listener = TcpListener::bind((host, port))?;\n    println!(\"Starting echo server on {:?}\", listener.local_addr());\n\n    // Process each new connection to the server\n    for stream in listener.incoming() {\n        match stream {\n            Err(e) => println!(\"Connection failed: {}\", e),\n            Ok(stream) => {\n                let addr = stream.peer_addr()?;\n                println!(\"New connection: {}\", addr);\n                // Launch a new thread to deal with the connection.\n                thread::spawn(move || {\n                    if let Err(e) = echo_session(stream) {\n                        println!(\"I/O error: {} -- {}\", addr, e);\n                    }\n                    println!(\"Closing connection: {}\", addr);\n                });\n            }\n        }\n    }\n    Ok(())\n    // Server closes automatically at end of block\n}\n\n// Each connection gets its own session.\nfn echo_session(stream: TcpStream) -> io::Result<()> {\n    let addr = stream.peer_addr()?;\n    let mut writer = stream.try_clone().unwrap();\n    let reader = BufReader::new(stream);\n    for line in reader.lines() {\n        let line = line?;\n        println!(\"Received line from {}: {}\", addr, line);\n        writer.write_all(line.as_bytes())?;\n        println!(\"Wrote line to {}: {}\", addr, line);\n    }\n    Ok(())\n}\n\nconst HOST: &str = \"127.0.0.1\";\n#[cfg_attr(feature = \"cargo-clippy\", allow(unreadable_literal))]\nconst PORT: u16 = 12321;\n\npub fn main() {\n    echo_server(HOST, PORT).unwrap();\n}\n",
    "path": "tasks/echo-server",
    "remote_code": "\nuse std::net::{TcpListener, TcpStream};\nuse std::io::{BufReader, BufRead, Write};\nuse std::thread;\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:12321\").unwrap();\n    println!(\"server is running on 127.0.0.1:12321 ...\");\n    \n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n        thread::spawn(move || handle_client(stream));\n    }\n}\n\nfn handle_client(stream: TcpStream) {\n    let mut stream = BufReader::new(stream);\n    loop {\n        let mut buf = String::new();\n        if stream.read_line(&mut buf).is_err() {\n            break;\n        }\n        stream\n            .get_ref()\n            .write(buf.as_bytes())\n            .unwrap();\n    }\n}\n",
    "title": "Echo server",
    "url": "http://rosettacode.org/wiki/Echo_server"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Eertree",
    "url": "http://rosettacode.org/wiki/Eertree"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn egyptian_divide(dividend: u32, divisor: u32) -> (u32, u32) {\n    let dividend = dividend as u64;\n    let divisor = divisor as u64;\n    \n    let pows = (0..32).map(|p| 1 << p);\n    let doublings = (0..32).map(|p| divisor << p);\n    \n    let (answer, sum) = doublings\n        .zip(pows)\n        .rev()\n        .skip_while(|(i, _)| i > &dividend )\n        .fold((0, 0), |(answer, sum), (double, power)| {\n            if sum + double < dividend {\n                (answer + power, sum + double)\n            } else {\n                (answer, sum)\n            }\n        });\n    \n    (answer as u32, (dividend - sum) as u32)\n}\n\nfn main() {\n    let (div, rem) = egyptian_divide(580, 34);\n    println!(\"580 divided by 34 is {} remainder {}\", div, rem);\n}",
    "title": "Egyptian division",
    "url": "http://rosettacode.org/wiki/Egyptian_division"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Egyptian fractions",
    "url": "http://rosettacode.org/wiki/Egyptian_fractions"
  },
  {
    "local_code": "struct Matrix {\n    elements: Vec<f32>,\n    pub height: u32,\n    pub width: u32,\n}\n\nimpl Matrix {\n    fn new(elements: Vec<f32>, height: u32, width: u32) -> Matrix {\n        // Should check for dimensions but omitting to be succient\n        Matrix {\n            elements: elements,\n            height: height,\n            width: width,\n        }\n    }\n\n    fn get(&self, row: u32, col: u32) -> f32 {\n        let row = row as usize;\n        let col = col as usize;\n        self.elements[col + row * (self.width as usize)]\n    }\n\n    fn set(&mut self, row: u32, col: u32, value: f32) {\n        let row = row as usize;\n        let col = col as usize;\n        self.elements[col + row * (self.width as usize)] = value;\n    }\n\n    fn print(&self) {\n        for row in 0..self.height {\n            for col in 0..self.width {\n                print!(\"{:3.0}\", self.get(row, col));\n            }\n            println!();\n        }\n        println!();\n    }\n}\n\n// Matrix addition will perform element-wise addition\nfn matrix_addition(first: &Matrix, second: &Matrix) -> Result<Matrix, String> {\n    if first.width == second.width && first.height == second.height {\n        let mut result = Matrix::new(\n            vec![0.0f32; (first.height * first.width) as usize],\n            first.height,\n            first.width,\n        );\n        for row in 0..first.height {\n            for col in 0..first.width {\n                let first_value = first.get(row, col);\n                let second_value = second.get(row, col);\n                result.set(row, col, first_value + second_value);\n            }\n        }\n        Ok(result)\n    } else {\n        Err(\"Dimensions don't match\".to_owned())\n    }\n}\n\nfn scalar_multiplication(scalar: f32, matrix: &Matrix) -> Matrix {\n    let mut result = Matrix::new(\n        vec![0.0f32; (matrix.height * matrix.width) as usize],\n        matrix.height,\n        matrix.width,\n    );\n    for row in 0..matrix.height {\n        for col in 0..matrix.width {\n            let value = matrix.get(row, col);\n            result.set(row, col, scalar * value);\n        }\n    }\n    result\n}\n\n// Subtract second from first\nfn matrix_subtraction(first: &Matrix, second: &Matrix) -> Result<Matrix, String> {\n    if first.width == second.width && first.height == second.height {\n        let negative_matrix = scalar_multiplication(-1.0, second);\n        let result = matrix_addition(first, &negative_matrix).unwrap();\n        Ok(result)\n    } else {\n        Err(\"Dimensions don't match\".to_owned())\n    }\n}\n\n// First must be a l x m matrix and second a m x n matrix for this to work.\nfn matrix_multiplication(first: &Matrix, second: &Matrix) -> Result<Matrix, String> {\n    if first.width == second.height {\n        let mut result = Matrix::new(\n            vec![0.0f32; (first.height * second.width) as usize],\n            first.height,\n            second.width,\n        );\n        for row in 0..result.height {\n            for col in 0..result.width {\n                let mut value = 0.0;\n                for it in 0..first.width {\n                    value += first.get(row, it) * second.get(it, col);\n                }\n                result.set(row, col, value);\n            }\n        }\n        Ok(result)\n    } else {\n        Err(\"Dimensions don't match. Width of first must equal height of second\".to_owned())\n    }\n}\n\nfn main() {\n    let height = 2;\n    let width = 3;\n    // Matrix will look like:\n    // | 1.0  2.0  3.0  |\n    // | 4.0  5.0  6.0 |\n    let matrix1 = Matrix::new(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0], height, width);\n\n    // Matrix will look like:\n    // | 6.0  5.0  4.0  |\n    // | 3.0  2.0  1.0 |\n    let matrix2 = Matrix::new(vec![6.0, 5.0, 4.0, 3.0, 2.0, 1.0], height, width);\n\n    // | 7.0  7.0  7.0  |\n    // | 7.0  7.0  7.0 |\n    matrix_addition(&matrix1, &matrix2).unwrap().print();\n    // | 2.0   4.0   6.0  |\n    // | 8.0  10.0  12.0 |\n    scalar_multiplication(2.0, &matrix1).print();\n    // | -5.0  -3.0  -1.0  |\n    // |  1.0   3.0   5.0 |\n    matrix_subtraction(&matrix1, &matrix2).unwrap().print();\n\n    // | 1.0 |\n    // | 1.0 |\n    // | 1.0 |\n    let matrix3 = Matrix::new(vec![1.0, 1.0, 1.0], width, 1);\n    // |  6 |\n    // | 15 |\n    matrix_multiplication(&matrix1, &matrix3).unwrap().print();\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{\n        matrix_addition, matrix_multiplication, matrix_subtraction, scalar_multiplication, Matrix,\n    };\n\n    const HEIGHT: u32 = 2;\n    const WIDTH: u32 = 3;\n    #[test]\n    fn matrix_addition_test() {\n        let matrix1: Matrix = Matrix::new(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0], HEIGHT, WIDTH);\n        let matrix2: Matrix = Matrix::new(vec![6.0, 5.0, 4.0, 3.0, 2.0, 1.0], HEIGHT, WIDTH);\n        let result = matrix_addition(&matrix1, &matrix2).unwrap();\n        for col in 0..result.width {\n            for row in 0..result.height {\n                assert_eq!(result.get(row, col), 7.0);\n            }\n        }\n    }\n\n    #[test]\n    fn scalar_multiplication_test() {\n        let matrix1: Matrix = Matrix::new(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0], HEIGHT, WIDTH);\n        let result = scalar_multiplication(2.0, &matrix1);\n        assert_eq!(result.get(0, 0), 2.0);\n        assert_eq!(result.get(0, 1), 4.0);\n        assert_eq!(result.get(0, 2), 6.0);\n        assert_eq!(result.get(1, 0), 8.0);\n        assert_eq!(result.get(1, 1), 10.0);\n        assert_eq!(result.get(1, 2), 12.0);\n    }\n\n    #[test]\n    fn matrix_subtraction_test() {\n        let matrix1: Matrix = Matrix::new(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0], HEIGHT, WIDTH);\n        let matrix2: Matrix = Matrix::new(vec![6.0, 5.0, 4.0, 3.0, 2.0, 1.0], HEIGHT, WIDTH);\n        let result = matrix_subtraction(&matrix1, &matrix2).unwrap();\n        assert_eq!(result.get(0, 0), -5.0);\n        assert_eq!(result.get(0, 1), -3.0);\n        assert_eq!(result.get(0, 2), -1.0);\n        assert_eq!(result.get(1, 0), 1.0);\n        assert_eq!(result.get(1, 1), 3.0);\n        assert_eq!(result.get(1, 2), 5.0);\n    }\n\n    #[test]\n    fn matrix_multiplication_test() {\n        let matrix1: Matrix = Matrix::new(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0], HEIGHT, WIDTH);\n        let matrix2 = Matrix::new(vec![1.0, 1.0, 1.0], WIDTH, 1);\n        let result = matrix_multiplication(&matrix1, &matrix2).unwrap();\n        assert_eq!(result.get(0, 0), 6.0);\n        assert_eq!(result.get(1, 0), 15.0);\n    }\n}\n",
    "path": "tasks/element-wise-operations",
    "remote_code": "struct Matrix {\n    elements: Vec<f32>,\n    pub height: u32,\n    pub width: u32,\n}\n\nimpl Matrix {\n    fn new(elements: Vec<f32>, height: u32, width: u32) -> Matrix {\n        // Should check for dimensions but omitting to be succient\n        Matrix {\n            elements: elements,\n            height: height,\n            width: width,\n        }\n    }\n\n    fn get(&self, row: u32, col: u32) -> f32 {\n        let row = row as usize;\n        let col = col as usize;\n        self.elements[col + row * (self.width as usize)]\n    }\n\n    fn set(&mut self, row: u32, col: u32, value: f32) {\n        let row = row as usize;\n        let col = col as usize;\n        self.elements[col + row * (self.width as usize)] = value;\n    }\n\n    fn print(&self) {\n        for row in 0..self.height {\n            for col in 0..self.width {\n                print!(\"{:3.0}\", self.get(row, col));\n            }\n            println!(\"\");\n        }\n        println!(\"\");\n    }\n}\n\n// Matrix addition will perform element-wise addition\nfn matrix_addition(first: &Matrix, second: &Matrix) -> Result<Matrix, String> {\n    if first.width == second.width && first.height == second.height {\n        let mut result = Matrix::new(vec![0.0f32; (first.height * first.width) as usize],\n                                     first.height,\n                                     first.width);\n        for row in 0..first.height {\n            for col in 0..first.width {\n                let first_value = first.get(row, col);\n                let second_value = second.get(row, col);\n                result.set(row, col, first_value + second_value);\n            }\n        }\n        Ok(result)\n    } else {\n        Err(\"Dimensions don't match\".to_owned())\n    }\n}\n\nfn scalar_multiplication(scalar: f32, matrix: &Matrix) -> Matrix {\n    let mut result = Matrix::new(vec![0.0f32; (matrix.height * matrix.width) as usize],\n                                 matrix.height,\n                                 matrix.width);\n    for row in 0..matrix.height {\n        for col in 0..matrix.width {\n            let value = matrix.get(row, col);\n            result.set(row, col, scalar * value);\n        }\n    }\n    result\n}\n\n// Subtract second from first\nfn matrix_subtraction(first: &Matrix, second: &Matrix) -> Result<Matrix, String> {\n    if first.width == second.width && first.height == second.height {\n        let negative_matrix = scalar_multiplication(-1.0, second);\n        let result = matrix_addition(first, &negative_matrix).unwrap();\n        Ok(result)\n    } else {\n        Err(\"Dimensions don't match\".to_owned())\n    }\n}\n\n// First must be a l x m matrix and second a m x n matrix for this to work.\nfn matrix_multiplication(first: &Matrix, second: &Matrix) -> Result<Matrix, String> {\n    if first.width == second.height {\n        let mut result = Matrix::new(vec![0.0f32; (first.height * second.width) as usize],\n                                     first.height,\n                                     second.width);\n        for row in 0..result.height {\n            for col in 0..result.width {\n                let mut value = 0.0;\n                for it in 0..first.width {\n                    value += first.get(row, it) * second.get(it, col);\n                }\n                result.set(row, col, value);\n            }\n        }\n        Ok(result)\n    } else {\n        Err(\"Dimensions don't match. Width of first must equal height of second\".to_owned())\n    }\n}\n\n\nfn main() {\n    let height = 2;\n    let width = 3;\n    // Matrix will look like:\n    // | 1.0  2.0  3.0  |\n    // | 4.0  5.0  6.0 |\n    let matrix1 = Matrix::new(vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0], height, width);\n\n    // Matrix will look like:\n    // | 6.0  5.0  4.0  |\n    // | 3.0  2.0  1.0 |\n    let matrix2 = Matrix::new(vec![6.0, 5.0, 4.0, 3.0, 2.0, 1.0], height, width);\n\n    // | 7.0  7.0  7.0  |\n    // | 7.0  7.0  7.0 |\n    matrix_addition(&matrix1, &matrix2).unwrap().print();\n    // | 2.0   4.0   6.0  |\n    // | 8.0  10.0  12.0 |\n    scalar_multiplication(2.0, &matrix1).print();\n    // | -5.0  -3.0  -1.0  |\n    // |  1.0   3.0   5.0 |\n    matrix_subtraction(&matrix1, &matrix2).unwrap().print();\n\n    // | 1.0 |\n    // | 1.0 |\n    // | 1.0 |\n    let matrix3 = Matrix::new(vec![1.0, 1.0, 1.0], width, 1);\n    // |  6 |\n    // | 15 |\n    matrix_multiplication(&matrix1, &matrix3).unwrap().print();\n}",
    "title": "Element-wise operations",
    "url": "http://rosettacode.org/wiki/Element-wise_operations"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Elementary cellular automaton",
    "url": "http://rosettacode.org/wiki/Elementary_cellular_automaton"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Emirp primes",
    "url": "http://rosettacode.org/wiki/Emirp_primes"
  },
  {
    "local_code": "use std::env::args;\nuse std::fs;\n\nfn main() {\n    // Open path\n    let dir = if let Some(arg) = args().nth(1) {\n        arg\n    } else {\n        println!(\"You must give a path as argument\");\n        return;\n    };\n\n    // map function for type Result executes a function (closure)\n    // on Ok(_) types but leaves Err(_) untouched.\n    //\n    // The directory is empty if the result of paths.count() == Ok(0)\n    // In any other case, the directory is not empty\n    match fs::read_dir(dir).map(|paths| paths.count()) {\n        Err(e) => println!(\"Error: {}\", e),\n        Ok(0) => println!(\"Directory is empty\"),\n        Ok(_) => println!(\"Directory is not empty\"),\n    }\n}\n",
    "path": "tasks/empty-directory",
    "remote_code": "use std::fs::read_dir;\nuse std::error::Error;\n\nfn main() {\n    for path in std::env::args().skip(1) { // iterate over the arguments, skipping the first (which is the executable)\n        match read_dir(path.as_str()) { // try to read the directory specified\n            Ok(contents) => {\n                let len = contents.collect::<Vec<_>>().len(); // calculate the amount of items in the directory\n                if len == 0 {\n                    println!(\"{} is empty\", path);\n                } else {\n                    println!(\"{} is not empty\", path);\n                }\n            },\n            Err(e) => { // If the attempt failed, print the corresponding error msg\n                println!(\"Failed to read directory \\\"{}\\\": {}\", path, e.description());\n            }\n        }\n    }\n}",
    "title": "Empty directory",
    "url": "http://rosettacode.org/wiki/Empty_directory"
  },
  {
    "local_code": "fn main() {}\n",
    "path": "tasks/empty-program",
    "remote_code": "fn main(){}",
    "title": "Empty program",
    "url": "http://rosettacode.org/wiki/Empty_program"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "let s = \"\";\nprintln!(\"is empty: {}\", s.is_empty());\nlet t = \"x\";\nprintln!(\"is empty: {}\", t.is_empty());\nlet a = String::new();\nprintln!(\"is empty: {}\", a.is_empty());\nlet b = \"x\".to_string();\nprintln!(\"is empty: {}\", b.is_empty());\nprintln!(\"is not empty: {}\", !b.is_empty());",
    "title": "Empty string",
    "url": "http://rosettacode.org/wiki/Empty_string"
  },
  {
    "local_code": "#![allow(unused_variables)]\n\nfn main() {\n    // Rust let bindings are immutable by default.\n    let x = 3;\n    // This will raise a compiler error:\n    // x += 2;  //~ ERROR cannot assign to immutable borrowed content `*y`\n\n    // You must declare a variable mutable explicitly:\n    let mut x = 3;\n\n    // Similarly, references are immutable by default e.g.\n    // The following lines would raise a compiler error. Even though x is mutable, y is an\n    // immutable reference.\n    // let y = &x;\n    // *y += 2; //~ ERROR cannot borrow `x` as mutable because it is also borrowed as immutable\n\n    let y = &mut x;\n    *y += 2; // Works\n\n    // Note that though y is now a mutable reference, y itself is still immutable e.g.\n    // let mut z = 5;\n    // y = &mut z; //~ ERROR re-assignment of immutable variable `y`\n}\n",
    "path": "tasks/enforced-immutability",
    "remote_code": "let x = 3;\nx += 2;",
    "title": "Enforced immutability",
    "url": "http://rosettacode.org/wiki/Enforced_immutability"
  },
  {
    "local_code": "use std::collections::hash_map::Entry::{Occupied, Vacant};\nuse std::collections::HashMap;\n\npub fn shannon_entropy(s: &str) -> f64 {\n    let mut map = HashMap::new();\n\n    // Count occurrences of each char\n    for c in s.chars() {\n        match map.entry(c) {\n            Vacant(entry) => {\n                entry.insert(1);\n            }\n            Occupied(mut entry) => {\n                *entry.get_mut() += 1;\n            }\n        };\n    }\n\n    // Calculate the entropy\n    let len = s.len() as f64;\n    map.iter().fold(0f64, |acc, (_, &nb)| {\n        let p = f64::from(nb) / len;\n        acc - p * p.log2()\n    })\n}\n\n#[test]\nfn test_entropy() {\n    let tests = vec![\n        (\"1223334444\", 1.846439344671f64),\n        (\"1223334444555555555\", 1.969811065121),\n        (\"122333\", 1.459147917061),\n        (\"1227774444\", 1.846439344671),\n        (\"aaBBcccDDDD\", 1.936260027482),\n        (\"1234567890abcdefghijklmnopqrstuvwxyz\", 5.169925004424),\n        (\"Rosetta Code\", 3.084962500407),\n    ];\n    // Good enough, actual float epsilon is much smaller\n    let epsilon: f64 = 0.0000001;\n    for (input, expected) in tests {\n        let output = shannon_entropy(input);\n        assert!((output - expected).abs() < epsilon);\n    }\n}\nextern crate entropy;\n\nuse entropy::shannon_entropy;\n\nfn main() {\n    println!(\"{}\", shannon_entropy(\"1223334444\"));\n}\n",
    "path": "tasks/entropy",
    "remote_code": "fn entropy(s: &[u8]) -> f32 {\n    let mut histogram = [0u64; 256];\n\n    for &b in s {\n        histogram[b as usize] += 1;\n    }\n\n    histogram\n        .iter()\n        .cloned()\n        .filter(|&h| h != 0)\n        .map(|h| h as f32 / s.len() as f32)\n        .map(|ratio| -ratio * ratio.log2())\n        .sum()\n}\n\nfn main() {\n    let arg = std::env::args().nth(1).expect(\"Need a string.\");\n    println!(\"Entropy of {} is {}.\", arg, entropy(arg.as_bytes()));\n}",
    "title": "Entropy",
    "url": "http://rosettacode.org/wiki/Entropy"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Entropy/Narcissist",
    "url": "http://rosettacode.org/wiki/Entropy/Narcissist"
  },
  {
    "local_code": "#[allow(dead_code)]\nenum Fruits {\n    Apple,\n    Banana,\n    Cherry,\n}\n\n#[allow(dead_code)]\nenum Days {\n    Monday = 0,\n    Tuesday = 1,\n    Wednesday = 2, // You know the rest...\n}\n\nfn main() {}\n",
    "path": "tasks/enumerations",
    "remote_code": "enum Fruits {\n    Apple,\n    Banana,\n    Cherry\n}\n\nenum FruitsWithNumbers {\n    Strawberry = 0,\n    Pear = 27,\n}\n\nfn main() {\n    // Access to numerical value by conversion\n    println!(\"{}\", FruitsWithNumbers::Pear as u8);\n}",
    "title": "Enumerations",
    "url": "http://rosettacode.org/wiki/Enumerations"
  },
  {
    "local_code": "use std::env;\n\nfn main() {\n    let variables = [\"PATH\", \"HOME\", \"USER\"];\n\n    for variable in &variables {\n        match env::var(variable) {\n            Ok(value) => println!(\"{}={}\", variable, value),\n            Err(e) => println!(\"Could not read {}: {}.\", variable, e),\n        }\n    }\n}\n",
    "path": "tasks/environment-variables",
    "remote_code": null,
    "title": "Environment variables",
    "url": "http://rosettacode.org/wiki/Environment_variables"
  },
  {
    "local_code": "extern crate num;\n\nuse num::traits::Zero;\n\nfn equilibrium_indices(v: &[i32]) -> Vec<usize> {\n    let mut right = v.iter().fold(0, |a, &b| a + b);\n    let mut left = i32::zero();\n\n    v.iter().enumerate().fold(vec![], |mut out, (i, &el)| {\n        right -= el;\n        if left == right {\n            out.push(i);\n        }\n        left += el;\n\n        out\n    })\n}\n\nfn main() {\n    let v = [-7i32, 1, 5, 2, -4, 3, 0];\n    let indices = equilibrium_indices(&v);\n    println!(\"Equilibrium indices for {:?} are: {:?}\", v, indices);\n}\n\n#[test]\nfn test_equilibrium_indices() {\n    let v = &[-7i32, 1, 5, 2, -4, 3, 0];\n    assert_eq!(equilibrium_indices(v), vec![3, 6]);\n}\n",
    "path": "tasks/equilibrium-index",
    "remote_code": null,
    "title": "Equilibrium index",
    "url": "http://rosettacode.org/wiki/Equilibrium_index"
  },
  {
    "local_code": "fn double(a: i32) -> i32 {\n    2 * a\n}\n\nfn halve(a: i32) -> i32 {\n    a / 2\n}\n\nfn is_even(a: i32) -> bool {\n    a % 2 == 0\n}\n\nfn ethiopian_multiplication(mut x: i32, mut y: i32) -> i32 {\n    let mut sum = 0;\n\n    while x >= 1 {\n        print!(\"{} \\t {}\", x, y);\n        if is_even(x) {\n            println!(\"\\t Not Kept\");\n        } else {\n            println!(\"\\t Kept\");\n            sum += y;\n        }\n        x = halve(x);\n        y = double(y);\n    }\n    sum\n}\n\nfn main() {\n    let output = ethiopian_multiplication(17, 34);\n    println!(\"---------------------------------\");\n    println!(\"\\t {}\", output);\n}\n",
    "path": "tasks/ethiopian-multiplication",
    "remote_code": "fn double(a: i32) -> i32 {\n    2*a\n}\n\nfn halve(a: i32) -> i32 {\n    a/2\n}\n\nfn is_even(a: i32) -> bool {\n    a % 2 == 0\n}\n\nfn ethiopian_multiplication(mut x: i32, mut y: i32) -> i32 {\n    let mut sum = 0;\n\n    while x >= 1 {\n        print!(\"{} \\t {}\", x, y);\n        match is_even(x) {\n            true  => println!(\"\\t Not Kept\"),\n            false => {\n                println!(\"\\t Kept\");\n                sum += y;\n            }\n        }\n        x = halve(x);\n        y = double(y);\n    }\n    sum\n}\n\nfn main() {\n    let output = ethiopian_multiplication(17, 34);\n    println!(\"---------------------------------\");\n    println!(\"\\t {}\", output);\n}",
    "title": "Ethiopian multiplication",
    "url": "http://rosettacode.org/wiki/Ethiopian_multiplication"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Euler method",
    "url": "http://rosettacode.org/wiki/Euler_method"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::f64::consts::PI;\n\nextern crate num_complex;\nuse num_complex::Complex;\n\nfn main() {\n    println!(\"{:e}\", Complex::new(0.0, PI).exp() + 1.0);\n}",
    "title": "Euler's identity",
    "url": "http://rosettacode.org/wiki/Euler's_identity"
  },
  {
    "local_code": "const MAX_N: u64 = 250;\n\nfn eulers_sum_of_powers() -> (usize, usize, usize, usize, usize) {\n    let pow5: Vec<u64> = (0..MAX_N).map(|i| i.pow(5)).collect();\n    let pow5_to_n = |pow| pow5.binary_search(&pow);\n\n    for x0 in 1..MAX_N as usize {\n        for x1 in 1..x0 {\n            for x2 in 1..x1 {\n                for x3 in 1..x2 {\n                    let pow_sum = pow5[x0] + pow5[x1] + pow5[x2] + pow5[x3];\n                    if let Ok(n) = pow5_to_n(pow_sum) {\n                        return (x0, x1, x2, x3, n);\n                    }\n                }\n            }\n        }\n    }\n\n    panic!();\n}\n\nfn main() {\n    let (x0, x1, x2, x3, y) = eulers_sum_of_powers();\n    println!(\"{}^5 + {}^5 + {}^5 + {}^5 == {}^5\", x0, x1, x2, x3, y)\n}\n",
    "path": "tasks/eulers-sum-of-powers-conjecture",
    "remote_code": "const MAX_N : u64 = 250;\n\nfn eulers_sum_of_powers() -> (usize, usize, usize, usize, usize) {\n    let pow5: Vec<u64> = (0..MAX_N).map(|i| i.pow(5)).collect();\n    let pow5_to_n = |pow| pow5.binary_search(&pow);\n\n    for x0 in 1..MAX_N as usize {\n        for x1 in 1..x0 {\n            for x2 in 1..x1 {\n                for x3 in 1..x2 {\n                    let pow_sum = pow5[x0] + pow5[x1] + pow5[x2] + pow5[x3];\n                    if let Ok(n) = pow5_to_n(pow_sum) {\n                        return (x0, x1, x2, x3, n)\n                    }\n                }\n            }\n        }\n    }\n\n    panic!();\n}\n\nfn main() {\n\tlet (x0, x1, x2, x3, y) = eulers_sum_of_powers();\n\tprintln!(\"{}^5 + {}^5 + {}^5 + {}^5 == {}^5\", x0, x1, x2, x3, y)\n}",
    "title": "Euler's sum of powers conjecture",
    "url": "http://rosettacode.org/wiki/Euler's_sum_of_powers_conjecture"
  },
  {
    "local_code": "extern crate num;\n\nuse num::bigint::{BigUint, ToBigUint};\nuse num::One;\n\nfn binomial(n: usize, mut k: usize) -> BigUint {\n    // Since binomial(n, k) = binomial(n, n - k), we might as well use\n    // the smaller k to optimize\n    if n - k < k {\n        k = n - k;\n    }\n\n    // Compute the coefficient\n    let mut res: BigUint = One::one();\n    for i in 1..(k + 1) {\n        let m: BigUint = (n - k + i).to_biguint().unwrap();\n        res *= m;\n        let d: BigUint = (i).to_biguint().unwrap();\n        res /= d;\n    }\n\n    res\n}\n\nfn main() {\n    println!(\"{}\", binomial(5, 3));\n}\n\n#[test]\nfn test_binomial() {\n    use num::traits::Num;\n\n    assert_eq!(binomial(20, 0), binomial(20, 20));\n    assert_eq!(binomial(20, 15), binomial(19, 14) + binomial(19, 15));\n    assert_eq!(binomial(5, 3), 10.to_biguint().unwrap());\n    assert_eq!(binomial(31, 17), 265182525.to_biguint().unwrap());\n    assert_eq!(\n        binomial(300, 30),\n        BigUint::from_str_radix(\"173193226149263513034110205899732811401360\", 10).unwrap()\n    );\n}\n",
    "path": "tasks/evaluate-binomial-coefficients",
    "remote_code": "fn fact(n:u32) -> u64 {\n  let mut f:u64 = n as u64;\n  for i in 2..n {\n    f *= i as u64;\n  }\n  return f;\n}\n\nfn choose(n: u32, k: u32)  -> u64 {\n   let mut num:u64 = n as u64;\n   for i in 1..k {\n     num *= (n-i) as u64;\n   }\n   return num / fact(k);\n}\n\nfn main() {\n  println!(\"{}\", choose(5,3));\n}",
    "title": "Evaluate binomial coefficients",
    "url": "http://rosettacode.org/wiki/Evaluate_binomial_coefficients"
  },
  {
    "local_code": "#![allow(unused_variables)]\n\nfn main() {\n    // Checking the last significant digit:\n    let is_odd = |x: i32| x & 1 == 1;\n    let is_even = |x: i32| x & 1 == 0;\n\n    // Using modular congruences:\n    let is_odd = |x: i32| x % 2 != 0;\n    let is_even = |x: i32| x % 2 == 0;\n}\n",
    "path": "tasks/even-or-odd",
    "remote_code": "let is_odd = |x: i32| x & 1 == 1;\nlet is_even = |x: i32| x & 1 == 0;",
    "title": "Even or odd",
    "url": "http://rosettacode.org/wiki/Even_or_odd"
  },
  {
    "local_code": "//! Rust uses condition variables (Condvars) for asynchronous event processing.  Each Mutex has a\n//! list of zero or more Condvars, which are essentially events that the task may wait on or signal\n//! when it holds the mutex.  When a task begins to wait on a condvar, it enters a waiting state\n//! until the condvar is signaled by another task, at which point it resumes processing.  Thus,\n//! each condvar represents an event on which a task may wait.  The one subtlety is that condvar\n//! signals are only received if there is actually a task waiting on the signal--see the below\n//! program for an example of how this may be achieved in practice.\n\nextern crate time;\n\nuse std::sync::{Arc, Condvar, Mutex};\nuse std::thread::{self, spawn};\nuse std::time::Duration;\n\n/// Given a duration to wait before sending an event from one process to another, returns the\n/// elapsed time before the event was actually sent.\n#[cfg_attr(feature = \"cargo-clippy\", allow(mutex_atomic))]\nfn handle_event(duration: Duration) -> Duration {\n    // Create a Mutex.  By default a Mutex is created with a single condition variable (condvar_id\n    // 0) but it can be created with an arbitrary number using Mutex::new_with_condvars();\n    let pair = Arc::new((Mutex::new(false), Condvar::new()));\n    let pair_ = Arc::clone(&pair);\n    let start = time::precise_time_ns();\n    // Lock the mutex\n    let &(ref mutex, ref cond) = &*pair;\n    let mut guard = mutex.lock().unwrap();\n    // Start our secondary task (which will signal our waiting main task)\n    spawn(move || {\n        let &(ref mutex_, ref cond_) = &*pair_;\n        // Lock the mutex\n        let mut guard = mutex_.lock().unwrap();\n        *guard = true;\n\n        // Sleep for `duration`.\n        thread::sleep(duration);\n        // Signal the waiting mutex (equivalent to guard.cond.signal_on(0)).\n        // One can also signal to all tasks on the waiting mutex with broadcast (broadcast_on(0)).\n        //\n        // Note that if no tasks are actually waiting yet (which is possible, if we got the lock\n        // before the other task), then this might report that it failed to wake up any tasks.\n        // That is why the mutex was locked before the task was spawned--we know we cannot possibly\n        // get past the mutex at the top of the task until the wait() statement below is reached.\n        cond_.notify_one();\n        // Although we signaled the waiting mutex, it will not awaken until this guard is dropped.\n    });\n    // Wait for the event state to be set to signaled (equivalent to guard.cond.wait_on(0)).\n    while !*guard {\n        guard = cond.wait(guard).unwrap();\n    }\n    // Should be done signaling (i.e. we've waited for `duration`).\n    let end = time::precise_time_ns();\n    // When the guard exits scope, the condvar is reset.\n    drop(guard);\n    // Return the elapsed time\n    Duration::from_millis((end - start) / 1_000_000)\n}\n\npub fn main() {\n    let duration = Duration::from_secs(1); // Process event after one second.\n    println!(\n        \"{} seconds elapsed before event triggered\",\n        handle_event(duration).as_secs()\n    );\n}\n\n#[test]\npub fn test_events() {\n    // Process event after one tenth of a second.\n    let duration = Duration::from_secs(1) / 10;\n\n    // Make sure it really did take at least that long for the event to be processed.\n    let out = handle_event(duration);\n    assert!(duration <= out);\n}\n",
    "path": "tasks/events",
    "remote_code": null,
    "title": "Events",
    "url": "http://rosettacode.org/wiki/Events"
  },
  {
    "local_code": "//! Author : Thibault Barbie\n//!\n//! A simple evolutionary algorithm written in Rust.\n\nextern crate rand;\n\nuse rand::distributions::Uniform;\nuse rand::prelude::*;\n\nfn main() {\n    let target = \"METHINKS IT IS LIKE A WEASEL\";\n    let copies = 100;\n    let mutation_rate = 1.0 / 20.0; // = 0.05 = 5%\n\n    let mut rng = thread_rng();\n\n    // Generate first sentence, mutating each character\n    let start = mutate(&mut rng, target, 1.0); // = 100%\n\n    println!(\"{}\", target);\n    println!(\"{}\", start);\n\n    evolve(&mut rng, target, start, copies, mutation_rate);\n}\n\n/// Evolution algorithm\n///\n/// Evolves `parent` to match `target`.  Returns the number of evolutions performed.\nfn evolve<R: Rng>(\n    rng: &mut R,\n    target: &str,\n    mut parent: String,\n    copies: usize,\n    mutation_rate: f64,\n) -> usize {\n    let mut counter = 0;\n    let mut parent_fitness = target.len() + 1;\n\n    loop {\n        counter += 1;\n\n        let (best_fitness, best_sentence) = (0..copies)\n            .map(|_| {\n                // Copy and mutate a new sentence.\n                let sentence = mutate(rng, &parent, mutation_rate);\n                // Find the fitness of the new mutation\n                (fitness(target, &sentence), sentence)\n            })\n            .min_by_key(|&(f, _)| f)\n            .expect(\"copies must be non-zero\");\n\n        // If the best mutation of this generation is better than `parent` then \"the fittest\n        // survives\" and the next parent becomes the best of this generation.\n        if best_fitness < parent_fitness {\n            parent = best_sentence;\n            parent_fitness = best_fitness;\n            println!(\n                \"{} : generation {} with fitness {}\",\n                parent, counter, best_fitness\n            );\n\n            if best_fitness == 0 {\n                return counter;\n            }\n        }\n    }\n}\n\n/// Computes the fitness of a sentence against a target string, returning the number of\n/// incorrect characters.\nfn fitness(target: &str, sentence: &str) -> usize {\n    sentence\n        .chars()\n        .zip(target.chars())\n        .filter(|&(c1, c2)| c1 != c2)\n        .count()\n}\n\n/// Mutation algorithm.\n///\n/// It mutates each character of a string, according to a `mutation_rate`.\nfn mutate<R: Rng>(rng: &mut R, sentence: &str, mutation_rate: f64) -> String {\n    let maybe_mutate = |c| {\n        if rng.gen_bool(mutation_rate) {\n            random_char(rng)\n        } else {\n            c\n        }\n    };\n    sentence.chars().map(maybe_mutate).collect()\n}\n\n/// Generates a random letter or space.\nfn random_char<R: Rng>(rng: &mut R) -> char {\n    // Something similar to `rand::distributions::Alphanumeric` might be faster.\n\n    // Returns a value in the range [A, Z] + an extra slot for the space character.\n    // `Uniform` rather than `gen_range`'s `Uniform::sample_single` for speed\n    let range = Uniform::new_inclusive(b'A', b'Z' + 1);\n    match rng.sample(range) {\n        c if c == b'Z' + 1 => ' ', // the `char` after 'Z'\n        c => c as char,\n    }\n}\n",
    "path": "tasks/evolutionary-algorithm",
    "remote_code": null,
    "title": "Evolutionary algorithm",
    "url": "http://rosettacode.org/wiki/Evolutionary_algorithm"
  },
  {
    "local_code": "// IO error is used here just as an example of an already existing\n// Error\nuse std::io::{Error, ErrorKind};\n\n// Rust technically doesn't have exception, but different\n// types of error handling. Here are two examples of results.\n\npub fn valid_function() -> Result<usize, Error> {\n    Ok(100)\n}\n\npub fn errored_function() -> Result<usize, Error> {\n    Err(Error::new(ErrorKind::Other, \"Something wrong happened.\"))\n}\n\n// This should happen only when an unrecoverable error happened\npub fn panicking_function() {\n    panic!(\"Unrecoverable state reached\");\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_valid_function() {\n        let result = match valid_function() {\n            Ok(number) => number,\n            Err(_) => panic!(\"This is not going to happen\"),\n        };\n        assert_eq!(result, 100);\n    }\n\n    #[test]\n    fn test_errored_function() {\n        let result = match errored_function() {\n            Ok(_) => panic!(\"This is not going to happen\"),\n            Err(e) => {\n                assert_eq!(e.to_string(), \"Something wrong happened.\");\n                0\n            }\n        };\n        assert_eq!(result, 0);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_panicking_function() {\n        panicking_function();\n    }\n}\n",
    "path": "tasks/exceptions",
    "remote_code": null,
    "title": "Exceptions",
    "url": "http://rosettacode.org/wiki/Exceptions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Exceptions/Catch an exception thrown in a nested call",
    "url": "http://rosettacode.org/wiki/Exceptions/Catch_an_exception_thrown_in_a_nested_call"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Executable library",
    "url": "http://rosettacode.org/wiki/Executable_library"
  },
  {
    "local_code": "use std::collections::HashMap;\nuse std::env;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::io::stdin;\nuse std::num::Wrapping;\n\nfn main() {\n    let args: Vec<_> = env::args().collect();\n    if args.len() < 2 {\n        println!(\"Usage: {} [path] (--debug)\", args[0]);\n        return;\n    }\n\n    let src: Vec<char> = {\n        let mut buf = String::new();\n        match File::open(&args[1]) {\n            Ok(mut f) => {\n                f.read_to_string(&mut buf).unwrap();\n            }\n            Err(e) => {\n                println!(\"Error opening '{}': {}\", args[1], e);\n                return;\n            }\n        }\n\n        buf.chars().collect()\n    };\n\n    // Launch options\n    let debug = args.contains(&\"--debug\".to_owned());\n\n    // One pass to find bracket pairs.\n    let brackets: HashMap<usize, usize> = {\n        let mut m = HashMap::new();\n        let mut scope_stack = Vec::new();\n        for (idx, ch) in src.iter().enumerate() {\n            match *ch {\n                '[' => {\n                    scope_stack.push(idx);\n                }\n                ']' => {\n                    m.insert(scope_stack.pop().unwrap(), idx);\n                }\n                _ => (),\n            }\n        }\n\n        m\n    };\n\n    // Program counter\n    let mut pc: usize = 0;\n\n    // Program memory\n    let mut mem: [Wrapping<u8>; 5000] = [Wrapping(0); 5000];\n\n    // Pointer\n    let mut ptr: usize = 0;\n\n    // Bracket stack\n    let mut stack: Vec<usize> = Vec::new();\n\n    let stdin_ = stdin();\n    let mut reader = stdin_.lock().bytes();\n    while pc < src.len() {\n        let Wrapping(val) = mem[ptr];\n\n        if debug {\n            println!(\n                \"(BFDB) PC: {:04} \\tPTR: {:04} \\t$PTR: {:03} \\tSTACK_DEPTH: {} \\tSYMBOL: {}\",\n                pc,\n                ptr,\n                val,\n                stack.len(),\n                src[pc]\n            );\n        }\n\n        const ONE: Wrapping<u8> = Wrapping(1);\n        match src[pc] {\n            '>' => {\n                ptr += 1;\n            }\n            '<' => {\n                ptr -= 1;\n            }\n            '+' => {\n                mem[ptr] += ONE;\n            }\n            '-' => {\n                mem[ptr] -= ONE;\n            }\n            '[' => {\n                if val == 0 {\n                    pc = brackets[&pc];\n                } else {\n                    stack.push(pc);\n                }\n            }\n            ']' => {\n                let matching_bracket = stack.pop().unwrap();\n                if val != 0 {\n                    pc = matching_bracket - 1;\n                }\n            }\n            '.' => {\n                if debug {\n                    println!(\"(BFDB) STDOUT: '{}'\", val as char); // Intercept output\n                } else {\n                    print!(\"{}\", val as char);\n                }\n            }\n            ',' => {\n                mem[ptr] = Wrapping(reader.next().unwrap().unwrap());\n            }\n            _ => (),\n        }\n\n        pc += 1;\n    }\n}\n",
    "path": "tasks/execute-brainfuck",
    "remote_code": "use std::collections::HashMap;\nuse std::env;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::io::stdin;\nuse std::num::Wrapping;\n\nfn main() {\n    let args: Vec<_> = env::args().collect();\n    if args.len() < 2 {\n        println!(\"Usage: {} [path] (--debug)\", args[0]);\n        return;\n    }\n\n    let src: Vec<char> = {\n        let mut buf = String::new();\n        match File::open(&args[1])\n        {\n            Ok(mut f) => { f.read_to_string(&mut buf).unwrap(); }\n            Err(e)    => {\n                println!(\"Error opening '{}': {}\", args[1], e);\n                return;\n            }\n        }\n\n        buf.chars().collect()\n    };\n\n    // Launch options\n    let debug = args.contains(&\"--debug\".to_owned());\n\n    // One pass to find bracket pairs.\n    let brackets: HashMap<usize, usize> = {\n        let mut m = HashMap::new();\n        let mut scope_stack = Vec::new();\n        for (idx, ch) in src.iter().enumerate() {\n            match ch {\n                &'[' => { scope_stack.push(idx); }\n                &']' => { m.insert(scope_stack.pop().unwrap(), idx); }\n                _    => { /* ignore */ }\n            }\n        }\n\n        m\n    };\n\n    let mut pc: usize = 0;                                  // Program counter\n    let mut mem: [Wrapping<u8>;5000] = [Wrapping(0);5000];  // Program cemory\n    let mut ptr: usize = 0;                                 // Pointer\n    let mut stack: Vec<usize> = Vec::new();                 // Bracket stack\n\n    let stdin_ = stdin();\n    let mut reader = stdin_.lock().bytes();\n    while pc < src.len() {\n        let Wrapping(val) = mem[ptr];\n\n        if debug {\n            println!(\"(BFDB) PC: {:04} \\tPTR: {:04} \\t$PTR: {:03} \\tSTACK_DEPTH: {} \\tSYMBOL: {}\", pc, ptr, val, stack.len(), src[pc]);\n        }\n\n        const ONE: Wrapping<u8> = Wrapping(1);\n        match src[pc] {\n            '>' => { ptr += 1; }\n            '<' => { ptr -= 1; }\n\n            '+' => { mem[ptr] = mem[ptr] + ONE; }\n            '-' => { mem[ptr] = mem[ptr] - ONE; }\n\n            '[' => {\n                if val == 0 {\n                    pc = brackets[&pc];\n                } else {\n                    stack.push(pc);\n                }\n            }\n            ']' => {\n                let matching_bracket = stack.pop().unwrap();\n                if val != 0 {\n                    pc = matching_bracket - 1;\n                }\n            }\n\n            '.' => {\n                if debug {\n                    println!(\"(BFDB) STDOUT: '{}'\", val as char);  // Intercept output\n                } else {\n                    print!(\"{}\", val as char);\n                }\n            }\n            ',' => {\n                mem[ptr] = Wrapping(reader.next().unwrap().unwrap());\n            }\n\n            _   => { /* ignore */ }\n        }\n\n        pc += 1;\n    }\n}",
    "title": "Execute Brain****",
    "url": "http://rosettacode.org/wiki/Execute_Brain****"
  },
  {
    "local_code": "use std::env;\n\n// HQ9+ requires that '+' increments an accumulator, but it's inaccessible (and thus, unused).\n#[allow(unused_variables)]\nfn execute(code: &str) {\n    let mut accumulator = 0;\n\n    for c in code.chars() {\n        match c {\n            'Q' => println!(\"{}\", code),\n            'H' => println!(\"Hello, World!\"),\n            '9' => {\n                for n in (1..100).rev() {\n                    println!(\"{} bottles of beer on the wall\", n);\n                    println!(\"{} bottles of beer\", n);\n                    println!(\"Take one down, pass it around\");\n                    if (n - 1) > 1 {\n                        println!(\"{} bottles of beer on the wall\\n\", n - 1);\n                    } else {\n                        println!(\"1 bottle of beer on the wall\\n\");\n                    }\n                }\n            }\n            '+' => accumulator += 1,\n            _ => panic!(\"Invalid character '{}' found in source.\", c),\n        }\n    }\n}\n\nfn main() {\n    execute(&env::args().nth(1).unwrap());\n}\n",
    "path": "tasks/execute-hq9-plus",
    "remote_code": "use std::env;\n\n// HQ9+ requires that '+' increments an accumulator, but it's inaccessible (and thus, unused).\n#[allow(unused_variables)]\nfn execute(code: &str) {\n    let mut accumulator = 0;\n\n    for c in code.chars() {\n        match c {\n            'Q' => println!(\"{}\", code),\n            'H' => println!(\"Hello, World!\"),\n            '9' => {\n                for n in (1..100).rev() {\n                    println!(\"{} bottles of beer on the wall\", n);\n                    println!(\"{} bottles of beer\", n);\n                    println!(\"Take one down, pass it around\");\n                    if (n - 1) > 1 {\n                        println!(\"{} bottles of beer on the wall\\n\", n - 1);\n                    } else {\n                        println!(\"1 bottle of beer on the wall\\n\");\n                    }\n                }\n            }\n            '+' => accumulator += 1,\n            _ => panic!(\"Invalid character '{}' found in source.\", c),\n        }\n    }\n}\n\nfn main() {\n    execute(&env::args().nth(1).unwrap());\n}",
    "title": "Execute HQ9+",
    "url": "http://rosettacode.org/wiki/Execute_HQ9%2B"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Execute SNUSP",
    "url": "http://rosettacode.org/wiki/Execute_SNUSP"
  },
  {
    "local_code": "/// Individual markov rule\nstruct MarkovRule {\n    pattern: String,\n    replacement: String,\n    stop: bool,\n}\n\nimpl MarkovRule {\n    fn new(pattern: String, replacement: String, stop: bool) -> MarkovRule {\n        MarkovRule {\n            pattern: pattern,\n            replacement: replacement,\n            stop: stop,\n        }\n    }\n}\n\n/// The complete markov algorithm\nstruct MarkovAlgorithm {\n    rules: Vec<MarkovRule>,\n}\n\nimpl MarkovAlgorithm {\n    /// Parse an algorithm description to build a markov algorithm\n    pub fn parse(s: &str) -> Result<MarkovAlgorithm, String> {\n        let mut rules: Vec<MarkovRule> = vec![];\n        for line in s\n            .lines()\n            .map(|l| l.trim())\n            .filter(|l| match l.chars().next() {\n                Some(c) if c != '#' => true,\n                _ => false,\n            })\n        {\n            // Ignore comments\n\n            // check for -> (must be preceded by whitespace)\n            // invalid ruleset if absent\n            // whitespace rules mean there's 2 possible variations: \" ->\" and \"\\t->\"\n            let arrow_pos = line.find(\" ->\").or_else(|| line.find(\"\\t->\"));\n            match arrow_pos {\n                None => {\n                    // Ruleset is invalid\n                    return Err(format!(\"Invalid rule \\\"{}\\\"\", line));\n                }\n                Some(arrow) => {\n                    // extract pattern (trim trailing whitespace)\n                    let pattern = line[..arrow].trim_end();\n\n                    // get the string after the arrow\n                    // this adds 3 to skip the arrow itself\n                    let line_end = line[arrow + 3..].trim_start();\n\n                    // check for . (stop)\n                    let stop = match line_end.chars().next() {\n                        Some('.') => true,\n                        _ => false,\n                    };\n\n                    // extract replacement\n                    let replacement = if stop { &line_end[1..] } else { line_end };\n\n                    // add to rules\n                    let new_rule =\n                        MarkovRule::new(pattern.to_string(), replacement.to_string(), stop);\n                    rules.push(new_rule);\n                }\n            }\n        }\n        let rule_set = MarkovAlgorithm { rules: rules };\n        Ok(rule_set)\n    }\n\n    /// Transform a text string by applying the markov algorithm\n    pub fn apply(&self, input: &str) -> String {\n        // get a writable version of the input to work with\n        let mut state = input.to_string();\n\n        // loop while operations are possible\n        loop {\n            // find the first rule that is applicable\n            // (pattern string is in state)\n            let possible_rule = self\n                .rules\n                .iter()\n                .find(|rule| state.find(&rule.pattern[..]).is_some());\n\n            match possible_rule {\n                // stop if no rule found\n                None => {\n                    break;\n                }\n                Some(rule) => {\n                    // replace the first instance (only) of the pattern\n                    // Note: cannot use str::replace as that replaces all instances\n\n                    // unwrap is safe here as the code for finding a rule\n                    // already established that the pattern is present\n                    let pos = state.find(&rule.pattern[..]).unwrap();\n                    let width = rule.pattern.len();\n\n                    // string parts\n                    let left = state[..pos].to_string();\n                    let right = state[pos + width..].to_string();\n\n                    // construct new string\n                    state = format!(\"{}{}{}\", left, rule.replacement, right);\n\n                    // stop if required\n                    if rule.stop {\n                        break;\n                    }\n                }\n            }\n        }\n\n        state\n    }\n}\n\n/// A Rosetta Code sample\nstruct RCSample<'a> {\n    ruleset: &'a str,\n    input: &'a str,\n    expected_result: &'a str,\n}\n\n// Sample markov algorithms from Rosetta Code\n// The extra whitespaces are trimmed when MarkovAlgorithm::parse is called.\nfn get_samples<'a>() -> [RCSample<'a>; 5] {\n    [\n        RCSample {\n            ruleset: r\"# This rules file is extracted from Wikipedia:\n                # http://en.wikipedia.org/wiki/Markov_Algorithm\n                A -> apple\n                B -> bag\n                S -> shop\n                T -> the\n                the shop -> my brother\n                a never used -> .terminating rule\",\n            input: \"I bought a B of As from T S.\",\n            expected_result: \"I bought a bag of apples from my brother.\",\n        },\n        RCSample {\n            ruleset: r\"# Slightly modified from the rules on Wikipedia\n                A -> apple\n                B -> bag\n                S -> .shop\n                T -> the\n                the shop -> my brother\n                a never used -> .terminating rule\",\n            input: \"I bought a B of As from T S.\",\n            expected_result: \"I bought a bag of apples from T shop.\",\n        },\n        RCSample {\n            ruleset: r\"# BNF Syntax testing rules\n                A -> apple\n                WWWW -> with\n                Bgage -> ->.*\n                B -> bag\n                ->.* -> money\n                W -> WW\n                S -> .shop\n                T -> the\n                the shop -> my brother\n                a never used -> .terminating rule\",\n            input: \"I bought a B of As W my Bgage from T S.\",\n            expected_result: \"I bought a bag of apples with my money from T shop.\",\n        },\n        RCSample {\n            ruleset: r\"### Unary Multiplication Engine, for testing Markov Algorithm implementations\n                ### By Donal Fellows.\n                # Unary addition engine\n                _+1 -> _1+\n                1+1 -> 11+\n                # Pass for converting from the splitting of multiplication into ordinary\n                # addition\n                1! -> !1\n                ,! -> !+\n                _! -> _\n                # Unary multiplication by duplicating left side, right side times\n                1*1 -> x,@y\n                1x -> xX\n                X, -> 1,1\n                X1 -> 1X\n                _x -> _X\n                ,x -> ,X\n                y1 -> 1y\n                y_ -> _\n                # Next phase of applying\n                1@1 -> x,@y\n                1@_ -> @_\n                ,@_ -> !_\n                ++ -> +\n                # Termination cleanup for addition\n                _1 -> 1\n                1+_ -> 1\n                _+_ -> \",\n            input: \"_1111*11111_\",\n            expected_result: \"11111111111111111111\",\n        },\n        RCSample {\n            ruleset: r\"# Turing machine: three-state busy beaver\n                #\n                # state A, symbol 0 => write 1, move right, new state B\n                A0 -> 1B\n                # state A, symbol 1 => write 1, move left, new state C\n                0A1 -> C01\n                1A1 -> C11\n                # state B, symbol 0 => write 1, move left, new state A\n                0B0 -> A01\n                1B0 -> A11\n                # state B, symbol 1 => write 1, move right, new state B\n                B1 -> 1B\n                # state C, symbol 0 => write 1, move left, new state B\n                0C0 -> B01\n                1C0 -> B11\n                # state C, symbol 1 => write 1, move left, halt\n                0C1 -> H01\n                1C1 -> H11\",\n            input: \"000000A000000\",\n            expected_result: \"00011H1111000\",\n        },\n    ]\n}\n\nfn main() {\n    for (index, sample) in get_samples().iter().enumerate() {\n        match MarkovAlgorithm::parse(sample.ruleset) {\n            Ok(algorithm) => {\n                println!(\"Sample {}\", (index + 1));\n                println!(\"Output: {}\", algorithm.apply(sample.input));\n                println!(\"Expected result: {}\", sample.expected_result);\n            }\n            Err(message) => println!(\"{}\", message),\n        }\n    }\n}\n\n#[test]\nfn test_samples() {\n    for sample in &get_samples() {\n        match MarkovAlgorithm::parse(sample.ruleset) {\n            Ok(algorithm) => assert_eq!(sample.expected_result, algorithm.apply(sample.input)),\n            Err(message) => panic!(\"{}\", message),\n        }\n    }\n}\n",
    "path": "tasks/execute-a-markov-algorithm",
    "remote_code": null,
    "title": "Execute a Markov algorithm",
    "url": "http://rosettacode.org/wiki/Execute_a_Markov_algorithm"
  },
  {
    "local_code": "use std::process::Command;\n\nfn main() {\n    let output = Command::new(\"ls\")\n        .output()\n        .unwrap_or_else(|e| panic!(\"failed to execute process: {}\", e));\n    println!(\"{}\", String::from_utf8_lossy(&output.stdout));\n}\n",
    "path": "tasks/execute-a-system-command",
    "remote_code": "use std::process::Command;\nfn main() {\n    let output = Command::new(\"ls\").output().unwrap_or_else(|e| {\n        panic!(\"failed to execute process: {}\", e)\n    });\n    println!(\"{}\", String::from_utf8_lossy(&output.stdout));\n}\n",
    "title": "Execute a system command",
    "url": "http://rosettacode.org/wiki/Execute_a_system_command"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate num;\nuse num::traits::One;\nuse std::ops::Mul;\n\nfn pow<T>(mut base: T, mut exp: usize) -> T \n    where T: Clone + One + Mul<T, Output=T>\n{\n    if exp == 0 { return T::one() }\n    while exp & 1 == 0 {\n        base = base.clone() * base;\n        exp >>= 1;\n    }\n    if exp == 1 { return base }\n    let mut acc = base.clone();\n\n    while exp > 1 {\n        exp >>= 1;\n        base = base.clone() * base;\n        if exp & 1 == 1 {\n            acc = acc * base.clone();\n        }\n    }\n    acc\n}",
    "title": "Exponentiation operator",
    "url": "http://rosettacode.org/wiki/Exponentiation_operator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    println!(\"5**3**2   = {:7}\", 5u32.pow(3).pow(2));\n    println!(\"(5**3)**2 = {:7}\", (5u32.pow(3)).pow(2));\n    println!(\"5**(3**2) = {:7}\", 5u32.pow(3u32.pow(2)));\n}",
    "title": "Exponentiation order",
    "url": "http://rosettacode.org/wiki/Exponentiation_order"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#![allow(unused_variables)]\nmacro_rules! if2 {\n    ($cond1: expr, $cond2: expr \n        => $both:expr \n        => $first: expr \n        => $second:expr \n        => $none:expr) \n    => {\n        match ($cond1, $cond2) {\n            (true, true) => $both,\n            (true, _   ) => $first,\n            (_   , true) => $second,\n            _            => $none\n        }\n    }\n}\n\nfn main() {\n    let i = 1;\n    let j = 2;\n    if2!(i > j, i + j >= 3\n        => {\n            // code blocks and statements can go here also\n            let k = i + j;\n            println!(\"both were true\")\n        }\n        => println!(\"the first was true\")\n        => println!(\"the second was true\")\n        => println!(\"neither were true\")\n    )\n}",
    "title": "Extend your language",
    "url": "http://rosettacode.org/wiki/Extend_your_language"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "mod pagesieve;\n\nuse pagesieve::{count_primes_paged, primes_paged};\n\nfn main() {\n    println!(\"First 20 primes:\\n {:?}\",\n             primes_paged().take(20).collect::<Vec<_>>());\n    println!(\"Primes between 100 and 150:\\n {:?}\",\n             primes_paged().skip_while(|&x| x < 100)\n                           .take_while(|&x| x < 150)\n                           .collect::<Vec<_>>());\n    let diff = count_primes_paged(8000) - count_primes_paged(7700);\n    println!(\"There are {} primes between 7,700 and 8,000\", diff);\n    // rust enumerations are zero base, so need to subtract 1!!!\n    println!(\"The 10,000th prime is {}\", primes_paged().nth(10_000 - 1).unwrap());\n}",
    "title": "Extensible prime generator",
    "url": "http://rosettacode.org/wiki/Extensible_prime_generator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let inf: f64 = 1. / 0.;          // or std::f64::INFINITY\n    let minus_inf: f64 = -1. / 0.;   // or std::f64::NEG_INFINITY\n    let minus_zero: f64 = -1. / inf; // or -0.0\n    let nan: f64 = 0. / 0.;          // or std::f64::NAN\n                                     // or std::f32 for the above\n    println!(\"positive infinity: {:+}\", inf);\n    println!(\"negative infinity: {:+}\", minus_inf);\n    println!(\"negative zero: {:+?}\", minus_zero);\n    println!(\"not a number: {:+}\", nan);\n    println!();\n    println!(\"+inf + 2.0 = {:+}\", inf + 2.);\n    println!(\"+inf - 10.0 = {:+}\", inf - 10.);\n    println!(\"+inf + -inf = {:+}\", inf + minus_inf);\n    println!(\"0.0 * inf = {:+}\", 0. * inf);\n    println!(\"1.0 / -0.0 = {:+}\", 1. / -0.);\n    println!(\"NaN + 1.0 = {:+}\", nan + 1.);\n    println!(\"NaN + NaN = {:+}\", nan + nan);\n    println!();\n    println!(\"NaN == NaN = {}\", nan == nan);\n    println!(\"0.0 == -0.0 = {}\", 0. == -0.);\n}",
    "title": "Extreme floating point values",
    "url": "http://rosettacode.org/wiki/Extreme_floating_point_values"
  },
  {
    "local_code": "//! Ported and adapted from rosettacode D example\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn format_fasta<T: BufRead>(reader: &mut T) -> String {\n    reader\n        .lines()\n        .map(|l| l.unwrap())\n        .fold(String::new(), |mut out, line| {\n            // We need to trim new lines\n            let ln = line.trim();\n\n            // Lines that begin with '>' require special treatment\n            match &ln[..1] {\n                \">\" => {\n                    if !out.is_empty() {\n                        out.push('\\n');\n                    }\n\n                    // Push skipping the '>'\n                    out.push_str(&ln[1..]);\n                    out.push_str(\": \");\n                }\n                // Other lines are just pushed\n                _ => out.push_str(ln),\n            }\n            out\n        })\n}\n\nfn read_file() -> String {\n    let file = File::open(\"resources/test_data.fasta\").unwrap();\n    format_fasta(&mut BufReader::new(file))\n}\n\nfn main() {\n    let s = read_file();\n    println!(\"{}\", s);\n}\n\n#[test]\nfn test_format_fasta() {\n    let s = read_file();\n    assert_eq!(\n        s,\n        r\"Rosetta_Example_1: THERECANBENOSPACE\nRosetta_Example_2: THERECANBESEVERALLINESBUTTHEYALLMUSTBECONCATENATED\"\n    );\n}\n",
    "path": "tasks/fasta-format",
    "remote_code": "\nuse std::env;\nuse std::io::{BufReader, Lines};\nuse std::io::prelude::*;\nuse std::fs::File;\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let f = File::open(&args[1]).unwrap();\n    for line in FastaIter::new(f) {\n        println!(\"{}\", line);\n    }\n}\n\nstruct FastaIter<T> {\n    buffer_lines: Lines<BufReader<T>>,\n    current_name: Option<String>,\n    current_sequence: String\n}\n\nimpl<T: Read> FastaIter<T> {\n    fn new(file: T) -> FastaIter<T> {\n        FastaIter { buffer_lines: BufReader::new(file).lines(),\n                    current_name: None,\n                    current_sequence: String::new() }\n    }\n}\n\nimpl<T: Read> Iterator for FastaIter<T> {\n    type Item = String;\n\n    fn next(&mut self) -> Option<String> {\n        while let Some(l) = self.buffer_lines.next() {\n            let line = l.unwrap();\n            if line.starts_with(\">\") {\n                if self.current_name.is_some() {                    \n                    let mut res = String::new();\n                    res.push_str(self.current_name.as_ref().unwrap());\n                    res.push_str(\": \");\n                    res.push_str(&self.current_sequence);\n                    self.current_name = Some(String::from(&line[1..]));\n                    self.current_sequence.clear();\n                    return Some(res);\n                } else {\n                    self.current_name = Some(String::from(&line[1..]));\n                    self.current_sequence.clear();\n                }\n                continue;\n            }\n            self.current_sequence.push_str(line.trim());\n        }\n        if self.current_name.is_some() {\n            let mut res = String::new();\n            res.push_str(self.current_name.as_ref().unwrap());\n            res.push_str(\": \");\n            res.push_str(&self.current_sequence);\n            self.current_name = None;\n            self.current_sequence.clear();\n            self.current_sequence.shrink_to_fit();\n            return Some(res);\n        }\n        None\n    }\n}\n",
    "title": "FASTA format",
    "url": "http://rosettacode.org/wiki/FASTA_format"
  },
  {
    "local_code": "extern crate ftp;\n\nuse ftp::types::{FileType, Result};\nuse ftp::FtpStream;\nuse std::fs::File;\nuse std::io::{Read, Write};\n\nfn write_file(filename: &str) -> impl Fn(&mut dyn Read) -> Result<()> {\n    let filename = filename.to_string();\n    move |stream| {\n        let mut file = File::create(&filename).unwrap();\n        let mut buf = [0; 2048];\n        loop {\n            match stream.read(&mut buf) {\n                Ok(0) => break,\n                Ok(n) => file.write_all(&buf[0..n]).unwrap(),\n                Err(err) => panic!(err),\n            };\n        }\n        Ok(())\n    }\n}\n\nfn main() {\n    // connect to the server\n    let mut ftp = FtpStream::connect(\"kernel.org:21\").unwrap();\n    ftp.login(\"anonymous\", \"\").unwrap();\n\n    // change working directory\n    ftp.cwd(\"/pub/linux/kernel\").unwrap();\n\n    // list files in the current directory\n    match ftp.list(None) {\n        Ok(output) => println!(\"{}\", output.join(\"\")),\n        Err(err) => panic!(err),\n    }\n\n    // download a file a write it on the disk\n    ftp.transfer_type(FileType::Binary).unwrap();\n    ftp.retr(\"README\", write_file(\"README\")).unwrap();\n}\n\n#[cfg(test)]\nmod test {\n    use super::write_file;\n    use ftp::types::FileType;\n    use ftp::FtpStream;\n    use std::fs;\n\n    fn connect() -> FtpStream {\n        let mut ftp = FtpStream::connect(\"kernel.org:21\").unwrap();\n        ftp.login(\"anonymous\", \"\").unwrap();\n        return ftp;\n    }\n\n    #[ignore]\n    #[test]\n    fn test_cwd() {\n        let mut ftp = connect();\n        // make sure the current directory is /\n        assert_eq!(ftp.pwd().unwrap(), \"/\");\n        ftp.cwd(\"/pub/linux/kernel\").unwrap();\n        assert_eq!(ftp.pwd().unwrap(), \"/pub/linux/kernel\");\n    }\n\n    #[ignore]\n    #[test]\n    fn test_list_dir() {\n        let mut ftp = connect();\n        assert_eq!(\n            ftp.list(Some(\"/\")).unwrap().join(\"\"),\n            \"drwxr-xr-x    9 ftp      ftp          4096 Dec 01  2011 pub\"\n        );\n    }\n\n    #[ignore]\n    #[test]\n    fn test_download_file() {\n        let filename = \".test_download_file\";\n        let mut ftp = connect();\n        ftp.cwd(\"/pub/linux/kernel\").unwrap();\n        // make sure the file does not already exist\n        match fs::metadata(filename) {\n            Ok(_) => fs::remove_file(filename).unwrap(),\n            Err(_) => {}\n        }\n        ftp.transfer_type(FileType::Binary).unwrap();\n        ftp.retr(\"README\", write_file(filename)).unwrap();\n        match fs::metadata(filename) {\n            Ok(metadata) => {\n                assert_eq!(metadata.is_file(), true);\n                assert_eq!(metadata.len(), 12056);\n                fs::remove_file(filename).unwrap();\n            }\n            Err(_) => panic!(\"file not downloaded\"),\n        }\n    }\n}\n",
    "path": "tasks/ftp",
    "remote_code": null,
    "title": "FTP",
    "url": "http://rosettacode.org/wiki/FTP"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Faces from a mesh",
    "url": "http://rosettacode.org/wiki/Faces_from_a_mesh"
  },
  {
    "local_code": "#![feature(test)]\nextern crate test;\n\n/// Calculate the factorial using recursion\nfn factorial_recursive(n: usize) -> usize {\n    match n {\n        0 => 1,\n        _ => n * factorial_recursive(n - 1),\n    }\n}\n\n/// Calculate the factorial using a fold\nfn factorial_iterative(n: usize) -> usize {\n    (1..n + 1).fold(1, |p, t| p * t)\n}\n\n/// Calculate the factorial using a for loop\nfn factorial_loop(n: usize) -> usize {\n    let mut fac = 1;\n    for x in 1..n + 1 {\n        fac *= x;\n    }\n    fac\n}\n\nfn main() {\n    let fs = vec![\n        (\"Recursive\", factorial_recursive as fn(usize) -> usize),\n        (\"Iterative\", factorial_iterative as fn(usize) -> usize),\n        (\"Looooooop\", factorial_loop as fn(usize) -> usize),\n    ];\n    for (name, f) in fs {\n        println!(\"---------\\n{}\", name);\n        for i in 1..10 {\n            println!(\"{}\", f(i))\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::test::{self, Bencher};\n    use super::{factorial_iterative, factorial_loop, factorial_recursive};\n\n    /// Tests\n    fn t(f: fn(usize) -> usize) {\n        assert_eq!(f(0), 1);\n        assert_eq!(f(1), 1);\n        assert_eq!(f(2), 2);\n        assert_eq!(f(3), 6);\n        assert_eq!(f(4), 24);\n        assert_eq!(f(5), 120);\n        assert_eq!(f(6), 720);\n        assert_eq!(f(7), 5040);\n        assert_eq!(f(8), 40320);\n        assert_eq!(f(9), 362880);\n        assert_eq!(f(10), 3628800);\n    }\n\n    #[test]\n    fn test_fac_recursive() {\n        t(factorial_recursive as fn(usize) -> usize)\n    }\n\n    #[test]\n    fn test_fac_iterative() {\n        t(factorial_iterative as fn(usize) -> usize)\n    }\n\n    #[test]\n    fn test_fac_loop() {\n        t(factorial_loop as fn(usize) -> usize)\n    }\n\n    // Benchmarks\n    #[bench]\n    fn bench_fac_recursive(b: &mut Bencher) {\n        b.iter(|| {\n            test::black_box(factorial_recursive(10));\n        });\n    }\n\n    #[bench]\n    fn bench_fac_iterative(b: &mut Bencher) {\n        b.iter(|| {\n            test::black_box(factorial_iterative(10));\n        });\n    }\n\n    #[bench]\n    fn bench_fac_loop(b: &mut Bencher) {\n        b.iter(|| {\n            test::black_box(factorial_loop(10));\n        });\n    }\n}\n",
    "path": "tasks/factorial",
    "remote_code": "fn factorial_recursive (n: u64) -> u64 {\n    match n {\n        0 => 1,\n        _ => n * factorial_recursive(n-1)\n    }\n}\n\nfn factorial_iterative(n: u64) -> u64 {\n    (1..=n).product()\n}\n\nfn main () {\n    for i in 1..10 {\n        println!(\"{}\", factorial_recursive(i))\n    }\n    for i in 1..10 {\n        println!(\"{}\", factorial_iterative(i))\n    }\n}\n",
    "title": "Factorial",
    "url": "http://rosettacode.org/wiki/Factorial"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Factorial base numbers indexing permutations of a collection",
    "url": "http://rosettacode.org/wiki/Factorial_base_numbers_indexing_permutations_of_a_collection"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Factors of a Mersenne number",
    "url": "http://rosettacode.org/wiki/Factors_of_a_Mersenne_number"
  },
  {
    "local_code": "fn main() {\n    let target = 78i32;\n    println!(\"Factors of integer {}:\", target);\n    let factors = factor_int(target);\n\n    for f in factors {\n        println!(\"{}\", f);\n    }\n}\n\n/// Compute the factors of an integer\n/// This method uses a simple check on each value between 1 and sqrt(x) to find\n/// pairs of factors\nfn factor_int(x: i32) -> Vec<i32> {\n    let mut factors: Vec<i32> = Vec::new();\n\n    let bound: i32 = f64::from(x).sqrt().floor() as i32;\n\n    for i in 1i32..bound {\n        if x % i == 0 {\n            factors.push(i);\n            factors.push(x / i);\n        }\n    }\n\n    factors\n}\n\n#[test]\nfn test() {\n    let result = factor_int(78i32);\n    assert_eq!(result, vec![1i32, 78, 2, 39, 3, 26, 6, 13]);\n}\n",
    "path": "tasks/factors-of-an-integer",
    "remote_code": "fn main() {\n    assert_eq!(vec![1, 2, 4, 5, 10, 10, 20, 25, 50, 100], factor(100)); // asserts that two expressions are equal to each other\n    assert_eq!(vec![1, 101], factor(101));\n\n}\n\nfn factor(num: i32) -> Vec<i32> {\n    let mut factors: Vec<i32> = Vec::new(); // creates a new vector for the factors of the number\n\n    for i in 1..((num as f32).sqrt() as i32 + 1) { \n        if num % i == 0 {\n            factors.push(i); // pushes smallest factor to factors\n            factors.push(num/i); // pushes largest factor to factors\n        }\n    }\n    factors.sort(); // sorts the factors into numerical order for viewing purposes\n    factors // returns the factors\n}",
    "title": "Factors of an integer",
    "url": "http://rosettacode.org/wiki/Factors_of_an_integer"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Farey sequence",
    "url": "http://rosettacode.org/wiki/Farey_sequence"
  },
  {
    "local_code": "extern crate num;\n\nuse num::complex::Complex;\nuse std::f32::consts::PI;\nuse std::iter::repeat;\n\nfn fft(arr: &[Complex<f32>]) -> Vec<Complex<f32>> {\n    if arr.len() <= 1 {\n        return arr.to_vec();\n    }\n\n    let mut even = Vec::with_capacity(arr.len() / 2);\n    let mut odd = Vec::with_capacity(arr.len() / 2);\n\n    for (i, val) in arr.iter().enumerate() {\n        if i % 2 == 0 {\n            even.push(*val);\n        } else {\n            odd.push(*val);\n        }\n    }\n\n    let even_fft = fft(&even[..]);\n    let odd_fft = fft(&odd[..]);\n\n    let mut out: Vec<Complex<f32>> = repeat(Complex::new(0f32, 0f32)).take(arr.len()).collect();\n    for i in 0..arr.len() / 2 {\n        let twiddle: Complex<f32> =\n            Complex::from_polar(&1f32, &(-2f32 * PI * (i as f32) / (arr.len() as f32)));\n        out[i] = even_fft[i] + twiddle * odd_fft[i];\n        out[i + arr.len() / 2] = even_fft[i] - twiddle * odd_fft[i];\n    }\n\n    out\n}\n\nfn main() {\n    let test = [\n        Complex::new(1f32, 0f32),\n        Complex::new(1f32, 0f32),\n        Complex::new(1f32, 0f32),\n        Complex::new(1f32, 0f32),\n        Complex::new(0f32, 0f32),\n        Complex::new(0f32, 0f32),\n        Complex::new(0f32, 0f32),\n        Complex::new(0f32, 0f32),\n    ];\n\n    let test_fft = fft(&test[..]);\n    println!(\"{:?}\", test_fft);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::fft;\n    use num::complex::Complex;\n\n    #[test]\n    fn transform() {\n        let test = [\n            Complex::new(1f32, 0f32),\n            Complex::new(1f32, 0f32),\n            Complex::new(1f32, 0f32),\n            Complex::new(1f32, 0f32),\n            Complex::new(0f32, 0f32),\n            Complex::new(0f32, 0f32),\n            Complex::new(0f32, 0f32),\n            Complex::new(0f32, 0f32),\n        ];\n        let target = [\n            Complex::new(4f32, 0f32),\n            Complex::new(1f32, -2.414f32),\n            Complex::new(0f32, 0f32),\n            Complex::new(1f32, -0.414f32),\n            Complex::new(0f32, 0f32),\n            Complex::new(1f32, 0.414f32),\n            Complex::new(0f32, 0f32),\n            Complex::new(1f32, 2.414f32),\n        ];\n\n        let test_fft = fft(&test[..]);\n        println!(\"{:?}\", target.to_vec());\n        println!(\"{:?}\", test_fft);\n        for (test_item, target_item) in test_fft.iter().zip(target.iter()) {\n            assert!((*test_item - *target_item).norm_sqr() < 1e-6);\n        }\n    }\n}\n",
    "path": "tasks/fast-fourier-transform",
    "remote_code": "extern crate num;\nuse num::complex::Complex;\nuse std::f64::consts::PI;\n\nconst I: Complex<f64> = Complex { re: 0.0, im: 1.0 };\n\npub fn fft(input: &[Complex<f64>]) -> Vec<Complex<f64>> {\n    fn fft_inner(\n        buf_a: &mut [Complex<f64>],\n        buf_b: &mut [Complex<f64>],\n        n: usize,    // total length of the input array\n        step: usize, // precalculated values for t\n    ) {\n        if step >= n {\n            return;\n        }\n\n        fft_inner(buf_b, buf_a, n, step * 2);\n        fft_inner(&mut buf_b[step..], &mut buf_a[step..], n, step * 2);\n        // create a slice for each half of buf_a:\n        let (left, right) = buf_a.split_at_mut(n / 2);\n\n        for i in (0..n).step_by(step * 2) {\n            let t = (-I * PI * (i as f64) / (n as f64)).exp() * buf_b[i + step];\n            left[i / 2] = buf_b[i] + t;\n            right[i / 2] = buf_b[i] - t;\n        }\n    }\n\n    // round n (length) up to a power of 2:\n    let n_orig = input.len();\n    let n = n_orig.next_power_of_two();\n    // copy the input into a buffer:\n    let mut buf_a = input.to_vec();\n    // right pad with zeros to a power of two:\n    buf_a.append(&mut vec![Complex { re: 0.0, im: 0.0 }; n - n_orig]);\n    // alternate between buf_a and buf_b to avoid allocating a new vector each time:\n    let mut buf_b = buf_a.clone();\n    fft_inner(&mut buf_a, &mut buf_b, n, 1);\n    buf_a\n}\n\nfn show(label: &str, buf: &[Complex<f64>]) {\n    println!(\"{}\", label);\n    let string = buf\n        .into_iter()\n        .map(|x| format!(\"{:.4}{:+.4}i\", x.re, x.im))\n        .collect::<Vec<_>>()\n        .join(\", \");\n    println!(\"{}\", string);\n}\n\nfn main() {\n    let input: Vec<_> = [1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0]\n        .into_iter()\n        .map(|x| Complex::from(x))\n        .collect();\n    show(\"input:\", &input);\n    let output = fft(&input);\n    show(\"output:\", &output);\n}",
    "title": "Fast Fourier transform",
    "url": "http://rosettacode.org/wiki/Fast_Fourier_transform"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": " struct DivisorGen {\n    curr: u64,\n    last: u64,\n}\n\nimpl Iterator for DivisorGen {\n    type Item = u64;\n\n    fn next(&mut self) -> Option<u64> {\n        self.curr += 2u64;\n\n        if self.curr < self.last{\n            None\n        } else {\n            Some(self.curr)\n        }\n    }\n}\n\nfn divisor_gen(num : u64) -> DivisorGen {\n    DivisorGen { curr: 0u64, last: (num / 2u64) + 1u64 }\n}\n\nfn is_prime(num : u64) -> bool{\n    if num == 2 || num == 3 {\n        return true;\n    } else if num % 2 == 0 || num % 3 == 0 || num <= 1{\n        return false;\n    }else{\n        for i in divisor_gen(num){\n            if num % i == 0{\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n\nfn main() {\n    let fermat_closure = |i : u32| -> u64 {2u64.pow(2u32.pow(i + 1u32))};\n    let mut f_numbers : Vec<u64> = Vec::new();\n    \n    println!(\"First 4 Fermat numbers:\");\n    for i in 0..4 {\n        let f = fermat_closure(i) + 1u64;\n        f_numbers.push(f);\n        println!(\"F{}: {}\", i, f);\n    }\n    \n    println!(\"Factor of the first four numbers:\");\n    for f in f_numbers.iter(){\n        let is_prime : bool = f % 4 == 1 && is_prime(*f);\n        let not_or_not = if is_prime {\" \"} else {\" not \"};\n        println!(\"{} is{}prime\", f, not_or_not);\n    }\n}",
    "title": "Fermat numbers",
    "url": "http://rosettacode.org/wiki/Fermat_numbers"
  },
  {
    "local_code": "/// state for producing generalized Fibonacci sequences\nstruct GenFibonacci {\n    /// current values being summed\n    buf: Vec<u64>,\n\n    /// current sum\n    sum: u64,\n\n    /// index of smallest element\n    idx: usize,\n}\n\n/// note: iterator starts with values *after* the buffer contents\nimpl Iterator for GenFibonacci {\n    type Item = u64;\n    fn next(&mut self) -> Option<u64> {\n        let result = self.sum; // capture current sum\n        self.sum += result - self.buf[self.idx]; // add new elt, subtract old\n        self.buf[self.idx] = result; // write new elt to buffer\n        self.idx = (self.idx + 1) % self.buf.len(); // advance index\n        Some(result) // return result\n    }\n}\n\n/// prints the starting buf and len number of additional elements\nfn print(buf: Vec<u64>, len: usize) {\n    let mut sum = 0;\n    for &elt in &buf {\n        sum += elt;\n        print!(\"\\t{}\", elt);\n    }\n    let iter = GenFibonacci {\n        buf: buf,\n        sum: sum,\n        idx: 0,\n    };\n    for x in iter.take(len) {\n        print!(\"\\t{}\", x);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::GenFibonacci;\n\n    /// test equivalence between tgt and sequence generated from buf\n    fn test(mut buf: Vec<u64>, tgt: Vec<u64>) {\n        let mut sum = 0;\n        for elt in &buf {\n            sum += *elt;\n        }\n        let mut iter = GenFibonacci {\n            buf: buf.clone(),\n            sum: sum,\n            idx: 0,\n        };\n        while buf.len() < tgt.len() {\n            buf.push(iter.next().unwrap());\n        }\n\n        assert_eq!(buf, tgt);\n    }\n\n    #[test]\n    fn test_fib2() {\n        test(vec![1, 1], vec![1, 1, 2, 3, 5, 8, 13, 21, 34, 55]);\n    }\n    #[test]\n    fn test_fib3() {\n        test(vec![1, 1, 2], vec![1, 1, 2, 4, 7, 13, 24, 44, 81, 149]);\n    }\n    #[test]\n    fn test_fib4() {\n        test(vec![1, 1, 2, 4], vec![1, 1, 2, 4, 8, 15, 29, 56, 108, 208]);\n    }\n    #[test]\n    fn test_lucas() {\n        test(vec![2, 1], vec![2, 1, 3, 4, 7, 11, 18, 29, 47, 76]);\n    }\n}\n\n// main() should print:\n// Fib2:\t1\t1\t2\t3\t5\t8\t13\t21\t34\t55\n// Fib3:\t1\t1\t2\t4\t7\t13\t24\t44\t81\t149\n// Fib4:\t1\t1\t2\t4\t8\t15\t29\t56\t108\t208\n// Lucas:\t2\t1\t3\t4\t7\t11\t18\t29\t47\t76\nfn main() {\n    print!(\"Fib2:\");\n    print(vec![1, 1], 10 - 2);\n\n    print!(\"\\nFib3:\");\n    print(vec![1, 1, 2], 10 - 3);\n\n    print!(\"\\nFib4:\");\n    print(vec![1, 1, 2, 4], 10 - 4);\n\n    print!(\"\\nLucas:\");\n    print(vec![2, 1], 10 - 2);\n}\n",
    "path": "tasks/fibonacci-n-step-number-sequences",
    "remote_code": " \nstruct GenFibonacci {\n    buf:    Vec<u64>,\n    sum:    u64,\n    idx:    usize,\n}\n\nimpl Iterator for GenFibonacci {\n    type Item = u64;\n    fn next(&mut self) -> Option<u64> {\n        let result = Some(self.sum);\n        self.sum -= self.buf[self.idx];\n        self.buf[self.idx] += self.sum;\n        self.sum += self.buf[self.idx];\n        self.idx = (self.idx + 1) % self.buf.len();\n        result\n    }\n}\n\nfn print(buf: Vec<u64>, len: usize) {\n    let mut sum = 0;\n    for &elt in buf.iter() { sum += elt; print!(\"\\t{}\", elt); }\n    let iter = GenFibonacci { buf: buf, sum: sum, idx: 0 };\n    for x in iter.take(len) {\n        print!(\"\\t{}\", x);\n    }\n}\n\n\nfn main() {\n    print!(\"Fib2:\");\n    print(vec![1,1], 10 - 2);\n    \n    print!(\"\\nFib3:\");\n    print(vec![1,1,2], 10 - 3);\n    \n    print!(\"\\nFib4:\");\n    print(vec![1,1,2,4], 10 - 4);\n    \n    print!(\"\\nLucas:\");\n    print(vec![2,1], 10 - 2);\n}\n",
    "title": "Fibonacci n-step number sequences",
    "url": "http://rosettacode.org/wiki/Fibonacci_n-step_number_sequences"
  },
  {
    "local_code": "fn main() {\n    let fns = vec![\n        (fib_recursive as fn(u64) -> u64, \"recursive\"),\n        (fib_tail_recursive as fn(u64) -> u64, \"tail recursive\"),\n        (fib_iterative as fn(u64) -> u64, \"iterative\"),\n    ];\n\n    for (f, desc) in fns {\n        let r = (0u64..10).map(f).collect::<Vec<u64>>();\n        println!(\"{} implementation:\\n{:?}\\n\", desc, r);\n    }\n}\n\n/// Fibonacci \"classic\" recursive version\n/// not tail recursive (it's going to blow the stack for n too high)\nfn fib_recursive(n: u64) -> u64 {\n    match n {\n        0 | 1 => n,\n        n => fib_recursive(n - 1) + fib_recursive(n - 2),\n    }\n}\n\n/// tail recursive version\nfn fib_tail_recursive(n: u64) -> u64 {\n    fn in_fib(n: u64, current: u64, next: u64) -> u64 {\n        match n {\n            0 => current,\n            n => in_fib(n - 1, next, current + next),\n        }\n    }\n\n    in_fib(n, 0, 1)\n}\n\n/// iterative version\nfn fib_iterative(n: u64) -> u64 {\n    let (mut cur, mut next) = (0u64, 1u64);\n\n    for _ in 0u64..n {\n        let tmp = cur + next;\n        cur = next;\n        next = tmp;\n    }\n\n    cur\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{fib_iterative, fib_recursive, fib_tail_recursive};\n\n    /// helper function to test that all versions of the fib function\n    /// return the expected values.\n    fn tester(f: fn(u64) -> u64) {\n        let exp = [0u64, 1, 1, 2, 3, 5, 8, 13, 21, 34];\n        for (i, expected) in (0u64..10).zip(exp.iter()) {\n            assert_eq!(f(i), *expected);\n        }\n    }\n\n    #[test]\n    fn fib_values() {\n        let fns = vec![\n            fib_recursive as fn(u64) -> u64,\n            fib_tail_recursive as fn(u64) -> u64,\n            fib_iterative as fn(u64) -> u64,\n        ];\n        for &f in &fns {\n            tester(f);\n        }\n    }\n}\n",
    "path": "tasks/fibonacci-sequence",
    "remote_code": "use std::mem;\nfn main() {\n    let mut prev = 0;\n    // Rust needs this type hint for the checked_add method\n    let mut curr = 1usize;\n\n    while let Some(n) = curr.checked_add(prev) {\n        prev = curr;\n        curr = n;\n        println!(\"{}\", n);\n    }\n}",
    "title": "Fibonacci sequence",
    "url": "http://rosettacode.org/wiki/Fibonacci_sequence"
  },
  {
    "local_code": "extern crate entropy;\n\nuse entropy::shannon_entropy;\n\n/// Returns \"amount\" fibonacci words as a vector of tuples\n/// The first value of the tuple is the length of the word\n/// and the second one its entropy\nfn fib_words(amount: usize) -> Vec<(usize, f64)> {\n    let mut data = Vec::with_capacity(amount);\n    let mut previous = String::from(\"1\");\n    let mut next = String::from(\"0\");\n\n    // The first two words (we need to add them manually because\n    // they are the base of the sequence)\n    data.push((previous.len(), shannon_entropy(&previous[..])));\n    data.push((next.len(), shannon_entropy(&next[..])));\n\n    // The rest of the words\n    for _ in 3..(amount + 1) {\n        let temp = next.clone();\n        next.push_str(&previous[..]);\n        previous = temp;\n        data.push((next.len(), shannon_entropy(&next[..])));\n    }\n\n    data\n}\n\nfn main() {\n    println!(\"Calculating... This may take a couple of minutes...\\n\");\n\n    let words = fib_words(18);\n    let mut i = 1;\n\n    println!(\"{:>2}:{:>10} {}\", \"N\", \"length\", \"entropy\");\n    for &(length, entropy) in &words {\n        println!(\"{:>2}:{:>10} {:.15}\", i, length, entropy);\n        i += 1;\n    }\n}\n\n#[test]\nfn test_fibonacii_words() {\n    let expected = vec![\n        (1, 0.000000000000000f64),\n        (1, 0.000000000000000),\n        (2, 1.000000000000000),\n        (3, 0.918295834054490),\n        (5, 0.970950594454669),\n        (8, 0.954434002924965),\n        (13, 0.961236604722876),\n        (21, 0.958711882977132),\n        (34, 0.959686893774217),\n        (55, 0.959316032054378),\n        (89, 0.959457915838670),\n        (144, 0.959403754221023),\n        (233, 0.959424446955987),\n        (377, 0.959416543740441),\n        (610, 0.959419562603144),\n        (987, 0.959418409515224),\n        (1597, 0.959418849957810),\n        (2584, 0.959418681724032),\n    ];\n\n    let epsilon = 0.0000000001f64;\n    let output = fib_words(18);\n\n    for ((output_length, output_entropy), (expected_length, expected_entropy)) in\n        output.into_iter().zip(expected.into_iter())\n    {\n        assert!(output_length == expected_length);\n        assert!((output_entropy - expected_entropy).abs() < epsilon);\n    }\n}\n",
    "path": "tasks/fibonacci-word",
    "remote_code": "struct Fib<T> {\n    curr: T,\n    next: T,\n}\n\nimpl<T> Fib<T> {\n    fn new(curr: T, next: T) -> Self {\n        Fib { curr: curr, next: next, }\n    }\n}\n\nimpl Iterator for Fib<String>  {\n    type Item = String;\n    fn next(&mut self) -> Option<Self::Item> {\n        let ret = self.curr.clone();\n        self.curr = self.next.clone();\n        self.next = format!(\"{}{}\", ret, self.next);\n        Some(ret)\n    }\n}\n\nfn get_entropy(s: &[u8]) -> f64 {\n    let mut entropy = 0.0;\n    let mut histogram = [0.0; 256];\n \n    for i in 0..s.len() {\n        histogram.get_mut(s[i] as usize).map(|v| *v += 1.0);\n    }\n\n    for i in 0..256 {\n        if histogram[i] > 0.0 {\n            let ratio = histogram[i] / s.len() as f64;\n            entropy -= ratio * ratio.log2();\n        }\n    }\n    entropy\n}\n\nfn main() {\n    let f = Fib::new(\"1\".to_string(), \"0\".to_string());\n        println!(\"{:10} {:10} {:10} {:60}\", \"N\", \"Length\", \"Entropy\", \"Word\");\n    for (i, s) in f.take(37).enumerate() {\n        let word = if s.len() > 60 {\"Too long\"} else {&*s};\n        println!(\"{:10} {:10} {:.10} {:60}\", i + 1, s.len(), get_entropy(&s.bytes().collect::<Vec<_>>()), word);\n    }\n}",
    "title": "Fibonacci word",
    "url": "http://rosettacode.org/wiki/Fibonacci_word"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Fibonacci word/fractal",
    "url": "http://rosettacode.org/wiki/Fibonacci_word/fractal"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "File extension is in extensions list",
    "url": "http://rosettacode.org/wiki/File_extension_is_in_extensions_list"
  },
  {
    "local_code": "use std::fs::File;\nuse std::io::{Read, Write};\n\nfn main() {\n    let mut file = File::open(\"input.txt\").unwrap();\n    let mut data = Vec::new();\n    file.read_to_end(&mut data).unwrap();\n    let mut file = File::create(\"output.txt\").unwrap();\n    file.write_all(&data).unwrap();\n}\n",
    "path": "tasks/file-input-output",
    "remote_code": "use std::fs::File;\nuse std::io::{Read, Write};\n\nfn main() {\n    let mut file = File::open(\"input.txt\").unwrap();\n    let mut data = Vec::new();\n    file.read_to_end(&mut data).unwrap();\n    let mut file = File::create(\"output.txt\").unwrap();\n    file.write_all(&data).unwrap();\n}\n",
    "title": "File input/output",
    "url": "http://rosettacode.org/wiki/File_input/output"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::fs;\n\nfn main() -> std::io::Result<()> {\n    let metadata = fs::metadata(\"foo.txt\")?;\n\n    if let Ok(time) = metadata.accessed() {\n        println!(\"{:?}\", time);\n    } else {\n        println!(\"Not supported on this platform\");\n    }\n    Ok(())\n}\n",
    "title": "File modification time",
    "url": "http://rosettacode.org/wiki/File_modification_time"
  },
  {
    "local_code": "use std::fs;\n\nfn main() {\n    if let Ok(attr) = fs::metadata(\"input.txt\") {\n        println!(\"size: {}\", attr.len());\n    }\n    if let Ok(attr_root) = fs::metadata(\"/input.txt\") {\n        println!(\"{}\", attr_root.len());\n    }\n}\n",
    "path": "tasks/file-size",
    "remote_code": "use std::{env, fs, process};\nuse std::io::{self, Write};\nuse std::fmt::Display;\n\nfn main() {\n    let file_name = env::args().nth(1).unwrap_or_else(|| exit_err(\"No file name supplied\", 1));\n    let metadata = fs::metadata(file_name).unwrap_or_else(|e| exit_err(e, 2));\n\n    println!(\"Size of file.txt is {} bytes\", metadata.len());\n}\n\n#[inline]\nfn exit_err<T: Display>(msg: T, code: i32) -> ! {\n    writeln!(&mut io::stderr(), \"Error: {}\", msg).expect(\"Could not write to stdout\");\n    process::exit(code)\n}\n\n}",
    "title": "File size",
    "url": "http://rosettacode.org/wiki/File_size"
  },
  {
    "local_code": "fn main() {\n    println!(\"new vec filtered: \");\n    let nums: Vec<i32> = (1..20).collect();\n    let evens: Vec<i32> = nums.iter().cloned().filter(|x| x % 2 == 0).collect();\n    println!(\"{:?}\", evens);\n\n    // Filter an already existing vector\n    println!(\"original vec filtered: \");\n    let mut nums: Vec<i32> = (1..20).collect();\n    nums.retain(|x| x % 2 == 0);\n    println!(\"{:?}\", nums);\n}\n",
    "path": "tasks/filter",
    "remote_code": "fn main() {\n    println!(\"new vec filtered: \");\n    let nums: Vec<i32> = (1..20).collect();\n    let evens: Vec<i32> = nums.iter().cloned().filter(|x| x % 2 == 0).collect();\n    println!(\"{:?}\", evens);\n\n    // Filter an already existing vector\n    println!(\"original vec filtered: \");\n    let mut nums: Vec<i32> = (1..20).collect();\n    nums.retain(|x| x % 2 == 0);\n    println!(\"{:?}\", nums);\n}",
    "title": "Filter",
    "url": "http://rosettacode.org/wiki/Filter"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Find common directory path",
    "url": "http://rosettacode.org/wiki/Find_common_directory_path"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Find largest left truncatable prime in a given base",
    "url": "http://rosettacode.org/wiki/Find_largest_left_truncatable_prime_in_a_given_base"
  },
  {
    "local_code": "#[allow(unconditional_recursion)]\n\nfn recursion(n: i32) {\n    println!(\"deep: {}\", n);\n    recursion(n + 1);\n}\n\nfn main() {\n    recursion(0);\n}\n",
    "path": "tasks/find-limit-of-recursion",
    "remote_code": "fn recurse(n: i32) {\n    println!(\"depth: {}\", n);\n    recurse(n + 1)\n}\n\nfn main() {\n    recurse(0);\n}",
    "title": "Find limit of recursion",
    "url": "http://rosettacode.org/wiki/Find_limit_of_recursion"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Find palindromic numbers in both binary and ternary bases",
    "url": "http://rosettacode.org/wiki/Find_palindromic_numbers_in_both_binary_and_ternary_bases"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Find the intersection of two lines",
    "url": "http://rosettacode.org/wiki/Find_the_intersection_of_two_lines"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Find the last Sunday of each month",
    "url": "http://rosettacode.org/wiki/Find_the_last_Sunday_of_each_month"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Find the missing permutation",
    "url": "http://rosettacode.org/wiki/Find_the_missing_permutation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "First class environments",
    "url": "http://rosettacode.org/wiki/First_class_environments"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "First perfect square in base N with N unique digits",
    "url": "http://rosettacode.org/wiki/First_perfect_square_in_base_N_with_N_unique_digits"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#![feature(conservative_impl_trait)]\nfn main() {\n    let cube      = |x: f64| x.powi(3);\n    let cube_root = |x: f64| x.powf(1.0 / 3.0);\n\n    let flist  : [&Fn(f64) -> f64; 3] = [&cube     , &f64::sin , &f64::cos ];\n    let invlist: [&Fn(f64) -> f64; 3] = [&cube_root, &f64::asin, &f64::acos];\n\n    let result = flist.iter()\n                      .zip(&invlist)\n                      .map(|(f,i)| compose(f,i)(0.5))\n                      .collect::<Vec<_>>();\n\n    println!(\"{:?}\", result);\n\n}\n\nfn compose<'a, F, G, T, U, V>(f: F, g: G) -> impl 'a + Fn(T) -> V\n    where F: 'a + Fn(T) -> U,\n          G: 'a + Fn(U) -> V,\n{\n    move |x| g(f(x))\n\n}",
    "title": "First-class functions",
    "url": "http://rosettacode.org/wiki/First-class_functions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#![feature(conservative_impl_trait)]\nfn main() {\n    let (x, xi) = (2.0, 0.5);\n    let (y, yi) = (4.0, 0.25);\n    let z = x + y;\n    let zi = 1.0/z;\n\n    let numlist = [x,y,z];\n    let invlist = [xi,yi,zi];\n\n    let result = numlist.iter()\n                        .zip(&invlist)\n                        .map(|(x,y)| multiplier(*x,*y)(0.5))\n                        .collect::<Vec<_>>();\n    println!(\"{:?}\", result);\n}\n\nfn multiplier(x: f64, y: f64) -> impl Fn(f64) -> f64 {\n    move |m| x*y*m\n}\n",
    "title": "First-class functions/Use numbers analogously",
    "url": "http://rosettacode.org/wiki/First-class_functions/Use_numbers_analogously"
  },
  {
    "local_code": "extern crate chrono;\nuse chrono::prelude::*;\n\n/// Months with 31 days\nconst LONGMONTHS: [u32; 7] = [1, 3, 5, 7, 8, 10, 12];\n\n/// Get all the tuples (year, month) in wich there is five Fridays, five Saturdays and five Sundays\n/// between the years start and end (inclusive).\nfn five_weekends(start: i32, end: i32) -> Vec<(i32, u32)> {\n    let mut out = vec![];\n\n    for year in start..=end {\n        for month in LONGMONTHS.iter() {\n            // Five weekends if a 31-days month starts with a Friday.\n            if Local.ymd(year, *month, 1).weekday() == Weekday::Fri {\n                out.push((year, *month));\n            }\n        }\n    }\n\n    out\n}\n\nfn main() {\n    let out = five_weekends(1900, 2100);\n\n    let len = out.len();\n    println!(\n        \"There are {} months of which the first and last five are:\",\n        len\n    );\n    for (y, m) in &out[..5] {\n        println!(\"\\t{} / {}\", y, m);\n    }\n    println!(\"...\");\n    for (y, m) in &out[(len - 5..)] {\n        println!(\"\\t{} / {}\", y, m);\n    }\n}\n\n#[test]\nfn test() {\n    let out = five_weekends(1900, 2100);\n    assert_eq!(out.len(), 201);\n}\n",
    "path": "tasks/five-weekends",
    "remote_code": null,
    "title": "Five weekends",
    "url": "http://rosettacode.org/wiki/Five_weekends"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Fixed length records",
    "url": "http://rosettacode.org/wiki/Fixed_length_records"
  },
  {
    "local_code": "// Using conditional expressions,\n// checking 15 divisibility avoided so negligibly faster\nfn fb_one() {\n    let mut f: bool;\n    for x in 1..101 {\n        f = false;\n        if x % 3 == 0 {\n            print!(\"Fizz\");\n            f = true;\n        }\n        if x % 5 == 0 {\n            print!(\"Buzz\");\n            f = true;\n        }\n        if f {\n            println!();\n        } else {\n            println!(\"{}\", x)\n        }\n    }\n}\n\n// Rust tuples come in handy, as does matching\nfn fb_two() {\n    for i in 1..101 {\n        match (i % 3 == 0, i % 5 == 0) {\n            (true, true) => println!(\"FizzBuzz\"),\n            (true, false) => println!(\"Fizz\"),\n            (false, true) => println!(\"Buzz\"),\n            (false, false) => println!(\"{}\", i),\n        }\n    }\n}\n\nfn main() {\n    fb_one();\n    fb_two();\n}\n",
    "path": "tasks/fizzbuzz",
    "remote_code": "use std::borrow::Cow; // Allows us to avoid unnecessary allocations\nfn main() {\n    (1..101).map(|n| match (n % 3, n % 5) {\n        (0, 0) => \"FizzBuzz\".into(),\n        (0, _) => \"Fizz\".into(),\n        (_, 0) => \"Buzz\".into(),\n        _ => Cow::from(n.to_string())\n    }).for_each(|n| println!(\"{}\", n));\n}\n",
    "title": "FizzBuzz",
    "url": "http://rosettacode.org/wiki/FizzBuzz"
  },
  {
    "local_code": "#![feature(box_syntax)]\n\nuse Tree::{Leaf, Node};\n\n#[derive(Debug)]\nenum Tree<T> {\n    Node(Vec<Tree<T>>),\n    Leaf(T),\n}\n\nfn flatten<T>(tree: Tree<T>) -> Vec<T> {\n    match tree {\n        Leaf(val) => vec![val],\n        Node(vec) => vec\n            .into_iter()\n            .flat_map(|t| flatten(t).into_iter())\n            .collect(),\n    }\n}\n\nfn main() {\n    // [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\n    let list: Tree<i32> = Node(vec![\n        Node(vec![Leaf(1)]),\n        Leaf(2),\n        Node(vec![Node(vec![Leaf(3), Leaf(4)]), Leaf(5)]),\n        Node(vec![Node(vec![Node(vec![])])]),\n        Node(vec![Node(vec![Node(vec![Leaf(6)])])]),\n        Leaf(7),\n        Leaf(8),\n        Node(vec![]),\n    ]);\n\n    println!(\"{:?}\", list);\n\n    let flattened = flatten(list);\n\n    println!(\"{:?}\", flattened);\n}\n\n#[test]\nfn rosetta_flatten_test() {\n    // [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]\n    let list: Tree<i32> = Node(vec![\n        Node(vec![Leaf(1)]),\n        Leaf(2),\n        Node(vec![Node(vec![Leaf(3), Leaf(4)]), Leaf(5)]),\n        Node(vec![Node(vec![Node(vec![])])]),\n        Node(vec![Node(vec![Node(vec![Leaf(6)])])]),\n        Leaf(7),\n        Leaf(8),\n        Node(vec![]),\n    ]);\n\n    println!(\"{:?}\", list);\n\n    let flattened = flatten(list);\n\n    assert!(flattened == vec![1, 2, 3, 4, 5, 6, 7, 8])\n}\n",
    "path": "tasks/flatten-a-list",
    "remote_code": "use std::{vec, mem, iter};\n\nenum List<T> {\n    Node(Vec<List<T>>),\n    Leaf(T),\n}\n\nimpl<T> IntoIterator for List<T> {\n    type Item = List<T>;\n    type IntoIter = ListIter<T>;\n    fn into_iter(self) -> Self::IntoIter {\n        match self {\n            List::Node(vec) => ListIter::NodeIter(vec.into_iter()),\n            leaf @ List::Leaf(_) => ListIter::LeafIter(iter::once(leaf)),\n        }\n    }\n}\n\nenum ListIter<T> {\n    NodeIter(vec::IntoIter<List<T>>),\n    LeafIter(iter::Once<List<T>>),\n}\n\nimpl<T> ListIter<T> {\n    fn flatten(self) -> Flatten<T> {\n        Flatten {\n            stack: Vec::new(),\n            curr: self,\n        }\n    }\n}\n\nimpl<T> Iterator for ListIter<T> {\n    type Item = List<T>;\n    fn next(&mut self) -> Option<Self::Item> {\n        match *self {\n            ListIter::NodeIter(ref mut v_iter) => v_iter.next(),\n            ListIter::LeafIter(ref mut o_iter) => o_iter.next(),\n        }\n    }\n}\n\nstruct Flatten<T> {\n    stack: Vec<ListIter<T>>,\n    curr: ListIter<T>,\n}\n\n// Flatten code is a little messy since we are shoehorning recursion into an Iterator\nimpl<T> Iterator for Flatten<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<Self::Item> {\n        loop {\n            match self.curr.next() {\n                Some(list) => {\n                    match list {\n                        node @ List::Node(_) => {\n                            self.stack.push(node.into_iter());\n                            let len = self.stack.len();\n                            mem::swap(&mut self.stack[len - 1], &mut self.curr);\n                        }\n                        List::Leaf(item) => return Some(item),\n                    }\n                }\n                None => {\n                    if let Some(next) = self.stack.pop() {\n                        self.curr = next;\n                    } else {\n                        return None;\n                    }\n                }\n            }\n        }\n    }\n}\n\nuse List::*;\nfn main() {\n    let list = Node(vec![Node(vec![Leaf(1)]),\n                         Leaf(2),\n                         Node(vec![Node(vec![Leaf(3), Leaf(4)]), Leaf(5)]),\n                         Node(vec![Node(vec![Node(vec![])])]),\n                         Node(vec![Node(vec![Node(vec![Leaf(6)])])]),\n                         Leaf(7),\n                         Leaf(8),\n                         Node(vec![])]);\n\n    for elem in list.into_iter().flatten() {\n        print!(\"{} \", elem);\n    }\n    println!();\n\n}",
    "title": "Flatten a list",
    "url": "http://rosettacode.org/wiki/Flatten_a_list"
  },
  {
    "local_code": "// For random generation\nextern crate rand;\n\n// For fmt::Display\nuse std::fmt;\n// For I/O (stdin, stdout, etc)\nuse std::io::prelude::*;\n\nuse rand::Rng;\n\n/// A simple struct for a board\nstruct Board {\n    /// The cells of the board\n    cells: Vec<bool>,\n    /// The size of the board\n    size: usize,\n}\n\n// Functions for the Board struct\nimpl Board {\n    /// Generate a new, empty board, of size >= 1\n    ///\n    /// Returns a Board in the \"off\" state, where all cells are 0.\n    /// If a size of 0 is given, a Board of size 1 will be created instead.\n    /// A mutable board is required for using Board::fliprow and Board::flipcol functions.\n    ///\n    /// ```\n    /// let mut board: Board = Board::new(3);\n    /// ```\n    fn new(size: usize) -> Board {\n        // Ensure we make a board with a non-zero size\n        if size > 0 {\n            Board {\n                cells: vec![false; size * size],\n                size,\n            }\n        } else {\n            Board::new(1)\n        }\n    }\n\n    /// Flip the specified row\n    ///\n    /// Returns true if the row is within the size, false otherwise.\n    ///\n    /// ```\n    /// let mut board: Board = Board::new(3);\n    /// board.fliprow(1);\n    /// ```\n    fn fliprow(&mut self, row: usize) -> bool {\n        // Check constraints\n        if row > self.size {\n            return false;\n        }\n        // Starting position in the vector\n        let start = row * self.size;\n        // Loop through the vector row\n        for i in start..start + self.size {\n            self.cells[i] = !self.cells[i];\n        }\n        true\n    }\n\n    /// Flip the specified column\n    ///\n    /// Returns true if the column is within the size, false otherwise.\n    ///\n    /// ```\n    /// let mut board: Board = Board::new(3);\n    /// board.flipcol(0);\n    /// ```\n    fn flipcol(&mut self, col: usize) -> bool {\n        // Check constraints\n        if col > self.size {\n            return false;\n        }\n        // Loop through the vector column\n        for i in 0..self.size {\n            self.cells[col + i * self.size] = !self.cells[col + i * self.size];\n        }\n        true\n    }\n\n    /// Generate a random board\n    ///\n    /// Returns a Board in a random state.\n    /// If a size of 0 is given, a Board of size 1 will be created instead.\n    ///\n    /// ```\n    /// let target: Board = Board::random(3);\n    /// ```\n    fn random<R: Rng>(rng: &mut R, size: usize) -> Board {\n        // Ensure we make a board with a non-zero size\n        if size == 0 {\n            return Board::random(rng, 1);\n        }\n\n        // Make a vector of the board size with random bits\n        let cells = (0..size * size)\n            .map(|_| rng.gen::<bool>())\n            .collect::<Vec<_>>();\n        // Return the random board\n        Board { cells, size }\n    }\n}\n\nimpl PartialEq for Board {\n    fn eq(&self, rhs: &Board) -> bool {\n        self.cells == rhs.cells\n    }\n}\n\n// Implement the Display format, used with `print!(\"{}\", &board);`\nimpl fmt::Display for Board {\n    // Example output:\n    //   0 1 2\n    // 0 0 1 0\n    // 1 1 0 0\n    // 2 0 1 1\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        // Get the string width of the size of the board\n        let width = (self.size - 1).to_string().len();\n        // Write the initial spaces (upper left)\n        write!(f, \"{space: >0$}\", width, space = \" \")?;\n        // Write the column numbers\n        for i in 0..self.size {\n            write!(f, \" {offset:>0$}\", width, offset = i)?;\n        }\n        // Newline for rows\n        writeln!(f)?;\n        // Loop through the rows\n        for row in 0..self.size {\n            // Write the row number\n            write!(f, \"{row:>0$}\", width, row = row)?;\n            // Loop through the columns\n            for col in 0..self.size {\n                // Get the value of the cell as 1 or 0\n                let p = self.cells[row * self.size + col] as usize;\n                // Write the column value\n                write!(f, \" {col:>0$}\", width, col = p)?;\n            }\n            // Newline for next row\n            writeln!(f)?;\n        }\n        // Return Formatter result\n        Ok(())\n    }\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n\n    // The board size\n    let size: usize = 3;\n    // The target board\n    let target: Board = Board::random(&mut rng, size);\n    // The user board\n    let mut board: Board = Board::new(size);\n    // How many moves taken\n    let mut moves: u32 = 0;\n    // Loop until win or quit\n    'mainloop: loop {\n        // User input\n        let mut input: String;\n        // Write the boards\n        println!(\"Target:\\n{}\\nBoard:\\n{}\", &target, &board);\n        // User input loop\n        'userinput: loop {\n            // Prompt\n            print!(\"\\nFlip? [q|[r|c]#] \");\n            // Flush stdout to write the previous print, if we can't then exit\n            match std::io::stdout().flush() {\n                Ok(_) => {}\n                Err(e) => {\n                    println!(\"Error: cannot flush stdout: {}\", e);\n                    break 'mainloop;\n                }\n            };\n            // Reset input for each loop\n            input = String::new();\n            // Read user input\n            match std::io::stdin().read_line(&mut input) {\n                Ok(_) => {\n                    input = input.trim().to_string();\n                    // Get the first character\n                    let rc: char = match input.chars().nth(0) {\n                        Some(c) => c,\n                        None => {\n                            println!(\"Error: No input\");\n                            continue 'userinput;\n                        }\n                    };\n                    // Make sure input is r, c, or q\n                    if rc != 'r' && rc != 'c' && rc != 'q' {\n                        println!(\"Error: '{}': Must use 'r'ow or 'c'olumn or 'q'uit\", rc);\n                        continue 'userinput;\n                    }\n                    // If input is q, exit game\n                    if rc == 'q' {\n                        println!(\"Thanks for playing!\");\n                        break 'mainloop;\n                    }\n                    // If input is r or c, get the number after\n                    let n: usize = match input[1..].to_string().parse() {\n                        Ok(x) => {\n                            // If we're within bounds, return the parsed number\n                            if x < size {\n                                x\n                            } else {\n                                println!(\n                                    \"Error: Must specify a row or column within size({})\",\n                                    size\n                                );\n                                continue 'userinput;\n                            }\n                        }\n                        Err(_) => {\n                            println!(\n                                \"Error: '{}': Unable to parse row or column number\",\n                                input[1..].to_string()\n                            );\n                            continue 'userinput;\n                        }\n                    };\n                    // Flip the row or column specified\n                    match rc {\n                        'r' => board.fliprow(n),\n                        'c' => board.flipcol(n),\n                        _ => {\n                            // We want to panic here because should NEVER\n                            // have anything other than 'r' or 'c' here\n                            panic!(\"How did you end up here?\");\n                        }\n                    };\n                    // Increment moves\n                    moves += 1;\n                    println!(\"Moves taken: {}\", moves);\n                    break 'userinput;\n                }\n                Err(e) => {\n                    println!(\"Error reading input: {}\", e);\n                    break 'mainloop;\n                }\n            }\n        } // 'userinput\n        if board == target {\n            println!(\"You win!\");\n            break;\n        }\n    } // 'mainloop\n}\n",
    "path": "tasks/flipping-bits-game",
    "remote_code": null,
    "title": "Flipping bits game",
    "url": "http://rosettacode.org/wiki/Flipping_bits_game"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Flow-control structures",
    "url": "http://rosettacode.org/wiki/Flow-control_structures"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    floyds_triangle(5);\n    floyds_triangle(14);\n}\n\nfn floyds_triangle(n: u32) {\n    let mut triangle: Vec<Vec<String>> = Vec::new();\n    let mut current = 0;\n    for i in 1..=n {\n        let mut v = Vec::new();\n        for _ in 0..i {\n            current += 1;\n            v.push(current);\n        }\n        let row = v.iter().map(|x| x.to_string()).collect::<Vec<_>>();\n        triangle.push(row);\n    }\n\n    for row in &triangle {\n        let arranged_row: Vec<_> = row\n            .iter()\n            .enumerate()\n            .map(|(i, number)| {\n                let space_len = triangle.last().unwrap()[i].len() - number.len() + 1;\n                let spaces = \" \".repeat(space_len);\n                let mut padded_number = spaces;\n                padded_number.push_str(&number);\n                padded_number\n            })\n            .collect();\n        println!(\"{}\", arranged_row.join(\"\"))\n    }\n}\n\n",
    "title": "Floyd's triangle",
    "url": "http://rosettacode.org/wiki/Floyd's_triangle"
  },
  {
    "local_code": "use std::cmp;\nuse std::collections::BTreeMap;\nuse std::i32;\nuse std::ops::{Index, IndexMut};\n\n/// A 2-D array for storing data per-vertex pair. 1-indexed.\n#[derive(Debug, Default)]\nstruct VertexArray<T> {\n    dimension: usize,\n    data: Vec<T>,\n}\n\nimpl<T> VertexArray<T>\nwhere\n    T: Default + Copy + Clone,\n{\n    fn new(dimension: usize) -> Self {\n        Self {\n            dimension,\n            data: vec![T::default(); dimension * dimension],\n        }\n    }\n}\n\nimpl<T> Index<(usize, usize)> for VertexArray<T> {\n    type Output = T;\n\n    fn index(&self, (i, j): (usize, usize)) -> &Self::Output {\n        let (i, j) = (i - 1, j - 1);\n        &self.data[self.dimension * i + j]\n    }\n}\n\nimpl<T> IndexMut<(usize, usize)> for VertexArray<T> {\n    fn index_mut(&mut self, (i, j): (usize, usize)) -> &mut Self::Output {\n        let (i, j) = (i - 1, j - 1);\n        &mut self.data[self.dimension * i + j]\n    }\n}\n\n/// Returns a `BTreeMap` mapping pairs of vertices to a pair consisting of the weight of the\n/// shortest path between them, and a `Vec` containing the path itself.\nfn floyd_warshall(graph: &[((usize, usize), i32)]) -> BTreeMap<(usize, usize), (i32, Vec<usize>)> {\n    let num_vertices = graph\n        .iter()\n        .map(|&((u, v), _)| cmp::max(u, v))\n        .max()\n        .unwrap();\n\n    let mut dist = VertexArray::<Option<i32>>::new(num_vertices);\n    let mut next = VertexArray::<Option<usize>>::new(num_vertices);\n\n    for &((u, v), w) in graph {\n        dist[(u, v)] = Some(w);\n        next[(u, v)] = Some(v);\n    }\n\n    for k in 1..=num_vertices {\n        dist[(k, k)] = Some(0);\n    }\n\n    for k in 1..=num_vertices {\n        for i in 1..=num_vertices {\n            for j in 1..=num_vertices {\n                if let (Some(w1), Some(w2)) = (dist[(i, k)], dist[(k, j)]) {\n                    if dist[(i, j)].is_none() || dist[(i, j)].unwrap() > w1 + w2 {\n                        dist[(i, j)] = Some(w1 + w2);\n                        next[(i, j)] = next[(i, k)];\n                    }\n                }\n            }\n        }\n    }\n\n    let mut pairs = BTreeMap::new();\n\n    for i in 1..=num_vertices {\n        for j in 1..=num_vertices {\n            if i == j {\n                continue;\n            }\n\n            let distance = dist[(i, j)].unwrap();\n            let path = path(&next, (i, j));\n            pairs.insert((i, j), (distance, path));\n        }\n    }\n\n    pairs\n}\n\nfn path(next: &VertexArray<Option<usize>>, (mut u, v): (usize, usize)) -> Vec<usize> {\n    let mut path = vec![u];\n\n    while u != v && next[(u, v)].is_some() {\n        u = next[(u, v)].unwrap();\n        path.push(u);\n    }\n\n    path\n}\n\nfn main() {\n    let weights = vec![\n        ((1, 3), -2),\n        ((2, 1), 4),\n        ((2, 3), 3),\n        ((3, 4), 2),\n        ((4, 2), -1),\n    ];\n\n    println!(\"{:<7} {:<7} {}\", \"pair\", \"dist\", \"path\");\n    let pairs = floyd_warshall(&weights);\n    for (pair, &(distance, ref path)) in &pairs {\n        println!(\n            \"{:<7} {:<7} {:?}\",\n            format!(\"{} -> {}\", pair.0, pair.1),\n            format!(\"{:>4}\", distance),\n            path\n        );\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::collections::BTreeMap;\n\n    #[test]\n    fn floyd_warshall() {\n        let weights = vec![\n            ((1, 3), -2),\n            ((2, 1), 4),\n            ((2, 3), 3),\n            ((3, 4), 2),\n            ((4, 2), -1),\n        ];\n\n        let mut expected = BTreeMap::new();\n        expected.insert((1, 2), (-1, vec![1, 3, 4, 2]));\n        expected.insert((1, 3), (-2, vec![1, 3]));\n        expected.insert((1, 4), (0, vec![1, 3, 4]));\n        expected.insert((2, 1), (4, vec![2, 1]));\n        expected.insert((2, 3), (2, vec![2, 1, 3]));\n        expected.insert((2, 4), (4, vec![2, 1, 3, 4]));\n        expected.insert((3, 1), (5, vec![3, 4, 2, 1]));\n        expected.insert((3, 2), (1, vec![3, 4, 2]));\n        expected.insert((3, 4), (2, vec![3, 4]));\n        expected.insert((4, 1), (3, vec![4, 2, 1]));\n        expected.insert((4, 2), (-1, vec![4, 2]));\n        expected.insert((4, 3), (1, vec![4, 2, 1, 3]));\n\n        assert_eq!(expected, super::floyd_warshall(&weights));\n    }\n}\n",
    "path": "tasks/floyd-warshall-algorithm",
    "remote_code": null,
    "title": "Floyd-Warshall algorithm",
    "url": "http://rosettacode.org/wiki/Floyd-Warshall_algorithm"
  },
  {
    "local_code": "extern crate ansi_term;\nextern crate rand;\n\n#[derive(Copy, Clone, PartialEq)]\nenum Tile {\n    Empty,\n    Tree,\n    Burning,\n    Heating,\n}\n\nimpl fmt::Display for Tile {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let output = match *self {\n            Empty => Black.paint(\" \"),\n            Tree => Green.bold().paint(\"T\"),\n            Burning => Red.bold().paint(\"B\"),\n            Heating => Yellow.bold().paint(\"T\"),\n        };\n        write!(f, \"{}\", output)\n    }\n}\n\nconst NEW_TREE_PROB: f64 = 0.01;\nconst INITIAL_TREE_PROB: f64 = 0.5;\nconst FIRE_PROB: f64 = 0.001;\n\nconst FOREST_WIDTH: usize = 60;\nconst FOREST_HEIGHT: usize = 30;\n\nconst SLEEP_MILLIS: u64 = 25;\n\nuse std::fmt;\nuse std::io::prelude::*;\nuse std::io::{stdout, BufWriter, StdoutLock};\nuse std::process::Command;\nuse std::time::Duration;\n\nuse ansi_term::Colour::*;\nuse rand::{thread_rng, Rng};\n\nuse Tile::{Burning, Empty, Heating, Tree};\n\nfn main() {\n    let sleep_duration = Duration::from_millis(SLEEP_MILLIS);\n    let mut forest = [[Tile::Empty; FOREST_WIDTH]; FOREST_HEIGHT];\n\n    prepopulate_forest(&mut forest);\n    print_forest(forest, 0);\n\n    std::thread::sleep(sleep_duration);\n\n    for generation in 1.. {\n        for row in &mut forest {\n            for tile in row.iter_mut() {\n                update_tile(tile);\n            }\n        }\n\n        for y in 0..FOREST_HEIGHT {\n            for x in 0..FOREST_WIDTH {\n                if forest[y][x] == Burning {\n                    heat_neighbors(&mut forest, y, x);\n                }\n            }\n        }\n\n        print_forest(forest, generation);\n\n        std::thread::sleep(sleep_duration);\n    }\n}\n\nfn prepopulate_forest(forest: &mut [[Tile; FOREST_WIDTH]; FOREST_HEIGHT]) {\n    let mut rng = thread_rng();\n\n    for row in forest.iter_mut() {\n        for tile in row.iter_mut() {\n            *tile = if rng.gen_bool(INITIAL_TREE_PROB) {\n                Tree\n            } else {\n                Empty\n            };\n        }\n    }\n}\n\nfn update_tile(tile: &mut Tile) {\n    let mut rng = thread_rng();\n    *tile = match *tile {\n        Empty => {\n            if rng.gen_bool(NEW_TREE_PROB) {\n                Tree\n            } else {\n                Empty\n            }\n        }\n        Tree => {\n            if rng.gen_bool(FIRE_PROB) {\n                Burning\n            } else {\n                Tree\n            }\n        }\n        Burning => Empty,\n        Heating => Burning,\n    }\n}\n\nfn heat_neighbors(forest: &mut [[Tile; FOREST_WIDTH]; FOREST_HEIGHT], y: usize, x: usize) {\n    let neighbors = [\n        (-1, -1),\n        (-1, 0),\n        (-1, 1),\n        (0, -1),\n        (0, 1),\n        (1, -1),\n        (1, 0),\n        (1, 1),\n    ];\n\n    for (nx, ny) in neighbors\n        .iter()\n        .map(|&(x_off, y_off)| (x as i8 + x_off, (y as i8 + y_off)))\n        .filter(|&(nx, ny)| nx > 0 && ny > 0)\n        .map(|(nx, ny)| (nx as usize, (ny as usize)))\n    {\n        if let Some(tile) = forest.get_mut(ny).and_then(|r| r.get_mut(nx)) {\n            if *tile == Tree {\n                *tile = Heating;\n            }\n        }\n    }\n}\n\nfn print_forest(forest: [[Tile; FOREST_WIDTH]; FOREST_HEIGHT], generation: usize) {\n    let stdout = stdout();\n    let mut writer = BufWriter::new(stdout.lock());\n    clear_screen(&mut writer);\n    writeln!(writer, \"Generation: {}\", generation + 1).unwrap();\n    for row in &forest {\n        for tree in row.iter() {\n            write!(writer, \"{}\", tree).unwrap();\n        }\n        writeln!(writer).unwrap();\n    }\n}\n\nfn clear_screen(writer: &mut BufWriter<StdoutLock>) {\n    let output = Command::new(\"clear\").output().unwrap();\n    write!(writer, \"{}\", String::from_utf8_lossy(&output.stdout)).unwrap();\n}\n",
    "path": "tasks/forest-fire",
    "remote_code": "extern crate rand;\nextern crate ansi_term;\n\n#[derive(Copy, Clone, PartialEq)]\nenum Tile {\n    Empty,\n    Tree,\n    Burning,\n    Heating,\n}\n\nimpl fmt::Display for Tile {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let output = match *self {\n            Empty => Black.paint(\" \"),\n            Tree => Green.bold().paint(\"T\"),\n            Burning => Red.bold().paint(\"B\"),\n            Heating => Yellow.bold().paint(\"T\"),\n        };\n        write!(f, \"{}\", output)\n    }\n}\n\n// This has been added to the nightly rust build as of March 24, 2016\n// Remove when in stable branch!\ntrait Contains<T> {\n    fn contains(&self, T) -> bool;\n}\n\nimpl<T: PartialOrd> Contains<T> for std::ops::Range<T> {\n    fn contains(&self, elt: T) -> bool {\n        self.start <= elt && elt < self.end\n    }\n}\n\nconst NEW_TREE_PROB: f32 = 0.01;\nconst INITIAL_TREE_PROB: f32 = 0.5;\nconst FIRE_PROB: f32 = 0.001;\n\nconst FOREST_WIDTH: usize = 60;\nconst FOREST_HEIGHT: usize = 30;\n\nconst SLEEP_MILLIS: u64 = 25;\n\nuse std::fmt;\nuse std::io;\nuse std::io::prelude::*;\nuse std::io::BufWriter;\nuse std::io::Stdout;\nuse std::process::Command;\nuse std::time::Duration;\nuse rand::Rng;\nuse ansi_term::Colour::*;\n\nuse Tile::{Empty, Tree, Burning, Heating};\n\nfn main() {\n    let sleep_duration = Duration::from_millis(SLEEP_MILLIS);\n    let mut forest = [[Tile::Empty; FOREST_WIDTH]; FOREST_HEIGHT];\n\n    prepopulate_forest(&mut forest);\n    print_forest(forest, 0);\n\n    std::thread::sleep(sleep_duration);\n\n    for generation in 1.. {\n\n        for row in forest.iter_mut() {\n            for tile in row.iter_mut() {\n                update_tile(tile);\n            }\n        }\n\n        for y in 0..FOREST_HEIGHT {\n            for x in 0..FOREST_WIDTH {\n                if forest[y][x] == Burning {\n                    heat_neighbors(&mut forest, y, x);\n                }\n            }\n        }\n\n        print_forest(forest, generation);\n\n        std::thread::sleep(sleep_duration);\n    }\n}\n\nfn prepopulate_forest(forest: &mut [[Tile; FOREST_WIDTH]; FOREST_HEIGHT]) {\n    for row in forest.iter_mut() {\n        for tile in row.iter_mut() {\n            *tile = if prob_check(INITIAL_TREE_PROB) {\n                Tree\n            } else {\n                Empty\n            };\n        }\n    }\n}\n\nfn update_tile(tile: &mut Tile) {\n    *tile = match *tile {\n        Empty => {\n            if prob_check(NEW_TREE_PROB) == true {\n                Tree\n            } else {\n                Empty\n            }\n        }\n        Tree => {\n            if prob_check(FIRE_PROB) == true {\n                Burning\n            } else {\n                Tree\n            }\n        }\n        Burning => Empty,\n        Heating => Burning,\n    }\n}\n\nfn heat_neighbors(forest: &mut [[Tile; FOREST_WIDTH]; FOREST_HEIGHT], y: usize, x: usize) {\n    let neighbors = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)];\n\n    for &(xoff, yoff) in neighbors.iter() {\n        let nx: i32 = (x as i32) + xoff;\n        let ny: i32 = (y as i32) + yoff;\n        if (0..FOREST_WIDTH as i32).contains(nx) && (0..FOREST_HEIGHT as i32).contains(ny) &&\n           forest[ny as usize][nx as usize] == Tree {\n            forest[ny as usize][nx as usize] = Heating\n        }\n    }\n}\n\nfn prob_check(chance: f32) -> bool {\n    let roll = rand::thread_rng().gen::<f32>();\n    if chance - roll > 0.0 {\n        true\n    } else {\n        false\n    }\n}\n\nfn print_forest(forest: [[Tile; FOREST_WIDTH]; FOREST_HEIGHT], generation: u32) {\n    let mut writer = BufWriter::new(io::stdout());\n    clear_screen(&mut writer);\n    writeln!(writer, \"Generation: {}\", generation + 1).unwrap();\n    for row in forest.iter() {\n        for tree in row.iter() {\n            write!(writer, \"{}\", tree).unwrap();\n        }\n        writer.write(b\"\\n\").unwrap();\n    }\n}\n\nfn clear_screen(writer: &mut BufWriter<Stdout>) {\n    let output = Command::new(\"clear\").output().unwrap();\n    write!(writer, \"{}\", String::from_utf8_lossy(&output.stdout)).unwrap();\n}\n",
    "title": "Forest fire",
    "url": "http://rosettacode.org/wiki/Forest_fire"
  },
  {
    "local_code": "use std::process::Command;\n\nfn main() {\n    println!(\"parent\");\n\n    let _ = Command::new(\"echo\").arg(\"child\").spawn().unwrap();\n}\n",
    "path": "tasks/fork",
    "remote_code": "use nix::unistd::{fork, ForkResult};\nuse std::process::id;\n\nfn main() {\n    match fork() {\n        Ok(ForkResult::Parent { child, .. }) => {\n            println!(\n                \"This is the original process(pid: {}). New child has pid: {}\",\n                id(),\n                child\n            );\n        }\n        Ok(ForkResult::Child) => println!(\"This is the new process(pid: {}).\", id()),\n        Err(_) => println!(\"Something went wrong.\"),\n    }\n}\n",
    "title": "Fork",
    "url": "http://rosettacode.org/wiki/Fork"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Formal power series",
    "url": "http://rosettacode.org/wiki/Formal_power_series"
  },
  {
    "local_code": "fn main() {\n    let x = 7.125;\n\n    println!(\"{:9}\", x);\n    println!(\"{:09}\", x);\n    println!(\"{:9}\", -x);\n    println!(\"{:09}\", -x);\n}\n",
    "path": "tasks/formatted-numeric-output",
    "remote_code": "\nfn main() {\n    let x = 7.125;\n\n    println!(\"{:9}\", x);\n    println!(\"{:09}\", x);\n    println!(\"{:9}\", -x);\n    println!(\"{:09}\", -x);\n}\n",
    "title": "Formatted numeric output",
    "url": "http://rosettacode.org/wiki/Formatted_numeric_output"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Forward difference",
    "url": "http://rosettacode.org/wiki/Forward_difference"
  },
  {
    "local_code": "use std::fmt;\nuse std::ops::Deref;\n\n// primitive gates\nfn not(a: bool) -> bool {\n    !a\n}\nfn or(a: bool, b: bool) -> bool {\n    a || b\n}\nfn and(a: bool, b: bool) -> bool {\n    a && b\n}\n\n/// xor gate [2x not, 2x and, 1x or]\n/// (A & !B) | (B & !A)\nfn xor(a: bool, b: bool) -> bool {\n    or(and(a, not(b)), and(b, not(a)))\n}\n\n/// half adder [1x xor, 1x and]\n/// S = A ^ B, C = A & B\nfn half_adder(a: bool, b: bool) -> (bool, bool) {\n    (xor(a, b), and(a, b))\n}\n\n/// full adder [2x half adder, 1x or]\n/// t = (C0 + A), t2 = t.S + B\n/// S = t2.S, C = t.C | t2.C\nfn full_adder(a: bool, b: bool, carry: bool) -> (bool, bool) {\n    let (s0, c0) = half_adder(carry, a);\n    let (s1, c1) = half_adder(s0, b);\n\n    (s1, or(c0, c1))\n}\n\n#[derive(Copy, Clone)]\nstruct Nibble([bool; 4]);\nimpl Nibble {\n    fn new(arr: [u8; 4]) -> Nibble {\n        Nibble([arr[0] != 0, arr[1] != 0, arr[2] != 0, arr[3] != 0])\n    }\n\n    fn from_u8(n: u8) -> Nibble {\n        Nibble::new([n & 8, n & 4, n & 2, n & 1])\n    }\n\n    fn to_u8(&self, carry: bool) -> u8 {\n        match u8::from_str_radix(&(format!(\"{}\", self))[..], 2) {\n            Ok(n) if carry => n + 16,\n            Ok(n) => n,\n            Err(_) => unreachable!(),\n        }\n    }\n}\n\nimpl fmt::Display for Nibble {\n    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n        write!(\n            f,\n            \"{}\",\n            self.iter()\n                .map(|&b| if b { '1' } else { '0' })\n                .collect::<String>()\n        )\n    }\n}\n\n/// We implement `Deref` so we can index the Nibble easily\nimpl<'a> Deref for Nibble {\n    type Target = [bool; 4];\n\n    fn deref(&self) -> &[bool; 4] {\n        let Nibble(ref inner) = *self;\n        inner\n    }\n}\n\n/// 4bit adder [4x full adder]\n/// calculate each bit of the sum, propagate the carry\nfn four_bit_adder(a: Nibble, b: Nibble, carry: bool) -> (Nibble, bool) {\n    let (s0, carry) = full_adder(a[3], b[3], carry);\n    let (s1, carry) = full_adder(a[2], b[2], carry);\n    let (s2, carry) = full_adder(a[1], b[1], carry);\n    let (s3, carry) = full_adder(a[0], b[0], carry);\n\n    (Nibble([s3, s2, s1, s0]), carry)\n}\n\nfn main() {\n    let nib_a = Nibble::new([1u8, 0, 1, 1]);\n    let a = nib_a.to_u8(false);\n    let b = 6;\n    let nib_b = Nibble::from_u8(b);\n    let (result, carry) = four_bit_adder(nib_a, nib_b, false);\n    println!(\n        \"{} + {} = {} | {} + {} = {} | overflow: {}\",\n        a,\n        b,\n        result.to_u8(carry),\n        nib_a,\n        nib_b,\n        result,\n        carry\n    )\n}\n\n#[test]\nfn test_not() {\n    assert_eq!(true, not(false));\n    assert_eq!(false, not(true));\n}\n\n#[test]\nfn test_or() {\n    assert_eq!(false, or(false, false));\n    assert_eq!(true, or(true, false));\n    assert_eq!(true, or(false, true));\n    assert_eq!(true, or(true, true));\n}\n\n#[test]\nfn test_and() {\n    assert_eq!(false, and(false, false));\n    assert_eq!(false, and(false, true));\n    assert_eq!(false, and(true, false));\n    assert_eq!(true, and(true, true));\n}\n\n#[test]\nfn test_xor() {\n    assert_eq!(false, xor(false, false));\n    assert_eq!(true, xor(false, true));\n    assert_eq!(true, xor(true, false));\n    assert_eq!(false, xor(true, true));\n}\n\n#[test]\nfn test_full_add() {\n    assert_eq!((false, false), full_adder(false, false, false));\n    assert_eq!((true, false), full_adder(false, false, true));\n    assert_eq!((true, false), full_adder(false, true, false));\n    assert_eq!((true, false), full_adder(true, false, false));\n    assert_eq!((false, true), full_adder(false, true, true));\n    assert_eq!((false, true), full_adder(true, false, true));\n    assert_eq!((false, true), full_adder(true, true, false));\n    assert_eq!((true, true), full_adder(true, true, true));\n}\n\n#[test]\nfn test_four_bit_adder() {\n    for (a, b) in (0..std::u8::MAX).map(|n| (n >> 4, n & 15)) {\n        let nib_a = Nibble::from_u8(a);\n        let nib_b = Nibble::from_u8(b);\n\n        let (result, carry) = four_bit_adder(nib_a, nib_b, false);\n        assert_eq!(a + b, result.to_u8(carry));\n        let (result, carry) = four_bit_adder(nib_a, nib_b, true);\n        assert_eq!(a + b + 1, result.to_u8(carry));\n    }\n}\n",
    "path": "tasks/four-bit-adder",
    "remote_code": "\n// half adder with XOR and AND\n// SUM = A XOR B\n// CARRY = A.B\nfn half_adder(a: usize, b: usize) -> (usize, usize) {\n    return (a ^ b, a & b);\n}\n\n// full adder as a combination of half adders\n// SUM = A XOR B XOR C\n// CARRY = A.B + B.C + C.A\nfn full_adder(a: usize, b: usize, c_in: usize) -> (usize, usize) {\n    let (s0, c0) = half_adder(a, b);\n    let (s1, c1) = half_adder(s0, c_in);\n    return (s1, c0 | c1);\n}\n\n// A = (A3, A2, A1, A0)\n// B = (B3, B2, B1, B0)\n// S = (S3, S2, S1, S0)\nfn four_bit_adder (\n    a: (usize, usize, usize, usize),\n    b: (usize, usize, usize, usize)\n)\n    ->\n    // 4 bit output, carry is ignored\n    (usize, usize, usize, usize)\n{\n    // lets have a.0 refer to the rightmost element\n    let a = a.reverse();\n    let b = b.reverse();\n\n    // i would prefer a loop but that would abstract\n    // the \"connections of the constructive blocks\"\n    let (sum, carry) = half_adder(a.0, b.0);\n    let out0 = sum;\n    let (sum, carry) = full_adder(a.1, b.1, carry);\n    let out1 = sum;\n    let (sum, carry) = full_adder(a.2, b.2, carry);\n    let out2 = sum;\n    let (sum, _) = full_adder(a.3, b.3, carry);\n    let out3 = sum;\n    return (out3, out2, out1, out0);\n}\n\nfn main() {\n    let a: (usize, usize, usize, usize) = (0, 1, 1, 0);\n    let b: (usize, usize, usize, usize) = (0, 1, 1, 0);\n    assert_eq!(four_bit_adder(a, b), (1, 1, 0, 0));\n    // 0110 + 0110 = 1100\n    // 6 + 6 = 12\n}\n\n// misc. traits to make our life easier\ntrait Reverse<A, B, C, D> {\n    fn reverse(self) -> (D, C, B, A);\n}\n\n// reverse a generic tuple of arity 4\nimpl<A, B, C, D> Reverse<A, B, C, D> for (A, B, C, D) {\n    fn reverse(self) -> (D, C, B, A){\n        return (self.3, self.2, self.1, self.0)\n    }\n}\n\n",
    "title": "Four bit adder",
    "url": "http://rosettacode.org/wiki/Four_bit_adder"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Four is magic",
    "url": "http://rosettacode.org/wiki/Four_is_magic"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Four is the number of letters in the ...",
    "url": "http://rosettacode.org/wiki/Four_is_the_number_of_letters_in_the_..."
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Fractal tree",
    "url": "http://rosettacode.org/wiki/Fractal_tree"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Fraction reduction",
    "url": "http://rosettacode.org/wiki/Fraction_reduction"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Fractran",
    "url": "http://rosettacode.org/wiki/Fractran"
  },
  {
    "local_code": "fn main() {\n    use std::f32::consts;\n\n    // the two functions we will compose:\n    let f = |x: u32| x.to_string();\n    let g = |x: f32| x as u32;\n\n    // their composition\n    let comp = compose(f, g);\n\n    println!(\"{:?}\", (*comp)(consts::PI));\n}\n\nfn compose<'a, F, G, A, B, C>(f: F, g: G) -> Box<dyn Fn(A) -> C + 'a>\nwhere\n    G: Fn(A) -> B + 'a,\n    F: Fn(B) -> C + 'a,\n{\n    Box::new(move |a: A| f(g(a)))\n}\n\n#[test]\nfn test_compose() {\n    fn inc(x: usize) -> usize {\n        x + 1\n    }\n    fn mul(x: usize) -> usize {\n        x * 3\n    }\n\n    let comp = compose(inc, mul);\n    assert_eq!((*comp)(3), 10);\n}\n",
    "path": "tasks/function-composition",
    "remote_code": "fn compose<'a,F,G,T,U,V>(f: F, g: G) -> Box<Fn(T) -> V + 'a>\n    where F: Fn(U) -> V + 'a,\n          G: Fn(T) -> U + 'a,\n{\n   Box::new(move |x| f(g(x)))\n}",
    "title": "Function composition",
    "url": "http://rosettacode.org/wiki/Function_composition"
  },
  {
    "local_code": "use std::ops::Mul;\n\n/// Function taking 2 ints, multply them and return the value\nfn multiply(x: i32, y: i32) -> i32 {\n    // In Rust a statement is a expression. An expression at the end of a\n    // function without semicolon is a return expression\n    x * y //equivalent \"return x * y;\"\n}\n\n/// generic version of multiply\nfn multiply_gen<T: Mul<Output = T>>(x: T, y: T) -> T {\n    x * y\n}\n\n#[test]\nfn test_multiply_gen() {\n    assert_eq!(multiply_gen(2i32, 2), 4);\n}\n\n#[test]\nfn test_multiply() {\n    assert_eq!(multiply(2i32, 2), 4);\n}\n\nfn main() {\n    println!(\"2 multiply 4 = {}\", multiply(2i32, 4));\n    println!(\"2.0 multiply 4.0 = {}\", multiply_gen(2.0f32, 4.0));\n    println!(\n        \"5.0 multiply 7.0 is {}\",\n        multiply_gen(5.0 as f32, 7.0 as f32)\n    );\n}\n",
    "path": "tasks/function-definition",
    "remote_code": "fn multiply(a: i32, b: i32) -> i32 {\n    a * b\n}",
    "title": "Function definition",
    "url": "http://rosettacode.org/wiki/Function_definition"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Function frequency",
    "url": "http://rosettacode.org/wiki/Function_frequency"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Function prototype",
    "url": "http://rosettacode.org/wiki/Function_prototype"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Functional coverage tree",
    "url": "http://rosettacode.org/wiki/Functional_coverage_tree"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Fusc sequence",
    "url": "http://rosettacode.org/wiki/Fusc_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "GUI component interaction",
    "url": "http://rosettacode.org/wiki/GUI_component_interaction"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "GUI enabling/disabling of controls",
    "url": "http://rosettacode.org/wiki/GUI_enabling/disabling_of_controls"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "GUI/Maximum window dimensions",
    "url": "http://rosettacode.org/wiki/GUI/Maximum_window_dimensions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Galton box animation",
    "url": "http://rosettacode.org/wiki/Galton_box_animation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Gamma function",
    "url": "http://rosettacode.org/wiki/Gamma_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Gapful numbers",
    "url": "http://rosettacode.org/wiki/Gapful_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n// using a Vec<f32> might be a better idea\n// for now, let us create a fixed size array\n// of size:\nconst SIZE: usize = 6;\n\npub fn eliminate(mut system: [[f32; SIZE+1]; SIZE]) -> Option<Vec<f32>> {\n    // produce the row reduced echelon form\n    //\n    // for every row...\n    for i in 0..SIZE-1 {\n        // for every column in that row...\n        for j in i..SIZE-1 {\n            if system[i][i] == 0f32 {\n                continue;\n            } else {\n                // reduce every element under that element to 0\n                let factor = system[j + 1][i] as f32 / system[i][i] as f32;\n                for k in i..SIZE+1 {\n                    // potential optimization: set every element to zero, instead of subtracting\n                    // i think subtraction helps showcase the process better\n                    system[j + 1][k] -= factor * system[i][k] as f32;\n                }\n            }\n        }\n    }\n\n    // produce gaussian eliminated array\n    //\n    // the process follows a similar pattern\n    // but this one reduces the upper triangular \n    // elements\n    for i in (1..SIZE).rev() {\n        if system[i][i] == 0f32 {\n            continue;\n        } else {\n            for j in (1..i+1).rev() {\n                let factor = system[j - 1][i] as f32 / system[i][i] as f32;\n                for k in (0..SIZE+1).rev() {\n                    system[j - 1][k] -= factor * system[i][k] as f32;\n                }\n            }\n        }\n    }\n\n    // produce solutions through back substitution\n    let mut solutions: Vec<f32> = vec![];\n    for i in 0..SIZE {\n        if system[i][i] == 0f32 {\n            return None;\n        }\n        else {\n            system[i][SIZE] /= system[i][i] as f32;\n            system[i][i] = 1f32;\n            println!(\"X{} = {}\", i + 1, system[i][SIZE]);\n            solutions.push(system[i][SIZE])\n        }\n    }\n    return Some(solutions);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    // sample run of the program\n    #[test]\n    fn eliminate_seven_by_six() {\n        let system: [[f32; SIZE +1]; SIZE] = [\n            [1.00 , 0.00 , 0.00 , 0.00  , 0.00  , 0.00   , -0.01 ] ,\n            [1.00 , 0.63 , 0.39 , 0.25  , 0.16  , 0.10   , 0.61  ] ,\n            [1.00 , 1.26 , 1.58 , 1.98  , 2.49  , 3.13   , 0.91  ] ,\n            [1.00 , 1.88 , 3.55 , 6.70  , 12.62 , 23.80  , 0.99  ] ,\n            [1.00 , 2.51 , 6.32 , 15.88 , 39.90 , 100.28 , 0.60  ] ,\n            [1.00 , 3.14 , 9.87 , 31.01 , 97.41 , 306.02 , 0.02  ]\n        ] ;\n        let solutions = eliminate(system).unwrap();\n        assert_eq!(6, solutions.len());\n        let assert_solns = vec![-0.01, 1.60278, -1.61320, 1.24549, -0.49098, 0.06576];\n        for (ans, key) in solutions.iter().zip(assert_solns.iter()) {\n            if (ans - key).abs() > 1E-4 { panic!(\"Test Failed!\") }\n        }\n    }\n}\n",
    "title": "Gaussian elimination",
    "url": "http://rosettacode.org/wiki/Gaussian_elimination"
  },
  {
    "local_code": "use std::io;\nuse std::io::BufRead;\n\nfn parse_entry(l: &str) -> (i32, String) {\n    let params: Vec<&str> = l.split(' ').collect();\n\n    let divisor = params[0].parse::<i32>().unwrap();\n    let word = params[1].to_string();\n    (divisor, word)\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|l| l.unwrap());\n\n    let l = lines.next().unwrap();\n    let high = l.parse::<i32>().unwrap();\n\n    let mut entries = Vec::new();\n    for l in lines {\n        if &l == \"\" {\n            break;\n        }\n        let entry = parse_entry(&l);\n        entries.push(entry);\n    }\n\n    for i in 1..(high + 1) {\n        let mut line = String::new();\n        for &(divisor, ref word) in &entries {\n            if i % divisor == 0 {\n                line = line + word;\n            }\n        }\n        if line == \"\" {\n            println!(\"{}\", i);\n        } else {\n            println!(\"{}\", line);\n        }\n    }\n}\n",
    "path": "tasks/general-fizzbuzz",
    "remote_code": "use std::io;\nuse std::io::BufRead;\n\nfn parse_entry(l: &str) -> (i32, String) {\n    let params: Vec<&str> = l.split(' ').collect();\n\n    let divisor = params[0].parse::<i32>().unwrap();\n    let word = params[1].to_string();\n    (divisor, word)\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|l| l.unwrap());\n\n    let l = lines.next().unwrap();\n    let high = l.parse::<i32>().unwrap();\n\n    let mut entries = Vec::new();\n    for l in lines {\n        if &l == \"\" { break }\n        let entry = parse_entry(&l);\n        entries.push(entry);\n    }\n\n    for i in 1..(high + 1) {\n        let mut line = String::new();\n        for &(divisor, ref word) in &entries {\n            if i % divisor == 0 {\n                line = line + &word;\n            }\n        }\n        if line == \"\" {\n            println!(\"{}\", i);\n        } else {\n            println!(\"{}\", line);\n        }\n    }\n}",
    "title": "General FizzBuzz",
    "url": "http://rosettacode.org/wiki/General_FizzBuzz"
  },
  {
    "local_code": "use std::collections::BTreeSet;\n\nstruct Chess960(BTreeSet<String>);\n\nimpl Chess960 {\n    fn invoke(&mut self, b: &str, e: &str) {\n        if e.len() <= 1 {\n            let s = b.to_string() + e;\n            if Chess960::is_valid(&s) {\n                self.0.insert(s);\n            }\n        } else {\n            for (i, c) in e.char_indices() {\n                let mut b = b.to_string();\n                b.push(c);\n                let mut e = e.to_string();\n                e.remove(i);\n                self.invoke(&b, &e);\n            }\n        }\n    }\n\n    fn is_valid(s: &str) -> bool {\n        let k = s.find('K').unwrap();\n        k > s.find('R').unwrap()\n            && k < s.rfind('R').unwrap()\n            && s.find('B').unwrap() % 2 != s.rfind('B').unwrap() % 2\n    }\n}\n\n// Program entry point.\nfn main() {\n    let mut chess960 = Chess960(BTreeSet::new());\n    chess960.invoke(\"\", \"KQRRNNBB\");\n\n    for (i, p) in chess960.0.iter().enumerate() {\n        println!(\"{}: {}\", i, p);\n    }\n}\n",
    "path": "tasks/generate-chess960-starting-position",
    "remote_code": "use std::collections::BTreeSet;\n\nstruct Chess960 ( BTreeSet<String> );\n\nimpl Chess960 {\n    fn invoke(&mut self, b: &str, e: &str) {\n        if e.len() <= 1 {\n            let s = b.to_string() + e;\n            if Chess960::is_valid(&s) { self.0.insert(s); }\n        } else {\n            for (i, c) in e.char_indices() {\n                let mut b = b.to_string();\n                b.push(c);\n                let mut e = e.to_string();\n                e.remove(i);\n                self.invoke(&b, &e);\n            }\n        }\n    }\n\n    fn is_valid(s: &str) -> bool {\n        let k = s.find('K').unwrap();\n        k > s.find('R').unwrap() && k < s.rfind('R').unwrap() && s.find('B').unwrap() % 2 != s.rfind('B').unwrap() % 2\n    }\n}\n\n// Program entry point.\nfn main() {\n    let mut chess960 = Chess960(BTreeSet::new());\n    chess960.invoke(\"\", \"KQRRNNBB\");\n\n    for (i, p) in chess960.0.iter().enumerate() {\n        println!(\"{}: {}\", i, p);\n    }\n}",
    "title": "Generate Chess960 starting position",
    "url": "http://rosettacode.org/wiki/Generate_Chess960_starting_position"
  },
  {
    "local_code": "fn lower_case_alphabet() -> Box<dyn Iterator<Item = char>> {\n    let ascii_iter = (0..26).map(|x| (x + b'a') as char);\n    Box::new(ascii_iter)\n}\n\nfn main() {\n    println!(\"{:?}\", lower_case_alphabet().collect::<Vec<_>>());\n}\n\n#[test]\nfn test_alphabet() {\n    let expected = vec![\n        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\n        's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n    ];\n    assert_eq!(expected, lower_case_alphabet().collect::<Vec<_>>());\n}\n",
    "path": "tasks/generate-lower-case-ascii-alphabet",
    "remote_code": "fn main() {\n    // An iterator over the lowercase alpha's\n    let ascii_iter = (0..26)\n        .map(|x| (x + b'a') as char);\n \n    println!(\"{:?}\", ascii_iter.collect::<Vec<char>>());\n}",
    "title": "Generate lower case ASCII alphabet",
    "url": "http://rosettacode.org/wiki/Generate_lower_case_ASCII_alphabet"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Generate random chess position",
    "url": "http://rosettacode.org/wiki/Generate_random_chess_position"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Generator/Exponential",
    "url": "http://rosettacode.org/wiki/Generator/Exponential"
  },
  {
    "local_code": "use std::mem::swap;\n\nfn main() {\n    println!(\"Same type:\");\n    let mut thing_one = \"The First String\";\n    let mut thing_two = \"The Second String\";\n    println!(\"Thing 1: {}, Thing 2: {}\", thing_one, thing_two);\n    swap(&mut thing_one, &mut thing_two);\n    println!(\"Thing 1: {}, Thing 2: {}\", thing_one, thing_two);\n}\n",
    "path": "tasks/generic-swap",
    "remote_code": "fn main() {\n    let mut a=\"Anna\".to_owned();\n    let mut b=\"Bob\".to_owned();\n    std::mem::swap(&mut a, &mut b);\n    println!(\"a={},b={}\",a,b);\n}",
    "title": "Generic swap",
    "url": "http://rosettacode.org/wiki/Generic_swap"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::process::Command;\nuse std::io::{Write, self};\n\nfn main() {\n    let output = Command::new(\"/bin/cat\")\n                            .arg(\"/etc/fstab\")\n                            .output()\n                            .expect(\"failed to execute process\");\n\n    io::stdout().write(&output.stdout);\n}",
    "title": "Get system command output",
    "url": "http://rosettacode.org/wiki/Get_system_command_output"
  },
  {
    "local_code": "//! Author: Rahul Sharma\n//! Github: <https://github.com/creativcoder>\n\nuse std::fs::File;\nuse std::fs::OpenOptions;\nuse std::io::BufRead;\nuse std::io::BufReader;\nuse std::io::BufWriter;\nuse std::io::Write;\n\nfn main() {\n    // opens file for writing replaced lines\n    let out_fd = OpenOptions::new()\n        .write(true)\n        .create(true)\n        .open(\"resources/output.txt\");\n\n    // defining a closure write_line\n    let write_line = |line: &str| match out_fd {\n        Ok(ref v) => {\n            let mut writer = BufWriter::new(v);\n            writer.write_all(line.as_bytes()).unwrap();\n        }\n        Err(ref e) => {\n            println!(\"Error:{}\", e);\n        }\n    };\n    // read input file\n    match File::open(\"resources/paragraph.txt\") {\n        Ok(handle) => {\n            let mut reader = BufReader::new(handle);\n            let mut line = String::new();\n            // read the first line\n            reader.read_line(&mut line).unwrap();\n            // loop until line end\n            while line.trim() != \"\" {\n                let mut replaced_line = line.trim().replace(\"Goodbye London!\", \"Hello New York!\");\n                replaced_line += \"\\n\";\n                write_line(&replaced_line[..]);\n                line.clear();\n                reader.read_line(&mut line).unwrap();\n            }\n        }\n        Err(e) => println!(\"Error:{}\", e),\n    }\n}\n",
    "path": "tasks/globally-replace-text-in-several-files",
    "remote_code": null,
    "title": "Globally replace text in several files",
    "url": "http://rosettacode.org/wiki/Globally_replace_text_in_several_files"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Go Fish",
    "url": "http://rosettacode.org/wiki/Go_Fish"
  },
  {
    "local_code": "/// Encode an usize\nfn gray_encode(integer: usize) -> usize {\n    (integer >> 1) ^ integer\n}\n\n/// Decode an usize\nfn gray_decode(integer: usize) -> usize {\n    match integer {\n        0 => 0,\n        _ => integer ^ gray_decode(integer >> 1),\n    }\n}\n\nfn main() {\n    for i in 0..32 {\n        println!(\n            \"{:2} {:0>5} {:0>5} {:2}\",\n            i,\n            i,\n            gray_encode(i),\n            gray_decode(i)\n        );\n    }\n}\n\n#[test]\nfn test_coherence() {\n    assert!((0..1000).all(|x| gray_decode(gray_encode(x)) == x));\n}\n",
    "path": "tasks/gray-code",
    "remote_code": "fn gray_encode(integer: u64) -> u64 {\n    (integer >> 1) ^ integer\n}\n\nfn gray_decode(integer: u64) -> u64 {\n    match integer {\n        0 => 0,\n        _ => integer ^ gray_decode(integer >> 1)\n    }\n}\n\nfn main() {\n    for i in 0..32 {\n        println!(\"{:2} {:0>5b} {:0>5b} {:2}\", i, i, gray_encode(i),\n            gray_decode(i));\n    }\n\n}",
    "title": "Gray code",
    "url": "http://rosettacode.org/wiki/Gray_code"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Grayscale image",
    "url": "http://rosettacode.org/wiki/Grayscale_image"
  },
  {
    "local_code": "//! This task demonstrates three possible implementation strategies.\n\nextern crate num;\n\nuse num::integer::gcd;\n\n/// Iterative Euclid algorithm\nfn iterative_euclid_gcd(mut m: i32, mut n: i32) -> i32 {\n    while m != 0 {\n        let old_m = m;\n        m = n % m;\n        n = old_m;\n    }\n    n.abs()\n}\n\n/// Recursive Euclid algorithm\nfn recursive_euclid_gcd(m: i32, n: i32) -> i32 {\n    if m == 0 {\n        n.abs()\n    } else {\n        recursive_euclid_gcd(n % m, m)\n    }\n}\n\nfn main() {\n    println!(\"gcd(399, -3999) = {}\", gcd(399, -3999));\n    println!(\"gcd(0, 3999) = {}\", iterative_euclid_gcd(0, 3999));\n    println!(\n        \"gcd(13 * 13, 13 * 29) = {}\",\n        recursive_euclid_gcd(13 * 13, 13 * 29)\n    );\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{iterative_euclid_gcd, recursive_euclid_gcd};\n\n    #[test]\n    fn iterative() {\n        assert_eq!(3, iterative_euclid_gcd(399, -3999));\n        assert_eq!(3999, iterative_euclid_gcd(0, 3999));\n        assert_eq!(13, iterative_euclid_gcd(13 * 13, 13 * 29));\n    }\n\n    #[test]\n    fn recursive() {\n        assert_eq!(3, recursive_euclid_gcd(399, -3999));\n        assert_eq!(3999, recursive_euclid_gcd(0, 3999));\n        assert_eq!(13, recursive_euclid_gcd(13 * 13, 13 * 29));\n    }\n}\n",
    "path": "tasks/greatest-common-divisor",
    "remote_code": "extern crate num;\nuse num::integer::gcd;",
    "title": "Greatest common divisor",
    "url": "http://rosettacode.org/wiki/Greatest_common_divisor"
  },
  {
    "local_code": "use std::fmt::Display;\n\nfn main() {\n    find_max(\"first\", &[1i32, 2, 3, 4, 5, 6, 7, 8, 9]);\n    find_max(\n        \"second\",\n        &[\n            123i32, 3543, 23, 432, 5, 2, 34, 234, 234, 2, 4, 234, 23, 4, 24, 25, 7, 658, 68,\n        ],\n    );\n    find_max(\"third\", &['a', 'b', 'c', 'd', 'e']);\n    find_max(\n        \"fourth\",\n        &[\"Bonjour\", \"Hola\", \"Hello\", \"Hallo\", \"Buongiorno\"],\n    );\n}\n\nfn find_max<T: Display + Ord>(count: &str, list: &[T]) {\n    let max = list.iter().max().unwrap();\n    println!(\"Max of the {} list: {}\", count, max);\n}\n",
    "path": "tasks/greatest-element-of-a-list",
    "remote_code": "fn main() {\n    let nums = [1,2,39,34,20];\n    println!(\"{:?}\", nums.iter().max());\n    println!(\"{}\", nums.iter().max().unwrap());\n}",
    "title": "Greatest element of a list",
    "url": "http://rosettacode.org/wiki/Greatest_element_of_a_list"
  },
  {
    "local_code": "use std::ops::Range;\n\nfn greatest_subsequential_sum(nums: &[i32]) -> (i32, Range<usize>) {\n    let mut max = 0;\n    let mut boundaries = 0..0;\n\n    for length in 0..nums.len() {\n        for start in 0..nums.len() - length {\n            let sum = (&nums[start..start + length]).iter().sum();\n            if sum > max {\n                max = sum;\n                boundaries = start..start + length;\n            }\n        }\n    }\n\n    (max, boundaries)\n}\n\nfn main() {\n    let nums = [1, 2, 39, 34, 20, -20, -16, 35, 0];\n\n    let (max, boundaries) = greatest_subsequential_sum(&nums);\n\n    println!(\"Max subsequence sum: {} for {:?}\", max, &nums[boundaries]);\n}\n\n#[test]\nfn subsequential_sum() {\n    let nums = [1, 2, 39, 34, 20, -20, -16, 35, 0];\n\n    let (max, boundaries) = greatest_subsequential_sum(&nums);\n\n    assert_eq!(max, 96);\n    assert_eq!(&nums[boundaries], &[1, 2, 39, 34, 20]);\n}\n",
    "path": "tasks/greatest-subsequential-sum",
    "remote_code": "fn main() {\n    let nums = [1,2,39,34,20, -20, -16, 35, 0];\n\n    let mut max = 0;\n    let mut boundaries = 0..0;\n\n    for length in 0..nums.len() {\n        for start in 0..nums.len()-length {\n            let sum = (&nums[start..start+length]).iter()\n                .fold(0, |sum, elem| sum+elem);\n            if sum > max {\n                max = sum;\n                boundaries = start..start+length;\n            }\n        }\n    }\n\n    println!(\"Max subsequence sum: {} for {:?}\", max, &nums[boundaries]);;\n}",
    "title": "Greatest subsequential sum",
    "url": "http://rosettacode.org/wiki/Greatest_subsequential_sum"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Greyscale bars/Display",
    "url": "http://rosettacode.org/wiki/Greyscale_bars/Display"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::{thread_rng, Rng};\nuse std::io::stdin;\n\nconst LOWEST: isize = 1;\nconst HIGHEST: isize = 100;\n\nfn main() {\n    let mut rng = thread_rng();\n\n    loop {\n        let number: isize = rng.gen_range(LOWEST, HIGHEST + 1);\n        let mut num_guesses = 0;\n\n        println!(\n            \"I have chosen my number between {} and {}. You know what to do\",\n            LOWEST, HIGHEST\n        );\n\n        loop {\n            num_guesses += 1;\n\n            let mut line = String::new();\n            let res = stdin().read_line(&mut line);\n            let input: Option<isize> = res.ok().and_then(|_| line.trim().parse().ok());\n\n            match input {\n                None => println!(\"numbers only, please\"),\n                Some(n) if n == number => {\n                    println!(\"you got it in {} tries!\", num_guesses);\n                    break;\n                }\n                Some(n) if n < number => println!(\"too low!\"),\n                Some(n) if n > number => println!(\"too high!\"),\n                Some(_) => println!(\"something went wrong\"),\n            }\n        }\n    }\n}\nextern crate rand;\n\nuse std::io::stdin;\n\nuse rand::{thread_rng, Rng};\n\nfn main() {\n    let mystery_number = thread_rng().gen_range(0u8, 10) + 1;\n    println!(\"Guess my number between 1 and 10\");\n\n    let input = stdin();\n    loop {\n        let mut line = String::new();\n        let _ = input.read_line(&mut line).unwrap();\n        match line.trim().parse::<u8>() {\n            Ok(guess) if guess == mystery_number => break,\n            Ok(_) => println!(\"Wrong! Try again!\"),\n            Err(_) => println!(\"Please enter an integer\"),\n        }\n    }\n\n    // The loop ends only if the player wins\n    println!(\"Well guessed!\");\n}\nuse std::io::stdin;\n\nconst MIN: isize = 1;\nconst MAX: isize = 100;\n\nfn main() {\n    loop {\n        let mut min = MIN;\n        let mut max = MAX;\n        let mut num_guesses = 1;\n        println!(\"Please think of a number between {} and {}\", min, max);\n        loop {\n            let guess = (min + max) / 2;\n            println!(\"Is it {}?\", guess);\n            println!(\"(type h if my guess is too high, l if too low, e if equal and q to quit)\");\n\n            let mut line = String::new();\n            let input = stdin()\n                .read_line(&mut line)\n                .ok()\n                .and_then(|_| line.trim_start().chars().next())\n                .and_then(|c| c.to_uppercase().next());\n            match input {\n                Some('H') => {\n                    max = guess - 1;\n                    num_guesses += 1;\n                }\n                Some('L') => {\n                    min = guess + 1;\n                    num_guesses += 1;\n                }\n                Some('E') => {\n                    if num_guesses == 1 {\n                        println!(\"\\n*** That was easy! Got it in one guess! ***\\n\");\n                    } else {\n                        println!(\n                            \"\\n*** I knew it! Got it in only {} guesses! ***\\n\",\n                            num_guesses\n                        );\n                    }\n                    break;\n                }\n                Some('Q') => return,\n                _ => println!(\"Sorry, I didn't quite get that. Please try again.\"),\n            }\n        }\n    }\n}\n",
    "path": "tasks/guess-the-number",
    "remote_code": "extern crate rand;\n\nfn main() {\n    println!(\"Type in an integer between 1 and 10 and press enter.\");\n\n    let n = rand::random::<u32>() % 10 + 1;\n    loop {\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).unwrap();\n        let option: Result<u32,_> = line.trim().parse();\n        match option {\n            Ok(guess) => {\n                if guess < 1 || guess > 10 {\n                    println!(\"Guess is out of bounds; try again.\");\n                } else if guess == n {\n                    println!(\"Well guessed!\");\n                    break;\n                } else {\n                    println!(\"Wrong! Try again.\");\n                }\n            },\n            Err(_) => println!(\"Invalid input; try again.\")\n        }\n    }\n}",
    "title": "Guess the number",
    "url": "http://rosettacode.org/wiki/Guess_the_number"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::{thread_rng, Rng};\nuse std::io::stdin;\n\nconst LOWEST: isize = 1;\nconst HIGHEST: isize = 100;\n\nfn main() {\n    let mut rng = thread_rng();\n\n    loop {\n        let number: isize = rng.gen_range(LOWEST, HIGHEST + 1);\n        let mut num_guesses = 0;\n\n        println!(\n            \"I have chosen my number between {} and {}. You know what to do\",\n            LOWEST, HIGHEST\n        );\n\n        loop {\n            num_guesses += 1;\n\n            let mut line = String::new();\n            let res = stdin().read_line(&mut line);\n            let input: Option<isize> = res.ok().and_then(|_| line.trim().parse().ok());\n\n            match input {\n                None => println!(\"numbers only, please\"),\n                Some(n) if n == number => {\n                    println!(\"you got it in {} tries!\", num_guesses);\n                    break;\n                }\n                Some(n) if n < number => println!(\"too low!\"),\n                Some(n) if n > number => println!(\"too high!\"),\n                Some(_) => println!(\"something went wrong\"),\n            }\n        }\n    }\n}\n",
    "path": "tasks/guess-the-number/with-feedback",
    "remote_code": "use std::io::stdin;\nuse rand::{Rng, thread_rng};\n\nextern crate rand;\n\nconst LOWEST: isize = 1;\nconst HIGHEST: isize = 100;\n\nfn main() {\n    let mut rng = thread_rng();\n\n    loop {\n        let number: isize = rng.gen_range(LOWEST, HIGHEST + 1);\n        let mut num_guesses = 0;\n\n        println!(\"I have chosen my number between {} and {}. You know what to do\", LOWEST, HIGHEST);\n\n        loop {\n            num_guesses += 1;\n\n            let mut line = String::new();\n            let res = stdin().read_line(&mut line);\n            let input: Option<isize> = res.ok().map_or(None, |_| line.trim().parse().ok());\n\n            match input {\n                None => println!(\"numbers only, please\"),\n                Some(n) if n == number => {\n                    println!(\"you got it in {} tries!\", num_guesses);\n                    break;\n                }\n                Some(n) if n < number => println!(\"too low!\"),\n                Some(n) if n > number => println!(\"too high!\"),\n                Some(_) => println!(\"something went wrong\")\n            }\n        }\n    }\n}",
    "title": "Guess the number/With feedback",
    "url": "http://rosettacode.org/wiki/Guess_the_number/With_feedback"
  },
  {
    "local_code": "use std::io::stdin;\n\nconst MIN: isize = 1;\nconst MAX: isize = 100;\n\nfn main() {\n    loop {\n        let mut min = MIN;\n        let mut max = MAX;\n        let mut num_guesses = 1;\n        println!(\"Please think of a number between {} and {}\", min, max);\n        loop {\n            let guess = (min + max) / 2;\n            println!(\"Is it {}?\", guess);\n            println!(\"(type h if my guess is too high, l if too low, e if equal and q to quit)\");\n\n            let mut line = String::new();\n            let input = stdin()\n                .read_line(&mut line)\n                .ok()\n                .and_then(|_| line.trim_start().chars().next())\n                .and_then(|c| c.to_uppercase().next());\n            match input {\n                Some('H') => {\n                    max = guess - 1;\n                    num_guesses += 1;\n                }\n                Some('L') => {\n                    min = guess + 1;\n                    num_guesses += 1;\n                }\n                Some('E') => {\n                    if num_guesses == 1 {\n                        println!(\"\\n*** That was easy! Got it in one guess! ***\\n\");\n                    } else {\n                        println!(\n                            \"\\n*** I knew it! Got it in only {} guesses! ***\\n\",\n                            num_guesses\n                        );\n                    }\n                    break;\n                }\n                Some('Q') => return,\n                _ => println!(\"Sorry, I didn't quite get that. Please try again.\"),\n            }\n        }\n    }\n}\n",
    "path": "tasks/guess-the-number/with-feedback-player",
    "remote_code": "use std::io::stdin;\n\nconst MIN: isize = 1;\nconst MAX: isize = 100;\n\nfn main() {\n    loop {\n        let mut min = MIN;\n        let mut max = MAX;\n        let mut num_guesses = 1;\n        println!(\"Please think of a number between {} and {}\", min, max);\n        loop {\n            let guess = (min + max) / 2;\n            println!(\"Is it {}?\", guess);\n            println!(\"(type h if my guess is too high, l if too low, e if equal and q to quit)\");\n\n            let mut line = String::new();\n            stdin().read_line(&mut line).unwrap();\n            match Some(line.chars().next().unwrap().to_uppercase().next().unwrap()) {\n                Some('H') => {\n                    max = guess - 1;\n                    num_guesses += 1;\n                },\n                Some('L')=> {\n                    min = guess + 1;\n                    num_guesses += 1;\n                },\n                Some('E') => {\n                    if num_guesses == 1 {\n                        println!(\"\\n*** That was easy! Got it in one guess! ***\\n\");\n                    } else {\n                        println!(\"\\n*** I knew it! Got it in only {} guesses! ***\\n\", num_guesses);\n                    }\n                    break;\n                },\n                Some('Q') => return,\n                _ => println!(\"Sorry, I didn't quite get that. Please try again.\")\n            }\n        }\n    }\n}",
    "title": "Guess the number/With feedback (player)",
    "url": "http://rosettacode.org/wiki/Guess_the_number/With_feedback_(player)"
  },
  {
    "local_code": "extern crate reqwest;\n\nuse std::io::prelude::*;\n\nfn main() {\n    let mut response = reqwest::get(\"http://rosettacode.org\").unwrap();\n    let mut response_text = String::new();\n    response.read_to_string(&mut response_text).unwrap();\n\n    println!(\"{}\", response_text);\n}\n",
    "path": "tasks/http",
    "remote_code": "\n//cargo-deps: hyper=\"0.6\"\n// The above line can be used with cargo-script which makes cargo's dependency handling more convenient for small programs\nextern crate hyper;\n\nuse std::io::Read;\nuse hyper::client::Client;\n\nfn main() {\n    let client = Client::new();\n    let mut resp = client.get(\"http://rosettacode.org\").send().unwrap();\n    let mut body = String::new();\n    resp.read_to_string(&mut body).unwrap();\n    println!(\"{}\", body);\n}\n",
    "title": "HTTP",
    "url": "http://rosettacode.org/wiki/HTTP"
  },
  {
    "local_code": "extern crate reqwest;\n\nuse std::io::Read;\n\nfn main() {\n    let mut response = match reqwest::get(\"https://sourceforge.net\") {\n        Ok(response) => response,\n        Err(e) => panic!(\"error encountered while making request: {:?}\", e),\n    };\n    let mut body = String::new();\n    response.read_to_string(&mut body).unwrap();\n\n    println!(\"{}\", &body);\n}\nextern crate reqwest;\n\nuse std::io::Read;\n\nuse reqwest::header::CONNECTION;\nuse reqwest::Client;\n\nfn main() {\n    let client = Client::new();\n\n    // reqwest uses strongly-typed structs for creating headers\n    let mut res = client\n        .get(\"https://www.example.com\")\n        .basic_auth(\"user\", Some(\"password\"))\n        .header(CONNECTION, \"close\")\n        .send()\n        .unwrap();\n\n    let mut body = String::new();\n    res.read_to_string(&mut body).unwrap();\n\n    println!(\"{}\", &body);\n}\n",
    "path": "tasks/https",
    "remote_code": null,
    "title": "HTTPS",
    "url": "http://rosettacode.org/wiki/HTTPS"
  },
  {
    "local_code": "extern crate reqwest;\n\nuse std::io::Read;\n\nuse reqwest::header::CONNECTION;\nuse reqwest::Client;\n\nfn main() {\n    let client = Client::new();\n\n    // reqwest uses strongly-typed structs for creating headers\n    let mut res = client\n        .get(\"https://www.example.com\")\n        .basic_auth(\"user\", Some(\"password\"))\n        .header(CONNECTION, \"close\")\n        .send()\n        .unwrap();\n\n    let mut body = String::new();\n    res.read_to_string(&mut body).unwrap();\n\n    println!(\"{}\", &body);\n}\n",
    "path": "tasks/https/authenticated",
    "remote_code": null,
    "title": "HTTPS/Authenticated",
    "url": "http://rosettacode.org/wiki/HTTPS/Authenticated"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "HTTPS/Client-authenticated",
    "url": "http://rosettacode.org/wiki/HTTPS/Client-authenticated"
  },
  {
    "local_code": "/// Define a struct which stores the state for the iterator.\nstruct Hailstone {\n    next: usize,\n    pub start: usize,\n}\n\nimpl Hailstone {\n    /// Define a constructor for the struct.\n    fn new(n: usize) -> Hailstone {\n        Hailstone { next: n, start: n }\n    }\n}\n\n/// Implement the hailstone iteration sequence.\nimpl Iterator for Hailstone {\n    type Item = usize;\n\n    /// This gets called to fetch the next item of the iterator.\n    fn next(&mut self) -> Option<usize> {\n        // We need to cache the current value.\n        let current = self.next;\n        // And then calculate the 'next'\n        self.next = match current {\n            0 => {\n                // Resets the iterator.\n                self.next = self.start;\n                return None;\n            }\n            // At the end, yield 1 and roll over next time called.\n            1 => 0,\n            // Got an even.\n            x if x % 2 == 0 => x / 2,\n            // All remaining numbers are odd.\n            x => (3 * x) + 1,\n        };\n\n        Some(current)\n    }\n}\n\n/// Returns the start number and length of the longest hailstone sequence up to `limit`\nfn biggest_hailstone(limit: usize) -> (usize, usize) {\n    (0..limit)\n        .map(|n| (n, Hailstone::new(n).count()))\n        .max_by_key(|&(_, count)| count)\n        .unwrap()\n}\n\nfn main() {\n    // Find the hailstone for 27.\n    let two_seven = Hailstone::new(27).collect::<Vec<usize>>();\n    let ts_len = two_seven.len();\n    println!(\n        \"Testing: {}, Length: {}, Values: {:?}...{:?}\",\n        two_seven[0],\n        ts_len,\n        &two_seven[0..4],\n        &two_seven[ts_len - 4..]\n    );\n\n    // Find the longest.\n    let (biggest, length) = biggest_hailstone(100_000);\n    println!(\"Largest: {}, Size: {}\", biggest, length);\n}\n\n#[test]\nfn test_27() {\n    let seq = Hailstone::new(27).collect::<Vec<usize>>();\n\n    assert_eq!(&seq[0..4], [27, 82, 41, 124]);\n    assert_eq!(&seq[seq.len() - 4..], [8, 4, 2, 1]);\n}\n\n#[test]\nfn test_biggest() {\n    let (biggest, length) = biggest_hailstone(100_000);\n    assert_eq!(biggest, 77031);\n    assert_eq!(length, 351);\n}\n",
    "path": "tasks/hailstone-sequence",
    "remote_code": "fn hailstone(start : u32) -> Vec<u32> {\n    let mut res = Vec::new();\n    let mut next = start;\n\n    res.push(start);\n\n    while next != 1  {\n        next = if next % 2 == 0 { next/2 } else { 3*next+1 };\n        res.push(next);\n    }\n    res\n}\n\n \nfn main() {\n    let test_num = 27;\n    let test_hailseq = hailstone(test_num);\n\n    println!(\"For {} number of elements is {} \", test_num, test_hailseq.len());\n\n    let fst_slice = test_hailseq[0..4].iter()\n                        .fold(\"\".to_owned(), |acc, i| { acc + &*(i.to_string()).to_owned() + \", \" });\n    let last_slice = test_hailseq[test_hailseq.len()-4..].iter()\n                        .fold(\"\".to_owned(), |acc, i| { acc + &*(i.to_string()).to_owned() + \", \" });\n    \n    println!(\"  hailstone starting with {} ending with {} \", fst_slice, last_slice);\n\n    let max_range = 100000;\n    let mut max_len = 0;\n    let mut max_seed = 0;\n    for i_seed in 1..max_range {\n        let i_len = hailstone(i_seed).len();\n\n        if i_len > max_len {\n            max_len = i_len;\n            max_seed = i_seed;\n        }\n    }\n    println!(\"Longest sequence is {} element long for seed {}\", max_len, max_seed);\n}",
    "title": "Hailstone sequence",
    "url": "http://rosettacode.org/wiki/Hailstone_sequence"
  },
  {
    "local_code": "extern crate num;\n\nuse std::cmp::min;\nuse std::collections::VecDeque;\nuse std::ops::Mul;\n\nuse num::bigint::{BigUint, ToBigUint};\nuse num::one;\nuse num::traits::One;\n\n/// representing a Hamming number as a `BigUint`\nimpl HammingNumber for BigUint {\n    // returns the multipliers 2, 3 and 5 in the representation for the HammingNumber\n    fn multipliers() -> (BigUint, BigUint, BigUint) {\n        (\n            2u8.to_biguint().unwrap(),\n            3u8.to_biguint().unwrap(),\n            5u8.to_biguint().unwrap(),\n        )\n    }\n}\n\n/// representation of a Hamming number\n/// allows to abstract on how the hamming number is stored\n/// i.e. as `BigUint` directly or just as the powers of 2, 3 and 5 used to build it\npub trait HammingNumber: Eq + Ord + ToBigUint + Mul<Output = Self> + One + Clone {\n    fn multipliers() -> (Self, Self, Self);\n}\n\n/// Hamming numbers are multiples of 2, 3 or 5.\n///\n/// We keep them on three queues and extract the lowest (leftmost) value from\n/// the three queues at each iteration.\npub struct Hamming<T> {\n    // Using a VecDeque as a queue, push to the back, pop from the front\n    q2: VecDeque<T>,\n    q3: VecDeque<T>,\n    q5: VecDeque<T>,\n}\n\nimpl<T: HammingNumber> Hamming<T> {\n    /// Static constructor method\n    /// `n` initializes the capacity of the queues\n    pub fn new(n: usize) -> Hamming<T> {\n        let mut h = Hamming {\n            q2: VecDeque::with_capacity(n),\n            q3: VecDeque::with_capacity(n),\n            q5: VecDeque::with_capacity(n),\n        };\n\n        h.q2.push_back(one());\n        h.q3.push_back(one());\n        h.q5.push_back(one());\n\n        h\n    }\n\n    /// Pushes the next multiple of `n` (x2, x3, x5) to the queues\n    pub fn enqueue(&mut self, n: &T) {\n        let (two, three, five): (T, T, T) = HammingNumber::multipliers();\n        self.q2.push_back(two * n.clone());\n        self.q3.push_back(three * n.clone());\n        self.q5.push_back(five * n.clone());\n    }\n}\n\n/// Implements the `Iterator` trait, so we can generate Hamming numbers lazily\nimpl<T: HammingNumber> Iterator for Hamming<T> {\n    type Item = T;\n\n    /// The core of the work is done in the `next` method.\n    /// We check which of the 3 queues has the lowest candidate and extract it\n    /// as the next Hamming number.\n    fn next(&mut self) -> Option<T> {\n        // Return `pop_targets` so the borrow from `front()` will be finished\n        let (two, three, five) = match (self.q2.front(), self.q3.front(), self.q5.front()) {\n            (Some(head2), Some(head3), Some(head5)) => {\n                let n = min(head2, min(head3, head5));\n                (head2 == n, head3 == n, head5 == n)\n            }\n            _ => unreachable!(),\n        };\n\n        let h2 = if two { self.q2.pop_front() } else { None };\n        let h3 = if three { self.q3.pop_front() } else { None };\n        let h5 = if five { self.q5.pop_front() } else { None };\n\n        match h2.or(h3).or(h5) {\n            Some(n) => {\n                self.enqueue(&n);\n                Some(n)\n            }\n            None => unreachable!(),\n        }\n    }\n}\n\n#[test]\nfn create() {\n    let mut h = Hamming::<BigUint>::new(5);\n    h.q2.push_back(one::<BigUint>());\n    h.q2.push_back(one::<BigUint>() * 3.to_biguint().unwrap());\n\n    assert_eq!(h.q2.pop_front().unwrap(), one::<BigUint>());\n}\n\n#[test]\nfn try_enqueue() {\n    let mut h = Hamming::<BigUint>::new(5);\n    let (two, three, five): (BigUint, BigUint, BigUint) = HammingNumber::multipliers();\n    h.enqueue(&one::<BigUint>());\n    h.enqueue(&(one::<BigUint>() * two.clone()));\n\n    assert!(h.q2.pop_front().unwrap() == one::<BigUint>());\n    assert!(h.q3.pop_front().unwrap() == one::<BigUint>());\n    assert!(h.q5.pop_front().unwrap() == one::<BigUint>());\n    assert!(h.q2.pop_front().unwrap() == one::<BigUint>() * two);\n    assert!(h.q3.pop_front().unwrap() == one::<BigUint>() * three);\n    assert!(h.q5.pop_front().unwrap() == one::<BigUint>() * five);\n}\n\n#[test]\nfn hamming_iter() {\n    let mut hamming = Hamming::<BigUint>::new(20);\n    assert!(hamming.nth(19).unwrap().to_biguint() == 36.to_biguint());\n}\n\n#[ignore]\n#[test]\nfn hamming_iter_1million() {\n    let mut hamming = Hamming::<BigUint>::new(128);\n    // one-million-th hamming number has index 999_999 because indexes are zero-based\n    let millionth_hamming_number = \"51931278044838873608958984375000000000000000000000000000000000\\\n                                    0000000000000000000000\";\n    assert_eq!(\n        hamming.nth(999_999).unwrap().to_biguint(),\n        millionth_hamming_number.parse::<BigUint>().ok()\n    );\n}\n//! Alternate version: uses a more efficient representation of Hamming numbers:\n//! instead of storing them as `BigUint` directly, it stores the three exponents\n//! i, j and k for 2^i * 3^j * 5 ^k and the logarithm of the number for comparisons\n\nextern crate num;\n\nextern crate hamming_numbers;\n\nuse std::cmp::Ordering;\nuse std::cmp::Ordering::{Equal, Greater, Less};\nuse std::ops::Mul;\n\nuse num::bigint::{BigUint, ToBigUint};\nuse num::pow;\nuse num::traits::One;\n\nuse hamming_numbers::{Hamming, HammingNumber};\n\nfn main() {\n    // capacity of the queue currently needs to be a power of 2 because of a bug with VecDeque\n    let hamming: Hamming<HammingTriple> = Hamming::new(128);\n\n    for (idx, h) in hamming.enumerate().take(1_000_000) {\n        match idx + 1 {\n            1..=20 => print!(\"{} \", h.to_biguint().unwrap()),\n            i @ 1691 | i @ 1_000_000 => println!(\"\\n{}th number: {}\", i, h.to_biguint().unwrap()),\n            _ => continue,\n        }\n    }\n}\n\n// we store these to calculate the ln of a hamming number\npub const LN_2: f64 =\n    0.693_147_180_559_945_309_417_232_121_458_176_568_075_500_134_360_255_254_120_680;\npub const LN_3: f64 =\n    1.098_612_288_668_109_691_395_245_236_922_525_704_647_490_557_822_749_451_734_694;\npub const LN_5: f64 =\n    1.609_437_912_434_100_374_600_759_333_226_187_639_525_601_354_268_517_721_912_647;\n\n/// more space-efficient representation of a Hamming number.\n/// A Hamming number is 2^i * 3^j * 5^k;\n/// instead of storing it directly as a `BigUint`\n/// we store the powers i, j and k and calculate the\n/// result as a `BigUint` only when we need it.\n/// we also store the logarithm for quicker comparisons, using this property\n/// of logarithms: ln(2^i * 3^j * 5^k) = i*ln2 + j*ln3 + k*ln5\n#[derive(Debug, Copy, Clone)]\npub struct HammingTriple {\n    pow_2: usize,\n    pow_3: usize,\n    pow_5: usize,\n    ln: f64,\n}\n\nimpl Mul for HammingTriple {\n    type Output = HammingTriple;\n    fn mul(self, other: HammingTriple) -> HammingTriple {\n        HammingTriple {\n            pow_2: self.pow_2 + other.pow_2,\n            pow_3: self.pow_3 + other.pow_3,\n            pow_5: self.pow_5 + other.pow_5,\n            ln: self.ln + other.ln,\n        }\n    }\n}\n\nimpl One for HammingTriple {\n    /// 1 as an HammingNumber is 2^0 * 3^0 * 5^0\n    /// ln(1) = 0\n    fn one() -> HammingTriple {\n        HammingTriple::new(0, 0, 0)\n    }\n}\n\nimpl HammingNumber for HammingTriple {\n    fn multipliers() -> (HammingTriple, HammingTriple, HammingTriple) {\n        (\n            HammingTriple {\n                pow_2: 1,\n                pow_3: 0,\n                pow_5: 0,\n                ln: LN_2,\n            },\n            HammingTriple {\n                pow_2: 0,\n                pow_3: 1,\n                pow_5: 0,\n                ln: LN_3,\n            },\n            HammingTriple {\n                pow_2: 0,\n                pow_3: 0,\n                pow_5: 1,\n                ln: LN_5,\n            },\n        )\n    }\n}\n\nimpl ToBigUint for HammingTriple {\n    /// calculate the value as a `BigUint`\n    fn to_biguint(&self) -> Option<BigUint> {\n        Some(\n            pow(2u8.to_biguint().unwrap(), self.pow_2)\n                * pow(3u8.to_biguint().unwrap(), self.pow_3)\n                * pow(5u8.to_biguint().unwrap(), self.pow_5),\n        )\n    }\n}\n\nimpl HammingTriple {\n    fn new(pow_2: usize, pow_3: usize, pow_5: usize) -> HammingTriple {\n        HammingTriple {\n            pow_2: pow_2,\n            pow_3: pow_3,\n            pow_5: pow_5,\n            ln: (pow_2 as f64) * LN_2 + (pow_3 as f64) * LN_3 + (pow_5 as f64) * LN_5,\n        }\n    }\n}\n\nimpl PartialEq for HammingTriple {\n    fn eq(&self, other: &HammingTriple) -> bool {\n        self.pow_2 == other.pow_2 && self.pow_3 == other.pow_3 && self.pow_5 == other.pow_5\n    }\n}\n\nimpl Eq for HammingTriple {}\n\nimpl PartialOrd for HammingTriple {\n    fn partial_cmp(&self, other: &HammingTriple) -> Option<Ordering> {\n        if self == other {\n            Some(Equal)\n        } else if ((self.pow_2 >= other.pow_2)\n            && (self.pow_3 >= other.pow_3)\n            && (self.pow_5 >= other.pow_5))\n            || (self.ln > other.ln)\n        {\n            Some(Greater)\n        } else if ((self.pow_2 <= other.pow_2)\n            && (self.pow_3 <= other.pow_3)\n            && (self.pow_5 <= other.pow_5))\n            || (self.ln < other.ln)\n        {\n            Some(Less)\n        } else {\n            None\n        }\n    }\n}\n\nimpl Ord for HammingTriple {\n    fn cmp(&self, other: &HammingTriple) -> Ordering {\n        // as a last resort we need to calculate the BigUint values and compare them.\n        // This should be rare. The reason is that for very big values floating point precision\n        // could make hamming_1.ln == hamming_2.ln even if the two numbers are actually different\n        self.partial_cmp(other)\n            .unwrap_or_else(|| self.to_biguint().unwrap().cmp(&other.to_biguint().unwrap()))\n    }\n}\n\n#[test]\nfn hamming_iter() {\n    let mut hamming = Hamming::<HammingTriple>::new(20);\n    assert!(hamming.nth(19).unwrap().to_biguint() == 36u8.to_biguint());\n}\n\n#[test]\nfn hamming_iter_1million() {\n    let mut hamming = Hamming::<HammingTriple>::new(128);\n    let millionth_hamming_number = \"51931278044838873608958984375000000000000000000000000000000000\\\n                                    0000000000000000000000\";\n\n    // one-million-th hamming number has index 999_999 because indexes are zero-based\n    assert_eq!(\n        hamming.nth(999_999).unwrap().to_biguint(),\n        millionth_hamming_number.parse::<BigUint>().ok()\n    );\n}\nextern crate num;\n\nextern crate hamming_numbers;\n\nuse num::bigint::ToBigUint;\nuse num::BigUint;\n\nuse hamming_numbers::Hamming;\n\nfn main() {\n    // capacity of the queue currently needs to be a power of 2 because of a bug with VecDeque\n    let hamming: Hamming<BigUint> = Hamming::new(128);\n\n    for (idx, h) in hamming.enumerate().take(1_000_000) {\n        match idx + 1 {\n            1..=20 => print!(\"{} \", h.to_biguint().unwrap()),\n            i @ 1691 | i @ 1_000_000 => println!(\"\\n{}th number: {}\", i, h.to_biguint().unwrap()),\n            _ => continue,\n        }\n    }\n}\n",
    "path": "tasks/hamming-numbers",
    "remote_code": "extern crate num;\nnum::bigint::BigUint;\n\nuse std::time::Instant;\n\nfn basic_hamming(n: usize) -> BigUint {\n    let two = BigUint::from(2u8);\n    let three = BigUint::from(3u8);\n    let five = BigUint::from(5u8);\n    let mut h = vec![BigUint::from(0u8); n];\n    h[0] = BigUint::from(1u8);\n    let mut x2 = BigUint::from(2u8);\n    let mut x3 = BigUint::from(3u8);\n    let mut x5 = BigUint::from(5u8);\n    let mut i = 0usize; let mut j = 0usize; let mut k = 0usize;\n\n    // BigUint comparisons are expensive, so do it only as necessary...\n    fn min3(x: &BigUint, y: &BigUint, z: &BigUint) -> (usize, BigUint) {\n        let (cs, r1) = if y == z { (0x6, y) } \n                        else if y < z { (2, y) } else { (4, z) };\n        if x == r1 { (cs | 1, x.clone()) }\n        else if x < r1 { (1, x.clone()) } else { (cs, r1.clone()) }\n    }\n\n    let mut c = 1;\n    while c < n { // satisfy borrow checker with extra blocks: {  }\n        let (cs, e1) = { min3(&x2, &x3, &x5) };\n        h[c] = e1; // vector now owns the generated value\n        if (cs & 1) != 0 { i += 1; x2 = &two * &h[i] }\n        if (cs & 2) != 0 { j += 1; x3 = &three * &h[j] }\t\n        if (cs & 4) != 0 { k += 1; x5 = &five * &h[k] }\n        c += 1;\n    }\n\n    match h.pop() {\n        Some(v) => v,\n        _ => panic!(\"basic_hamming: arg is zero; no elements\")\n    }\n}\n\nfn main() {\n    print!(\"[\");\n    for (i, h) in (1..21).map(basic_hamming).enumerate() {\n        if i != 0 { print!(\",\") }\n        print!(\" {}\", h)\n    }\n    println!(\" ]\");\n    println!(\"{}\", basic_hamming(1691));\n\n    let strt = Instant::now();\n\n    let rslt = basic_hamming(1000000);\n\n    let elpsd = strt.elapsed();\n    let secs = elpsd.as_secs();\n    let millis = (elpsd.subsec_nanos() / 1000000)as u64;\n    let dur = secs * 1000 + millis;\n\n    let rs = rslt.to_str_radix(10);\n    let mut s = rs.as_str();\n    println!(\"{} digits:\", s.len());\n        while s.len() > 100 {\n            let (f, r) = s.split_at(100);\n            s = r;\n            println!(\"{}\", f);\n        }\n        println!(\"{}\", s);\n\n    println!(\"This last took {} milliseconds\", dur);\n}",
    "title": "Hamming numbers",
    "url": "http://rosettacode.org/wiki/Hamming_numbers"
  },
  {
    "local_code": "extern crate libc;\nextern crate time;\n\n#[cfg(unix)]\nfn main() {\n    use std::sync::atomic::{AtomicBool, Ordering};\n    use std::thread;\n    use std::time::Duration;\n\n    use libc::{sighandler_t, SIGINT};\n\n    // The time between ticks of our counter.\n    let duration = Duration::from_secs(1) / 2;\n\n    // \"SIGINT received\" global variable.\n    static mut GOT_SIGINT: AtomicBool = AtomicBool::new(false);\n\n    unsafe {\n        // Initially, \"SIGINT received\" is false.\n        GOT_SIGINT.store(false, Ordering::Release);\n        // Interrupt handler that handles the SIGINT signal\n        unsafe fn handle_sigint() {\n            // It is dangerous to perform any system calls in interrupts, so just set the atomic\n            // \"SIGINT received\" global to true when it arrives.\n            GOT_SIGINT.store(true, Ordering::Release);\n        }\n        // Make handle_sigint the signal handler for SIGINT.\n        libc::signal(SIGINT, handle_sigint as sighandler_t);\n    }\n\n    // Get the start time...\n    let start = time::precise_time_ns();\n\n    // Integer counter\n    let mut i = 0u32;\n\n    // Every `duration`...\n    loop {\n        thread::sleep(duration);\n\n        // Break if SIGINT was handled\n        if unsafe { GOT_SIGINT.load(Ordering::Acquire) } {\n            break;\n        }\n\n        // Otherwise, increment and display the integer and continue the loop.\n        i += 1;\n        println!(\"{}\", i);\n    }\n\n    // Get the end time.\n    let end = time::precise_time_ns();\n\n    // Compute the difference\n    let diff = Duration::from_millis((end - start) / 1_000_000);\n\n    // Print the difference and exit\n    println!(\"Program has run for {} seconds\", diff.as_secs());\n}\n\n#[cfg(not(unix))]\nfn main() {\n    println!(\"Not supported on this platform\");\n}\n",
    "path": "tasks/handle-a-signal",
    "remote_code": null,
    "title": "Handle a signal",
    "url": "http://rosettacode.org/wiki/Handle_a_signal"
  },
  {
    "local_code": "fn digits(mut n: usize) -> Vec<usize> {\n    let mut ds = vec![];\n    if n == 0 {\n        return vec![0];\n    }\n    while n > 0 {\n        ds.push(n % 10);\n        n /= 10;\n    }\n    ds.reverse();\n    ds\n}\n\nfn is_happy(mut x: usize) -> bool {\n    let mut past = Vec::new();\n    while x != 1 {\n        // Take the sum of the squares of the digits of x\n        x = digits(x).iter().fold(0, |a, &b| a + b * b);\n\n        // The number is not happy if there is an endless loop\n        if past.contains(&x) {\n            return false;\n        }\n\n        // past.insert(x);\n        past.push(x);\n    }\n    true\n}\n\nfn main() {\n    // Print the first 8 happy numbers\n    let v: Vec<usize> = (1..).filter(|x| is_happy(*x)).take(8).collect();\n    println!(\"{:?}\", v)\n}\n\n#[test]\nfn test_digits() {\n    assert_eq!(digits(0), vec![0]);\n    assert_eq!(digits(1), vec![1]);\n    assert_eq!(digits(2), vec![2]);\n    assert_eq!(digits(10), vec![1, 0]);\n    assert_eq!(digits(11), vec![1, 1]);\n    assert_eq!(digits(101), vec![1, 0, 1]);\n    assert_eq!(digits(1000), vec![1, 0, 0, 0]);\n}\n\n#[test]\nfn test_is_happy() {\n    let happys = [1, 7, 10, 13, 19, 23, 28, 31, 1607, 1663];\n    let unhappys = [0, 2, 3, 4, 5, 6, 8, 9, 29, 1662];\n\n    assert!(happys.iter().all(|&n| is_happy(n)));\n    assert!(unhappys.iter().all(|&n| !is_happy(n)));\n}\n",
    "path": "tasks/happy-numbers",
    "remote_code": "#![feature(core)]\n\nfn sumsqd(mut n: i32) -> i32 {\n    let mut sq = 0;\n    while n > 0 {\n        let d = n % 10;\n        sq += d*d;\n        n /= 10\n    }\n    sq\n}\n\nuse std::num::Int;\nfn cycle<T: Int>(a: T, f: fn(T) -> T) -> T {\n    let mut t = a;\n    let mut h = f(a);\n\n    while t != h {\n        t = f(t);\n        h = f(f(h))\n    }\n    t\n}\n\nfn ishappy(n: i32) -> bool {\n    cycle(n, sumsqd) == 1\n}\n\nfn main() {\n    let happy = std::iter::count(1, 1)\n                    .filter(|&n| ishappy(n))\n                    .take(8)\n                    .collect::<Vec<i32>>();\n\n    println!(\"{:?}\", happy)\n}",
    "title": "Happy numbers",
    "url": "http://rosettacode.org/wiki/Happy_numbers"
  },
  {
    "local_code": "use std::u32;\n\nfn main() {\n    let digit_sum = |i: u32| {\n        i.to_string()\n            .chars()\n            .fold(0u32, |d, c| d + c.to_digit(10).unwrap())\n    };\n    let mut harshads = (1u32..u32::MAX).filter(|&n| n % digit_sum(n) == 0);\n\n    for _ in 0u32..20 {\n        print!(\"{} \", harshads.next().unwrap())\n    }\n    println!(\"\\n{}\", harshads.skip_while(|&h| h <= 1000).next().unwrap());\n}\n",
    "path": "tasks/harshad-or-niven-series",
    "remote_code": null,
    "title": "Harshad or Niven series",
    "url": "http://rosettacode.org/wiki/Harshad_or_Niven_series"
  },
  {
    "local_code": "use std::collections::HashMap;\n\nfn main() {\n    let keys = [\"a\", \"b\", \"c\"];\n    let values = [1, 2, 3];\n\n    let hash = keys.iter().zip(values.iter()).collect::<HashMap<_, _>>();\n    println!(\"{:?}\", hash);\n}\n",
    "path": "tasks/hash-from-two-arrays",
    "remote_code": "use std::collections::HashMap;\n\nfn main() {\n    let keys = [\"a\", \"b\", \"c\"];\n    let values = [1, 2, 3];\n\n    let hash = keys.iter().zip(values.iter()).collect::<HashMap<_, _>>();\n    println!(\"{:?}\", hash);\n}",
    "title": "Hash from two arrays",
    "url": "http://rosettacode.org/wiki/Hash_from_two_arrays"
  },
  {
    "local_code": "use std::collections::HashMap;\nuse std::hash::Hash;\n\n// If you know one of the tables is smaller, it is best to make it the second parameter.\nfn hash_join<A, B, K>(first: &[(K, A)], second: &[(K, B)]) -> Vec<(A, K, B)>\nwhere\n    K: Hash + Eq + Copy,\n    A: Copy,\n    B: Copy,\n{\n    let mut hash_map = HashMap::new();\n\n    // hash phase\n    for &(key, val_a) in second {\n        // collect all values by their keys, appending new ones to each existing entry\n        hash_map.entry(key).or_insert_with(Vec::new).push(val_a);\n    }\n\n    let mut result = Vec::new();\n    // join phase\n    for &(key, val_b) in first {\n        if let Some(vals) = hash_map.get(&key) {\n            let tuples = vals.iter().map(|&val_a| (val_b, key, val_a));\n            result.extend(tuples);\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let table1 = [\n        (\"Jonah\", 27),\n        (\"Alan\", 18),\n        (\"Glory\", 28),\n        (\"Popeye\", 18),\n        (\"Alan\", 28),\n    ];\n    let table2 = [\n        (\"Jonah\", \"Whales\"),\n        (\"Jonah\", \"Spiders\"),\n        (\"Alan\", \"Ghosts\"),\n        (\"Alan\", \"Zombies\"),\n        (\"Glory\", \"Buffy\"),\n    ];\n    let result = hash_join(&table1, &table2);\n    println!(\"Age | Character Name | Nemesis\");\n    println!(\"----|----------------|--------\");\n    for (age, name, nemesis) in result {\n        println!(\"{:<3} | {:^14} | {}\", age, name, nemesis);\n    }\n}\n\n#[test]\nfn test() {\n    let t1 = [(\"hello\", 0), (\"world\", 1)];\n    let t2 = [(\"hello\", \"rust\"), (\"hello\", \"cargo\")];\n    let r = hash_join(&t1, &t2);\n    let expected = [(0, \"hello\", \"rust\"), (0, \"hello\", \"cargo\")];\n    assert_eq!(r, expected);\n}\n",
    "path": "tasks/hash-join",
    "remote_code": "use std::collections::HashMap;\nuse std::hash::Hash;\n\n// If you know one of the tables is smaller, it is best to make it the second parameter.\nfn hash_join<A, B, K>(first: &[(K, A)], second: &[(K, B)]) -> Vec<(A, K, B)>\nwhere\n    K: Hash + Eq + Copy,\n    A: Copy,\n    B: Copy,\n{\n    let mut hash_map = HashMap::new();\n\n    // hash phase\n    for &(key, val_a) in second {\n        // collect all values by their keys, appending new ones to each existing entry\n        hash_map.entry(key).or_insert_with(Vec::new).push(val_a);\n    }\n\n    let mut result = Vec::new();\n    // join phase\n    for &(key, val_b) in first {\n        if let Some(vals) = hash_map.get(&key) {\n            let tuples = vals.iter().map(|&val_a| (val_b, key, val_a));\n            result.extend(tuples);\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let table1 = [(\"Jonah\", 27), (\"Alan\", 18), (\"Glory\", 28), (\"Popeye\", 18), (\"Alan\", 28)];\n    let table2 = [\n        (\"Jonah\", \"Whales\"), (\"Jonah\", \"Spiders\"), (\"Alan\", \"Ghosts\"),\n        (\"Alan\", \"Zombies\"), (\"Glory\", \"Buffy\")\n    ];\n    let result = hash_join(&table1, &table2);\n    println!(\"Age | Character Name | Nemesis\");\n    println!(\"----|----------------|--------\");\n    for (age, name, nemesis) in result {\n        println!(\"{:<3} | {:^14} | {}\", age, name, nemesis);\n    }\n}",
    "title": "Hash join",
    "url": "http://rosettacode.org/wiki/Hash_join"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse std::f64;\n\nstatic R: f64 = 6372.8;\n\nfn haversine_dist(mut th1: f64, mut ph1: f64, mut th2: f64, ph2: f64) -> f64 {\n    ph1 -= ph2;\n    ph1 = ph1.to_radians();\n    th1 = th1.to_radians();\n    th2 = th2.to_radians();\n    let dz: f64 = th1.sin() - th2.sin();\n    let dx: f64 = ph1.cos() * th1.cos() - th2.cos();\n    let dy: f64 = ph1.sin() * th1.cos();\n    ((dx * dx + dy * dy + dz * dz).sqrt() / 2.0).asin() * 2.0 * R\n}\n\nfn main() {\n    let d: f64 = haversine_dist(36.12, -86.67, 33.94, -118.4);\n    println!(\"Distance: {} km ({} mi)\", d, d / 1.609344);\n}\n\n",
    "title": "Haversine formula",
    "url": "http://rosettacode.org/wiki/Haversine_formula"
  },
  {
    "local_code": "#[cfg(feature = \"gtk\")]\nmod graphical {\n    extern crate gtk;\n\n    use self::gtk::traits::*;\n    use self::gtk::{Inhibit, Window, WindowPosition, WindowType};\n\n    pub fn hello_world() {\n        gtk::init().unwrap();\n        let window = Window::new(WindowType::Toplevel);\n\n        window.set_title(\"Hello World!\");\n        window.set_border_width(10);\n        window.set_position(WindowPosition::Center);\n        window.set_default_size(350, 70);\n\n        window.connect_delete_event(|_, _| {\n            gtk::main_quit();\n            Inhibit(false)\n        });\n\n        window.show_all();\n        gtk::main();\n    }\n}\n\n#[cfg(feature = \"gtk\")]\nfn main() {\n    graphical::hello_world();\n}\n\n#[cfg(not(feature = \"gtk\"))]\nfn main() {}\n",
    "path": "tasks/hello-world/graphical",
    "remote_code": "// cargo-deps:  gtk\nextern crate gtk;\nuse gtk::traits::*;\nuse gtk::{Window, WindowType, WindowPosition};\nuse gtk::signal::Inhibit;\n\nfn main() {\n    gtk::init().unwrap();\n    let window = Window::new(WindowType::Toplevel).unwrap();\n\n    window.set_title(\"Goodbye, World!\");\n    window.set_border_width(10);\n    window.set_window_position(WindowPosition::Center);\n    window.set_default_size(350, 70);\n    window.connect_delete_event(|_,_| {\n        gtk::main_quit();\n        Inhibit(false)\n    });\n\n    window.show_all();\n    gtk::main();\n}",
    "title": "Hello world/Graphical",
    "url": "http://rosettacode.org/wiki/Hello_world/Graphical"
  },
  {
    "local_code": "use std::fs::File;\nuse std::io::Write;\n\nfn main() {\n    let mut file = File::open(\"/dev/lp0\").unwrap();\n    write!(file, \"Hello World!\").unwrap();\n}\n",
    "path": "tasks/hello-world/line-printer",
    "remote_code": "use std::fs::OpenOptions;\nuse std::io::Write;\n\nfn main() {\n    let file = OpenOptions::new().write(true).open(\"/dev/lp0\").unwrap();\n    file.write(b\"Hello, World!\").unwrap();\n}",
    "title": "Hello world/Line printer",
    "url": "http://rosettacode.org/wiki/Hello_world/Line_printer"
  },
  {
    "local_code": "//! A complete description of how to install the language can be found on the [Install page] of the\n//! [Rust web site]. However, for the purposes of trying out code examples, use the [online REPL]\n//! which allows you to enter code, compile it and run it within a single browser window.\n//!\n//! [Install page]: http://www.rust-lang.org/install.html\n//! [Rust web site]: http://www.rust-lang.org/\n//! [online REPL]: http://play.rust-lang.org/\n\nfn main() {\n    println!(\"Hello world!\");\n}\n",
    "path": "tasks/hello-world/newbie",
    "remote_code": "fn main() {\n    println!(\"Hello world!\");\n}",
    "title": "Hello world/Newbie",
    "url": "http://rosettacode.org/wiki/Hello_world/Newbie"
  },
  {
    "local_code": "fn main() {\n    print!(\"Goodbye, World!\");\n}\n",
    "path": "tasks/hello-world/newline-omission",
    "remote_code": "fn main () {\n    print!(\"Goodbye, World!\");\n}",
    "title": "Hello world/Newline omission",
    "url": "http://rosettacode.org/wiki/Hello_world/Newline_omission"
  },
  {
    "local_code": "use std::io::{self, Write};\n\nfn main() {\n    let mut stderr = io::stderr();\n    let _ = stderr.write_all(b\"Goodbye, World!\\n\");\n}\n",
    "path": "tasks/hello-world/standard-error",
    "remote_code": "fn main() {\n    eprintln!(\"Hello, {}!\", \"world\");\n}",
    "title": "Hello world/Standard error",
    "url": "http://rosettacode.org/wiki/Hello_world/Standard_error"
  },
  {
    "local_code": "fn main() {\n    println!(\"Hello world!\");\n}\n",
    "path": "tasks/hello-world/text",
    "remote_code": "\nfn main() {\n   print!(\"Hello world!\");\n}\n",
    "title": "Hello world/Text",
    "url": "http://rosettacode.org/wiki/Hello_world/Text"
  },
  {
    "local_code": "use std::env;\nuse std::io::{Result, Write};\nuse std::net::{Shutdown, TcpListener, TcpStream};\n\nfn handle_client(mut stream: TcpStream) -> Result<()> {\n    let response = b\"HTTP/1.1 200 OK\nContent-Type: text/html;\ncharset=UTF-8\n\n<!doctype html>\n<html>\n    <head>\n        <title>Bye-bye baby bye-bye</title>\n        <style>\n            body { background-color: #111 }\n            h1 { font-size:4cm; text-align: center; color: black; text-shadow: 0 0 2mm red}\n        </style>\n    </head>\n    <body>\n        <h1>Goodbye, world!</h1>\n    </body>\n</html>\";\n\n    stream.write_all(response)?;\n    stream.shutdown(Shutdown::Write)\n}\n\nfn handle_server(ip: &str, port: u16) -> Result<TcpListener> {\n    use std::thread::spawn;\n    let listener = TcpListener::bind((ip, port))?;\n    println!(\"Listening for connections on port {}\", port);\n\n    let handle = listener.try_clone()?;\n    for stream in handle.incoming() {\n        match stream {\n            Ok(s) => {\n                spawn(move || match handle_client(s) {\n                    Ok(_) => println!(\"Response sent!\"),\n                    Err(e) => println!(\"Failed sending response: {}!\", e),\n                });\n            }\n            Err(e) => {\n                println!(\"No longer accepting new requests: {}\", e);\n                break;\n            }\n        }\n    }\n    drop(listener);\n    Ok(handle)\n}\n\nfn main() {\n    let mut args = env::args();\n    let app_name = args.next().unwrap().to_owned();\n    let host = \"127.0.0.1\";\n    let port = if let Some(os_port) = args.next() {\n        let s_port = os_port.to_owned();\n        s_port\n            .parse::<u16>()\n            .expect(&*format!(\"Usage: {:?} <port>\", app_name))\n    } else {\n        8080\n    };\n\n    handle_server(host, port).unwrap();\n}\n",
    "path": "tasks/hello-world/web-server",
    "remote_code": "use std::net::{Shutdown, TcpListener};\nuse std::thread;\nuse std::io::Write;\n\nconst RESPONSE: &'static [u8] = b\"HTTP/1.1 200 OK\\r\nContent-Type: text/html; charset=UTF-8\\r\\n\\r\n<!DOCTYPE html><html><head><title>Bye-bye baby bye-bye</title>\n<style>body { background-color: #111 }\nh1 { font-size:4cm; text-align: center; color: black;\ntext-shadow: 0 0 2mm red}</style></head>\n<body><h1>Goodbye, world!</h1></body></html>\\r\";\n\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:8080\").unwrap();\n\n    for stream in listener.incoming() {\n        thread::spawn(move || {\n            let mut stream = stream.unwrap();\n            match stream.write(RESPONSE) {\n                Ok(_) => println!(\"Response sent!\"),\n                Err(e) => println!(\"Failed sending response: {}!\", e),\n            }\n            stream.shutdown(Shutdown::Write).unwrap();\n        });\n    }\n}\n",
    "title": "Hello world/Web server",
    "url": "http://rosettacode.org/wiki/Hello_world/Web_server"
  },
  {
    "local_code": "fn main() {\n    // Similar to C++, Rust offers raw strings:\n    let x = r#\"\n        This is a \"raw string literal,\" roughly equivalent to a heredoc.\n    \"#;\n\n    println!(\"{}\", x);\n}\n",
    "path": "tasks/here-document",
    "remote_code": "let x = r#\"\n    This is a \"raw string literal,\" roughly equivalent to a heredoc.   \n\"#;\n\nlet y = r##\"\n  This string contains a #.\n\"##;\n",
    "title": "Here document",
    "url": "http://rosettacode.org/wiki/Here_document"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Heronian triangles",
    "url": "http://rosettacode.org/wiki/Heronian_triangles"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Hickerson series of almost integers",
    "url": "http://rosettacode.org/wiki/Hickerson_series_of_almost_integers"
  },
  {
    "local_code": "fn plain_function() {\n    println!(\"regular function\");\n}\n\nfn higher_order<F>(cb: F)\nwhere\n    F: Fn(),\n{\n    cb();\n}\n\nfn main() {\n    higher_order(plain_function);\n    higher_order(|| println!(\"a closure\"));\n}\n",
    "path": "tasks/higher-order-functions",
    "remote_code": "fn execute_with_10<F: Fn(u64) -> u64> (f: F) -> u64 {\n\tf(10)\n}\n\nfn square(n: u64) -> u64 {\n\tn*n\n}\n\nfn main() {\n\tprintln!(\"{}\", execute_with_10(|n| n*n )); // closure\n\tprintln!(\"{}\", execute_with_10(square));   // function\n}",
    "title": "Higher-order functions",
    "url": "http://rosettacode.org/wiki/Higher-order_functions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Hilbert curve",
    "url": "http://rosettacode.org/wiki/Hilbert_curve"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "History variables",
    "url": "http://rosettacode.org/wiki/History_variables"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Hofstadter Figure-Figure sequences",
    "url": "http://rosettacode.org/wiki/Hofstadter_Figure-Figure_sequences"
  },
  {
    "local_code": "//! An iterable version.\n\n/// Define a struct which stores the state for the iterator.\nstruct HofstadterQ {\n    next: usize,\n    memoize_vec: Vec<usize>,\n}\n\nimpl HofstadterQ {\n    /// Define a constructor for the struct.\n    fn new() -> HofstadterQ {\n        HofstadterQ {\n            next: 1,\n            memoize_vec: vec![1],\n        }\n    }\n}\n\nimpl Default for HofstadterQ {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Implement the hofstadter q iteration sequence.\nimpl Iterator for HofstadterQ {\n    type Item = usize;\n\n    /// This gets called to fetch the next item of the iterator.\n    fn next(&mut self) -> Option<usize> {\n        // Cache the current value.\n        self.memoize_vec.push(self.next);\n        // And then calculate the 'next'.\n        // First, make the four recursive calls.\n        let current: usize = self.memoize_vec.len();\n        let rec_call_1: usize = self.memoize_vec[current - 1];\n        let rec_call_2: usize = self.memoize_vec[current - 2];\n        let rec_call_3: usize = self.memoize_vec[current - rec_call_1];\n        let rec_call_4: usize = self.memoize_vec[current - rec_call_2];\n        // Then update self.next and return it.\n        self.next = rec_call_3 + rec_call_4;\n        Some(self.next)\n    }\n}\n\nfn main() {\n    // Set up the iterable.\n    let hof: HofstadterQ = HofstadterQ::new();\n    // The number of terms we want from the iterator.\n    let upto: usize = 1000;\n    // Create the iterator.\n    let mut it = hof.take(upto - 2);\n    // Print the base values.\n    println!(\"H(1) = 1\");\n    println!(\"H(2) = 1\");\n    // Print the rest of the sequence.\n    for i in 3..1 + upto {\n        println!(\"H({}) = {}\", i, it.next().unwrap());\n    }\n}\n\n#[test]\nfn test_first_ten() {\n    let hofstadter_q = HofstadterQ::new().take(10).collect::<Vec<_>>();\n    // Test that the first ten values are as expected\n    // The first two values are hardcoded, so no need to test those.\n    let hofstadter_q_expected = vec![2, 3, 3, 4, 5, 5, 6, 6, 6, 8];\n    assert_eq!(hofstadter_q_expected, hofstadter_q);\n}\n\n#[test]\nfn test_thousandth() {\n    // Set up the iterable.\n    let hof: HofstadterQ = HofstadterQ::new();\n    // The number of terms we want from the iterator.\n    let upto: usize = 1000;\n    // Create the iterator.\n    let mut it = hof.take(upto - 2);\n    let expected: usize = 502;\n    // Test that the upto-th term is as expected.\n    for _ in 3..upto {\n        it.next();\n    }\n    assert_eq!(expected, it.next().unwrap());\n}\n",
    "path": "tasks/hofstadter-q-sequence",
    "remote_code": "fn hofq(q: &mut Vec<u32>, x : u32) -> u32 {\n    let cur_len=q.len()-1;\n    let i=x as usize;\n    if i>cur_len {\n        // extend storage\n        q.reserve(i+1);\n        for j in (cur_len+1)..(i+1) {\n            let qj=(q[j-q[j-1] as usize]+q[j-q[j-2] as usize]) as u32;\n            q.push(qj);\n        }\n    }\n    q[i]\n}\n\nfn main() {\n    let mut q_memo: Vec<u32>=vec![0,1,1];\n    let mut q=|i| {hofq(&mut q_memo, i)};\n    for i in 1..11 {\n        println!(\"Q({})={}\", i, q(i));\n    }\n    println!(\"Q(1000)={}\", q(1000));\n    let q100001=q(100_000); // precompute all\n    println!(\"Q(100000)={}\", q100000);\n    let nless=(1..100_000).fold(0,|s,i|{if q(i+1)<q(i) {s+1} else {s}});\n    println!(\"Term is less than preceding term {} times\", nless);\n}\n",
    "title": "Hofstadter Q sequence",
    "url": "http://rosettacode.org/wiki/Hofstadter_Q_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Hofstadter-Conway $10,000 sequence",
    "url": "http://rosettacode.org/wiki/Hofstadter-Conway_$10,000_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Holidays related to Easter",
    "url": "http://rosettacode.org/wiki/Holidays_related_to_Easter"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Honeycombs",
    "url": "http://rosettacode.org/wiki/Honeycombs"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Horizontal sundial calculations",
    "url": "http://rosettacode.org/wiki/Horizontal_sundial_calculations"
  },
  {
    "local_code": "extern crate num;\n\nuse num::traits::{PrimInt, Zero};\n\nfn horner<T: PrimInt + Zero>(cs: &[T], x: T) -> T {\n    cs.iter()\n        .rev()\n        .fold(Zero::zero(), |acc: T, c| (acc * x) + (*c))\n}\n\nfn main() {\n    println!(\"{}\", horner(&[-19i32, 7, -4, 6], 3i32)); // 128\n}\n\n#[cfg(test)]\nmod tests {\n    use super::horner;\n\n    #[test]\n    fn test() {\n        assert_eq!(horner(&[-19i32, 7, -4, 6], 3i32), 128);\n        assert_eq!(horner(&[-1i32, 7, -4, 6], 0i32), -1);\n        assert_eq!(horner(&[-0i32, 3], 100i32), 300);\n        assert_eq!(horner(&[-20i32, 7, 1], 10i32), 150);\n        assert_eq!(horner(&[-19i32, 7, -4, 0], 5i32), -84);\n    }\n}\n",
    "path": "tasks/horners-rule-for-polynomial-evaluation",
    "remote_code": "fn horner(v: &[f64], x: f64) -> f64 {\n    v.iter().rev().fold(0.0, |acc, coeff| acc*x + coeff)\n}\n\nfn main() {\n    let v = [-19., 7., -4., 6.];\n    println!(\"result: {}\", horner(&v, 3.0));\n}",
    "title": "Horner's rule for polynomial evaluation",
    "url": "http://rosettacode.org/wiki/Horner's_rule_for_polynomial_evaluation"
  },
  {
    "local_code": "fn main() {\n    println!(\"word size: {} bits\", 8 * std::mem::size_of::<usize>());\n\n    if cfg!(target_endian = \"big\") {\n        println!(\"big endian\");\n    } else {\n        println!(\"little endian\");\n    }\n}\n",
    "path": "tasks/host-introspection",
    "remote_code": null,
    "title": "Host introspection",
    "url": "http://rosettacode.org/wiki/Host_introspection"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Hostname",
    "url": "http://rosettacode.org/wiki/Hostname"
  },
  {
    "local_code": "//! Contributed by Gavin Baker <gavinb@antonym.org>\n//! Adapted from the Go version\n\nuse std::fs::File;\nuse std::io::{BufRead, BufReader, BufWriter, Read, Write};\nuse std::iter::repeat;\n\n/// Simple 8-bit grayscale image\nstruct ImageGray8 {\n    width: usize,\n    height: usize,\n    data: Vec<u8>,\n}\n\nfn load_pgm(filename: &str) -> ImageGray8 {\n    // Open file\n    let mut file = BufReader::new(File::open(filename).unwrap());\n\n    // Read header\n    let mut magic_in = String::new();\n    let _ = file.read_line(&mut magic_in).unwrap();\n    let mut width_in = String::new();\n    let _ = file.read_line(&mut width_in).unwrap();\n    let mut height_in = String::new();\n    let _ = file.read_line(&mut height_in).unwrap();\n    let mut maxval_in = String::new();\n    let _ = file.read_line(&mut maxval_in).unwrap();\n\n    assert_eq!(magic_in, \"P5\\n\");\n    assert_eq!(maxval_in, \"255\\n\");\n\n    // Parse header\n\n    let width = width_in.trim().parse::<usize>().unwrap();\n    let height: usize = height_in.trim().parse::<usize>().unwrap();\n\n    println!(\"Reading pgm file {}: {} x {}\", filename, width, height);\n\n    // Create image and allocate buffer\n\n    let mut img = ImageGray8 {\n        width: width,\n        height: height,\n        data: repeat(0u8).take(width * height).collect(),\n    };\n\n    // Read image data\n    let len = img.data.len();\n    match file.read(&mut img.data) {\n        Ok(bytes_read) if bytes_read == len => println!(\"Read {} bytes\", bytes_read),\n        Ok(bytes_read) => println!(\"Error: read {} bytes, expected {}\", bytes_read, len),\n        Err(e) => println!(\"error reading: {}\", e),\n    }\n\n    img\n}\n\nfn save_pgm(img: &ImageGray8, filename: &str) {\n    // Open file\n    let mut file = BufWriter::new(File::create(filename).unwrap());\n\n    // Write header\n    if let Err(e) = writeln!(&mut file, \"P5\\n{}\\n{}\\n255\", img.width, img.height) {\n        println!(\"Failed to write header: {}\", e);\n    }\n\n    println!(\n        \"Writing pgm file {}: {} x {}\",\n        filename, img.width, img.height\n    );\n\n    // Write binary image data\n    if let Err(e) = file.write_all(&(img.data[..])) {\n        println!(\"Failed to image data: {}\", e);\n    }\n}\n\nfn hough(image: &ImageGray8, out_width: usize, out_height: usize) -> ImageGray8 {\n    let in_width = image.width;\n    let in_height = image.height;\n\n    // Allocate accumulation buffer\n    let out_height = ((out_height / 2) * 2) as usize;\n    let mut accum = ImageGray8 {\n        width: out_width,\n        height: out_height,\n        data: repeat(255).take(out_width * out_height).collect(),\n    };\n\n    // Transform extents\n    let rmax = (in_width as f64).hypot(in_height as f64);\n    let dr = rmax / (out_height / 2) as f64;\n    let dth = std::f64::consts::PI / out_width as f64;\n\n    // Process input image in raster order\n    for y in 0..in_height {\n        for x in 0..in_width {\n            let in_idx = y * in_width + x;\n            let col = image.data[in_idx];\n            if col == 255 {\n                continue;\n            }\n\n            // Project into rho,theta space\n            for jtx in 0..out_width {\n                let th = dth * (jtx as f64);\n                let r = (x as f64) * (th.cos()) + (y as f64) * (th.sin());\n\n                let iry = out_height / 2 - (r / (dr as f64) + 0.5).floor() as usize;\n                let out_idx = jtx + iry * out_width;\n                let col = accum.data[out_idx];\n                if col > 0 {\n                    accum.data[out_idx] = col - 1;\n                }\n            }\n        }\n    }\n    accum\n}\n\nfn main() {\n    let image = load_pgm(\"resources/Pentagon.pgm\");\n\n    let accum = hough(&image, 460, 360);\n\n    save_pgm(&accum, \"hough.pgm\");\n}\n",
    "path": "tasks/hough-transform",
    "remote_code": null,
    "title": "Hough transform",
    "url": "http://rosettacode.org/wiki/Hough_transform"
  },
  {
    "local_code": "// Implement data structures for a Huffman encoding tree:\nuse std::cmp::Ordering;\nuse std::cmp::Ordering::{Equal, Greater, Less};\nuse std::collections::hash_map::Entry::{Occupied, Vacant};\nuse std::collections::BinaryHeap;\nuse std::collections::HashMap;\n\n/// Each `HNode` has a weight, representing the sum of the frequencies for all its\n/// children. It is either a leaf (containing a character), or an `HTree` (containing two children)\nstruct HNode {\n    weight: usize,\n    item: HItem,\n}\n\nenum HItem {\n    Tree(HTreeData),\n    Leaf(char),\n}\n\nstruct HTreeData {\n    left: Box<HNode>,\n    right: Box<HNode>,\n}\n\n/// Implementing comparison traits (`Ord` and all its dependencies) such that the `HNode` with the\n/// greatest weight is the smallest in a comparison. Basically reversing all the comparison\n/// operators.\nimpl Ord for HNode {\n    fn cmp(&self, other: &HNode) -> Ordering {\n        match self.weight.cmp(&other.weight) {\n            Less => Greater,\n            Equal => Equal,\n            Greater => Less,\n        }\n    }\n}\n\nimpl PartialOrd for HNode {\n    fn partial_cmp(&self, other: &HNode) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Eq for HNode {}\nimpl PartialEq for HNode {\n    fn eq(&self, other: &HNode) -> bool {\n        self.weight == other.weight\n    }\n}\n\n/// Takes a non-empty string (function will fail if string is empty) and computes the Huffman\n/// encoding tree for that string.\nfn huffman_tree(input: &str) -> HNode {\n    // 1. Loop through all the characters in that string, adding them to a HashMap\n    //    of character to frequency.\n    let mut freq = HashMap::new();\n    for ch in input.chars() {\n        match freq.entry(ch) {\n            Vacant(entry) => {\n                entry.insert(1);\n            }\n            Occupied(mut entry) => {\n                *entry.get_mut() += 1;\n            }\n        };\n    }\n\n    // 2. For each (character, frequency) pair in the HashMap, add a Leaf to a\n    //    PriorityQueue\n    let mut queue = BinaryHeap::<HNode>::new();\n    for (ch, freq) in &freq {\n        let new_node = HNode {\n            weight: *freq,\n            item: HItem::Leaf(*ch),\n        };\n        queue.push(new_node);\n    }\n\n    // 3. Pop two items with the least weight from the queue, combine them into\n    //    a tree as children. The parent node's weight is the sum of the\n    //    children's weight. Continue until one item is left on the queue, and\n    //    return that item.\n    while queue.len() > 1 {\n        let item1 = queue.pop().unwrap();\n        let item2 = queue.pop().unwrap();\n        let new_node = HNode {\n            weight: item1.weight + item2.weight,\n            item: HItem::Tree(HTreeData {\n                left: Box::new(item1),\n                right: Box::new(item2),\n            }),\n        };\n        queue.push(new_node);\n    }\n    queue.pop().unwrap()\n}\n\n/// Takes a Huffman Tree, traverse it and build a table with each character and\n/// its encoding string.\nfn build_encoding_table(tree: &HNode, table: &mut HashMap<char, String>, start_str: &str) {\n    match tree.item {\n        HItem::Tree(ref data) => {\n            build_encoding_table(&data.left, table, &format!(\"{}0\", start_str)[..]);\n            build_encoding_table(&data.right, table, &format!(\"{}1\", start_str)[..]);\n        }\n        HItem::Leaf(ch) => {\n            table.insert(ch, start_str.to_string());\n        }\n    };\n}\n\n/// Attempts to construct a tree, and test that the construction is successful\n///\n/// ```\n///     7\n///    ----\n///   /    \\\n///  4:'4'  3\n///       -----\n///      /     \\\n///     2:'2'  1:'1'\n/// ```\n#[test]\nfn test_tree_construction() {\n    let to_encode = \"4444221\";\n    let tree = huffman_tree(to_encode);\n    assert!(tree.weight == 7);\n    let children = match tree.item {\n        HItem::Tree(data) => data,\n        HItem::Leaf(_) => panic!(\"Tree Missing Children!\"),\n    };\n    let left = &children.left;\n    let right = &children.right;\n    assert!(right.weight == 4);\n    assert!(left.weight == 3);\n    let right_char = match right.item {\n        HItem::Tree(_) => panic!(\"Node is not Leaf Node!\"),\n        HItem::Leaf(ch) => ch,\n    };\n    assert!(right_char == '4');\n    let children = match left.item {\n        HItem::Tree(ref data) => data,\n        HItem::Leaf(_) => panic!(\"Tree Missing Children!\"),\n    };\n    let left = &children.left;\n    let right = &children.right;\n    let left_char = match left.item {\n        HItem::Tree(_) => panic!(\"Node is not Leaf Node!\"),\n        HItem::Leaf(ch) => ch,\n    };\n    let right_char = match right.item {\n        HItem::Tree(_) => panic!(\"Node is not Leaf Node!\"),\n        HItem::Leaf(ch) => ch,\n    };\n    match (left.weight, right.weight) {\n        (1, 2) => {\n            assert!(left_char == '1');\n            assert!(right_char == '2');\n        }\n        (2, 1) => {\n            assert!(left_char == '2');\n            assert!(right_char == '1');\n        }\n        (_, _) => {\n            panic!(\"Incorrect Leaf Nodes\");\n        }\n    };\n}\n\n/// Constructs a table:\n///\n/// ```\n///  '4': 1\n///  '2': 01 OR 00\n///  '1': 00    01\n///  ```\n///\n/// And tests that the table was correctly constructed\n#[test]\nfn test_table_construction() {\n    let to_encode = \"4444221\";\n    let tree = huffman_tree(to_encode);\n    let mut table = HashMap::<char, String>::new();\n    build_encoding_table(&tree, &mut table, \"\");\n    let one = &*table[&'1'];\n    let two = &*table[&'2'];\n    let four = &*table[&'4'];\n    assert!(four == \"1\");\n    assert!((one == \"01\" && two == \"00\") || (one == \"00\" && two == \"01\"));\n}\n\nfn main() {\n    let to_encode = \"this is an example for huffman encoding\";\n    let tree = huffman_tree(to_encode);\n    let mut table = HashMap::<char, String>::new();\n    build_encoding_table(&tree, &mut table, \"\");\n\n    for (ch, encoding) in &table {\n        println!(\"{}: {}\", *ch, encoding);\n    }\n}\n",
    "path": "tasks/huffman-coding",
    "remote_code": "\nuse std::collections::BTreeMap;\nuse std::collections::binary_heap::BinaryHeap;\n\n#[derive(Debug, Eq, PartialEq)]\nenum NodeKind {\n    Internal(Box<Node>, Box<Node>),\n    Leaf(char),\n}\n\n#[derive(Debug, Eq, PartialEq)]\nstruct Node {\n    frequency: usize,\n    kind: NodeKind,\n}\n\nimpl Ord for Node {\n    fn cmp(&self, rhs: &Self) -> std::cmp::Ordering {\n        rhs.frequency.cmp(&self.frequency)\n    }\n}\n\nimpl PartialOrd for Node {\n    fn partial_cmp(&self, rhs: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(&rhs))\n    }\n}\n\ntype HuffmanCodeMap = BTreeMap<char, Vec<u8>>;\n\nfn main() {\n    let text = \"this is an example for huffman encoding\";\n\n    let mut frequencies = BTreeMap::new();\n    for ch in text.chars() {\n        *frequencies.entry(ch).or_insert(0) += 1;\n    }\n\n    let mut prioritized_frequencies = BinaryHeap::new();\n    for counted_char in frequencies {\n        prioritized_frequencies.push(Node {\n            frequency: counted_char.1,\n            kind: NodeKind::Leaf(counted_char.0),\n        });\n    }\n\n    while prioritized_frequencies.len() > 1 {\n        let left_child = prioritized_frequencies.pop().unwrap();\n        let right_child = prioritized_frequencies.pop().unwrap();\n        prioritized_frequencies.push(Node {\n            frequency: right_child.frequency + left_child.frequency,\n            kind: NodeKind::Internal(Box::new(left_child), Box::new(right_child)),\n        });\n    }\n\n    let mut codes = HuffmanCodeMap::new();\n    generate_codes(\n        prioritized_frequencies.peek().unwrap(),\n        vec![0u8; 0],\n        &mut codes,\n    );\n\n    for item in codes {\n        print!(\"{}: \", item.0);\n        for bit in item.1 {\n            print!(\"{}\", bit);\n        }\n        println!();\n    }\n}\n\nfn generate_codes(node: &Node, prefix: Vec<u8>, out_codes: &mut HuffmanCodeMap) {\n    match node.kind {\n        NodeKind::Internal(ref left_child, ref right_child) => {\n            let mut left_prefix = prefix.clone();\n            left_prefix.push(0);\n            generate_codes(&left_child, left_prefix, out_codes);\n\n            let mut right_prefix = prefix;\n            right_prefix.push(1);\n            generate_codes(&right_child, right_prefix, out_codes);\n        }\n        NodeKind::Leaf(ch) => {\n            out_codes.insert(ch, prefix);\n        }\n    }\n}\n",
    "title": "Huffman coding",
    "url": "http://rosettacode.org/wiki/Huffman_coding"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Humble numbers",
    "url": "http://rosettacode.org/wiki/Humble_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Hunt The Wumpus",
    "url": "http://rosettacode.org/wiki/Hunt_The_Wumpus"
  },
  {
    "local_code": "use std::fs::File;\nuse std::io::Read;\nuse std::path::Path;\n\nenum MatchState {\n    /// Nothing of interest seen so far\n    Nothing,\n\n    /// Last seen a 'c'\n    C,\n\n    /// Last seen a 'c' followed by an 'e'\n    Ce,\n\n    /// Last seen a 'c' followed by an 'i'\n    Ci,\n\n    /// Last seen an 'e' not preceded by a 'c'\n    E,\n\n    /// Last seen an 'i' not preceded by a 'c'\n    I,\n}\n\nstruct Occurrences {\n    cie: u32,\n    cei: u32,\n    ie: u32,\n    ei: u32,\n}\n\nfn count_occurrences(data: &str) -> Occurrences {\n    // The counting process is implemented by a state machine. The state variable\n    // tracks what pattern prefix was recognized so far (details at MatchState).\n    // Each time a full pattern is matched the corresponding saw_* variable is set\n    // to true to record its presence for the current word (They are not added\n    // directly to result to ensure that words having multiple occurrences of one\n    // pattern are only counted once.).\n    // At each word boundary add to result what was recorded and clear all state\n    // for next word.\n    let mut result = Occurrences {\n        cie: 0,\n        cei: 0,\n        ie: 0,\n        ei: 0,\n    };\n    let mut saw_cie = false;\n    let mut saw_cei = false;\n    let mut saw_ie = false;\n    let mut saw_ei = false;\n    let mut state = MatchState::Nothing;\n    for c in data.chars() {\n        state = match (state, c.to_lowercase().next().unwrap()) {\n            (_, '\\n') | (_, '\\r') => {\n                if saw_cie {\n                    result.cie += 1;\n                    saw_cie = false;\n                }\n                if saw_cei {\n                    result.cei += 1;\n                    saw_cei = false;\n                }\n                if saw_ie {\n                    result.ie += 1;\n                    saw_ie = false;\n                }\n                if saw_ei {\n                    result.ei += 1;\n                    saw_ei = false;\n                }\n                MatchState::Nothing\n            }\n            (_, 'c') => MatchState::C,\n            (MatchState::C, 'i') => MatchState::Ci,\n            (MatchState::Ce, 'i') => {\n                saw_cei = true;\n                MatchState::Nothing\n            }\n            (MatchState::E, 'i') => {\n                saw_ei = true;\n                MatchState::Nothing\n            }\n            (_, 'i') => MatchState::I,\n            (MatchState::C, 'e') => MatchState::Ce,\n            (MatchState::Ci, 'e') => {\n                saw_cie = true;\n                MatchState::Nothing\n            }\n            (MatchState::I, 'e') => {\n                saw_ie = true;\n                MatchState::Nothing\n            }\n            (_, 'e') => MatchState::E,\n            _ => MatchState::Nothing,\n        };\n    }\n    result\n}\n\nfn main() {\n    let path = Path::new(\"resources/unixdict.txt\");\n    let mut file = File::open(&path).unwrap();\n    let mut data = String::new();\n    file.read_to_string(&mut data).unwrap();\n    let occ = count_occurrences(&data);\n    println!(\n        \"I before E when not preceded by C is {} (ie: {}, cie: {})\",\n        if occ.ie > 2 * occ.cie {\n            \"plausible\"\n        } else {\n            \"implausible\"\n        },\n        occ.ie,\n        occ.cie\n    );\n    println!(\n        \"E before I when preceded by C is {} (cei: {}, ei: {})\",\n        if occ.cei > 2 * occ.ei {\n            \"plausible\"\n        } else {\n            \"implausible\"\n        },\n        occ.cei,\n        occ.ei\n    );\n}\n\n#[test]\nfn basic_test() {\n    let occ1 = count_occurrences(\"ceiling\\nclient\\nleisure\\n\");\n    assert_eq!(occ1.cie, 0);\n    assert_eq!(occ1.cei, 1);\n    assert_eq!(occ1.ie, 1);\n    assert_eq!(occ1.ei, 1);\n}\n",
    "path": "tasks/i-before-e-except-after-c",
    "remote_code": "use std::default::Default;\nuse std::ops::AddAssign;\n\nuse itertools::Itertools;\nuse reqwest::get;\n\n#[derive(Default, Debug)]\nstruct Feature<T> {\n    pub cie: T,\n    pub xie: T,\n    pub cei: T,\n    pub xei: T,\n}\n\nimpl AddAssign<Feature<bool>> for Feature<u64> {\n    fn add_assign(&mut self, rhs: Feature<bool>) {\n        self.cei += rhs.cei as u64;\n        self.xei += rhs.xei as u64;\n        self.cie += rhs.cie as u64;\n        self.xie += rhs.xie as u64;\n    }\n}\n\nfn check_feature(word: &str) -> Feature<bool> {\n    let mut feature: Feature<bool> = Default::default();\n\n    for window in word.chars().tuple_windows::<(char, char, char)>() {\n        match window {\n            ('c', 'e', 'i') => { feature.cei = true }\n            ('c', 'i', 'e') => { feature.cie = true }\n            (not_c, 'e', 'i') if not_c != 'c' => (feature.xei = true),\n            (not_c, 'i', 'e') if not_c != 'c' => (feature.xie = true),\n            _ => {}\n        }\n    }\n\n    feature\n}\n\n\nfn maybe_is_feature_plausible(feature_count: u64, opposing_count: u64) -> Option<bool> {\n    if feature_count > 2 * opposing_count { Some(true) } else if opposing_count > 2 * feature_count { Some(false) } else { None }\n}\n\nfn print_feature_plausibility(feature_plausibility: Option<bool>, feature_name: &str) {\n    let plausible_msg =\n        match feature_plausibility {\n            None => \" is implausible\",\n            Some(true) => \"is plausible\",\n            Some(false) => \"is definitely implausible\",\n        };\n\n    println!(\"{} {}\", feature_name, plausible_msg)\n}\n\nfn main() {\n    let mut res = get(\" http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\").unwrap();\n    let texts = res.text().unwrap();\n\n    let mut feature_count: Feature<u64> = Default::default();\n    for word in texts.lines() {\n        let feature = check_feature(word);\n        feature_count += feature;\n    }\n\n    println!(\"Counting {:#?}\", feature_count);\n\n    let xie_plausibility =\n        maybe_is_feature_plausible(feature_count.xie, feature_count.cie);\n    let cei_plausibility =\n        maybe_is_feature_plausible(feature_count.cei, feature_count.xei);\n\n    print_feature_plausibility(xie_plausibility, \"I before E when not preceded by C\");\n    print_feature_plausibility(cei_plausibility, \"E before I when preceded by C\");\n    println!(\"The rule in general is {}\",\n             if xie_plausibility.unwrap_or(false) && cei_plausibility.unwrap_or(false)\n             { \"Plausible\" } else { \"Implausible\" }\n    );\n}\n",
    "title": "I before E except after C",
    "url": "http://rosettacode.org/wiki/I_before_E_except_after_C"
  },
  {
    "local_code": "extern crate num;\n\nuse num::bigint::{BigInt, ToBigInt};\n\nfn main() {\n    if is_valid(\"GB82 WEST 1234 5698 7654 32\") {\n        println!(\"IBAN correctly validated!\");\n    } else {\n        println!(\"Invalid IBAN!\");\n    }\n}\n\n/// Returns true if the IBAN is valid\n/// See [Validating the IBAN][iban].\n///\n/// [iban]: http://en.wikipedia.org/wiki/International_Bank_Account_Number#Validating_the_IBAN\nfn is_valid(iban: &str) -> bool {\n    // Discard whitespace\n    let mut iban_chars: Vec<char> = iban.chars().filter(|c| !c.is_whitespace()).collect();\n\n    if iban_chars.len() < 2 {\n        return false;\n    }\n\n    // Check length of the IBAN\n    match country_length(&iban[..2]) {\n        Some(l) if l == iban_chars.len() => {}\n        _ => return false,\n    };\n\n    // Rearrange (first four characters go to the back)\n    for _ in 0..4 {\n        let front = iban_chars.remove(0);\n        iban_chars.push(front);\n    }\n\n    // Expand letters to digits\n    let iban_int = parse_digits(&iban_chars);\n\n    // Check if the remainder is one\n    match iban_int {\n        Some(x) => x % 97.to_bigint().unwrap() == 1.to_bigint().unwrap(),\n        None => false,\n    }\n}\n\n/// Returns a `BigInt` made from the digits and letters of the IBAN\nfn parse_digits(chars: &[char]) -> Option<BigInt> {\n    let mut vec: Vec<u8> = Vec::with_capacity(chars.len() + 10);\n\n    // Copy the digits to the vector and expand the letters to digits\n    for &c in chars {\n        match c.to_digit(36) {\n            Some(d) => vec.extend(d.to_string().bytes()),\n            None => return None,\n        }\n    }\n    // Since it was built from digits we know the vec is valid utf8, so we can just unwrap().\n    let as_str = String::from_utf8(vec).unwrap();\n    as_str.parse::<BigInt>().ok()\n}\n\nfn country_length(country_code: &str) -> Option<usize> {\n    let countries = [\n        (\"AL\", 28),\n        (\"AD\", 24),\n        (\"AT\", 20),\n        (\"AZ\", 28),\n        (\"BE\", 16),\n        (\"BH\", 22),\n        (\"BA\", 20),\n        (\"BR\", 29),\n        (\"BG\", 22),\n        (\"CR\", 21),\n        (\"HR\", 21),\n        (\"CY\", 28),\n        (\"CZ\", 24),\n        (\"DK\", 18),\n        (\"DO\", 28),\n        (\"EE\", 20),\n        (\"FO\", 18),\n        (\"FI\", 18),\n        (\"FR\", 27),\n        (\"GE\", 22),\n        (\"DE\", 22),\n        (\"GI\", 23),\n        (\"GR\", 27),\n        (\"GL\", 18),\n        (\"GT\", 28),\n        (\"HU\", 28),\n        (\"IS\", 26),\n        (\"IE\", 22),\n        (\"IL\", 23),\n        (\"IT\", 27),\n        (\"KZ\", 20),\n        (\"KW\", 30),\n        (\"LV\", 21),\n        (\"LB\", 28),\n        (\"LI\", 21),\n        (\"LT\", 20),\n        (\"LU\", 20),\n        (\"MK\", 19),\n        (\"MT\", 31),\n        (\"MR\", 27),\n        (\"MU\", 30),\n        (\"MC\", 27),\n        (\"MD\", 24),\n        (\"ME\", 22),\n        (\"NL\", 18),\n        (\"NO\", 15),\n        (\"PK\", 24),\n        (\"PS\", 29),\n        (\"PL\", 28),\n        (\"PT\", 25),\n        (\"RO\", 24),\n        (\"SM\", 27),\n        (\"SA\", 24),\n        (\"RS\", 22),\n        (\"SK\", 24),\n        (\"SI\", 19),\n        (\"ES\", 24),\n        (\"SE\", 24),\n        (\"CH\", 21),\n        (\"TN\", 24),\n        (\"TR\", 26),\n        (\"AE\", 23),\n        (\"GB\", 22),\n        (\"VG\", 24),\n    ];\n\n    countries\n        .iter()\n        .find(|&&(country, _)| country == country_code)\n        .map(|&(_, length)| length)\n}\n\n#[test]\nfn test_valid() {\n    assert!(is_valid(\"GB82 WEST 1234 5698 7654 32\"));\n    assert!(is_valid(\"BE18 0016 5492 3565\"));\n}\n\n#[test]\nfn test_wrong() {\n    assert!(!is_valid(\"ASDA FJAS DMAF BKDB AKGS DH\"));\n    assert!(!is_valid(\"XX82 WEST 1234 5698 7654 32\"));\n    assert!(!is_valid(\"BE18 0016 5492 3566\"));\n    assert!(!is_valid(\"BE18 0016 5492 3565 6\"));\n    assert!(!is_valid(\"BE18 0016 5492 356\"));\n    assert!(!is_valid(\"\"));\n}\n",
    "path": "tasks/iban",
    "remote_code": null,
    "title": "IBAN",
    "url": "http://rosettacode.org/wiki/IBAN"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nextern crate num;\nstruct Matrix<T> {\n    data: Vec<T>,\n    size: usize,\n}\n\nimpl<T> Matrix<T>\nwhere\n    T: num::Num + Clone + Copy,\n{\n    fn new(size: usize) -> Self {\n        Self {\n            data: vec![T::zero(); size * size],\n            size: size,\n        }\n    }\n    fn get(&mut self, x: usize, y: usize) -> T {\n        self.data[x + self.size * y]\n    }\n    fn identity(&mut self) {\n        for (i, item) in self.data.iter_mut().enumerate() {\n            *item = if i % (self.size + 1) == 0 {\n                T::one()\n            } else {\n                T::zero()\n            }\n        }\n    }\n}\n\nfn main() {\n    let size = std::env::args().nth(1).unwrap().parse().unwrap();\n    let mut matrix = Matrix::<i32>::new(size);\n    matrix.identity();\n    for y in 0..size {\n        for x in 0..size {\n            print!(\"{} \", matrix.get(x, y));\n        }\n        println!();\n    }\n}\n",
    "title": "Identity matrix",
    "url": "http://rosettacode.org/wiki/Identity_matrix"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Idiomatically determine all the characters that can be used for symbols",
    "url": "http://rosettacode.org/wiki/Idiomatically_determine_all_the_characters_that_can_be_used_for_symbols"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Idiomatically determine all the lowercase and uppercase letters",
    "url": "http://rosettacode.org/wiki/Idiomatically_determine_all_the_lowercase_and_uppercase_letters"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Image convolution",
    "url": "http://rosettacode.org/wiki/Image_convolution"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Image noise",
    "url": "http://rosettacode.org/wiki/Image_noise"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Imaginary base numbers",
    "url": "http://rosettacode.org/wiki/Imaginary_base_numbers"
  },
  {
    "local_code": "// The compiler will import either `hello_world.rs` or `hello_world/mod.rs` (if the first one\n// doesn't exist).\nmod hello_world;\n\n// You can import public functions, structs, etc. from a module with the `use` statement.\nuse hello_world::hello_world;\n\n// Additionally, third-party libraries (called `crates` in Rust) can be declared thusly:\nextern crate url;\n\nuse url::Url;\n\nfn main() {\n    // Call an imported function.\n    hello_world();\n\n    // Use a struct included from an external crate.\n    println!(\"{:?}\", Url::parse(\"http://rosettacode.org\").unwrap());\n\n    // Though uncommon, it is also possible to include source directly from files with the\n    // `include!` macro.\n    include!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/resources/include.rs\"));\n}\npub fn hello_world() {\n    println!(\"Hello world!\");\n}\nprintln!(\"Hello from included file!\")\n",
    "path": "tasks/include-a-file",
    "remote_code": "mod test;\n\nfn main() {\n    test::some_function();\n}",
    "title": "Include a file",
    "url": "http://rosettacode.org/wiki/Include_a_file"
  },
  {
    "local_code": "use std::num::ParseIntError;\n\nfn increment(input: &str) -> Result<String, ParseIntError> {\n    input.parse::<i64>().map(|num| (num + 1).to_string())\n}\n\nfn main() {\n    let s = \"-1\";\n    let s2 = increment(s).unwrap();\n    println!(\"{:?}\", s2);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::increment;\n\n    #[test]\n    fn numeric() {\n        assert_eq!(increment(\"47\").unwrap(), \"48\".to_owned());\n    }\n\n    #[test]\n    fn not_numeric() {\n        assert!(increment(\"abc\").is_err());\n    }\n}\n",
    "path": "tasks/increment-a-numerical-string",
    "remote_code": "fn next_string(input: &str) -> String {\n    (input.parse::<i64>().unwrap() + 1).to_string()\n}\n\nfn main() {\n    let s = \"-1\";\n    let s2 = next_string(s);\n    println!(\"{:?}\", s2);\n}",
    "title": "Increment a numerical string",
    "url": "http://rosettacode.org/wiki/Increment_a_numerical_string"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Index finite lists of positive integers",
    "url": "http://rosettacode.org/wiki/Index_finite_lists_of_positive_integers"
  },
  {
    "local_code": "fn main() {\n    let inf = ::std::f32::INFINITY;\n    println!(\"{}\", inf);\n}\n",
    "path": "tasks/infinity",
    "remote_code": "fn main() {\n    let inf = std::f32::INFINITY;\n    println!(\"{}\", inf);\n}",
    "title": "Infinity",
    "url": "http://rosettacode.org/wiki/Infinity"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Inheritance/Multiple",
    "url": "http://rosettacode.org/wiki/Inheritance/Multiple"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Inheritance/Single",
    "url": "http://rosettacode.org/wiki/Inheritance/Single"
  },
  {
    "local_code": "use std::io::{self, BufRead};\n\nfn main() {\n    let stdin = io::stdin();\n    for line in stdin.lock().lines() {\n        println!(\"{}\", line.unwrap());\n    }\n}\n",
    "path": "tasks/input-loop",
    "remote_code": null,
    "title": "Input loop",
    "url": "http://rosettacode.org/wiki/Input_loop"
  },
  {
    "local_code": "use std::io::{self, BufRead};\n\nfn main() {\n    let reader = io::stdin();\n    let lines = reader.lock().lines().take(2);\n    let nums = lines\n        .map(|string| string.unwrap().trim().parse().unwrap())\n        .collect::<Vec<i32>>();\n    let a = nums[0];\n    let b = nums[1];\n    if a < b {\n        println!(\"{} is less than {}\", a, b)\n    } else if a == b {\n        println!(\"{} equals {}\", a, b)\n    } else if a > b {\n        println!(\"{} is greater than {}\", a, b)\n    };\n}\n",
    "path": "tasks/integer-comparison",
    "remote_code": "use std::io::{self, BufRead};\n\nfn main() {\n    let mut reader = io::stdin();\n    let mut buffer = String::new();\n    let mut lines = reader.lock().lines().take(2);\n    let nums: Vec<i32>= lines.map(|string|\n        string.unwrap().trim().parse().unwrap()\n        ).collect();\n    let a: i32 = nums[0];\n    let b: i32 = nums[1];\n    if a < b {\n        println!(\"{} is less than {}\" , a , b)\n    } else if a == b {\n        println!(\"{} equals {}\" , a , b)\n    } else if a > b {\n        println!(\"{} is greater than {}\" , a , b)\n    };\n}",
    "title": "Integer comparison",
    "url": "http://rosettacode.org/wiki/Integer_comparison"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Integer overflow",
    "url": "http://rosettacode.org/wiki/Integer_overflow"
  },
  {
    "local_code": "extern crate num;\n\nuse num::{BigUint, One};\n\nfn main() {\n    let one: BigUint = One::one();\n    let mut i: BigUint = One::one();\n\n    loop {\n        println!(\"{}\", i);\n        i = &i + &one;\n    }\n}\n",
    "path": "tasks/integer-sequence",
    "remote_code": "fn main() {\n    for i in 0.. {\n        println!(\"{}\", i);\n    }\n}",
    "title": "Integer sequence",
    "url": "http://rosettacode.org/wiki/Integer_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Interactive programming",
    "url": "http://rosettacode.org/wiki/Interactive_programming"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Intersecting Number Wheels",
    "url": "http://rosettacode.org/wiki/Intersecting_Number_Wheels"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Introspection",
    "url": "http://rosettacode.org/wiki/Introspection"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Inverted index",
    "url": "http://rosettacode.org/wiki/Inverted_index"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Inverted syntax",
    "url": "http://rosettacode.org/wiki/Inverted_syntax"
  },
  {
    "local_code": "//! These are two naive solutions, one with lots of redundant calculations (memoizationless\n//! recursion) and one with a few precomputed values. All digit square sums are no greater than 648\n//! for numbers < 100,000,000.\n//!\n//! Both are slow algorithms, however, Rust is among faster languages, so this doesn't take minutes\n//! or hours.\n\nfn digit_square_sum(mut num: usize) -> usize {\n    let mut sum = 0;\n    while num != 0 {\n        sum += (num % 10).pow(2);\n        num /= 10;\n    }\n    sum\n}\n\nfn last_in_chain(num: usize) -> usize {\n    match num {\n        0 => 0,\n        1 | 89 => num,\n        _ => last_in_chain(digit_square_sum(num)),\n    }\n}\n\nfn main() {\n    let count = (1..100_000_000).filter(|&n| last_in_chain(n) == 89).count();\n    println!(\"{}\", count);\n\n    let precomputed = (0..649).map(last_in_chain).collect::<Vec<_>>();\n    let count = (1..100_000_000)\n        .filter(|&n| precomputed[digit_square_sum(n)] == 89)\n        .count();\n    println!(\"{}\", count);\n}\n\n/// Ignore these tests because they're pretty expensive on a non-release build.\n#[cfg(test)]\nmod tests {\n    use super::{digit_square_sum, last_in_chain};\n\n    #[test]\n    #[ignore]\n    fn naive() {\n        let count = (1..100_000_000).filter(|&n| last_in_chain(n) == 89).count();\n        assert_eq!(count, 85744333);\n    }\n\n    #[test]\n    #[ignore]\n    fn precomputation() {\n        let precomputed = (0..649).map(last_in_chain).collect::<Vec<_>>();\n        let count = (1..100_000_000)\n            .filter(|&n| precomputed[digit_square_sum(n)] == 89)\n            .count();\n        assert_eq!(count, 85744333);\n    }\n}\n",
    "path": "tasks/iterated-digits-squaring",
    "remote_code": "fn digit_square_sum(mut num: usize) -> usize {\n    let mut sum = 0;\n    while num != 0 {\n        sum += (num % 10).pow(2);\n        num /= 10;\n    }\n    sum\n}\n\nfn last_in_chain(num: usize) -> usize {\n    match num {\n        1 | 89 => num,\n        _ => last_in_chain(digit_square_sum(num)),\n    }\n}\n\nfn main() {\n    let count = (1..100_000_000).filter(|&n| last_in_chain(n) == 89).count();\n    println!(\"{}\", count);\n}",
    "title": "Iterated digits squaring",
    "url": "http://rosettacode.org/wiki/Iterated_digits_squaring"
  },
  {
    "local_code": "#[macro_use]\nextern crate serde_derive;\n\nextern crate serde;\nextern crate serde_json;\n\n#[derive(Debug, PartialEq, Eq, Serialize, Deserialize)]\npub struct Contact {\n    name: String,\n    city: String,\n}\n\nfn main() {\n    // Encode contact to json\n    let c = Contact {\n        name: \"John\".to_string(),\n        city: \"Paris\".to_string(),\n    };\n    let json = serde_json::to_string(&c).unwrap();\n    println!(\"Encoded: {:?}\", json);\n\n    // Decode json to contact\n    let json_str = r#\"{ \"name\": \"Alan\", \"city\": \"Tokyo\" }\"#;\n    let contact: Contact = serde_json::from_str(json_str).unwrap();\n    println!(\"Decoded: {:?}\", contact);\n}\n\n#[test]\nfn test_coherence() {\n    let c = Contact {\n        name: \"John\".to_string(),\n        city: \"Paris\".to_string(),\n    };\n    assert_eq!(\n        serde_json::from_str::<Contact>(&serde_json::to_string(&c).unwrap()).unwrap(),\n        c\n    );\n}\n\n#[test]\nfn test_decode() {\n    let json_str = r#\"{ \"name\": \"Alan\", \"city\": \"Tokyo\" }\"#;\n    let contact: Contact = serde_json::from_str(json_str).unwrap();\n    assert_eq!(\n        contact,\n        Contact {\n            name: \"Alan\".to_string(),\n            city: \"Tokyo\".to_string(),\n        }\n    );\n}\n",
    "path": "tasks/json",
    "remote_code": "extern crate rustc_serialize;\n\nuse rustc_serialize::json;\n\n#[derive(RustcDecodable, RustcEncodable)]\nstruct Penguin {\n    name : String,\n    born : i16\n}\nfn main() {\n    let pengu = Penguin { name : \"pengu\".to_string(), born : 1999 };\n    println!(\"{}\", json::encode(&pengu).unwrap());\n    let pingu : Penguin = json::decode(r##\"{\"name\":\"pingu\",\"born\":2001}\"##).unwrap();\n    assert_eq!(&pingu.name, \"pingu\");\n    assert_eq!(pingu.born, 2001);\n}",
    "title": "JSON",
    "url": "http://rosettacode.org/wiki/JSON"
  },
  {
    "local_code": "use std::cmp;\n\nfn jaro(str1: &str, str2: &str) -> f64 {\n    // lengths of both strings\n    let str1_len: usize = str1.len();\n    let str2_len: usize = str2.len();\n\n    // if both strings are empty return 1\n    // if only one of the strings is empty return 0\n    if str1_len == 0 {\n        if str2_len == 0 {\n            return 1.0;\n        } else {\n            return 0.0;\n        }\n    }\n\n    // max distance between two chars to be considered matching\n    let match_distance: isize = cmp::max(str1_len, str2_len) as isize / 2 - 1;\n\n    // mutable vectors of bools that signify if that char in the matching string has a match\n    let mut str1_matches: Vec<bool> = vec![false; str1_len];\n    let mut str2_matches: Vec<bool> = vec![false; str2_len];\n\n    // number of matches and transpositions\n    let mut matches: f64 = 0.0;\n    let mut transpositions: f64 = 0.0;\n\n    // find the matches\n    for (i, str1_match) in str1_matches.iter_mut().enumerate() {\n        // cast new variable i_isize for clarity\n        let i_isize = i as isize;\n        // start and end take into account the match distance\n        let start: usize = cmp::max(0, i_isize - match_distance) as usize;\n        let end: usize = cmp::min(i_isize + match_distance + 1, str2_len as isize) as usize;\n\n        for (k, str2_match) in str2_matches.iter_mut().enumerate().take(end).skip(start) {\n            // if str2 already has a match continue\n            if *str2_match {\n                continue;\n            }\n            // if str1 at i and str2 at k are not equal\n            if str1.chars().nth(i).unwrap() != str2.chars().nth(k).unwrap() {\n                continue;\n            }\n            // otherwise assume there is a match\n            *str1_match = true;\n            *str2_match = true;\n            matches += 1.0;\n            break;\n        }\n    }\n\n    // if there are no matches return 0\n    if matches == 0.0 {\n        return 0.0;\n    }\n\n    // count transpositions\n    let mut k = 0;\n    for (i, str1_match) in str1_matches.iter().enumerate() {\n        // if there are no matches in str1 continue\n        if !str1_match {\n            continue;\n        }\n        // while there is no match in str2 increment k\n        while !str2_matches[k] {\n            k += 1;\n        }\n        // increment transpositions\n        if str1.chars().nth(i).unwrap() != str2.chars().nth(k).unwrap() {\n            transpositions += 1.0;\n        }\n        k += 1;\n    }\n\n    // divide the number of transpositions by two as per the algorithm specs\n    transpositions /= 2.0;\n\n    // return the Jaro distance\n    ((matches / str1_len as f64)\n        + (matches / str2_len as f64)\n        + ((matches - transpositions) / matches))\n        / 3.0\n}\n\nfn main() {\n    println!(\"{}\", jaro(\"MARTHA\", \"MARHTA\"));\n    println!(\"{}\", jaro(\"DIXON\", \"DICKSONX\"));\n    println!(\"{}\", jaro(\"JELLYFISH\", \"SMELLYFISH\"));\n}\n\n#[test]\nfn test_jaro() {\n    use std::f64;\n\n    assert!((jaro(\"MARTHA\", \"MARHTA\") - 0.9444444444444445).abs() < f64::EPSILON);\n    assert!((jaro(\"DIXON\", \"DICKSONX\") - 0.7666666666666666).abs() < f64::EPSILON);\n    assert!((jaro(\"JELLYFISH\", \"SMELLYFISH\") - 0.8962962962962964).abs() < f64::EPSILON);\n}\n",
    "path": "tasks/jaro-distance",
    "remote_code": "use std::cmp;\n\npub fn jaro(s1: &str, s2: &str) -> f64 {\n    let s1_len = s1.len();\n    let s2_len = s2.len();\n    if s1_len == 0 && s2_len == 0 { return 1.0; }\n    let match_distance = cmp::max(s1_len, s2_len) / 2 - 1;\n    let mut s1_matches = vec![false; s1_len];\n    let mut s2_matches = vec![false; s2_len];\n    let mut m: isize = 0;\n    for i in 0..s1_len {\n        let start = cmp::max(0, i as isize - match_distance as isize) as usize;\n        let end = cmp::min(i + match_distance + 1, s2_len);\n        for j in start..end {\n            if !s2_matches[j] && s1.as_bytes()[i] == s2.as_bytes()[j] {\n                s1_matches[i] = true;\n                s2_matches[j] = true;\n                m += 1;\n                break;\n            }\n        }\n    }\n    if m == 0 { return 0.0; }\n    let mut t = 0.0;\n    let mut k = 0;\n    for i in 0..s1_len {\n        if s1_matches[i] {\n            while !s2_matches[k] { k += 1; }\n            if s1.as_bytes()[i] != s2.as_bytes()[k] { t += 0.5; }\n            k += 1;\n        }\n    }\n\n    let m = m as f64;\n    (m / s1_len as f64 + m / s2_len as f64 + (m  - t) / m) / 3.0\n}\n\nfn main() {\n    let pairs = [(\"MARTHA\", \"MARHTA\"), (\"DIXON\", \"DICKSONX\"), (\"JELLYFISH\", \"SMELLYFISH\")];\n    for p in pairs.iter() { println!(\"{}/{} = {}\", p.0, p.1, jaro(p.0, p.1)); }\n}",
    "title": "Jaro distance",
    "url": "http://rosettacode.org/wiki/Jaro_distance"
  },
  {
    "local_code": "use std::f32;\n\nfn harmonic_sum<F>(lo: usize, hi: usize, term: F) -> f32\nwhere\n    F: Fn(f32) -> f32,\n{\n    (lo..hi + 1).fold(0.0, |acc, item| acc + term(item as f32))\n}\n\nfn main() {\n    println!(\"{}\", harmonic_sum(1, 100, |i| 1.0 / i));\n}\n\n#[test]\nfn test_harm_sum() {\n    let term = |i| 1.0 / i;\n    assert!((harmonic_sum(1, 100, &term).abs() - 5.187378) < f32::EPSILON);\n    assert!((harmonic_sum(1, 50, &term).abs() - 4.4992056) < f32::EPSILON);\n    assert!((harmonic_sum(1, 1000, &term).abs() - 7.4854784) < f32::EPSILON);\n    assert!((harmonic_sum(1, 2, &term).abs() - 1.5) < f32::EPSILON);\n}\n",
    "path": "tasks/jensens-device",
    "remote_code": null,
    "title": "Jensen's Device",
    "url": "http://rosettacode.org/wiki/Jensen's_Device"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn count_jewels(stones: &str, jewels: &str) -> u8 {\n    let mut count: u8 = 0;\n    for cur_char in stones.chars() {\n        if jewels.contains(cur_char) {\n            count += 1;\n        }\n    }\n    count\n}\nfn main() {\n    println!(\"{}\", count_jewels(\"aAAbbbb\", \"aA\"));\n    println!(\"{}\", count_jewels(\"ZZ\", \"z\"));\n}\n",
    "title": "Jewels and Stones",
    "url": "http://rosettacode.org/wiki/Jewels_and_Stones"
  },
  {
    "local_code": "use std::cmp::{Eq, Ord};\n\nfn jortsort<T: Ord + Eq + Clone>(array: &[T]) -> bool {\n    // sort the array\n    let mut sorted_array = array.to_vec();\n    sorted_array.sort();\n\n    // compare to see if it was originally sorted\n    for i in 0..array.len() {\n        if array[i] != sorted_array[i] {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn main() {\n    let unsorted = [1, 3, 2];\n    if jortsort(&unsorted) {\n        println!(\"{:?} is sorted.\", unsorted);\n    } else {\n        println!(\"{:?} is unsorted.\", unsorted);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::jortsort;\n\n    #[test]\n    fn sorted() {\n        let sorted = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n        assert!(jortsort(&sorted))\n    }\n\n    #[test]\n    fn unsorted() {\n        let unsorted = [1, 3, 2];\n        assert!(!jortsort(&unsorted))\n    }\n}\n",
    "path": "tasks/jortsort",
    "remote_code": "use std::cmp::{Ord, Eq};\n\nfn jort_sort<T: Ord + Eq + Clone>(array: Vec<T>) -> bool {\n    // sort the array\n    let mut sorted_array = array.to_vec();\n    sorted_array.sort();\n    \n    // compare to see if it was originally sorted\n    for i in 0..array.len() {\n        if array[i] != sorted_array[i] {\n            return false;\n        }\n    }\n\n    return true;\n}",
    "title": "JortSort",
    "url": "http://rosettacode.org/wiki/JortSort"
  },
  {
    "local_code": "/// implementation based on observation:\n/// `josephus(n, k) == if n < 2 { 0 } else { (josephus(n - 1, k) + k) % n }`\nfn josephus(n: u32, k: u32) -> u32 {\n    let mut result = 0u32;\n    for i in 2..(n + 1) {\n        result = (result + k) % i;\n    }\n    result\n}\n\nfn main() {\n    let n = 5;\n    let k = 2;\n    println!(\"n: {} k: {} survivor: {}\", n, k, josephus(n, k));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::josephus;\n\n    #[test]\n    fn test() {\n        assert!(josephus(5, 2) == 2);\n        assert!(josephus(41, 3) == 30);\n    }\n}\n",
    "path": "tasks/josephus-problem",
    "remote_code": "const N: usize = 41;\nconst K: usize = 3;\nconst M: usize = 3;\nconst POSITION: usize = 5;\n\nfn main() {\n    let mut prisoners: Vec<usize> = Vec::new();\n    let mut executed: Vec<usize> = Vec::new();\n    for pos in 0..N {\n        prisoners.push(pos);\n    }\n\n    let mut to_kill: usize = 0;\n    let mut len: usize = prisoners.len();\n\n    while len > M {\n        to_kill = (to_kill + K - 1) % len;\n        executed.push(prisoners.remove(to_kill));\n        len -= 1;\n    }\n\n    println!(\"JOSEPHUS n={}, k={}, m={}\", N, K, M);\n    println!(\"Executed: {:?}\", executed);\n    println!(\"Executed position number {}: {}\", POSITION, executed[POSITION - 1]);\n    println!(\"Survivors: {:?}\", prisoners);\n}",
    "title": "Josephus problem",
    "url": "http://rosettacode.org/wiki/Josephus_problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Joystick position",
    "url": "http://rosettacode.org/wiki/Joystick_position"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate image;\n\nuse image::{ImageBuffer, Pixel, Rgb};\n\nfn main() {\n    // 4 : 3 ratio is nice\n    let width = 8000;\n    let height = 6000;\n\n    let mut img = ImageBuffer::new(width as u32, height as u32);\n\n    // constants to tweak for appearance\n    let cx = -0.9;\n    let cy = 0.27015;\n    let iterations = 110;\n\n    for x in 0..width {\n        for y in 0..height {\n            let inner_height = height as f32;\n            let inner_width = width as f32;\n            let inner_y = y as f32;\n            let inner_x = x as f32;\n\n            let mut zx = 3.0 * (inner_x - 0.5 * inner_width) / (inner_width);\n            let mut zy = 2.0 * (inner_y - 0.5 * inner_height) / (inner_height);\n\n            let mut i = iterations;\n\n            while zx * zx + zy * zy < 4.0 && i > 1 {\n                let tmp = zx * zx - zy * zy + cx;\n                zy = 2.0 * zx * zy + cy;\n                zx = tmp;\n                i -= 1;\n            }\n\n            // guesswork to make the rgb color values look okay\n            let r = (i << 3) as u8;\n            let g = (i << 5) as u8;\n            let b = (i << 4) as u8;\n            let pixel = Rgb::from_channels(r, g, b, 0);\n            img.put_pixel(x as u32, y as u32, pixel);\n        }\n    }\n\n    let _ = img.save(\"output.png\");\n\n}",
    "title": "Julia set",
    "url": "http://rosettacode.org/wiki/Julia_set"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Jump anywhere",
    "url": "http://rosettacode.org/wiki/Jump_anywhere"
  },
  {
    "local_code": "extern crate rand;\nextern crate time;\n\nuse std::cmp::Ordering;\nuse std::cmp::Ordering::Less;\nuse std::ops::Sub;\n\nuse rand::prelude::*;\nuse time::get_time;\n\n#[derive(Clone, PartialEq, Debug)]\nstruct Point {\n    pub coords: Vec<f32>,\n}\n\nimpl<'a, 'b> Sub<&'b Point> for &'a Point {\n    type Output = Point;\n\n    fn sub(self, rhs: &Point) -> Point {\n        assert_eq!(self.coords.len(), rhs.coords.len());\n        Point {\n            coords: self\n                .coords\n                .iter()\n                .zip(rhs.coords.iter())\n                .map(|(&x, &y)| x - y)\n                .collect(),\n        }\n    }\n}\n\nimpl Point {\n    fn norm_sq(&self) -> f32 {\n        self.coords.iter().map(|n| n * n).sum()\n    }\n}\n\nstruct KDTreeNode {\n    point: Point,\n    dim: usize,\n    // Construction could become faster if we use an arena allocator,\n    // but this is easier to use.\n    left: Option<Box<KDTreeNode>>,\n    right: Option<Box<KDTreeNode>>,\n}\n\nimpl KDTreeNode {\n    /// Create a new KDTreeNode around the `dim`th dimension.\n    /// Alternatively, we could dynamically determine the dimension to\n    /// split on by using the longest dimension.\n    pub fn new(points: &mut [Point], dim: usize) -> KDTreeNode {\n        let points_len = points.len();\n        if points_len == 1 {\n            return KDTreeNode {\n                point: points[0].clone(),\n                dim,\n                left: None,\n                right: None,\n            };\n        }\n\n        // Split around the median\n        let pivot = quickselect_by(points, points_len / 2, &|a, b| {\n            a.coords[dim].partial_cmp(&b.coords[dim]).unwrap()\n        });\n\n        let left = Some(Box::new(KDTreeNode::new(\n            &mut points[0..points_len / 2],\n            (dim + 1) % pivot.coords.len(),\n        )));\n        let right = if points.len() >= 3 {\n            Some(Box::new(KDTreeNode::new(\n                &mut points[points_len / 2 + 1..points_len],\n                (dim + 1) % pivot.coords.len(),\n            )))\n        } else {\n            None\n        };\n\n        KDTreeNode {\n            point: pivot.clone(),\n            dim,\n            left,\n            right,\n        }\n    }\n\n    pub fn find_nearest_neighbor<'a>(&'a self, point: &Point) -> (&'a Point, usize) {\n        self.find_nearest_neighbor_helper(point, &self.point, (point - &self.point).norm_sq(), 1)\n    }\n\n    fn find_nearest_neighbor_helper<'a>(\n        &'a self,\n        point: &Point,\n        best: &'a Point,\n        best_dist_sq: f32,\n        n_visited: usize,\n    ) -> (&'a Point, usize) {\n        let mut my_best = best;\n        let mut my_best_dist_sq = best_dist_sq;\n        let mut my_n_visited = n_visited;\n\n        // We should always examine the near side\n        if self.point.coords[self.dim] < point.coords[self.dim] && self.right.is_some() {\n            let (a, b) = self.right.as_ref().unwrap().find_nearest_neighbor_helper(\n                point,\n                my_best,\n                my_best_dist_sq,\n                my_n_visited,\n            );\n            my_best = a;\n            my_n_visited = b;\n        } else if self.left.is_some() {\n            let (a, b) = self.left.as_ref().unwrap().find_nearest_neighbor_helper(\n                point,\n                my_best,\n                my_best_dist_sq,\n                my_n_visited,\n            );\n            my_best = a;\n            my_n_visited = b;\n        }\n\n        // distance along this node's axis\n        let axis_dist_sq = (self.point.coords[self.dim] - point.coords[self.dim]).powi(2);\n        if axis_dist_sq <= my_best_dist_sq {\n            // self can only be nearer than best if axis_dist_sq is less than\n            // best_dist_sq because axis_dist_sq is a lower bound for\n            // self_dist_sq\n            let self_dist_sq = (point - &self.point).norm_sq();\n            if self_dist_sq < my_best_dist_sq {\n                my_best = &self.point;\n                my_best_dist_sq = self_dist_sq;\n            }\n\n            // bookkeeping\n            my_n_visited += 1;\n\n            // same reasoning applies for the far side of the split\n            if self.point.coords[self.dim] < point.coords[self.dim] && self.left.is_some() {\n                let (a, b) = self.left.as_ref().unwrap().find_nearest_neighbor_helper(\n                    point,\n                    my_best,\n                    my_best_dist_sq,\n                    my_n_visited,\n                );\n                my_best = a;\n                my_n_visited = b;\n            } else if self.right.is_some() {\n                let (a, b) = self.right.as_ref().unwrap().find_nearest_neighbor_helper(\n                    point,\n                    my_best,\n                    my_best_dist_sq,\n                    my_n_visited,\n                );\n                my_best = a;\n                my_n_visited = b;\n            }\n        }\n\n        (my_best, my_n_visited)\n    }\n}\n\npub fn main() {\n    let mut rng = thread_rng();\n\n    // wordpress\n    let mut wp_points: Vec<Point> = [\n        [2.0, 3.0],\n        [5.0, 4.0],\n        [9.0, 6.0],\n        [4.0, 7.0],\n        [8.0, 1.0],\n        [7.0, 2.0],\n    ]\n    .iter()\n    .map(|x| Point { coords: x.to_vec() })\n    .collect();\n    let wp_tree = KDTreeNode::new(&mut wp_points, 0);\n\n    let wp_target = Point {\n        coords: vec![9.0, 2.0],\n    };\n    let (point, n_visited) = wp_tree.find_nearest_neighbor(&wp_target);\n    println!(\"Wikipedia example data:\");\n    println!(\"Point: [9, 2]\");\n    println!(\"Nearest neighbor: {:?}\", point);\n    println!(\"Distance: {}\", (point - &wp_target).norm_sq().sqrt());\n    println!(\"Nodes visited: {}\", n_visited);\n\n    // randomly generated 3D\n    let n_random = 1000;\n    let mut make_random_point = || Point {\n        coords: (0..3).map(|_| (rng.gen::<f32>() - 0.5) * 1000.0).collect(),\n    };\n    let mut random_points: Vec<Point> = (0..n_random).map(|_| make_random_point()).collect();\n\n    let start_cons_time = get_time();\n    let random_tree = KDTreeNode::new(&mut random_points, 0);\n    let end_cons_time = get_time();\n    println!(\n        \"1,000 3d points (Construction time: {}ms)\",\n        ((end_cons_time.sec - start_cons_time.sec) * 1000) as f32\n            + ((end_cons_time.nsec - start_cons_time.nsec) as f32) / 1_000_000f32\n    );\n\n    let random_target = make_random_point();\n\n    let (point, n_visited) = random_tree.find_nearest_neighbor(&random_target);\n    println!(\"Point: {:?}\", random_target);\n    println!(\"Nearest neighbor: {:?}\", point);\n    println!(\"Distance: {}\", (point - &random_target).norm_sq().sqrt());\n    println!(\"Nodes visited: {}\", n_visited);\n\n    // benchmark search time\n    let n_searches = 1000;\n    let random_targets: Vec<Point> = (0..n_searches).map(|_| make_random_point()).collect();\n\n    let start_search_time = get_time();\n    let mut total_n_visited = 0;\n    for target in &random_targets {\n        let (_, n_visited) = random_tree.find_nearest_neighbor(target);\n        total_n_visited += n_visited;\n    }\n    let end_search_time = get_time();\n    println!(\n        \"Visited an average of {} nodes on {} searches in {} ms\",\n        total_n_visited as f32 / n_searches as f32,\n        n_searches,\n        ((end_search_time.sec - start_search_time.sec) * 1000) as f32\n            + ((end_search_time.nsec - start_search_time.nsec) as f32) / 1_000_000f32\n    );\n}\n\nfn quickselect_by<T>(arr: &mut [T], position: usize, cmp: &dyn Fn(&T, &T) -> Ordering) -> T\nwhere\n    T: Clone,\n{\n    // We use `thread_rng` here because it was already initialized in `main`.\n    let mut pivot_index = thread_rng().gen_range(0, arr.len());\n    // Need to wrap in another closure or we get ownership complaints.\n    // Tried using an unboxed closure to get around this but couldn't get it to work.\n    pivot_index = partition_by(arr, pivot_index, &|a: &T, b: &T| cmp(a, b));\n    let array_len = arr.len();\n    if position == pivot_index {\n        arr[position].clone()\n    } else if position < pivot_index {\n        quickselect_by(&mut arr[0..pivot_index], position, cmp)\n    } else {\n        quickselect_by(\n            &mut arr[pivot_index + 1..array_len],\n            position - pivot_index - 1,\n            cmp,\n        )\n    }\n}\n\nfn partition_by<T>(arr: &mut [T], pivot_index: usize, cmp: &dyn Fn(&T, &T) -> Ordering) -> usize {\n    let array_len = arr.len();\n    arr.swap(pivot_index, array_len - 1);\n    let mut store_index = 0;\n    for i in 0..array_len - 1 {\n        if cmp(&arr[i], &arr[array_len - 1]) == Less {\n            arr.swap(i, store_index);\n            store_index += 1;\n        }\n    }\n    arr.swap(array_len - 1, store_index);\n    store_index\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{KDTreeNode, Point};\n\n    #[test]\n    fn wp() {\n        let mut wp_points: Vec<Point> = [\n            [2.0, 3.0],\n            [5.0, 4.0],\n            [9.0, 6.0],\n            [4.0, 7.0],\n            [8.0, 1.0],\n            [7.0, 2.0],\n        ]\n        .iter()\n        .map(|x| Point { coords: x.to_vec() })\n        .collect();\n        let wp_tree = KDTreeNode::new(&mut wp_points, 0);\n\n        let wp_target = Point {\n            coords: vec![9.0, 2.0],\n        };\n        let (point, _) = wp_tree.find_nearest_neighbor(&wp_target);\n        assert_eq!(\n            *point,\n            Point {\n                coords: vec![8.0, 1.0],\n            }\n        );\n    }\n}\n",
    "path": "tasks/k-d-tree",
    "remote_code": null,
    "title": "K-d tree",
    "url": "http://rosettacode.org/wiki/K-d_tree"
  },
  {
    "local_code": "extern crate csv;\nextern crate gnuplot;\nextern crate nalgebra;\nextern crate rand;\nextern crate structopt;\n\nuse std::f64::consts::PI;\nuse std::fs::File;\nuse std::path::PathBuf;\n\nuse gnuplot::{Axes2D, AxesCommon, Color, Figure, Fix, PointSize, PointSymbol};\nuse nalgebra::DVector;\nuse rand::distributions::Uniform;\nuse rand::prelude::*;\nuse structopt::StructOpt;\n\ntype Point = DVector<f64>;\n\nstruct Cluster<'a> {\n    members: Vec<&'a Point>,\n    center: Point,\n}\n\nstruct Stats {\n    centroids: Vec<Point>,\n    mean_d_from_centroid: DVector<f64>,\n}\n\n/// `DVector` doesn't implement `BaseFloat`, so a custom distance function is required.\nfn sqdist(p1: &Point, p2: &Point) -> f64 {\n    (p1.clone() - p2.clone()).iter().map(|x| x * x).sum()\n}\n\n/// Returns (distance^2, index) tuple of winning point.\nfn nearest(p: &Point, candidates: &[Point]) -> (f64, usize) {\n    let (dsquared, the_index) =\n        candidates\n            .iter()\n            .enumerate()\n            .fold((sqdist(p, &candidates[0]), 0), |(d, index), next| {\n                let dprime = sqdist(p, &candidates[next.0]);\n                if dprime < d {\n                    (dprime, next.0)\n                } else {\n                    (d, index)\n                }\n            });\n    (dsquared, the_index)\n}\n\n/// Computes starting centroids and makes initial assignments.\nfn kpp(points: &[Point], k: usize, rng: &mut impl Rng) -> Stats {\n    let mut centroids: Vec<Point> = Vec::new();\n    // Random point for first centroid guess:\n    centroids.push(points.choose(rng).unwrap().clone());\n    let mut dists: Vec<f64> = vec![0f64; points.len()];\n\n    for _ in 1..k {\n        let mut sum = 0.0;\n        for (j, p) in points.iter().enumerate() {\n            let (dsquared, _) = nearest(p, &centroids);\n            dists[j] = dsquared;\n            sum += dsquared;\n        }\n\n        // This part chooses the next cluster center with a probability proportional to d^2\n        sum *= rng.gen::<f64>();\n        for (j, d) in dists.iter().enumerate() {\n            sum -= *d;\n            if sum <= 0f64 {\n                centroids.push(points[j].clone());\n                break;\n            }\n        }\n    }\n\n    let clusters = assign_clusters(points, &centroids);\n    compute_stats(&clusters)\n}\n\nfn assign_clusters<'a>(points: &'a [Point], centroids: &[Point]) -> Vec<Cluster<'a>> {\n    let mut clusters: Vec<Cluster> = Vec::new();\n\n    for _ in 0..centroids.len() {\n        clusters.push(Cluster {\n            members: Vec::new(),\n            center: DVector::zeros(points[0].len()),\n        });\n    }\n\n    for p in points.iter() {\n        let (_, nearest_index) = nearest(p, centroids);\n        clusters[nearest_index].center = clusters[nearest_index].center.clone() + p.clone();\n        clusters[nearest_index].members.push(p);\n    }\n\n    for cluster in &mut clusters {\n        cluster.center = cluster.center.clone() / cluster.members.len() as f64;\n    }\n\n    clusters\n}\n\n/// Computes centroids and mean-distance-from-centroid for each cluster.\nfn compute_stats(clusters: &[Cluster]) -> Stats {\n    let mut centroids = Vec::new();\n    let mut means_vec = Vec::new();\n\n    for c in clusters.iter() {\n        let pts = &c.members;\n        let seed: DVector<f64> = DVector::zeros(pts[0].len());\n        let centroid = pts.iter().fold(seed, |a, &b| a + b.clone()) / pts.len() as f64;\n        means_vec.push(\n            pts.iter()\n                .fold(0f64, |acc, pt| acc + sqdist(pt, &centroid).sqrt())\n                / pts.len() as f64,\n        );\n        centroids.push(centroid);\n    }\n\n    Stats {\n        centroids: centroids,\n        mean_d_from_centroid: DVector::from_row_slice(means_vec.len(), means_vec.as_slice()),\n    }\n}\n\nfn lloyd<'a>(\n    points: &'a [Point],\n    k: usize,\n    stoppage_delta: f64,\n    max_iter: u32,\n    rng: &mut impl Rng,\n) -> (Vec<Cluster<'a>>, Stats) {\n    let mut clusters = Vec::new();\n    // Choose starting centroids and make initial assignments\n    let mut stats = kpp(points, k, rng);\n\n    for i in 1..max_iter {\n        let last_means: DVector<f64> = stats.mean_d_from_centroid.clone();\n        clusters = assign_clusters(points, &stats.centroids);\n        stats = compute_stats(&clusters);\n        let err = sqdist(&stats.mean_d_from_centroid, &last_means).sqrt();\n        if err < stoppage_delta {\n            println!(\"Stoppage condition reached on iteration {}\", i);\n            return (clusters, stats);\n        }\n        // Console output\n        print!(\"Iter {}: \", i);\n        for (cen, mu) in stats\n            .centroids\n            .iter()\n            .zip(stats.mean_d_from_centroid.iter())\n        {\n            print_dvec(cen);\n            print!(\" {:1.2} | \", mu);\n        }\n        print!(\"{:1.5}\\n\", err);\n    }\n\n    println!(\"Stoppage condition not reached by iteration {}\", max_iter);\n    (clusters, stats)\n}\n\n/// Uniform sampling on the unit disk.\nfn generate_points(n: u32, rng: &mut impl Rng) -> Vec<Point> {\n    // `Uniform` rather than `gen_range`'s `Uniform::sample_single` for speed\n    let range = Uniform::new(0.0, 2.0 * PI);\n\n    (0..n)\n        .map(|_| {\n            let root_r = rng.gen::<f64>();\n            let theta = rng.sample(range);\n            DVector::<f64>::from_row_slice(2, &[root_r * theta.cos(), root_r * theta.sin()])\n        })\n        .collect()\n}\n\n// Plot clusters (2d only). Closure idiom allows us to borrow and mutate the Axes2D.\nfn viz(clusters: &[Cluster], stats: &Stats, k: usize, n: u32, e: f64) {\n    let mut fg = Figure::new();\n    {\n        let prep = |fg: &mut Figure| {\n            let axes: &mut Axes2D = fg.axes2d();\n            let title: String = format!(\"k = {}, n = {}, e = {:4}\", k, n, e);\n            let centroids_x = stats.centroids.iter().map(|c| c[0]);\n            let centroids_y = stats.centroids.iter().map(|c| c[1]);\n            for cluster in clusters.iter() {\n                axes.points(\n                    cluster.members.iter().map(|p| p[0]),\n                    cluster.members.iter().map(|p| p[1]),\n                    &[PointSymbol('O'), PointSize(0.25)],\n                );\n            }\n            axes.set_aspect_ratio(Fix(1.0))\n                .points(\n                    centroids_x,\n                    centroids_y,\n                    &[PointSymbol('o'), PointSize(1.5), Color(\"black\")],\n                )\n                .set_title(&title[..], &[]);\n        };\n        prep(&mut fg);\n    }\n    fg.show();\n}\n\nfn print_dvec(v: &DVector<f64>) {\n    print!(\"(\");\n    for elem in v.iter().take(v.len() - 1) {\n        print!(\"{:+1.2}, \", elem)\n    }\n    print!(\"{:+1.2})\", v.iter().last().unwrap());\n}\n\nfn unseeded_stdrng() -> StdRng {\n    let mut seed = <StdRng as SeedableRng>::Seed::default();\n    for (i, x) in seed.iter_mut().enumerate() {\n        *x = i as u8;\n    }\n    StdRng::from_seed(seed)\n}\n\n#[derive(Debug, StructOpt)]\nstruct Opt {\n    /// Number of clusters to assign\n    #[structopt(short = \"k\", default_value = \"7\")]\n    clusters: usize,\n\n    /// Operate on this many points on the unit disk\n    #[structopt(short = \"n\", default_value = \"30000\")]\n    points: u32,\n\n    /// Min delta in norm of successive cluster centroids to continue\n    #[structopt(short = \"e\", default_value = \"1e-3\")]\n    epsilon: f64,\n\n    /// Read points from file (overrides -n)\n    #[structopt(short = \"f\", parse(from_os_str))]\n    csv: Option<PathBuf>,\n}\n\nfn main() {\n    let mut opt = Opt::from_args();\n    const MAX_ITERATIONS: u32 = 100u32;\n\n    let mut rng = unseeded_stdrng();\n\n    let points = if let Some(filename) = opt.csv {\n        let mut points = Vec::new();\n        let mut rdr = csv::Reader::from_reader(File::open(&filename).unwrap());\n        for row in rdr.deserialize() {\n            let floats: Vec<f64> = row.unwrap();\n            points.push(DVector::<f64>::from_row_slice(\n                floats.len(),\n                floats.as_slice(),\n            ));\n        }\n        assert!(points.iter().all(|v| v.len() == points[0].len()));\n        opt.points = points.len() as u32;\n        println!(\"Read {} points from {}\", points.len(), filename.display());\n        points\n    } else {\n        // Proceed with random 2d data\n        generate_points(opt.points, &mut rng)\n    };\n\n    assert!(points.len() >= opt.clusters);\n    let (clusters, stats) = lloyd(&points, opt.clusters, opt.epsilon, MAX_ITERATIONS, &mut rng);\n\n    println!(\n        \" k       centroid{}mean dist    pop\",\n        std::iter::repeat(\" \")\n            .take((points[0].len() - 2) * 7 + 7)\n            .collect::<String>()\n    );\n    println!(\n        \"===  {}  ===========  =====\",\n        std::iter::repeat(\"=\")\n            .take(points[0].len() * 7 + 2)\n            .collect::<String>()\n    );\n    for (i, cluster) in clusters.iter().enumerate() {\n        print!(\" {:>1}    \", i);\n        print_dvec(&stats.centroids[i]);\n        print!(\n            \"      {:1.2}       {:>4}\\n\",\n            stats.mean_d_from_centroid[i],\n            cluster.members.len()\n        );\n    }\n\n    if points[0].len() == 2 {\n        viz(&clusters, &stats, opt.clusters, opt.points, opt.epsilon)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{generate_points, lloyd, unseeded_stdrng};\n\n    #[test]\n    fn test_lloyd2d() {\n        let mut rng = unseeded_stdrng();\n        let points = generate_points(1000, &mut rng);\n\n        let (clusters, stats) = lloyd(&points, 4, 0.001, 100, &mut rng);\n\n        assert!(clusters.len() == 4);\n        for i in 0..clusters.len() {\n            assert!(clusters[i].members.len() > 0);\n        }\n        assert!(stats.mean_d_from_centroid.iter().all(|d| *d > 0f64));\n        assert!(stats.centroids.iter().any(|p| p[0] >= 0f64 && p[1] >= 0f64));\n        assert!(stats.centroids.iter().any(|p| p[0] >= 0f64 && p[1] < 0f64));\n        assert!(stats.centroids.iter().any(|p| p[0] < 0f64 && p[1] < 0f64));\n        assert!(stats.centroids.iter().any(|p| p[0] < 0f64 && p[1] >= 0f64));\n    }\n}\n",
    "path": "tasks/k-meanspp-clustering",
    "remote_code": "extern crate csv;\nextern crate getopts;\nextern crate gnuplot;\nextern crate nalgebra;\nextern crate num;\nextern crate rand;\nextern crate rustc_serialize;\nextern crate test;\n\nuse getopts::Options;\nuse gnuplot::{Axes2D, AxesCommon, Color, Figure, Fix, PointSize, PointSymbol};\nuse nalgebra::{DVector, Iterable};\nuse rand::{Rng, SeedableRng, StdRng};\nuse rand::distributions::{IndependentSample, Range};\nuse std::f64::consts::PI;\nuse std::env;\n\ntype Point = DVector<f64>;\n\nstruct Cluster<'a> {\n    members: Vec<&'a Point>,\n    center: Point,\n}\n\nstruct Stats {\n    centroids: Vec<Point>,\n    mean_d_from_centroid: DVector<f64>,\n}\n\n/// DVector doesn't implement BaseFloat, so a custom distance function is required.\nfn sqdist(p1: &Point, p2: &Point) -> f64 {\n    (p1.clone() - p2.clone()).iter().map(|x| x * x).fold(0f64, |a, b| a + b)\n}\n\n/// Returns (distance^2, index) tuple of winning point.\nfn nearest(p: &Point, candidates: &Vec<Point>) -> (f64, usize) {\n    let (dsquared, the_index) = candidates.iter()\n                                          .enumerate()\n                                          .fold((sqdist(p, &candidates[0]), 0),\n                                                |(d, index), next| {\n                                                    let dprime = sqdist(p, &candidates[next.0]);\n                                                    if dprime < d {\n                                                        (dprime, next.0)\n                                                    } else {\n                                                        (d, index)\n                                                    }\n                                                });\n    (dsquared, the_index)\n}\n\n/// Computes starting centroids and makes initial assignments.\nfn kpp(points: &Vec<Point>, k: usize, rng: &mut StdRng) -> Stats {\n    let mut centroids: Vec<Point> = Vec::new();\n    // Random point for first centroid guess:\n    centroids.push(points[rng.gen::<usize>() % points.len()].clone());\n    let mut dists: Vec<f64> = vec![0f64; points.len()];\n\n    for _ in 1..k {\n        let mut sum = 0f64;\n        for (j, p) in points.iter().enumerate() {\n            let (dsquared, _) = nearest(&p, &centroids);\n            dists[j] = dsquared;\n            sum += dsquared;\n        }\n\n        // This part chooses the next cluster center with a probability proportional to d^2\n        sum *= rng.next_f64();\n        for (j, d) in dists.iter().enumerate() {\n            sum -= *d;\n            if sum <= 0f64 {\n                centroids.push(points[j].clone());\n                break;\n            }\n        }\n    }\n\n    let clusters = assign_clusters(points, &centroids);\n    compute_stats(&clusters)\n}\n\nfn assign_clusters<'a>(points: &'a Vec<Point>, centroids: &Vec<Point>) -> Vec<Cluster<'a>> {\n    let mut clusters: Vec<Cluster> = Vec::new();\n\n    for _ in 0..centroids.len() {\n        clusters.push(Cluster {\n            members: Vec::new(),\n            center: DVector::new_zeros(points[0].len()),\n        });\n    }\n\n    for p in points.iter() {\n        let (_, nearest_index) = nearest(p, centroids);\n        clusters[nearest_index].center = clusters[nearest_index].center.clone() + p.clone();\n        clusters[nearest_index].members.push(p);\n    }\n\n    for i in 0..clusters.len() {\n        clusters[i].center = clusters[i].center.clone() / clusters[i].members.len() as f64;\n    }\n\n    clusters\n}\n\n/// Computes centroids and mean-distance-from-centroid for each cluster.\nfn compute_stats(clusters: &Vec<Cluster>) -> Stats {\n    let mut centroids = Vec::new();\n    let mut means_vec = Vec::new();\n\n    for c in clusters.iter() {\n        let pts = &c.members;\n        let seed: DVector<f64> = DVector::new_zeros(pts[0].len());\n        let centroid = pts.iter().fold(seed, |a, &b| a + b.clone()) / pts.len() as f64;\n        means_vec.push(pts.iter().fold(0f64, |acc, pt| acc + sqdist(pt, &centroid).sqrt()) /\n                       pts.len() as f64);\n        centroids.push(centroid);\n    }\n\n    Stats {\n        centroids: centroids,\n        mean_d_from_centroid: DVector::from_slice(means_vec.len(), means_vec.as_slice()),\n    }\n}\n\nfn lloyd<'a>(points: &'a Vec<Point>,\n             k: usize,\n             stoppage_delta: f64,\n             max_iter: u32,\n             rng: &mut StdRng)\n             -> (Vec<Cluster<'a>>, Stats) {\n\n    let mut clusters = Vec::new();\n    // Choose starting centroids and make initial assignments\n    let mut stats = kpp(points, k, rng);\n\n    for i in 1..max_iter {\n        let last_means: DVector<f64> = stats.mean_d_from_centroid.clone();\n        clusters = assign_clusters(points, &stats.centroids);\n        stats = compute_stats(&clusters);\n        let err = sqdist(&stats.mean_d_from_centroid, &last_means).sqrt();\n        if err < stoppage_delta {\n            println!(\"Stoppage condition reached on iteration {}\", i);\n            return (clusters, stats);\n        }\n        // Console output\n        print!(\"Iter {}: \", i);\n        for (cen, mu) in stats.centroids.iter().zip(stats.mean_d_from_centroid.iter()) {\n            print_dvec(cen);\n            print!(\" {:1.2} | \", mu);\n        }\n        print!(\"{:1.5}\\n\", err);\n    }\n\n    println!(\"Stoppage condition not reached by iteration {}\", max_iter);\n    (clusters, stats)\n}\n\n/// Uniform sampling on the unit disk.\nfn generate_points(n: u32, rng: &mut StdRng) -> Vec<Point> {\n    let r_range = Range::new(0f64, 1f64);\n    let theta_range = Range::new(0f64, 2f64 * PI);\n    let mut points: Vec<Point> = Vec::new();\n\n    for _ in 0..n {\n        let root_r = r_range.ind_sample(rng).sqrt();\n        let theta = theta_range.ind_sample(rng);\n        points.push(DVector::<f64>::from_slice(2, &[root_r * theta.cos(), root_r * theta.sin()]));\n    }\n\n    points\n}\n\n// Plot clusters (2d only). Closure idiom allows us to borrow and mutate the Axes2D.\nfn viz(clusters: Vec<Cluster>, stats: Stats, k: usize, n: u32, e: f64) {\n    let mut fg = Figure::new();\n    {\n        let prep = |fg: &mut Figure| {\n            let axes: &mut Axes2D = fg.axes2d();\n            let title: String = format!(\"k = {}, n = {}, e = {:4}\", k, n, e);\n            let centroids_x = stats.centroids.iter().map(|c| c[0]);\n            let centroids_y = stats.centroids.iter().map(|c| c[1]);\n            for cluster in clusters.iter() {\n                axes.points(cluster.members.iter().map(|p| p[0]),\n                            cluster.members\n                                   .iter()\n                                   .map(|p| p[1]),\n                            &[PointSymbol('O'), PointSize(0.25)]);\n            }\n            axes.set_aspect_ratio(Fix(1.0))\n                .points(centroids_x,\n                        centroids_y,\n                        &[PointSymbol('o'), PointSize(1.5), Color(\"black\")])\n                .set_title(&title[..], &[]);\n        };\n        prep(&mut fg);\n    }\n    fg.show();\n}\n\nfn print_dvec(v: &DVector<f64>) {\n    print!(\"(\");\n    for elem in v.at.iter().take(v.len() - 1) {\n        print!(\"{:+1.2}, \", elem)\n    }\n    print!(\"{:+1.2})\", v.at.iter().last().unwrap());\n}\n\nfn print_usage(program: &str, opts: Options) {\n    let brief = format!(\"Usage: {} [options]\", program);\n    print!(\"{}\", opts.usage(&brief));\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut k: usize = 7;\n    let mut n: u32 = 30000;\n    let mut e: f64 = 1e-3;\n    let max_iterations = 100u32;\n\n    let mut opts = Options::new();\n    opts.optflag(\"?\", \"help\", \"Print this help menu\");\n    opts.optopt(\"k\",\n                \"\",\n                \"Number of clusters to assign (default: 7)\",\n                \"<clusters>\");\n    opts.optopt(\"n\",\n                \"\",\n                \"Operate on this many points on the unit disk (default: 30000)\",\n                \"<pts>\");\n    opts.optopt(\"e\",\n                \"\",\n                \"Min delta in norm of successive cluster centroids to continue (default: 1e-3)\",\n                \"<eps>\");\n    opts.optopt(\"f\", \"\", \"Read points from file (overrides -n)\", \"<csv>\");\n\n    let program = args[0].clone();\n    let matches = match opts.parse(&args[1..]) {\n        Ok(m) => m,\n        Err(f) => panic!(f.to_string()),\n    };\n    if matches.opt_present(\"?\") {\n        print_usage(&program, opts);\n        return;\n    }\n    match matches.opt_str(\"k\") {\n        None => {}\n        Some(x) => k = x.parse::<usize>().unwrap(),\n    };\n    match matches.opt_str(\"n\") {\n        None => {}\n        Some(x) => n = x.parse::<u32>().unwrap(),\n    };\n    match matches.opt_str(\"e\") {\n        None => {}\n        Some(x) => e = x.parse::<f64>().unwrap(),\n    };\n\n    let seed: &[_] = &[1, 2, 3, 4];\n    let mut rng: StdRng = SeedableRng::from_seed(seed);\n\n    let mut points: Vec<Point>;\n\n    match matches.opt_str(\"f\") {\n        None => {\n            // Proceed with random 2d data\n            points = generate_points(n, &mut rng)\n        }\n        Some(file) => {\n            points = Vec::new();\n            let mut rdr = csv::Reader::from_file(file.clone()).unwrap();\n            for row in rdr.records().map(|r| r.unwrap()) {\n                // row is Vec<String>\n                let floats: Vec<f64> = row.iter().map(|s| s.parse::<f64>().unwrap()).collect();\n                points.push(DVector::<f64>::from_slice(floats.len(), floats.as_slice()));\n            }\n            assert!(points.iter().all(|v| v.len() == points[0].len()));\n            n = points.len() as u32;\n            println!(\"Read {} points from {}\", points.len(), file.clone());\n        }\n    };\n\n    assert!(points.len() >= k);\n    let (clusters, stats) = lloyd(&points, k, e, max_iterations, &mut rng);\n\n    println!(\" k       centroid{}mean dist    pop\",\n             std::iter::repeat(\" \").take((points[0].len() - 2) * 7 + 7).collect::<String>());\n    println!(\"===  {}  ===========  =====\",\n             std::iter::repeat(\"=\").take(points[0].len() * 7 + 2).collect::<String>());\n    for i in 0..clusters.len() {\n        print!(\" {:>1}    \", i);\n        print_dvec(&stats.centroids[i]);\n        print!(\"      {:1.2}       {:>4}\\n\",\n               stats.mean_d_from_centroid[i],\n               clusters[i].members.len());\n    }\n\n    if points[0].len() == 2 {\n        viz(clusters, stats, k, n, e)\n    }\n}\n",
    "title": "K-means++ clustering",
    "url": "http://rosettacode.org/wiki/K-means%2B%2B_clustering"
  },
  {
    "local_code": "extern crate num;\nextern crate permutohedron;\n\nuse num::Float;\nuse permutohedron::Heap;\nuse std::f32;\n\nfn find_max(lst: &[f32]) -> Option<f32> {\n    if lst.is_empty() {\n        return None;\n    }\n    let max = lst.iter().fold(f32::NEG_INFINITY, |a, &b| Float::max(a, b));\n    Some(max)\n}\n\nfn with_bits(val: f32, digits: usize) -> f32 {\n    let num = format!(\"{:.*}\", digits, val);\n    num.parse::<f32>().unwrap()\n}\n\nfn kahan_sum(lst: &[f32]) -> Option<f32> {\n    let mut sum = 0.0f32;\n    let mut c = 0.0f32;\n    for i in lst {\n        let y = *i - c;\n        let t = sum + y;\n        c = (t - sum) - y;\n        sum = t;\n    }\n    Some(with_bits(sum, 1))\n}\n\nfn all_sums(vec: &mut [f32]) -> Vec<f32> {\n    let mut res = Vec::new();\n    let mut perms = Heap::new(vec);\n    loop {\n        let v = perms.next();\n        match v {\n            Some(v) => {\n                let mut sum = 0.0f32;\n                for e in &v {\n                    sum += with_bits(*e, 1);\n                }\n                res.push(with_bits(sum, 1));\n            }\n            None => break,\n        }\n    }\n    res\n}\n\n#[cfg_attr(feature = \"cargo-clippy\", allow(approx_constant))]\nfn main() {\n    let v = vec![10_000f32, 3.14159, 2.71828];\n    let sums = all_sums(&mut v.clone());\n    let res = kahan_sum(&v).unwrap();\n    let max = find_max(&sums[..]).unwrap();\n    println!(\"max: {} res: {}\", max, res);\n}\n\n#[test]\n#[cfg_attr(feature = \"cargo-clippy\", allow(approx_constant))]\nfn test_kahansum() {\n    let v = vec![10000.0f32, 3.14159, 2.71828];\n    let sums = all_sums(&mut v.clone());\n    let res = kahan_sum(&v).unwrap();\n    let max = find_max(&sums[..]).unwrap();\n    assert!(max < res);\n}\n\n#[test]\nfn test_withbits() {\n    let v = 3.123345f32;\n    let res = with_bits(v, 3);\n    assert!((res - 3.123f32).abs() < f32::EPSILON);\n}\n",
    "path": "tasks/kahan-summation",
    "remote_code": null,
    "title": "Kahan summation",
    "url": "http://rosettacode.org/wiki/Kahan_summation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Kaprekar numbers",
    "url": "http://rosettacode.org/wiki/Kaprekar_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Kernighans large earthquake problem",
    "url": "http://rosettacode.org/wiki/Kernighans_large_earthquake_problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Keyboard input/Flush the keyboard buffer",
    "url": "http://rosettacode.org/wiki/Keyboard_input/Flush_the_keyboard_buffer"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Keyboard input/Keypress check",
    "url": "http://rosettacode.org/wiki/Keyboard_input/Keypress_check"
  },
  {
    "local_code": "#[cfg(feature = \"ncurses\")]\nextern crate ncurses;\n\n#[cfg(feature = \"ncurses\")]\nfn main() {\n    ncurses::initscr();\n    loop {\n        ncurses::printw(\"Yes or no? \");\n        ncurses::refresh();\n\n        match ncurses::getch() as u8 as char {\n            'Y' | 'y' => {\n                ncurses::printw(\"You said yes!\");\n            }\n            'N' | 'n' => {\n                ncurses::printw(\"You said no!\");\n            }\n            _ => {\n                ncurses::printw(\"Try again!\\n\");\n                continue;\n            }\n        }\n\n        break;\n    }\n\n    ncurses::refresh();\n    ncurses::endwin();\n}\n\n#[cfg(not(feature = \"ncurses\"))]\nfn main() {}\n",
    "path": "tasks/keyboard-input/obtain-a-y-or-n-response",
    "remote_code": "//cargo-deps: ncurses\n\nextern crate ncurses;\nuse ncurses::*;\n\nfn main() {\n    initscr();\n    loop {\n        printw(\"Yes or no? \");\n        refresh();\n\n        match getch() as u8 as char {\n            'Y'|'y' => {printw(\"You said yes!\");},\n            'N'|'n' => {printw(\"You said no!\");},\n            _ => {printw(\"Try again!\\n\"); continue;},\n        }\n        break\n    }\n    refresh();\n    endwin();\n}",
    "title": "Keyboard input/Obtain a Y or N response",
    "url": "http://rosettacode.org/wiki/Keyboard_input/Obtain_a_Y_or_N_response"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Keyboard macros",
    "url": "http://rosettacode.org/wiki/Keyboard_macros"
  },
  {
    "local_code": "use std::cmp::max;\nuse std::iter::repeat;\n\n/// This struct is used to store our items that we want in our knap-sack.\n///\n#[derive(Copy, Clone)]\nstruct Want<'a> {\n    name: &'a str,\n    weight: usize,\n    value: usize,\n}\n\n/// Global, immutable allocation of our items. This is so we can reference\n/// this in multiple functions.\nconst ITEMS: &[Want<'static>] = &[\n    Want {\n        name: \"map\",\n        weight: 9,\n        value: 150,\n    },\n    Want {\n        name: \"compass\",\n        weight: 13,\n        value: 35,\n    },\n    Want {\n        name: \"water\",\n        weight: 153,\n        value: 200,\n    },\n    Want {\n        name: \"sandwich\",\n        weight: 50,\n        value: 160,\n    },\n    Want {\n        name: \"glucose\",\n        weight: 15,\n        value: 60,\n    },\n    Want {\n        name: \"tin\",\n        weight: 68,\n        value: 45,\n    },\n    Want {\n        name: \"banana\",\n        weight: 27,\n        value: 60,\n    },\n    Want {\n        name: \"apple\",\n        weight: 39,\n        value: 40,\n    },\n    Want {\n        name: \"cheese\",\n        weight: 23,\n        value: 30,\n    },\n    Want {\n        name: \"beer\",\n        weight: 52,\n        value: 10,\n    },\n    Want {\n        name: \"suntancream\",\n        weight: 11,\n        value: 70,\n    },\n    Want {\n        name: \"camera\",\n        weight: 32,\n        value: 30,\n    },\n    Want {\n        name: \"T-shirt\",\n        weight: 24,\n        value: 15,\n    },\n    Want {\n        name: \"trousers\",\n        weight: 48,\n        value: 10,\n    },\n    Want {\n        name: \"umbrella\",\n        weight: 73,\n        value: 40,\n    },\n    Want {\n        name: \"waterproof trousers\",\n        weight: 42,\n        value: 70,\n    },\n    Want {\n        name: \"waterproof overclothes\",\n        weight: 43,\n        value: 75,\n    },\n    Want {\n        name: \"note-case\",\n        weight: 22,\n        value: 80,\n    },\n    Want {\n        name: \"sunglasses\",\n        weight: 7,\n        value: 20,\n    },\n    Want {\n        name: \"towel\",\n        weight: 18,\n        value: 12,\n    },\n    Want {\n        name: \"socks\",\n        weight: 4,\n        value: 50,\n    },\n    Want {\n        name: \"book\",\n        weight: 30,\n        value: 10,\n    },\n];\n\n/// This is a bottom-up dynamic programming solution to the 0-1 knap-sack problem.\n///\n/// ```\n/// maximize value\n/// subject to weights <= max_weight\n/// ```\nfn knap_01_dp<'a>(xs: &[Want<'a>], max_weight: usize) -> Vec<Want<'a>> {\n    // Save this value, so we don't have to make repeated calls.\n    let xs_len = xs.len();\n\n    // Imagine we wrote a recursive function(item, max_weight) that returns a\n    // usize corresponding to the maximum cumulative value by considering a\n    // subset of items such that the combined weight <= max_weight.\n    //\n    // fn best_value(item: usize, max_weight: usize) -> usize{\n    //     if item == 0 {\n    //         return 0;\n    //     }\n    //     if xs[item - 1].weight > max_weight {\n    //         return best_value(item - 1, max_weight, xs);\n    //     }\n    //     return max(best_value(item - 1, max_weight, xs),\n    //                best_value(item - 1, max_weight - xs[item - 1].weight, xs)\n    //                + xs[item - 1].value);\n    //     }\n    //\n    // best_value(xs_len, max_weight) is equal to the maximum value that we\n    // can add to the bag.\n    //\n    // The problem with using this function is that it performs redudant\n    // calculations.\n    //\n    // The dynamic programming solution is to precompute all of the values we\n    // need and put them into a 2D array.\n    //\n    // In a similar vein, the top-down solution would be to memoize the\n    // function then compute the results on demand.\n\n    let zero_vec: Vec<usize> = repeat(0).take(max_weight + 1).collect();\n    let mut best_value: Vec<Vec<usize>> = repeat(zero_vec).take(xs_len + 1).collect();\n\n    // loop over the items\n    for i in 0..xs_len {\n        // loop over the weights\n        for w in 1..(max_weight + 1) {\n            // do we have room in our knapsack?\n            if xs[i].weight > w {\n                // if we don't, then we'll say that the value doesn't change\n                // when considering this item\n                best_value[i + 1][w] = best_value[i][w];\n            } else {\n                // if we do, then we have to see if the value we gain by adding\n                // the item, given the weight, is better than not adding the item\n                best_value[i + 1][w] = max(\n                    best_value[i][w],\n                    best_value[i][w - xs[i].weight] + xs[i].value,\n                );\n            }\n        }\n    }\n\n    // a variable representing the weight left in the bag\n    let mut left_weight = max_weight;\n\n    // a possibly over-allocated dynamically sized vector to push results to\n    let mut result = Vec::with_capacity(xs_len);\n\n    // we built up the solution space through a forward pass over the data,\n    // now we have to traverse backwards to get the solution\n    for i in (1..xs_len + 1).rev() {\n        // We can check if an item should be added to the knap-sack by comparing\n        // best_value with and without this item. If best_value added this\n        // item then so should we.\n        if best_value[i][left_weight] != best_value[i - 1][left_weight] {\n            result.push(xs[i - 1]);\n            // we remove the weight of the object from the remaining weight\n            // we can add to the bag\n            left_weight -= xs[i - 1].weight;\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let xs = knap_01_dp(ITEMS, 400);\n\n    // Print the items. We have to reverse the order because we solved the\n    // problem backward.\n    for i in xs.iter().rev() {\n        println!(\"Item: {}, Weight: {}, Value: {}\", i.name, i.weight, i.value);\n    }\n\n    // Print the sum of weights.\n    let weights = xs.iter().fold(0, |a, &b| a + b.weight);\n    println!(\"Total Weight: {}\", weights);\n\n    // Print the sum of the values.\n    let values = xs.iter().fold(0, |a, &b| a + b.value);\n    println!(\"Total Value: {}\", values);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{knap_01_dp, ITEMS};\n\n    #[test]\n    fn test_dp_results() {\n        let dp_results = knap_01_dp(ITEMS, 400);\n        let dp_weights = dp_results.iter().fold(0, |a, &b| a + b.weight);\n        let dp_values = dp_results.iter().fold(0, |a, &b| a + b.value);\n        assert_eq!(dp_weights, 396);\n        assert_eq!(dp_values, 1030);\n    }\n}\n",
    "path": "tasks/knapsack-problem/0-1",
    "remote_code": "use std::cmp;\n\nstruct Item {\n    name: &'static str,\n    weight: usize,\n    value: usize\n}\n\nfn knapsack01_dyn(items: &[Item], max_weight: usize) -> Vec<&Item> {\n    let mut best_value = vec![vec![0; max_weight + 1]; items.len() + 1];\n    for (i, it) in items.iter().enumerate() {\n        for w in 1 .. max_weight + 1 {\n            best_value[i + 1][w] =\n                if it.weight > w {\n                    best_value[i][w]\n                } else {\n                    cmp::max(best_value[i][w], best_value[i][w - it.weight] + it.value)\n                }\n        }\n    }\n\n    let mut result = Vec::with_capacity(items.len());\n    let mut left_weight = max_weight;\n\n    for (i, it) in items.iter().enumerate().rev() {\n        if best_value[i + 1][left_weight] != best_value[i][left_weight] {\n            result.push(it);\n            left_weight -= it.weight;\n        }\n    }\n\n    result\n}\n\n\nfn main () {\n    const MAX_WEIGHT: usize = 400;\n\n    const ITEMS: &[Item] = &[\n        Item { name: \"map\",                    weight: 9,   value: 150 },\n        Item { name: \"compass\",                weight: 13,  value: 35 },\n        Item { name: \"water\",                  weight: 153, value: 200 },\n        Item { name: \"sandwich\",               weight: 50,  value: 160 },\n        Item { name: \"glucose\",                weight: 15,  value: 60 },\n        Item { name: \"tin\",                    weight: 68,  value: 45 },\n        Item { name: \"banana\",                 weight: 27,  value: 60 },\n        Item { name: \"apple\",                  weight: 39,  value: 40 },\n        Item { name: \"cheese\",                 weight: 23,  value: 30 },\n        Item { name: \"beer\",                   weight: 52,  value: 10 },\n        Item { name: \"suntancream\",            weight: 11,  value: 70 },\n        Item { name: \"camera\",                 weight: 32,  value: 30 },\n        Item { name: \"T-shirt\",                weight: 24,  value: 15 },\n        Item { name: \"trousers\",               weight: 48,  value: 10 },\n        Item { name: \"umbrella\",               weight: 73,  value: 40 },\n        Item { name: \"waterproof trousers\",    weight: 42,  value: 70 },\n        Item { name: \"waterproof overclothes\", weight: 43,  value: 75 },\n        Item { name: \"note-case\",              weight: 22,  value: 80 },\n        Item { name: \"sunglasses\",             weight: 7,   value: 20 },\n        Item { name: \"towel\",                  weight: 18,  value: 12 },\n        Item { name: \"socks\",                  weight: 4,   value: 50 },\n        Item { name: \"book\",                   weight: 30,  value: 10 }\n    ];\n\n    let items = knapsack01_dyn(ITEMS, MAX_WEIGHT);\n\n    // We reverse the order because we solved the problem backward.\n    for it in items.iter().rev() {\n        println!(\"{}\", it.name);\n    }\n\n    println!(\"Total weight: {}\", items.iter().map(|w| w.weight).sum::<usize>());\n    println!(\"Total value: {}\", items.iter().map(|w| w.value).sum::<usize>());\n}",
    "title": "Knapsack problem/0-1",
    "url": "http://rosettacode.org/wiki/Knapsack_problem/0-1"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Knapsack problem/Bounded",
    "url": "http://rosettacode.org/wiki/Knapsack_problem/Bounded"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let items: [(&str, f32, u8); 9] = [\n        (\"beef\", 3.8, 36),\n        (\"pork\", 5.4, 43),\n        (\"ham\", 3.6, 90),\n        (\"greaves\", 2.4, 45),\n        (\"flitch\", 4.0, 30),\n        (\"brawn\", 2.5, 56),\n        (\"welt\", 3.7, 67),\n        (\"salami\", 3.0, 95),\n        (\"sausage\", 5.9, 98),\n    ];\n    let mut weight: f32 = 15.0;\n    let mut values: Vec<(&str, f32, f32)> = Vec::new();\n    for item in &items {\n        values.push((item.0, f32::from(item.2) / item.1, item.1));\n    }\n\n    values.sort_by(|a, b| (a.1).partial_cmp(&b.1).unwrap());\n    values.reverse();\n\n    for choice in values {\n        if choice.2 <= weight {\n            println!(\"Grab {:.1} kgs of {}\", choice.2, choice.0);\n            weight -= choice.2;\n            if (choice.2 - weight).abs() < std::f32::EPSILON {\n                return;\n            }\n        } else {\n            println!(\"Grab {:.1} kgs of {}\", weight, choice.0);\n            return;\n        }\n    }\n}",
    "title": "Knapsack problem/Continuous",
    "url": "http://rosettacode.org/wiki/Knapsack_problem/Continuous"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Knapsack problem/Unbounded",
    "url": "http://rosettacode.org/wiki/Knapsack_problem/Unbounded"
  },
  {
    "local_code": "use std::fmt;\n\nconst SIZE: usize = 8;\nconst MOVES: [(i32, i32); 8] = [\n    (2, 1),\n    (1, 2),\n    (-1, 2),\n    (-2, 1),\n    (-2, -1),\n    (-1, -2),\n    (1, -2),\n    (2, -1),\n];\n\n#[derive(Copy, Clone, Eq, PartialEq, PartialOrd, Ord)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Point {\n    fn mov(&self, &(dx, dy): &(i32, i32)) -> Point {\n        Point {\n            x: self.x + dx,\n            y: self.y + dy,\n        }\n    }\n}\n\nstruct Board {\n    field: [[i32; SIZE]; SIZE],\n}\n\nimpl Board {\n    fn new() -> Board {\n        Board {\n            field: [[0; SIZE]; SIZE],\n        }\n    }\n\n    fn available(&self, p: Point) -> bool {\n        let valid = 0 <= p.x && p.x < SIZE as i32 && 0 <= p.y && p.y < SIZE as i32;\n\n        valid && self.field[p.x as usize][p.y as usize] == 0\n    }\n\n    /// calculate the number of possible moves\n    fn count_degree(&self, p: Point) -> i32 {\n        let mut count = 0;\n        for dir in &MOVES {\n            let next = p.mov(dir);\n            if self.available(next) {\n                count += 1;\n            }\n        }\n        count\n    }\n}\n\nimpl Default for Board {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl fmt::Display for Board {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for row in &self.field {\n            for x in row.iter() {\n                write!(f, \"{:3} \", x)?;\n            }\n            write!(f, \"\\n\")?;\n        }\n        Ok(())\n    }\n}\n\nfn knights_tour(x: i32, y: i32) -> Option<Board> {\n    let mut board = Board::new();\n    let mut p = Point { x: x, y: y };\n    let mut step = 1;\n\n    board.field[p.x as usize][p.y as usize] = step;\n    step += 1;\n\n    while step <= (SIZE * SIZE) as i32 {\n        // choose next square by Warnsdorf's rule\n        let mut candidates = vec![];\n\n        for dir in &MOVES {\n            let adj = p.mov(dir);\n            if board.available(adj) {\n                let degree = board.count_degree(adj);\n                candidates.push((degree, adj));\n            }\n        }\n\n        match candidates.iter().min() {\n            Some(&(_, adj)) => p = adj,\n            None => return None,\n        };\n\n        board.field[p.x as usize][p.y as usize] = step;\n        step += 1;\n    }\n\n    Some(board)\n}\n\nfn main() {\n    let (x, y) = (3, 1);\n\n    println!(\"Board size: {}\", SIZE);\n    println!(\"Starting position: ({}, {})\", x, y);\n\n    match knights_tour(x, y) {\n        Some(b) => print!(\"{}\", b),\n        None => println!(\"Fail!\"),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{knights_tour, SIZE};\n\n    const ANSWER: [[i32; SIZE]; SIZE] = [\n        [23, 20, 3, 32, 25, 10, 5, 8],\n        [2, 33, 24, 21, 4, 7, 26, 11],\n        [19, 22, 51, 34, 31, 28, 9, 6],\n        [50, 1, 40, 29, 54, 35, 12, 27],\n        [41, 18, 55, 52, 61, 30, 57, 36],\n        [46, 49, 44, 39, 56, 53, 62, 13],\n        [17, 42, 47, 60, 15, 64, 37, 58],\n        [48, 45, 16, 43, 38, 59, 14, 63],\n    ];\n\n    #[test]\n    fn test() {\n        let (x, y) = (3, 1);\n        match knights_tour(x, y) {\n            Some(b) => assert_eq!(b.field, ANSWER),\n            None => panic!(),\n        }\n    }\n}\n",
    "path": "tasks/knights-tour",
    "remote_code": "use std::fmt;\n\nconst SIZE: usize = 8;\nconst MOVES: [(i32, i32); 8] = [\n    (2, 1),\n    (1, 2),\n    (-1, 2),\n    (-2, 1),\n    (-2, -1),\n    (-1, -2),\n    (1, -2),\n    (2, -1),\n];\n\n#[derive(Copy, Clone, Eq, PartialEq, PartialOrd, Ord)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Point {\n    fn mov(&self, &(dx, dy): &(i32, i32)) -> Self {\n        Self {\n            x: self.x + dx,\n            y: self.y + dy,\n        }\n    }\n}\n\nstruct Board {\n    field: [[i32; SIZE]; SIZE],\n}\n\nimpl Board {\n    fn new() -> Self {\n        Self {\n            field: [[0; SIZE]; SIZE],\n        }\n    }\n\n    fn available(&self, p: Point) -> bool {\n        0 <= p.x\n            && p.x < SIZE as i32\n            && 0 <= p.y\n            && p.y < SIZE as i32\n            && self.field[p.x as usize][p.y as usize] == 0\n    }\n\n    // calculate the number of possible moves\n    fn count_degree(&self, p: Point) -> i32 {\n        let mut count = 0;\n        for dir in MOVES.iter() {\n            let next = p.mov(dir);\n            if self.available(next) {\n                count += 1;\n            }\n        }\n        count\n    }\n}\n\nimpl fmt::Display for Board {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for row in self.field.iter() {\n            for x in row.iter() {\n                write!(f, \"{:3} \", x)?;\n            }\n            write!(f, \"\\n\")?;\n        }\n        Ok(())\n    }\n}\n\nfn knights_tour(x: i32, y: i32) -> Option<Board> {\n    let mut board = Board::new();\n    let mut p = Point { x: x, y: y };\n    let mut step = 1;\n    board.field[p.x as usize][p.y as usize] = step;\n    step += 1;\n\n    while step <= (SIZE * SIZE) as i32 {\n        // choose next square by Warnsdorf's rule\n        let mut candidates = vec![];\n        for dir in MOVES.iter() {\n            let adj = p.mov(dir);\n            if board.available(adj) {\n                let degree = board.count_degree(adj);\n                candidates.push((degree, adj));\n            }\n        }\n        match candidates.iter().min() {\n            // move to next square\n            Some(&(_, adj)) => p = adj,\n            // can't move\n            None => return None,\n        };\n        board.field[p.x as usize][p.y as usize] = step;\n        step += 1;\n    }\n    Some(board)\n}\n\nfn main() {\n    let (x, y) = (3, 1);\n    println!(\"Board size: {}\", SIZE);\n    println!(\"Starting position: ({}, {})\", x, y);\n    match knights_tour(x, y) {\n        Some(b) => print!(\"{}\", b),\n        None => println!(\"Fail!\"),\n    }\n}",
    "title": "Knight's tour",
    "url": "http://rosettacode.org/wiki/Knight's_tour"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::Rng;\n\n// Since you're probably already using the `rand` crate, you should just use\n// `rand::Rng::shuffle`.\nfn knuth_shuffle<T>(rng: &mut impl Rng, v: &mut [T]) {\n    let l = v.len();\n\n    for n in 0..l {\n        let i = rng.gen_range(0, l - n);\n        v.swap(i, l - n - 1);\n    }\n}\n\nfn main() {\n    let mut v: Vec<_> = (0..10).collect();\n    let mut rng = rand::thread_rng();\n\n    println!(\"before: {:?}\", v);\n    knuth_shuffle(&mut rng, &mut v);\n    println!(\"after:  {:?}\", v);\n}\n",
    "path": "tasks/knuth-shuffle",
    "remote_code": "use rand::Rng;\n\nextern crate rand;\n\nfn knuth_shuffle<T>(v: &mut [T]) {\n    let mut rng = rand::thread_rng();\n    let l = v.len();\n\n    for n in 0..l {\n        let i = rng.gen_range(0, l - n);\n        v.swap(i, l - n - 1);\n    }\n}\n\nfn main() {\n    let mut v: Vec<_> = (0..10).collect();\n\n    println!(\"before: {:?}\", v);\n    knuth_shuffle(&mut v);\n    println!(\"after:  {:?}\", v);\n}",
    "title": "Knuth shuffle",
    "url": "http://rosettacode.org/wiki/Knuth_shuffle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use rand::{Rng,weak_rng};\n\nstruct SofN<R: Rng+Sized, T> {\n    rng: R,\n    sample: Vec<T>,\n    i: usize,\n    n: usize,\n}\n\nimpl<R: Rng, T> SofN<R, T> {\n    fn new(rng: R, n: usize) -> Self {\n        SofN{rng, sample: Vec::new(), i: 0, n}\n    }\n\n    fn add(&mut self, item: T) {\n        self.i += 1;\n        if self.i <= self.n {\n            self.sample.push(item);\n        } else if self.rng.gen_range(0, self.i) < self.n {\n            self.sample[self.rng.gen_range(0, self.n)] = item;\n        }\n    }\n\n    fn sample(&self) -> &Vec<T> {\n        &self.sample\n    }\n}\n\n\npub fn main() {\n    const MAX: usize = 10;\n    let mut bin: [i32; MAX] = Default::default();\n    for _ in 0..100000 {\n        let mut s_of_n = SofN::new(weak_rng(), 3);\n        \n        for i in 0..MAX { s_of_n.add(i); }\n\n        for s in s_of_n.sample() {\n            bin[*s] += 1;\n        }\n    }\n    \n    for (i, x) in bin.iter().enumerate() {\n        println!(\"frequency of {}: {}\", i, x);\n    }\n}",
    "title": "Knuth's algorithm S",
    "url": "http://rosettacode.org/wiki/Knuth's_algorithm_S"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Knuth's power tree",
    "url": "http://rosettacode.org/wiki/Knuth's_power_tree"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Koch curve",
    "url": "http://rosettacode.org/wiki/Koch_curve"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Kolakoski sequence",
    "url": "http://rosettacode.org/wiki/Kolakoski_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Kosaraju",
    "url": "http://rosettacode.org/wiki/Kosaraju"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Kronecker product",
    "url": "http://rosettacode.org/wiki/Kronecker_product"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Kronecker product based fractals",
    "url": "http://rosettacode.org/wiki/Kronecker_product_based_fractals"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "LU decomposition",
    "url": "http://rosettacode.org/wiki/LU_decomposition"
  },
  {
    "local_code": "use std::collections::hash_map::HashMap;\n\n/// Compress using LZW\nfn compress(original_str: &str) -> Vec<i32> {\n    let original = original_str.as_bytes();\n    let mut dict_size = 256;\n    let mut dictionary = HashMap::new();\n\n    for i in 0i32..dict_size {\n        dictionary.insert(vec![i as u8], i);\n    }\n\n    let mut result = vec![];\n    let mut w = vec![];\n    for &c in original {\n        let mut wc = w.clone();\n        wc.push(c);\n\n        match dictionary.get(&wc) {\n            Some(_) => w = wc,\n            None => {\n                result.push(dictionary[&w]);\n                dictionary.insert(wc, dict_size);\n                dict_size += 1;\n                w = vec![c];\n            }\n        }\n    }\n\n    if !w.is_empty() {\n        result.push(dictionary[&w]);\n    }\n\n    result\n}\n\n/// Decompress using LZW\nfn decompress(compressed: &[i32]) -> String {\n    let mut dict_size = 256;\n    let mut dictionary = HashMap::new();\n\n    for i in 0i32..dict_size {\n        dictionary.insert(i, vec![i as u8]);\n    }\n\n    let mut w = vec![compressed[0] as u8];\n    let compressed = &compressed[1..];\n    let mut result = w.clone();\n    for &k in compressed {\n        let entry = match dictionary.get(&k) {\n            Some(v) => v.clone(),\n            None if k == dict_size => {\n                let mut new = w.clone();\n                new.push(w[0]);\n                new\n            }\n            None => panic!(\"Invalid compressed string\"),\n        };\n\n        result.extend(entry.iter().cloned());\n        w.push(entry[0]);\n        dictionary.insert(dict_size, w);\n        dict_size += 1;\n        w = entry;\n    }\n\n    String::from_utf8(result).unwrap()\n}\n\nfn main() {\n    // Show original\n    let original = \"TOBEORNOTTOBEORTOBEORNOT\";\n    println!(\"Original: {}\", original);\n\n    // Show compressed\n    let compressed = compress(original);\n    println!(\"Compressed: {:?}\", compressed);\n\n    // Show decompressed\n    let decompressed = decompress(&compressed[..]);\n    println!(\"Decompressed: {}\", &decompressed[..]);\n}\n\n#[test]\nfn test_coherence() {\n    for s in (50000i32..50100).map(|n| n.to_string()) {\n        let s = &s[..];\n        assert_eq!(&*decompress(&*compress(s)), s);\n    }\n}\n\n#[test]\nfn test_example() {\n    let original = \"TOBEORNOTTOBEORTOBEORNOT\";\n    assert_eq!(\n        compress(original),\n        [84i32, 79, 66, 69, 79, 82, 78, 79, 84, 256, 258, 260, 265, 259, 261, 263,]\n    );\n}\n",
    "path": "tasks/lzw-compression",
    "remote_code": "use std::collections::HashMap;\n\nfn compress(data: &[u8]) -> Vec<u32> {\n    // Build initial dictionary.\n    let mut dictionary: HashMap<Vec<u8>, u32> = (0u32..=255)\n        .map(|i| (vec![i as u8], i))\n        .collect();\n\n    let mut w = Vec::new();\n    let mut compressed = Vec::new();\n\n    for &b in data {\n        let mut wc = w.clone();\n        wc.push(b);\n\n        if dictionary.contains_key(&wc) {\n            w = wc;\n        } else {\n            // Write w to output.\n            compressed.push(dictionary[&w]);\n\n            // wc is a new sequence; add it to the dictionary.\n            dictionary.insert(wc, dictionary.len() as u32);\n            w.clear();\n            w.push(b);\n        }\n    }\n\n    // Write remaining output if necessary.\n    if !w.is_empty() {\n        compressed.push(dictionary[&w]);\n    }\n\n    compressed\n}\n\nfn decompress(mut data: &[u32]) -> Vec<u8> {\n    // Build the dictionary.\n    let mut dictionary: HashMap::<u32, Vec<u8>> = (0u32..=255)\n        .map(|i| (i, vec![i as u8]))\n        .collect();\n\n    let mut w = dictionary[&data[0]].clone();\n    data = &data[1..];\n    let mut decompressed = w.clone();\n\n    for &k in data {\n        let entry = if dictionary.contains_key(&k) {\n            dictionary[&k].clone()\n        } else if k == dictionary.len() as u32 {\n            let mut entry = w.clone();\n            entry.push(w[0]);\n            entry\n        } else {\n            panic!(\"Invalid dictionary!\");\n        };\n\n        decompressed.extend_from_slice(&entry);\n\n        // New sequence; add it to the dictionary.\n        w.push(entry[0]);\n        dictionary.insert(dictionary.len() as u32, w);\n\n        w = entry;\n    }\n\n    decompressed\n}\n\nfn main() {\n    let compressed = compress(\"TOBEORNOTTOBEORTOBEORNOT\".as_bytes());\n    println!(\"{:?}\", compressed);\n\n    let decompressed = decompress(&compressed);\n    let decompressed = String::from_utf8(decompressed).unwrap();\n    println!(\"{}\", decompressed);\n}",
    "title": "LZW compression",
    "url": "http://rosettacode.org/wiki/LZW_compression"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Lah numbers",
    "url": "http://rosettacode.org/wiki/Lah_numbers"
  },
  {
    "local_code": "use std::num::Wrapping;\n\nstruct Ant {\n    x: Wrapping<usize>,\n    y: Wrapping<usize>,\n    dir: Direction,\n}\n\n#[derive(Clone, Copy)]\nenum Direction {\n    North,\n    East,\n    South,\n    West,\n}\n\nuse Direction::*;\n\nimpl Ant {\n    fn mv(&mut self, vec: &mut Vec<Vec<u8>>) {\n        let pointer = &mut vec[self.y.0][self.x.0];\n        // change direction\n        match *pointer {\n            0 => self.dir = self.dir.right(),\n            1 => self.dir = self.dir.left(),\n            _ => panic!(\"Unexpected colour in grid\"),\n        }\n        // flip colour\n        // if it's 1 it's black\n        // if it's 0 it's white\n        *pointer ^= 1;\n\n        // move direction\n        match self.dir {\n            North => self.y -= Wrapping(1),\n            South => self.y += Wrapping(1),\n            East => self.x += Wrapping(1),\n            West => self.x -= Wrapping(1),\n        }\n    }\n}\n\nimpl Direction {\n    fn right(self) -> Direction {\n        match self {\n            North => East,\n            East => South,\n            South => West,\n            West => North,\n        }\n    }\n\n    fn left(self) -> Direction {\n        // 3 rights equal a left\n        self.right().right().right()\n    }\n}\n\nfn main() {\n    // create a 100x100 grid using vectors\n    let mut grid: Vec<Vec<u8>> = vec![vec![0; 100]; 100];\n    let mut ant = Ant {\n        x: Wrapping(50),\n        y: Wrapping(50),\n        dir: Direction::North,\n    };\n\n    while ant.x < Wrapping(100) && ant.y < Wrapping(100) {\n        ant.mv(&mut grid);\n    }\n    for each in &grid {\n        // construct string\n        // using iterator methods to quickly convert the vector\n        // to a string\n        let string = each\n            .iter()\n            .map(|&x| if x == 0 { \" \" } else { \"#\" })\n            .fold(String::new(), |x, y| x + y);\n        println!(\"{}\", string);\n    }\n}\n",
    "path": "tasks/langtons-ant",
    "remote_code": "struct Ant {\n    x: usize,\n    y: usize,\n    dir: Direction\n}\n\n#[derive(Clone,Copy)]\nenum Direction {\n    North,\n    East,\n    South,\n    West\n}\n\nuse Direction::*;\n\nimpl Ant {\n    fn mv(&mut self, vec: &mut Vec<Vec<u8>>) {\n        let pointer = &mut vec[self.y][self.x];\n        //change direction\n        match *pointer {\n            0 => self.dir = self.dir.right(),\n            1 => self.dir = self.dir.left(),\n            _ => panic!(\"Unexpected colour in grid\")\n        }\n        //flip colour\n        //if it's 1 it's black\n        //if it's 0 it's white\n        *pointer ^= 1;\n\n        //move direction\n        match self.dir {\n            North => self.y -= 1,\n            South => self.y += 1,\n            East => self.x += 1,\n            West => self.x -= 1,\n        }\n\n    }\n}\n\nimpl Direction {\n    fn right(self) -> Direction {\n        match self {\n            North => East,\n            East => South,\n            South => West,\n            West => North,\n        }\n    }\n\n    fn left(self) -> Direction {\n        //3 rights equal a left\n        self.right().right().right()\n    }\n}\n\nfn main(){\n    //create a 100x100 grid using vectors\n    let mut grid: Vec<Vec<u8>> = vec![vec![0; 100]; 100];\n    let mut ant = Ant {\n        x: 50, y: 50, dir: Direction::North\n    };\n\n    while ant.x < 100 && ant.y < 100 {\n        ant.mv(&mut grid);\n    }\n    for each in grid.iter() {\n        //construct string\n        //using iterator methods to quickly convert the vector\n        //to a string\n        let string = each.iter()\n                         .map(|&x| if x == 0 { \" \" } else { \"#\" })\n                         .fold(String::new(), |x, y| x+y);\n        println!(\"{}\", string);\n    }\n}",
    "title": "Langton's ant",
    "url": "http://rosettacode.org/wiki/Langton's_ant"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Largest int from concatenated ints",
    "url": "http://rosettacode.org/wiki/Largest_int_from_concatenated_ints"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Largest number divisible by its digits",
    "url": "http://rosettacode.org/wiki/Largest_number_divisible_by_its_digits"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Last Friday of each month",
    "url": "http://rosettacode.org/wiki/Last_Friday_of_each_month"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Last letter-first letter",
    "url": "http://rosettacode.org/wiki/Last_letter-first_letter"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Latin Squares in reduced form",
    "url": "http://rosettacode.org/wiki/Latin_Squares_in_reduced_form"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Law of cosines - triples",
    "url": "http://rosettacode.org/wiki/Law_of_cosines_-_triples"
  },
  {
    "local_code": "fn is_leap_year(year: i32) -> bool {\n    year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)\n}\n\nfn main() {\n    for &year in &[1900, 1995, 1996, 1999, 2000, 2001] {\n        println!(\n            \"{} {} a leap year\",\n            year,\n            if is_leap_year(year) { \"is\" } else { \"is not\" }\n        );\n    }\n}\n\n#[test]\nfn test_regular_common_year() {\n    assert_eq!(is_leap_year(2014), false);\n}\n\n#[test]\nfn test_regular_leap_year() {\n    assert_eq!(is_leap_year(2012), true);\n}\n\n#[test]\nfn test_century_common_year() {\n    assert_eq!(is_leap_year(1900), false);\n}\n\n#[test]\nfn test_400_leap_year() {\n    assert_eq!(is_leap_year(2000), true);\n}\n",
    "path": "tasks/leap-year",
    "remote_code": "fn is_leap(year: i32) -> bool {\n    let factor = |x| year % x == 0;\n    factor(4) && (!factor(100) || factor(400))\n}",
    "title": "Leap year",
    "url": "http://rosettacode.org/wiki/Leap_year"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::cmp::{max, min};\n\nfn gcd(a: usize, b: usize) -> usize {\n    match ((a, b), (a & 1, b & 1)) {\n        ((x, y), _) if x == y => y,\n        ((0, x), _) | ((x, 0), _) => x,\n        ((x, y), (0, 1)) | ((y, x), (1, 0)) => gcd(x >> 1, y),\n        ((x, y), (0, 0)) => gcd(x >> 1, y >> 1) << 1,\n        ((x, y), (1, 1)) => {\n            let (x, y) = (min(x, y), max(x, y));\n            gcd((y - x) >> 1, x)\n        }\n        _ => unreachable!(),\n    }\n}\n\nfn lcm(a: usize, b: usize) -> usize {\n    a * b / gcd(a, b)\n}\n\nfn main() {\n    println!(\"{}\", lcm(6324, 234))\n}",
    "title": "Least common multiple",
    "url": "http://rosettacode.org/wiki/Least_common_multiple"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Left factorials",
    "url": "http://rosettacode.org/wiki/Left_factorials"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Leonardo numbers",
    "url": "http://rosettacode.org/wiki/Leonardo_numbers"
  },
  {
    "local_code": "use std::collections::HashMap;\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::io::{self, BufReader};\n\n/// Returns a `HashMap` of each letter and its count\nfn count_chars<R: Read>(reader: R) -> io::Result<HashMap<char, usize>> {\n    let reader = BufReader::new(reader);\n\n    let mut map = HashMap::new();\n    for line in reader.lines() {\n        for c in line?.chars() {\n            *map.entry(c).or_insert(0) += 1;\n        }\n    }\n\n    Ok(map)\n}\n\nfn main() -> io::Result<()> {\n    let file = File::open(\"resources/unixdict.txt\")?;\n    let reader = BufReader::new(file);\n    let count = count_chars(reader)?;\n    println!(\"{:?}\", count);\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    use std::io::Cursor;\n\n    #[test]\n    fn test_empty() -> io::Result<()> {\n        let map = count_chars(Cursor::new(b\"\"))?;\n        assert!(map.is_empty());\n        Ok(())\n    }\n\n    #[test]\n    fn test_basic() -> io::Result<()> {\n        let map = count_chars(Cursor::new(b\"aaaabbbbc\"))?;\n        assert_eq!(map.len(), 3);\n        assert_eq!(map[&'a'], 4);\n        assert_eq!(map[&'b'], 4);\n        assert_eq!(map[&'c'], 1);\n        Ok(())\n    }\n}\n",
    "path": "tasks/letter-frequency",
    "remote_code": "use std::collections::btree_map::BTreeMap;\nuse std::{env, process};\nuse std::io::{self, Read, Write};\nuse std::fmt::Display;\nuse std::fs::File;\n\nfn main() {\n    let filename = env::args().nth(1)\n        .ok_or(\"Please supply a file name\")\n        .unwrap_or_else(|e| exit_err(e, 1));\n\n    let mut buf = String::new();\n    let mut count = BTreeMap::new();\n\n    File::open(&filename)\n        .unwrap_or_else(|e| exit_err(e, 2))\n        .read_to_string(&mut buf)\n        .unwrap_or_else(|e| exit_err(e, 3));\n\n\n    for c in buf.chars() {\n        *count.entry(c).or_insert(0) += 1;\n    }\n\n    println!(\"Number of occurences per character\");\n    for (ch, count) in &count {\n        println!(\"{:?}: {}\", ch, count);\n    }\n}\n\n#[inline]\nfn exit_err<T>(msg: T, code: i32) -> ! where T: Display {\n    writeln!(&mut io::stderr(), \"{}\", msg).expect(\"Could not write to stderr\");\n    process::exit(code)\n}",
    "title": "Letter frequency",
    "url": "http://rosettacode.org/wiki/Letter_frequency"
  },
  {
    "local_code": "#[cfg_attr(feature = \"cargo-clippy\", allow(needless_range_loop))]\nfn levenshtein_distance(word1: &str, word2: &str) -> usize {\n    let word1_length = word1.len() + 1;\n    let word2_length = word2.len() + 1;\n\n    let mut matrix = vec![vec![0]];\n\n    for i in 1..word1_length {\n        matrix[0].push(i);\n    }\n    for j in 1..word2_length {\n        matrix.push(vec![j]);\n    }\n\n    for j in 1..word2_length {\n        for i in 1..word1_length {\n            let x: usize = if word1.chars().nth(i - 1) == word2.chars().nth(j - 1) {\n                matrix[j - 1][i - 1]\n            } else {\n                let min_distance = [matrix[j][i - 1], matrix[j - 1][i], matrix[j - 1][i - 1]];\n                *min_distance.iter().min().unwrap() + 1\n            };\n\n            matrix[j].push(x);\n        }\n    }\n\n    matrix[word2_length - 1][word1_length - 1]\n}\n\nfn main() {\n    println!(\"{}\", levenshtein_distance(\"kitten\", \"sitting\"));\n    println!(\"{}\", levenshtein_distance(\"saturday\", \"sunday\"));\n    println!(\"{}\", levenshtein_distance(\"rosettacode\", \"raisethysword\"));\n}\n\n#[test]\nfn test_levenshtein_distance() {\n    assert_eq!(levenshtein_distance(\"kitten\", \"sitting\"), 3);\n}\nuse std::collections::VecDeque;\nuse std::iter::repeat;\nuse std::usize;\n\n/// Returns the value of a 2D vector given a pair of indexes.\n/// Returns the default value if indices are out of bounds.\nfn get_val(mat: &[Vec<usize>], r: usize, c: usize, default: usize) -> usize {\n    match mat.get(r) {\n        Some(col) => match col.get(c) {\n            Some(v) => *v,\n            None => default,\n        },\n        None => default,\n    }\n}\n\n/// Implementation of the [Needleman–Wunsch algorithm], with modification\n/// to the scoring method to only allow positive ints.\n///\n/// [Needleman-Wunsch algorithm]: http://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm\n#[cfg_attr(feature = \"cargo-clippy\", allow(needless_range_loop))]\nfn levenshtein_distance(s1: &str, s2: &str) -> (usize, String, String) {\n    let l1 = s1.len() + 1;\n    let l2 = s2.len() + 1;\n\n    let mut mat: Vec<Vec<usize>> = repeat(repeat(0).take(l2).collect()).take(l1).collect();\n    for row in 0..l1 {\n        mat[row][0] = row;\n    }\n    for col in 0..l2 {\n        mat[0][col] = col;\n    }\n    for row in 1..l1 {\n        for col in 1..l2 {\n            mat[row][col] = if s1.chars().nth(row - 1).unwrap() == s2.chars().nth(col - 1).unwrap()\n            {\n                mat[row - 1][col - 1]\n            } else {\n                let vals = [\n                    mat[row - 1][col] + 1,\n                    mat[row][col - 1] + 1,\n                    mat[row - 1][col - 1] + 1,\n                ];\n                *vals.iter().min().unwrap()\n            }\n        }\n    }\n    let mut res1: VecDeque<char> = VecDeque::new();\n    let mut res2: VecDeque<char> = VecDeque::new();\n    let mut cur_row = l1 - 1;\n    let mut cur_col = l2 - 1;\n    while cur_row > 0 || cur_col > 0 {\n        let ins = get_val(&mat, cur_row, cur_col - 1, usize::MAX);\n        let del = get_val(&mat, cur_row - 1, cur_col, usize::MAX);\n        let sub = get_val(&mat, cur_row - 1, cur_col - 1, usize::MAX);\n        let min_val = [sub, ins, del];\n        let min_val = min_val.into_iter().min().unwrap();\n        if *min_val == sub {\n            cur_row -= 1;\n            cur_col -= 1;\n            res1.push_front(s1.chars().nth(cur_row).unwrap());\n            res2.push_front(s2.chars().nth(cur_col).unwrap());\n        } else if *min_val == ins {\n            cur_col -= 1;\n            res1.push_front('-');\n            res2.push_front(s1.chars().nth(cur_col).unwrap());\n        } else if *min_val == del {\n            cur_row -= 1;\n            res1.push_front(s1.chars().nth(cur_row).unwrap());\n            res2.push_front('-');\n        }\n    }\n    let aligned1: String = res1.into_iter().collect();\n    let aligned2: String = res2.into_iter().collect();\n    let lev_dist = mat[l1 - 1][l2 - 1];\n\n    (lev_dist, aligned1, aligned2)\n}\n\nfn main() {\n    let (s1, s2) = (\"rosettacode\", \"raisethysword\");\n    let (lev_dist, aligned1, aligned2) = levenshtein_distance(s1, s2);\n    println!(\"Words are: {}, {}\", s1, s2);\n    println!(\"Levenshtein Distance: {}\", lev_dist);\n    println!(\"{}\", aligned1);\n    println!(\"{}\", aligned2);\n}\n\n#[test]\nfn test_lev_distance() {\n    let test_results = vec![\n        (\"sunday\", \"saturday\", (3, \"s--unday\", \"sunurday\")),\n        (\"sitting\", \"kitten\", (3, \"sitting\", \"kitten-\")),\n        (\"test\", \"test\", (0, \"test\", \"test\")),\n    ];\n    for (word1, word2, dist) in test_results {\n        let (d, s1, s2) = levenshtein_distance(word1, word2);\n        assert_eq!((d, &s1[..], &s2[..]), dist);\n    }\n}\n",
    "path": "tasks/levenshtein-distance",
    "remote_code": "fn main() {\n    println!(\"{}\", levenshtein_distance(\"kitten\", \"sitting\"));\n    println!(\"{}\", levenshtein_distance(\"saturday\", \"sunday\"));\n    println!(\"{}\", levenshtein_distance(\"rosettacode\", \"raisethysword\"));\n}\n\nfn levenshtein_distance(word1: &str, word2: &str) -> usize {\n    let w1 = word1.chars().collect::<Vec<_>>();\n    let w2 = word2.chars().collect::<Vec<_>>();\n\n    let word1_length = w1.len() + 1;\n    let word2_length = w2.len() + 1;\n\n    let mut matrix = vec![vec![0]];\n\n    for i in 1..word1_length { matrix[0].push(i); }\n    for j in 1..word2_length { matrix.push(vec![j]); }\n\n    for j in 1..word2_length {\n        for i in 1..word1_length {\n            let x: usize = if w1[i-1] == w2[j-1] {\n                matrix[j-1][i-1]\n            } else {\n                1 + std::cmp::min(\n                        std::cmp::min(matrix[j][i-1], matrix[j-1][i])\n                        , matrix[j-1][i-1])\n            };\n            matrix[j].push(x);\n        }\n    }\n    matrix[word2_length-1][word1_length-1]\n}",
    "title": "Levenshtein distance",
    "url": "http://rosettacode.org/wiki/Levenshtein_distance"
  },
  {
    "local_code": "use std::collections::VecDeque;\nuse std::iter::repeat;\nuse std::usize;\n\n/// Returns the value of a 2D vector given a pair of indexes.\n/// Returns the default value if indices are out of bounds.\nfn get_val(mat: &[Vec<usize>], r: usize, c: usize, default: usize) -> usize {\n    match mat.get(r) {\n        Some(col) => match col.get(c) {\n            Some(v) => *v,\n            None => default,\n        },\n        None => default,\n    }\n}\n\n/// Implementation of the [Needleman–Wunsch algorithm], with modification\n/// to the scoring method to only allow positive ints.\n///\n/// [Needleman-Wunsch algorithm]: http://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm\n#[cfg_attr(feature = \"cargo-clippy\", allow(needless_range_loop))]\nfn levenshtein_distance(s1: &str, s2: &str) -> (usize, String, String) {\n    let l1 = s1.len() + 1;\n    let l2 = s2.len() + 1;\n\n    let mut mat: Vec<Vec<usize>> = repeat(repeat(0).take(l2).collect()).take(l1).collect();\n    for row in 0..l1 {\n        mat[row][0] = row;\n    }\n    for col in 0..l2 {\n        mat[0][col] = col;\n    }\n    for row in 1..l1 {\n        for col in 1..l2 {\n            mat[row][col] = if s1.chars().nth(row - 1).unwrap() == s2.chars().nth(col - 1).unwrap()\n            {\n                mat[row - 1][col - 1]\n            } else {\n                let vals = [\n                    mat[row - 1][col] + 1,\n                    mat[row][col - 1] + 1,\n                    mat[row - 1][col - 1] + 1,\n                ];\n                *vals.iter().min().unwrap()\n            }\n        }\n    }\n    let mut res1: VecDeque<char> = VecDeque::new();\n    let mut res2: VecDeque<char> = VecDeque::new();\n    let mut cur_row = l1 - 1;\n    let mut cur_col = l2 - 1;\n    while cur_row > 0 || cur_col > 0 {\n        let ins = get_val(&mat, cur_row, cur_col - 1, usize::MAX);\n        let del = get_val(&mat, cur_row - 1, cur_col, usize::MAX);\n        let sub = get_val(&mat, cur_row - 1, cur_col - 1, usize::MAX);\n        let min_val = [sub, ins, del];\n        let min_val = min_val.into_iter().min().unwrap();\n        if *min_val == sub {\n            cur_row -= 1;\n            cur_col -= 1;\n            res1.push_front(s1.chars().nth(cur_row).unwrap());\n            res2.push_front(s2.chars().nth(cur_col).unwrap());\n        } else if *min_val == ins {\n            cur_col -= 1;\n            res1.push_front('-');\n            res2.push_front(s1.chars().nth(cur_col).unwrap());\n        } else if *min_val == del {\n            cur_row -= 1;\n            res1.push_front(s1.chars().nth(cur_row).unwrap());\n            res2.push_front('-');\n        }\n    }\n    let aligned1: String = res1.into_iter().collect();\n    let aligned2: String = res2.into_iter().collect();\n    let lev_dist = mat[l1 - 1][l2 - 1];\n\n    (lev_dist, aligned1, aligned2)\n}\n\nfn main() {\n    let (s1, s2) = (\"rosettacode\", \"raisethysword\");\n    let (lev_dist, aligned1, aligned2) = levenshtein_distance(s1, s2);\n    println!(\"Words are: {}, {}\", s1, s2);\n    println!(\"Levenshtein Distance: {}\", lev_dist);\n    println!(\"{}\", aligned1);\n    println!(\"{}\", aligned2);\n}\n\n#[test]\nfn test_lev_distance() {\n    let test_results = vec![\n        (\"sunday\", \"saturday\", (3, \"s--unday\", \"sunurday\")),\n        (\"sitting\", \"kitten\", (3, \"sitting\", \"kitten-\")),\n        (\"test\", \"test\", (0, \"test\", \"test\")),\n    ];\n    for (word1, word2, dist) in test_results {\n        let (d, s1, s2) = levenshtein_distance(word1, word2);\n        assert_eq!((d, &s1[..], &s2[..]), dist);\n    }\n}\n",
    "path": "tasks/levenshtein-distance/alignment",
    "remote_code": null,
    "title": "Levenshtein distance/Alignment",
    "url": "http://rosettacode.org/wiki/Levenshtein_distance/Alignment"
  },
  {
    "local_code": "extern crate linear_congruential_generator;\nextern crate rand;\n\nuse linear_congruential_generator::*;\n\nuse rand::distributions::Alphanumeric;\nuse rand::prelude::*;\n\nfn main() {\n    println!(\"~~~ BSD ~~~\");\n    let mut bsd = BsdLcg::from_seed_u32(0);\n    for _ in 0..10 {\n        println!(\"{}\", bsd.gen::<u32>());\n    }\n\n    println!(\"~~~ MS ~~~\");\n    let mut ms = MsLcg::from_seed_u32(0);\n    for _ in 0..10 {\n        println!(\"{}\", ms.gen::<u32>());\n    }\n\n    // Because we have implemented the `rand_core::RngCore` and `SeedableRng` traits,\n    // we can generate a variety of other types.\n    //\n    // Note that the alphanumeric sampling and the boolean sampling are broken because\n    // `MsLcg` does not generate a full 32 bits.\n    let mut rng = MsLcg::from_entropy();\n    println!(\"~~~ Others ~~~\");\n    println!(\"{:?}\", rng.gen::<[f32; 5]>());\n    println!(\"{}\", rng.gen::<bool>());\n    println!(\n        \"{}\",\n        rng.sample_iter(&Alphanumeric).take(15).collect::<String>()\n    );\n}\nextern crate rand_core;\n\nuse std::mem::size_of;\n\nuse rand_core::{impls, le, Error, RngCore, SeedableRng};\n\npub struct BsdLcg {\n    state: u32,\n}\n\nimpl RngCore for BsdLcg {\n    // Because the output is in the range [0, 2147483647], this should technically be `next_u16`\n    // (the largest integer size which is fully covered, as `rand::Rng` assumes).  The `rand`\n    // crate does not provide it however.  If serious usage (not recommended) is required,\n    // implementing this function as a concatenation of two `next_u16`s (elsewhere defined) should\n    // work.\n    fn next_u32(&mut self) -> u32 {\n        self.state = self.state.wrapping_mul(1_103_515_245).wrapping_add(12_345);\n        self.state %= 1 << 31;\n        self.state\n    }\n\n    fn next_u64(&mut self) -> u64 {\n        impls::next_u64_via_u32(self)\n    }\n\n    fn fill_bytes(&mut self, dest: &mut [u8]) {\n        impls::fill_bytes_via_next(self, dest)\n    }\n\n    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {\n        self.fill_bytes(dest);\n        Ok(())\n    }\n}\n\nimpl BsdLcg {\n    pub fn from_seed_u32(seed: u32) -> Self {\n        Self { state: seed }\n    }\n}\n\nimpl SeedableRng for BsdLcg {\n    type Seed = [u8; size_of::<u32>()];\n\n    fn from_seed(seed: Self::Seed) -> Self {\n        let mut seed_u32 = [0u32; 1];\n        le::read_u32_into(&seed, &mut seed_u32);\n        Self { state: seed_u32[0] }\n    }\n}\n\npub struct MsLcg {\n    state: u32,\n}\n\nimpl RngCore for MsLcg {\n    // Similarly, this outputs in the range [0, 32767] and should output a `u8`.  Concatenate\n    // four `next_u8`s for serious usage.\n    fn next_u32(&mut self) -> u32 {\n        self.state = self.state.wrapping_mul(214_013).wrapping_add(2_531_011);\n        self.state %= 1 << 31;\n        self.state >> 16 //  rand_n = state_n / 2^16\n    }\n\n    fn next_u64(&mut self) -> u64 {\n        impls::next_u64_via_u32(self)\n    }\n\n    fn fill_bytes(&mut self, dest: &mut [u8]) {\n        impls::fill_bytes_via_next(self, dest)\n    }\n\n    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {\n        self.fill_bytes(dest);\n        Ok(())\n    }\n}\n\nimpl MsLcg {\n    pub fn from_seed_u32(seed: u32) -> Self {\n        Self { state: seed }\n    }\n}\n\nimpl SeedableRng for MsLcg {\n    type Seed = [u8; size_of::<u32>()];\n\n    fn from_seed(seed: Self::Seed) -> Self {\n        let mut seed_u32 = [0u32; 1];\n        le::read_u32_into(&seed, &mut seed_u32);\n        Self { state: seed_u32[0] }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_ms() {\n        let mut rng = MsLcg::from_seed([1, 0, 0, 0]);\n\n        for &num in &[41, 18467, 6334, 26500, 19169] {\n            assert_eq!(rng.next_u32(), num);\n        }\n    }\n\n    #[test]\n    fn test_bsd() {\n        let mut rng = BsdLcg::from_seed([1, 0, 0, 0]);\n\n        for &num in &[1103527590, 377401575, 662824084, 1147902781, 2035015474] {\n            assert_eq!(rng.next_u32(), num);\n        }\n    }\n}\n",
    "path": "tasks/linear-congruential-generator",
    "remote_code": "extern crate rand;\n\npub use rand::{Rng, SeedableRng};\n\npub struct BsdLcg {\n    state: u32,\n}\n\nimpl Rng for BsdLcg {\n    // Because the output is in the range [0, 2147483647], this should technically be `next_u16`\n    // (the largest integer size which is fully covered, as `rand::Rng` assumes).  The `rand`\n    // crate does not provide it however.  If serious usage is required, implementing this\n    // function as a concatenation of two `next_u16`s (elsewhere defined) should work.\n    fn next_u32(&mut self) -> u32 {\n        self.state = self.state.wrapping_mul(1_103_515_245).wrapping_add(12_345);\n        self.state %= 1 << 31;\n        self.state\n    }\n}\n\nimpl SeedableRng<u32> for BsdLcg {\n    fn from_seed(seed: u32) -> Self {\n        Self { state: seed }\n    }\n    fn reseed(&mut self, seed: u32) {\n        self.state = seed;\n    }\n}\n\npub struct MsLcg {\n    state: u32,\n}\n\nimpl Rng for MsLcg {\n    // Similarly, this outputs in the range [0, 32767] and should output a `u8`.  Concatenate\n    // four `next_u8`s for serious usage.\n    fn next_u32(&mut self) -> u32 {\n        self.state = self.state.wrapping_mul(214_013).wrapping_add(2_531_011);\n        self.state %= 1 << 31;\n        self.state >> 16 // rand_n = state_n / 2^16\n    }\n}\n\nimpl SeedableRng<u32> for MsLcg {\n    fn from_seed(seed: u32) -> Self {\n        Self { state: seed }\n    }\n    fn reseed(&mut self, seed: u32) {\n        self.state = seed;\n    }\n}\n\nfn main() {\n    println!(\"~~~ BSD ~~~\");\n    let mut bsd = BsdLcg::from_seed(0);\n    for _ in 0..10 {\n        println!(\"{}\", bsd.next_u32());\n    }\n\n    println!(\"~~~ MS ~~~\");\n    let mut ms = MsLcg::from_seed(0);\n    for _ in 0..10 {\n        println!(\"{}\", ms.next_u32());\n    }\n\n    // Because we have implemented the `rand::Rng` trait, we can generate a variety of other types.\n    println!(\"~~~ Others ~~~\");\n    println!(\"{:?}\", ms.gen::<[u32; 5]>());\n    println!(\"{}\", ms.gen::<bool>());\n    println!(\"{}\", ms.gen_ascii_chars().take(15).collect::<String>());\n}",
    "title": "Linear congruential generator",
    "url": "http://rosettacode.org/wiki/Linear_congruential_generator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "List comprehensions",
    "url": "http://rosettacode.org/wiki/List_comprehensions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "2.3         // Normal floating point literal\n3.          // Equivalent to 3.0 (3 would be interpreted as an integer)\n2f64        // The type (in this case f64, a 64-bit floating point number) may be appended to the value\n1_000.2_f32 // Underscores may appear anywhere in the number for clarity.",
    "title": "Literals/Floating point",
    "url": "http://rosettacode.org/wiki/Literals/Floating_point"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "10     // Decimal\n0b10   // Binary\n0x10   // Hexadecimal\n0o10   // Octal\n1_000  // Underscores may appear anywhere in the numeric literal for clarity\n10_i32 // The type (in this case i32, a 32-bit signed integer) may also be appended.\n10i32  // With or without underscores",
    "title": "Literals/Integer",
    "url": "http://rosettacode.org/wiki/Literals/Integer"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Literals/String",
    "url": "http://rosettacode.org/wiki/Literals/String"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Logical operations",
    "url": "http://rosettacode.org/wiki/Logical_operations"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Long multiplication",
    "url": "http://rosettacode.org/wiki/Long_multiplication"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Long primes",
    "url": "http://rosettacode.org/wiki/Long_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Longest Common Substring",
    "url": "http://rosettacode.org/wiki/Longest_Common_Substring"
  },
  {
    "local_code": "/// Returns the longest common subsequence of a and b.\nfn longest_common_subsequence(a: &str, b: &str) -> String {\n    let a_chars: Vec<_> = a.chars().collect();\n    let b_chars: Vec<_> = b.chars().collect();\n\n    let mut lengths = vec![vec![0; b_chars.len() + 1]; a_chars.len() + 1];\n\n    for (i, a_char) in a_chars.iter().enumerate() {\n        for (j, b_char) in b_chars.iter().enumerate() {\n            if a_char == b_char {\n                lengths[i + 1][j + 1] = lengths[i][j] + 1;\n            } else {\n                lengths[i + 1][j + 1] = std::cmp::max(lengths[i + 1][j], lengths[i][j + 1]);\n            }\n        }\n    }\n\n    let mut lcs = Vec::new();\n    let mut i = a_chars.len();\n    let mut j = b_chars.len();\n\n    while i != 0 && j != 0 {\n        if lengths[i][j] == lengths[i - 1][j] {\n            i -= 1;\n        } else if lengths[i][j] == lengths[i][j - 1] {\n            j -= 1;\n        } else {\n            lcs.push(a_chars[i - 1]);\n            i -= 1;\n            j -= 1;\n        }\n    }\n\n    lcs.into_iter().rev().collect()\n}\n\nfn main() {\n    println!(\"{}\", longest_common_subsequence(\"abc\", \"abcd\"));\n    println!(\"{}\", longest_common_subsequence(\"ABCDGH\", \"AEDFHR\"));\n    println!(\"{}\", longest_common_subsequence(\"AGGTAB\", \"GXTXAYB\"));\n    println!(\"{}\", longest_common_subsequence(\"\", \"abcdefg\"));\n    println!(\"{}\", longest_common_subsequence(\"abc\", \"\"));\n    println!(\"{}\", longest_common_subsequence(\"abcdefg\", \"abc\"));\n    println!(\"{}\", longest_common_subsequence(\"aaaa\", \"aaaaaa\"));\n}\n\n#[test]\nfn test_longest_common_subsequence() {\n    assert_eq!(longest_common_subsequence(\"abc\", \"abcdefg\"), \"abc\");\n    assert_eq!(longest_common_subsequence(\"ABCDGH\", \"AEDFHR\"), \"ADH\");\n    assert_eq!(longest_common_subsequence(\"AGGTAB\", \"GXTXAYB\"), \"GTAB\");\n    assert_eq!(longest_common_subsequence(\"\", \"abcdefg\"), \"\");\n    assert_eq!(longest_common_subsequence(\"abc\", \"\"), \"\");\n    assert_eq!(longest_common_subsequence(\"abcdefg\", \"abc\"), \"abc\");\n    assert_eq!(longest_common_subsequence(\"aaaa\", \"aaaaaa\"), \"aaaa\");\n}\n\n#[test]\nfn test_unicode() {\n    assert_eq!(\n        longest_common_subsequence(\"самолетов была отмечена в Японском\", \"отмечена в\"),\n        \"отмечена в\"\n    );\n}\n",
    "path": "tasks/longest-common-subsequence",
    "remote_code": "\nuse std::cmp;\n\nfn lcs(string1: String, string2: String) -> (usize, String){\n    let total_rows = string1.len() + 1;\n    let total_columns = string2.len() + 1;\n    // rust doesn't allow accessing string by index\n    let string1_chars = string1.as_bytes();\n    let string2_chars = string2.as_bytes();\n\n    let mut table = vec![vec![0; total_columns]; total_rows];\n\n    for row in 1..total_rows{\n        for col in 1..total_columns {\n            if string1_chars[row - 1] == string2_chars[col - 1]{\n                table[row][col] = table[row - 1][col - 1] + 1;\n            } else {\n                table[row][col] = cmp::max(table[row][col-1], table[row-1][col]);\n            }\n        }\n    }\n\n    let mut common_seq = Vec::new();\n    let mut x = total_rows - 1;\n    let mut y = total_columns - 1;\n\n    while x != 0 && y != 0 {\n        // Check element above is equal\n        if table[x][y] == table[x - 1][y] {\n            x = x - 1;\n        }\n        // check element to the left is equal\n        else if table[x][y] == table[x][y - 1] {\n            y = y - 1;\n        }\n        else {\n            // check the two element at the respective x,y position is same\n            assert_eq!(string1_chars[x-1], string2_chars[y-1]);\n            let char = string1_chars[x - 1];\n            common_seq.push(char);\n            x = x - 1;\n            y = y - 1;\n        }\n    }\n    common_seq.reverse();\n    (table[total_rows - 1][total_columns - 1], String::from_utf8(common_seq).unwrap())\n}\n\nfn main() {\n    let res = lcs(\"abcdaf\".to_string(), \"acbcf\".to_string());\n    assert_eq!((4 as usize, \"abcf\".to_string()), res);\n    let res = lcs(\"thisisatest\".to_string(), \"testing123testing\".to_string());\n    assert_eq!((7 as usize, \"tsitest\".to_string()), res);\n    // LCS for input Sequences “AGGTAB” and “GXTXAYB” is “GTAB” of length 4.\n    let res = lcs(\"AGGTAB\".to_string(), \"GXTXAYB\".to_string());\n    assert_eq!((4 as usize, \"GTAB\".to_string()), res);\n}",
    "title": "Longest common subsequence",
    "url": "http://rosettacode.org/wiki/Longest_common_subsequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Longest increasing subsequence",
    "url": "http://rosettacode.org/wiki/Longest_increasing_subsequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Longest string challenge",
    "url": "http://rosettacode.org/wiki/Longest_string_challenge"
  },
  {
    "local_code": "extern crate run_length_encoding;\n\nuse run_length_encoding::encode;\n\nfn main() {\n    let mut s = look_and_say(\"1\");\n    for _ in 0..20 {\n        println!(\"{}\", s);\n        s = look_and_say(&s[..]);\n    }\n}\n\nfn look_and_say(value: &str) -> String {\n    if value.chars().any(|c| !c.is_digit(10)) {\n        panic!(\"this task requires all digits\");\n    }\n    encode(value)\n}\n\n#[test]\nfn test_say() {\n    assert_eq!(look_and_say(\"11222333\"), \"213233\".to_string());\n}\n",
    "path": "tasks/look-and-say-sequence",
    "remote_code": "fn next_sequence(in_seq: &[i8]) -> Vec<i8> {\n    assert!(!in_seq.is_empty());\n\n    let mut result = Vec::new();\n    let mut current_number = in_seq[0];\n    let mut current_runlength = 1;\n\n    for i in &in_seq[1..] {\n        if current_number == *i {\n            current_runlength += 1;\n        } else {\n            result.push(current_runlength);\n            result.push(current_number);\n            current_runlength = 1;\n            current_number = *i;\n        }\n    }\n    result.push(current_runlength);\n    result.push(current_number);\n    result\n}\n\nfn main() {\n    let mut seq = vec![1];\n\n    for i in 0..10 {\n        println!(\"Sequence {}: {:?}\", i, seq);\n        seq = next_sequence(&seq);\n    }\n}",
    "title": "Look-and-say sequence",
    "url": "http://rosettacode.org/wiki/Look-and-say_sequence"
  },
  {
    "local_code": "fn main() {\n    let a1 = [\"a\", \"b\", \"c\"];\n    let a2 = [\"A\", \"B\", \"C\"];\n    let a3 = [1, 2, 3];\n\n    for ((&x, &y), &z) in a1.iter().zip(a2.iter()).zip(a3.iter()) {\n        println!(\"{}{}{}\", x, y, z);\n    }\n}\n",
    "path": "tasks/loop-over-multiple-arrays-simultaneously",
    "remote_code": "fn main() {\n    let a1 = [\"a\", \"b\", \"c\"];\n    let a2 = [\"A\", \"B\", \"C\"];\n    let a3 = [1, 2, 3];\n\n    for ((&x, &y), &z) in a1.iter().zip(a2.iter()).zip(a3.iter()) {\n        println!(\"{}{}{}\", x, y, z);\n    }\n}",
    "title": "Loop over multiple arrays simultaneously",
    "url": "http://rosettacode.org/wiki/Loop_over_multiple_arrays_simultaneously"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::Rng;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    loop {\n        let num = rng.gen_range(0, 20);\n        println!(\"{}\", num);\n        if num == 10 {\n            break;\n        }\n        println!(\"{}\", rng.gen_range(0, 20));\n    }\n}\n",
    "path": "tasks/loops/break",
    "remote_code": "// cargo-deps: rand\n\nextern crate rand;\nuse rand::{thread_rng, Rng};\n \nfn main() {\n    let mut rng = thread_rng();\n    loop {\n        let num = rng.gen_range(0, 20);\n        if num == 10 {\n            println!(\"{}\", num);\n            break;\n        }\n        println!(\"{}\", rng.gen_range(0, 20));\n    }\n}",
    "title": "Loops/Break",
    "url": "http://rosettacode.org/wiki/Loops/Break"
  },
  {
    "local_code": "fn main() {\n    for i in 1..10 + 1 {\n        print!(\"{}\", i);\n        if i % 5 == 0 {\n            println!();\n            continue;\n        }\n        print!(\", \");\n    }\n}\n",
    "path": "tasks/loops/continue",
    "remote_code": "fn main() {\n    for i in 1..=10 {\n        print!(\"{}\", i);\n        if i % 5 == 0 {\n            println!();\n            continue;\n        }\n        print!(\", \");\n    }\n}",
    "title": "Loops/Continue",
    "url": "http://rosettacode.org/wiki/Loops/Continue"
  },
  {
    "local_code": "//! Rust does not have a `do...while` loop. Instead, the keyword `loop` is used with a termination\n//! condition.\n\nfn main() {\n    let mut x = 0;\n\n    loop {\n        x += 1;\n        println!(\"{}\", x);\n\n        if x % 6 == 0 {\n            break;\n        }\n    }\n}\n",
    "path": "tasks/loops/do-while",
    "remote_code": "let mut x = 0;\n\nloop {\n    x += 1;\n    println!(\"{}\", x);\n\n    if x % 6 == 0 { break; }\n}",
    "title": "Loops/Do-while",
    "url": "http://rosettacode.org/wiki/Loops/Do-while"
  },
  {
    "local_code": "fn main() {\n    for i in (1..=10).rev() {\n        println!(\"{}\", i);\n    }\n}\n",
    "path": "tasks/loops/downward-for",
    "remote_code": "fn main() {\n    for i in (0..=10).rev() {\n        println!(\"{}\", i);\n    }\n}",
    "title": "Loops/Downward for",
    "url": "http://rosettacode.org/wiki/Loops/Downward_for"
  },
  {
    "local_code": "fn main() {\n    for i in 1..6 {\n        for _ in 1..i + 1 {\n            print!(\"*\");\n        }\n        println!();\n    }\n}\n",
    "path": "tasks/loops/for",
    "remote_code": "fn main() {\n    for i in 0..5 {\n        for _ in 0..=i {\n            print!(\"*\");\n        }\n\n        println!();\n    }\n}",
    "title": "Loops/For",
    "url": "http://rosettacode.org/wiki/Loops/For"
  },
  {
    "local_code": "fn main() {\n    for i in (2..8 + 1).step_by(2) {\n        print!(\"{}\", i);\n    }\n    println!(\"who do we appreciate?!\");\n}\n",
    "path": "tasks/loops/for-with-a-specified-step",
    "remote_code": "fn main() {\n  for i in (2..=8).step_by(2) {\n    print!(\"{}\", i);\n  }\n  println!(\"who do we appreciate?!\");\n}\n",
    "title": "Loops/For with a specified step",
    "url": "http://rosettacode.org/wiki/Loops/For_with_a_specified_step"
  },
  {
    "local_code": "use std::collections::HashMap;\n\nfn main() {\n    // Rust's for-loop already is a foreach-loop.\n    let collection = vec![1, 2, 3, 4, 5];\n    for elem in collection {\n        println!(\"{}\", elem);\n    }\n\n    // Do note that Rust moves values by default and doesn't copy them. A vector would be unusable\n    // after looping over it like above. To preserve it, borrow it or use an Iter, to mutate values\n    // do a mutable borrow or create an IterMut. To get an immutable reference omit the mut-part.\n\n    let mut collection = vec![1, 2, 3, 4, 5];\n    for mut_ref in &mut collection {\n        // alternatively:\n        // for mut_ref in collection.iter_mut() {\n        *mut_ref *= 2;\n        println!(\"{}\", *mut_ref);\n    }\n\n    // immutable borrow\n    for immut_ref in &collection {\n        // alternatively:\n        // for immut_ref in collection.iter() {\n        println!(\"{}\", *immut_ref);\n    }\n\n    // Iterate through the characters of a string\n    let s = \"hello, world!\";\n    for i in s.chars() {\n        print!(\"{}\", i);\n    }\n    println!();\n\n    // Iterate through the elements of a slice\n    let array = [1, 2, 3, 4, 5];\n    for i in &array {\n        print!(\"{}\", i);\n    }\n    println!();\n\n    // Iterate through the elements of a hashmap\n    let mut hashmap = HashMap::new();\n    hashmap.insert(\"a\", 1u8);\n    hashmap.insert(\"b\", 2);\n    hashmap.insert(\"c\", 3);\n    for (c, i) in &hashmap {\n        println!(\"{}: '{}'\", c, i)\n    }\n}\n",
    "path": "tasks/loops/foreach",
    "remote_code": "let collection = vec![1,2,3,4,5];\nfor elem in collection {\n    println!(\"{}\", elem);\n}",
    "title": "Loops/Foreach",
    "url": "http://rosettacode.org/wiki/Loops/Foreach"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Loops/Increment loop index within loop body",
    "url": "http://rosettacode.org/wiki/Loops/Increment_loop_index_within_loop_body"
  },
  {
    "local_code": "fn main() {\n    loop {\n        println!(\"spam\");\n    }\n}\n",
    "path": "tasks/loops/infinite",
    "remote_code": "fn main() {\n    loop {\n        println!(\"SPAM\");\n    }\n}",
    "title": "Loops/Infinite",
    "url": "http://rosettacode.org/wiki/Loops/Infinite"
  },
  {
    "local_code": "fn main() {\n    for i in 1..11 {\n        print!(\"{}\", i);\n        if i == 10 {\n            break;\n        }\n        print!(\", \");\n    }\n}\n",
    "path": "tasks/loops/n-plus-one-half",
    "remote_code": "fn main() {\n    for i in 1..=10 {\n        print!(\"{}{}\", i, if i < 10 { \", \" } else { \"\\n\" });\n    }\n}",
    "title": "Loops/N plus one half",
    "url": "http://rosettacode.org/wiki/Loops/N_plus_one_half"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::Rng;\n\nfn main() {\n    let mut matrix = [[0u8; 10]; 10];\n    let mut rng = rand::thread_rng();\n\n    for row in &mut matrix {\n        for item in &mut *row {\n            *item = rng.gen_range(0, 21);\n        }\n    }\n\n    'outer: for row in &matrix {\n        for &item in row {\n            print!(\"{:2} \", item);\n            if item == 20 {\n                break 'outer;\n            }\n        }\n        println!();\n    }\n}\n",
    "path": "tasks/loops/nested",
    "remote_code": "use rand::Rng;\n\nextern crate rand;\n\nfn main() {\n    let mut matrix = [[0u8; 10]; 10];\n    let mut rng = rand::thread_rng();\n\n    for row in matrix.iter_mut() {\n        for item in row.iter_mut() {\n            *item = rng.gen_range(0, 21);\n        }\n    }\n\n    'outer: for row in matrix.iter() {\n        for &item in row.iter() {\n            print!(\"{:2} \", item);\n            if item == 20 { break 'outer }\n        }\n        println!();\n    }\n}",
    "title": "Loops/Nested",
    "url": "http://rosettacode.org/wiki/Loops/Nested"
  },
  {
    "local_code": "fn main() {\n    let mut i = 1024;\n    while i > 0 {\n        println!(\"{}\", i);\n        i /= 2;\n    }\n}\n",
    "path": "tasks/loops/while",
    "remote_code": "fn main() {\n    let mut n: i32 = 1024;\n    while n > 0 {\n        println!(\"{}\", n);\n        n /= 2;\n    }\n}",
    "title": "Loops/While",
    "url": "http://rosettacode.org/wiki/Loops/While"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Loops/Wrong ranges",
    "url": "http://rosettacode.org/wiki/Loops/Wrong_ranges"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Loops/with multiple ranges",
    "url": "http://rosettacode.org/wiki/Loops/with_multiple_ranges"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n\nextern crate rug;\nextern crate primal;\n\nuse rug::Integer;\nuse rug::ops::Pow;\nuse std::thread::spawn;\n\nfn is_mersenne (p : usize) {\n    let p = p as u32;\n    let mut m = Integer::from(1);\n    m = m << p;  \n    m = Integer::from(&m - 1);\n    let mut flag1 = false;\n    for k in 1..10_000 {\n        let mut flag2 = false;\n        let mut div : u32 = 2*k*p + 1;\n        if &div >= &m {break; }\n        for j in [3,5,7,11,13,17,19,23,29,31,37].iter() {\n            if div % j == 0 {\n                flag2 = true;\n                break;\n            }   \n        }\n        if flag2 == true {continue;}\n        if div % 8 != 1 && div % 8 != 7 { continue; }\n        if m.is_divisible_u(div) { \n            flag1 = true;\n            break;\n        }\n    }\n    if flag1 == true {return ()}\n    let mut s = Integer::from(4);\n    let two = Integer::from(2);\n    for _i in 2..p {\n\t\tlet mut sqr = s.pow(2);\n\t\ts = Integer::from(&Integer::from(&sqr & &m) + &Integer::from(&sqr >> p));\n\t\tif &s >= &m {s = s - &m}\n\t\ts = Integer::from(&s - &two);\n    }\n\tif s == 0 {println!(\"Mersenne : {}\",p);} \n}\n\nfn main () {\n    println!(\"Mersenne : 2\");\n    let limit = 11_214;\n    let mut thread_handles = vec![];\n    for p in primal::Primes::all().take_while(|p| *p < limit) {\n        thread_handles.push(spawn(move || is_mersenne(p))); \n    }\n    for handle in thread_handles {\n        handle.join().unwrap();\n    }\n}\n",
    "title": "Lucas-Lehmer test",
    "url": "http://rosettacode.org/wiki/Lucas-Lehmer_test"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Lucky and even lucky numbers",
    "url": "http://rosettacode.org/wiki/Lucky_and_even_lucky_numbers"
  },
  {
    "local_code": "const ARRAY_MAX: usize = 25_000;\nconst LUDIC_MAX: usize = 2100;\n\n/// Calculates and returns the first `LUDIC_MAX` Ludic numbers.\n///\n/// Needs a sufficiently large `ARRAY_MAX`.\nfn ludic_numbers() -> Vec<usize> {\n    // The first two Ludic numbers\n    let mut numbers = vec![1, 2];\n    // We start the array with an immediate first removal to reduce memory usage by\n    // collecting only odd numbers.\n    numbers.extend((3..ARRAY_MAX).step_by(2));\n\n    // We keep the correct Ludic numbers in place, removing the incorrect ones.\n    for ludic_idx in 2..LUDIC_MAX {\n        let next_ludic = numbers[ludic_idx];\n\n        // We remove incorrect numbers by counting the indices after the correct numbers.\n        // We start from zero and keep until we reach the potentially incorrect numbers.\n        // Then we keep only those not divisible by the `next_ludic`.\n        let mut idx = 0;\n        numbers.retain(|_| {\n            let keep = idx <= ludic_idx || (idx - ludic_idx) % next_ludic != 0;\n            idx += 1;\n            keep\n        });\n    }\n\n    numbers\n}\n\nfn main() {\n    let ludic_numbers = ludic_numbers();\n\n    print!(\"First 25: \");\n    print_n_ludics(&ludic_numbers, 25);\n    println!();\n    print!(\"Number of Ludics below 1000: \");\n    print_num_ludics_upto(&ludic_numbers, 1000);\n    println!();\n    print!(\"Ludics from 2000 to 2005: \");\n    print_ludics_from_to(&ludic_numbers, 2000, 2005);\n    println!();\n    println!(\"Triplets below 250: \");\n    print_triplets_until(&ludic_numbers, 250);\n}\n\n/// Prints the first `n` Ludic numbers.\nfn print_n_ludics(x: &[usize], n: usize) {\n    println!(\"{:?}\", &x[..n]);\n}\n\n/// Calculates how many Ludic numbers are below `max_num`.\nfn print_num_ludics_upto(x: &[usize], max_num: usize) {\n    let num = x.iter().take_while(|&&i| i < max_num).count();\n    println!(\"{}\", num);\n}\n\n/// Prints Ludic numbers between two numbers.\nfn print_ludics_from_to(x: &[usize], from: usize, to: usize) {\n    println!(\"{:?}\", &x[from - 1..to - 1]);\n}\n\n/// Calculates triplets until a certain Ludic number.\nfn triplets_below(ludics: &[usize], limit: usize) -> Vec<(usize, usize, usize)> {\n    ludics\n        .iter()\n        .enumerate()\n        .take_while(|&(_, &num)| num < limit)\n        .filter_map(|(idx, &number)| {\n            let triplet_2 = number + 2;\n            let triplet_3 = number + 6;\n\n            // Search for the other two triplet numbers.  We know they are larger than\n            // `number` so we can give the searches lower bounds of `idx + 1` and\n            // `idx + 2`.  We also know that the `n + 2` number can only ever be two\n            // numbers away from the previous and the `n + 6` number can only be four\n            // away (because we removed some in between).  Short circuiting and doing\n            // the check more likely to fail first are also useful.\n            let is_triplet = ludics[idx + 1..idx + 3].binary_search(&triplet_2).is_ok()\n                && ludics[idx + 2..idx + 5].binary_search(&triplet_3).is_ok();\n\n            if is_triplet {\n                Some((number, triplet_2, triplet_3))\n            } else {\n                None\n            }\n        })\n        .collect()\n}\n\n/// Prints triplets until a certain Ludic number.\nfn print_triplets_until(ludics: &[usize], limit: usize) {\n    for (number, triplet_2, triplet_3) in triplets_below(ludics, limit) {\n        println!(\"{} {} {}\", number, triplet_2, triplet_3);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn solutions() {\n        let ludics = ludic_numbers();\n\n        // First 25\n        let first_25 = [\n            1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43, 47, 53, 61, 67, 71, 77, 83, 89, 91,\n            97, 107,\n        ];\n        assert_eq!(ludics[..25], first_25);\n\n        // Count below 1000\n        assert_eq!(ludics.iter().take_while(|&&i| i < 1000).count(), 142);\n\n        // 2000th to 2005th numbers\n        let expected_range = [21475, 21481, 21487, 21493, 21503];\n        assert_eq!(ludics[2000 - 1..2005 - 1], expected_range);\n\n        // Triplets\n        let expected_triplets = [\n            (1, 3, 7),\n            (5, 7, 11),\n            (11, 13, 17),\n            (23, 25, 29),\n            (41, 43, 47),\n            (173, 175, 179),\n            (221, 223, 227),\n            (233, 235, 239),\n        ];\n        let tested_triplets = triplets_below(&ludics, 250);\n        assert_eq!(expected_triplets, tested_triplets.as_slice());\n    }\n}\n",
    "path": "tasks/ludic-numbers",
    "remote_code": null,
    "title": "Ludic numbers",
    "url": "http://rosettacode.org/wiki/Ludic_numbers"
  },
  {
    "local_code": "struct Digits {\n    m: u64,\n}\n\nimpl Iterator for Digits {\n    type Item = u64;\n\n    fn next(&mut self) -> Option<u64> {\n        match self.m {\n            0 => None,\n            n => {\n                let ret = n % 10;\n                self.m = n / 10;\n                Some(ret)\n            }\n        }\n    }\n}\n\n#[derive(Copy, Clone)]\nenum LuhnState {\n    Even,\n    Odd,\n}\n\nfn digits(n: u64) -> Digits {\n    Digits { m: n }\n}\n\npub fn luhn_test(n: u64) -> bool {\n    let odd_even = [LuhnState::Odd, LuhnState::Even];\n    let numbers = digits(n).zip(odd_even.iter().cycle().cloned());\n    let sum = numbers.fold(0u64, |s, n| {\n        s + match n {\n            (n, LuhnState::Odd) => n,\n            (n, LuhnState::Even) => digits(n * 2).fold(0, |s, n| s + n),\n        }\n    });\n    sum % 10 == 0\n}\n\n#[test]\nfn test_inputs() {\n    assert!(luhn_test(49927398716));\n    assert!(!luhn_test(49927398717));\n    assert!(!luhn_test(1234567812345678));\n    assert!(luhn_test(1234567812345670));\n}\n",
    "path": "tasks/luhn-test-of-credit-card-numbers",
    "remote_code": "extern crate luhn_test_of_credit_card_numbers;\n\nuse luhn_test_of_credit_card_numbers::luhn_test;\n\nfn validate_isin(isin: &str) -> bool {\n    if !isin.chars().all(|x| x.is_alphanumeric()) || isin.len() != 12 {\n        return false;\n    }\n    if !isin[..2].chars().all(|x| x.is_alphabetic())\n        || !isin[2..12].chars().all(|x| x.is_alphanumeric())\n        || !isin.chars().last().unwrap().is_numeric()\n    {\n        return false;\n    }\n\n    let bytes = isin.as_bytes();\n\n    let s2 = bytes\n        .iter()\n        .flat_map(|&c| {\n            if c.is_ascii_digit() {\n                vec![c]\n            } else {\n                (c + 10 - ('A' as u8)).to_string().into_bytes()\n            }\n        })\n        .collect::<Vec<u8>>();\n\n    let string = std::str::from_utf8(&s2).unwrap();\n    let number = string.parse::<u64>().unwrap();\n\n    return luhn_test(number as u64);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::validate_isin;\n\n    #[test]\n    fn test_validate_isin() {\n        assert_eq!(validate_isin(\"US0378331005\"), true);\n        assert_eq!(validate_isin(\"US0373831005\"), false);\n        assert_eq!(validate_isin(\"U50378331005\"), false);\n        assert_eq!(validate_isin(\"US03378331005\"), false);\n        assert_eq!(validate_isin(\"AU0000XVGZA3\"), true);\n        assert_eq!(validate_isin(\"AU0000VXGZA3\"), true);\n        assert_eq!(validate_isin(\"FR0000988040\"), true);\n    }\n}",
    "title": "Luhn test of credit card numbers",
    "url": "http://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers"
  },
  {
    "local_code": "extern crate num;\n\nuse num::bigint::BigInt;\nuse num::FromPrimitive;\n\nuse std::collections::HashSet;\n\n/// Reverse a number then add it to the original.\nfn rev_add(num: &BigInt) -> BigInt {\n    let rev_string: String = num.to_string().chars().rev().collect();\n    // should be safe, our string is guaranteed to be a number\n    let rev_val: BigInt = rev_string.parse().unwrap();\n    num + rev_val\n}\n\n/// Check if a number is a palindrome when written in base 10.\nfn is_palindrome(num: &BigInt) -> bool {\n    let num_string = num.to_string();\n    let rev_string = num_string.chars().rev();\n    let comp_len = num_string.len() / 2;\n    num_string\n        .chars()\n        .take(comp_len)\n        .eq(rev_string.take(comp_len))\n}\n\n/// Perform a lychrel test on a number, stopping after `max_tests`\n/// Returns the sequence of numbers if this number is a lychrel, None otherwise.\nfn test_lychrel(num: &BigInt, max_tests: usize) -> Option<Vec<BigInt>> {\n    let mut sequence = Vec::<BigInt>::new();\n\n    let is_lychrel = (0..max_tests)\n        .scan(num.clone(), |current, _| {\n            *current = rev_add(current);\n            Some(current.clone())\n        })\n        .inspect(|current| sequence.push(current.clone()))\n        .all(|cur| !is_palindrome(&cur));\n\n    if is_lychrel {\n        Some(sequence)\n    } else {\n        None\n    }\n}\n\n/// Determine if the sequence for a lychrel number is related to a previously seen sequence\nfn is_related(seq: &[BigInt], lychrel_seq_numbers: &HashSet<BigInt>) -> bool {\n    seq.iter().any(|num| lychrel_seq_numbers.contains(num))\n}\n\n/// Find the lychrel numbers up to `max_num` (inclusive).\n/// Returns a tuple (lychrel numbers, related numbers, palindrome lychrel/related numbers)\nfn find_lychrels(max_num: u64, max_tests: usize) -> (Vec<BigInt>, Vec<BigInt>, Vec<BigInt>) {\n    // storage for various outputs\n    let mut lychrels = Vec::<BigInt>::new();\n    let mut relateds = Vec::<BigInt>::new();\n    let mut palindrome_lychrels = Vec::<BigInt>::new();\n\n    let mut lychrel_seq_numbers: HashSet<BigInt> = HashSet::new();\n\n    for i in 1..(max_num + 1) {\n        let num = FromPrimitive::from_u64(i).unwrap();\n        let maybe_lychrel = test_lychrel(&num, max_tests);\n\n        if let Some(lychrel_seq) = maybe_lychrel {\n            // it's a lychrel - check if it's a related number\n            let related = is_related(&lychrel_seq, &lychrel_seq_numbers);\n\n            // update our sequences\n            for seq_num in lychrel_seq {\n                lychrel_seq_numbers.insert(seq_num);\n            }\n\n            if !related {\n                // the number has a new lychrel sequence, store it\n                lychrels.push(num.clone());\n            } else {\n                // just count it as a related number\n                relateds.push(num.clone());\n            }\n\n            if is_palindrome(&num) {\n                // doesn't matter if palindromes are related or not\n                palindrome_lychrels.push(num.clone());\n            }\n        }\n    }\n\n    (lychrels, relateds, palindrome_lychrels)\n}\n\nfn print_nums(before: &str, numbers: &[BigInt]) {\n    print!(\"{}\", before);\n    for (i, current) in numbers.iter().enumerate() {\n        print!(\"{}\", current);\n        if i + 1 < numbers.len() {\n            print!(\", \");\n        }\n    }\n    println!();\n}\n\nfn main() {\n    let max_num: u64 = 10_000;\n    let max_tests: usize = 500;\n\n    println!(\n        \"Calculations using n = 1..{} and limiting each search to {} reverse-digits-and-adds\",\n        max_num, max_tests\n    );\n\n    let (lychrels, relateds, palindrome_lychrels) = find_lychrels(max_num, max_tests);\n\n    println!(\"Number of Lychrel numbers: {}\", lychrels.len());\n    print_nums(\"Lychrel numbers: \", &lychrels);\n    println!(\"Number of Lychrel related: {}\", relateds.len());\n    println!(\n        \"Number of Lychrel palindromes: {}\",\n        palindrome_lychrels.len()\n    );\n    print_nums(\"Lychrel palindromes: \", &palindrome_lychrels);\n}\n\n#[test]\n#[ignore]\nfn test_lychrel_numbers() {\n    let (lychrels, relateds, palindrome_lychrels) = find_lychrels(10_000, 500);\n\n    let expected_lychrels = [196, 879, 1997, 7059, 9999]\n        .iter()\n        .map(|&num| FromPrimitive::from_u64(num).unwrap())\n        .collect::<Vec<_>>();\n    assert_eq!(lychrels, expected_lychrels);\n\n    assert_eq!(relateds.len(), 244);\n\n    let expected_palindromes = [4994, 8778, 9999]\n        .iter()\n        .map(|&num| FromPrimitive::from_u64(num).unwrap())\n        .collect::<Vec<_>>();\n    assert_eq!(palindrome_lychrels, expected_palindromes);\n}\n",
    "path": "tasks/lychrel-numbers",
    "remote_code": "extern crate num;\nuse num::FromPrimitive;\nuse num::bigint::BigInt;\n\nuse std::collections::HashSet;\n\n/// Reverse a number then add it to the original.\nfn rev_add(num: &BigInt) -> BigInt {\n    let rev_string: String = num.to_string().chars().rev().collect();\n    // should be safe, our string is guaranteed to be a number\n    let rev_val: BigInt = rev_string.parse().unwrap();\n    num + rev_val\n}\n\n/// Check if a number is a palindrome when written in base 10.\nfn is_palindrome(num: &BigInt) -> bool {\n    let num_string = num.to_string();\n    let rev_string: String = num_string.chars().rev().collect();\n    let comp_len = num_string.len() / 2;\n    num_string[0..comp_len] == rev_string[0..comp_len]\n}\n\n/// Perform a lychrel test on a number, stopping after max_tests\n/// Returns the sequence of numbers if this number is a lychrel, None otherwise.\nfn test_lychrel(num: &BigInt, max_tests: usize) -> Option<Vec<BigInt>> {\n    let mut sequence = Vec::<BigInt>::new();\n\n    let is_lychrel = (0..max_tests)\n        .scan(num.clone(), |current, _| {\n            *current = rev_add(current);\n            Some(current.clone())\n        })\n        .inspect(|current| sequence.push(current.clone()))\n        .filter(|curent| is_palindrome(curent))\n        .next()\n        .is_none();\n\n    if is_lychrel {\n        Some(sequence)\n    }\n    else {\n        None\n    }\n}\n\n/// Determine if the sequence for a lychrel number is related to a previously seen sequence\nfn is_related(seq: &Vec<BigInt>, lychrel_seq_numbers: &HashSet<BigInt>) -> bool {\n    seq.iter().filter(|num| lychrel_seq_numbers.contains(num)).next().is_some()\n}\n\n/// Find the lychrel numbers up to max_num (inclusive).\n/// Returns a tuple (lychrel numbers, related numbers, palindrome lychrel/related numbers)\nfn find_lychrels(max_num: u64, max_tests: usize) -> (Vec<BigInt>, Vec<BigInt>, Vec<BigInt>) {\n    // storage for various outputs\n    let mut lychrels = Vec::<BigInt>::new();\n    let mut relateds = Vec::<BigInt>::new();\n    let mut palindrome_lychrels = Vec::<BigInt>::new();\n\n    let mut lychrel_seq_numbers: HashSet<BigInt> = HashSet::new();\n\n    for i in (1..(max_num + 1)) {\n        let num = FromPrimitive::from_u64(i).unwrap();\n        let maybe_lychrel = test_lychrel(&num, max_tests);\n\n        if let Some(lychrel_seq) = maybe_lychrel {\n            // it's a lychrel - check if it's a related number\n            let related = is_related(&lychrel_seq, &lychrel_seq_numbers);\n\n            // update our sequences\n            for seq_num in lychrel_seq.into_iter() {\n                lychrel_seq_numbers.insert(seq_num);\n            }\n\n            if !related {\n                // the number has a new lychrel sequence, store it\n                lychrels.push(num.clone());\n            }\n            else {\n                // just count it as a related number\n                relateds.push(num.clone());\n            }\n\n            if is_palindrome(&num) {\n                // doesn't matter if palindromes are related or not\n                palindrome_lychrels.push(num.clone());\n            }\n        }\n    }\n\n    (lychrels, relateds, palindrome_lychrels)\n}\n\nfn print_nums(before: &str, numbers: &Vec<BigInt>) {\n    print!(\"{}\", before);\n    for (i, current) in numbers.iter().enumerate() {\n        print!(\"{}\", current);\n        if i + 1 < numbers.len() {\n            print!(\", \");\n        }\n    }\n    println!(\"\");\n}\n\nfn main() {\n    let max_num: u64 = 10_000;\n    let max_tests: usize = 500;\n\n    println!(\"Calculations using n = 1..{} and limiting each search to {} reverse-digits-and-adds\",\n        max_num, max_tests);\n\n    let (lychrels, relateds, palindrome_lychrels) = find_lychrels(max_num, max_tests);\n\n    println!(\"Number of Lychrel numbers: {}\", lychrels.len());\n    print_nums(\"Lychrel numbers: \", &lychrels);\n    println!(\"Number of Lychrel related: {}\", relateds.len());\n    println!(\"Number of Lychrel palindromes: {}\", palindrome_lychrels.len());\n    print_nums(\"Lychrel palindromes: \", &palindrome_lychrels);\n}",
    "title": "Lychrel numbers",
    "url": "http://rosettacode.org/wiki/Lychrel_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate reqwest;\n\nuse std::{thread, time};\n\nfn get_vendor(mac: &str) -> Option<String> {\n    let mut url = String::from(\"http://api.macvendors.com/\");\n    url.push_str(mac);\n    let url_ref = &url;\n    match reqwest::get(url_ref) {\n        Ok(mut res) => match res.text() {\n            Ok(text) => {\n                if text.contains(\"Not Found\") {\n                    Some(\"N/A\".to_string())\n                } else {\n                    Some(text)\n                }\n            }\n            Err(e) => {\n                println!(\"{:?}\", e);\n                None\n            }\n        },\n        Err(e) => {\n            println!(\"{:?}\", e);\n            None\n        }\n    }\n}\n\nfn main() {\n    let duration = time::Duration::from_millis(1000);\n    match get_vendor(\"88:53:2E:67:07:BE\") {\n        None => println!(\"Error!\"),\n        Some(text) => println!(\"{}\", text),\n    }\n    thread::sleep(duration);\n    match get_vendor(\"FC:FB:FB:01:FA:21\") {\n        None => println!(\"Error!\"),\n        Some(text) => println!(\"{}\", text),\n    }\n    thread::sleep(duration);\n    match get_vendor(\"FC-A1-3E\") {\n        None => println!(\"Error!\"),\n        Some(text) => println!(\"{}\", text),\n    }\n    thread::sleep(duration);\n    match get_vendor(\"abcdefg\") {\n        None => println!(\"Error!\"),\n        Some(text) => println!(\"{}\", text),\n    }\n}\n",
    "title": "MAC Vendor Lookup",
    "url": "http://rosettacode.org/wiki/MAC_Vendor_Lookup"
  },
  {
    "local_code": "// MD4, based on RFC 1186 and RFC 1320.\n//\n// https://www.ietf.org/rfc/rfc1186.txt\n// https://tools.ietf.org/html/rfc1320\n//\n\nuse std::fmt::Write;\nuse std::mem;\n\n// Let not(X) denote the bit-wise complement of X.\n// Let X v Y denote the bit-wise OR of X and Y.\n// Let X xor Y denote the bit-wise XOR of X and Y.\n// Let XY denote the bit-wise AND of X and Y.\n\n// f(X,Y,Z)  =  XY v not(X)Z\nfn f(x: u32, y: u32, z: u32) -> u32 {\n    (x & y) | (!x & z)\n}\n\n// g(X,Y,Z)  =  XY v XZ v YZ\nfn g(x: u32, y: u32, z: u32) -> u32 {\n    (x & y) | (x & z) | (y & z)\n}\n\n// h(X,Y,Z)  =  X xor Y xor Z\nfn h(x: u32, y: u32, z: u32) -> u32 {\n    x ^ y ^ z\n}\n\n// Round 1 macro\n// Let [A B C D i s] denote the operation\n//   A = (A + f(B,C,D) + X[i]) <<< s\nmacro_rules! md4round1 {\n    ($a:expr, $b:expr, $c:expr, $d:expr, $i:expr, $s:expr, $x:expr) => {{\n        // Rust defaults to non-overflowing arithmetic, so we need to specify wrapping add.\n        $a = ($a.wrapping_add(f($b, $c, $d)).wrapping_add($x[$i])).rotate_left($s);\n    }};\n}\n\n// Round 2 macro\n// Let [A B C D i s] denote the operation\n//   A = (A + g(B,C,D) + X[i] + 5A827999) <<< s .\nmacro_rules! md4round2 {\n    ($a:expr, $b:expr, $c:expr, $d:expr, $i:expr, $s:expr, $x:expr) => {{\n        $a = ($a\n            .wrapping_add(g($b, $c, $d))\n            .wrapping_add($x[$i])\n            .wrapping_add(0x5a82_7999_u32))\n        .rotate_left($s);\n    }};\n}\n\n// Round 3 macro\n// Let [A B C D i s] denote the operation\n//   A = (A + h(B,C,D) + X[i] + 6ED9EBA1) <<< s .\nmacro_rules! md4round3 {\n    ($a:expr, $b:expr, $c:expr, $d:expr, $i:expr, $s:expr, $x:expr) => {{\n        $a = ($a\n            .wrapping_add(h($b, $c, $d))\n            .wrapping_add($x[$i])\n            .wrapping_add(0x6ed9_eba1_u32))\n        .rotate_left($s);\n    }};\n}\n\nfn convert_byte_vec_to_u32(mut bytes: Vec<u8>) -> Vec<u32> {\n    bytes.shrink_to_fit();\n    let num_bytes = bytes.len();\n    let num_words = num_bytes / 4;\n    unsafe {\n        let words = Vec::from_raw_parts(bytes.as_mut_ptr() as *mut u32, num_words, num_words);\n        mem::forget(bytes);\n        words\n    }\n}\n\n// Returns a 128-bit MD4 hash as an array of four 32-bit words.\n// Based on RFC 1186 from https://www.ietf.org/rfc/rfc1186.txt\n#[cfg_attr(feature = \"cargo-clippy\", allow(many_single_char_names))]\nfn md4<T: Into<Vec<u8>>>(input: T) -> [u32; 4] {\n    let mut bytes = input.into().to_vec();\n    let initial_bit_len = (bytes.len() << 3) as u64;\n\n    // Step 1. Append padding bits\n    // Append one '1' bit, then append 0 ≤ k < 512 bits '0', such that the resulting message\n    // length in bis is congruent to 448 (mod 512).\n    // Since our message is in bytes, we use one byte with a set high-order bit (0x80) plus\n    // a variable number of zero bytes.\n\n    // Append zeros\n    // Number of padding bytes needed is 448 bits (56 bytes) modulo 512 bits (64 bytes)\n    bytes.push(0x80_u8);\n    while (bytes.len() % 64) != 56 {\n        bytes.push(0_u8);\n    }\n\n    // Everything after this operates on 32-bit words, so reinterpret the buffer.\n    let mut w = convert_byte_vec_to_u32(bytes);\n\n    // Step 2. Append length\n    // A 64-bit representation of b (the length of the message before the padding bits were added)\n    // is appended to the result of the previous step, low-order bytes first.\n    w.push(initial_bit_len as u32); // Push low-order bytes first\n    w.push((initial_bit_len >> 32) as u32);\n\n    // Step 3. Initialize MD buffer\n    let mut a = 0x6745_2301_u32;\n    let mut b = 0xefcd_ab89_u32;\n    let mut c = 0x98ba_dcfe_u32;\n    let mut d = 0x1032_5476_u32;\n\n    // Step 4. Process message in 16-word blocks\n    let n = w.len();\n    for i in 0..n / 16 {\n        // Select the next 512-bit (16-word) block to process.\n        let x = &w[i * 16..i * 16 + 16];\n\n        let aa = a;\n        let bb = b;\n        let cc = c;\n        let dd = d;\n\n        // [Round 1]\n        md4round1!(a, b, c, d, 0, 3, x); // [A B C D 0 3]\n        md4round1!(d, a, b, c, 1, 7, x); // [D A B C 1 7]\n        md4round1!(c, d, a, b, 2, 11, x); // [C D A B 2 11]\n        md4round1!(b, c, d, a, 3, 19, x); // [B C D A 3 19]\n        md4round1!(a, b, c, d, 4, 3, x); // [A B C D 4 3]\n        md4round1!(d, a, b, c, 5, 7, x); // [D A B C 5 7]\n        md4round1!(c, d, a, b, 6, 11, x); // [C D A B 6 11]\n        md4round1!(b, c, d, a, 7, 19, x); // [B C D A 7 19]\n        md4round1!(a, b, c, d, 8, 3, x); // [A B C D 8 3]\n        md4round1!(d, a, b, c, 9, 7, x); // [D A B C 9 7]\n        md4round1!(c, d, a, b, 10, 11, x); // [C D A B 10 11]\n        md4round1!(b, c, d, a, 11, 19, x); // [B C D A 11 19]\n        md4round1!(a, b, c, d, 12, 3, x); // [A B C D 12 3]\n        md4round1!(d, a, b, c, 13, 7, x); // [D A B C 13 7]\n        md4round1!(c, d, a, b, 14, 11, x); // [C D A B 14 11]\n        md4round1!(b, c, d, a, 15, 19, x); // [B C D A 15 19]\n\n        // [Round 2]\n        md4round2!(a, b, c, d, 0, 3, x); //[A B C D 0  3]\n        md4round2!(d, a, b, c, 4, 5, x); //[D A B C 4  5]\n        md4round2!(c, d, a, b, 8, 9, x); //[C D A B 8  9]\n        md4round2!(b, c, d, a, 12, 13, x); //[B C D A 12 13]\n        md4round2!(a, b, c, d, 1, 3, x); //[A B C D 1  3]\n        md4round2!(d, a, b, c, 5, 5, x); //[D A B C 5  5]\n        md4round2!(c, d, a, b, 9, 9, x); //[C D A B 9  9]\n        md4round2!(b, c, d, a, 13, 13, x); //[B C D A 13 13]\n        md4round2!(a, b, c, d, 2, 3, x); //[A B C D 2  3]\n        md4round2!(d, a, b, c, 6, 5, x); //[D A B C 6  5]\n        md4round2!(c, d, a, b, 10, 9, x); //[C D A B 10 9]\n        md4round2!(b, c, d, a, 14, 13, x); //[B C D A 14 13]\n        md4round2!(a, b, c, d, 3, 3, x); //[A B C D 3  3]\n        md4round2!(d, a, b, c, 7, 5, x); //[D A B C 7  5]\n        md4round2!(c, d, a, b, 11, 9, x); //[C D A B 11 9]\n        md4round2!(b, c, d, a, 15, 13, x); //[B C D A 15 13]\n\n        // [Round 3]\n        md4round3!(a, b, c, d, 0, 3, x); //[A B C D 0  3]\n        md4round3!(d, a, b, c, 8, 9, x); //[D A B C 8  9]\n        md4round3!(c, d, a, b, 4, 11, x); //[C D A B 4  11]\n        md4round3!(b, c, d, a, 12, 15, x); //[B C D A 12 15]\n        md4round3!(a, b, c, d, 2, 3, x); //[A B C D 2  3]\n        md4round3!(d, a, b, c, 10, 9, x); //[D A B C 10 9]\n        md4round3!(c, d, a, b, 6, 11, x); //[C D A B 6  11]\n        md4round3!(b, c, d, a, 14, 15, x); //[B C D A 14 15]\n        md4round3!(a, b, c, d, 1, 3, x); //[A B C D 1  3]\n        md4round3!(d, a, b, c, 9, 9, x); //[D A B C 9  9]\n        md4round3!(c, d, a, b, 5, 11, x); //[C D A B 5  11]\n        md4round3!(b, c, d, a, 13, 15, x); //[B C D A 13 15]\n        md4round3!(a, b, c, d, 3, 3, x); //[A B C D 3  3]\n        md4round3!(d, a, b, c, 11, 9, x); //[D A B C 11 9]\n        md4round3!(c, d, a, b, 7, 11, x); //[C D A B 7  11]\n        md4round3!(b, c, d, a, 15, 15, x); //[B C D A 15 15]\n\n        a = a.wrapping_add(aa);\n        b = b.wrapping_add(bb);\n        c = c.wrapping_add(cc);\n        d = d.wrapping_add(dd);\n    }\n\n    // Step 5. Output\n    // The message digest produced as output is A, B, C, D. That is, we begin with the low-order\n    // byte of A, and end with the high-order byte of D.\n    [\n        u32::from_be(a),\n        u32::from_be(b),\n        u32::from_be(c),\n        u32::from_be(d),\n    ]\n}\n\nfn digest_to_str(digest: &[u32]) -> String {\n    let mut s = String::new();\n    for &word in digest {\n        write!(&mut s, \"{:08x}\", word).unwrap();\n    }\n    s\n}\n\nfn main() {\n    let val = \"Rosetta Code\";\n    println!(\"md4(\\\"{}\\\") = {}\", val, digest_to_str(&md4(val)));\n}\n\n#[test]\nfn test_rfc1320() {\n    // The following test vectors are defined in RFC 1320 (The MD4 Message-Digest Algorithm).\n    assert_eq!(\"31d6cfe0d16ae931b73c59d7e0c089c0\", digest_to_str(&md4(\"\")));\n    assert_eq!(\"bde52cb31de33e46245e05fbdbd6fb24\", digest_to_str(&md4(\"a\")));\n\n    assert_eq!(\n        \"a448017aaf21d8525fc10ae87aa6729d\",\n        digest_to_str(&md4(\"abc\"))\n    );\n\n    assert_eq!(\n        \"d9130a8164549fe818874806e1c7014b\",\n        digest_to_str(&md4(\"message digest\"))\n    );\n\n    assert_eq!(\n        \"d79e1c308aa5bbcdeea8ed63df412da9\",\n        digest_to_str(&md4(\"abcdefghijklmnopqrstuvwxyz\"))\n    );\n\n    assert_eq!(\n        \"043f8582f241db351ce627e153e7f0e4\",\n        digest_to_str(&md4(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\n                            0123456789\"))\n    );\n\n    assert_eq!(\n        \"e33b4ddc9c38f2199c3e7b164fcc0536\",\n        digest_to_str(&md4(\n            \"12345678901234567890123456789012345678901234567890123456789\\\n             012345678901234567890\"\n        ))\n    );\n}\n",
    "path": "tasks/md4",
    "remote_code": "// MD4, based on RFC 1186 and RFC 1320.\n//\n// https://www.ietf.org/rfc/rfc1186.txt\n// https://tools.ietf.org/html/rfc1320\n//\n\nuse std::fmt::Write;\nuse std::mem;\n\n// Let not(X) denote the bit-wise complement of X.\n// Let X v Y denote the bit-wise OR of X and Y.\n// Let X xor Y denote the bit-wise XOR of X and Y.\n// Let XY denote the bit-wise AND of X and Y.\n\n// f(X,Y,Z)  =  XY v not(X)Z\nfn f(x: u32, y: u32, z: u32) -> u32 {\n    (x & y) | (!x & z)\n}\n\n// g(X,Y,Z)  =  XY v XZ v YZ\nfn g(x: u32, y: u32, z: u32) -> u32 {\n    (x & y) | (x & z) | (y & z)\n}\n\n// h(X,Y,Z)  =  X xor Y xor Z\nfn h(x: u32, y: u32, z: u32) -> u32 {\n    x ^ y ^ z\n}\n\n// Round 1 macro\n// Let [A B C D i s] denote the operation\n//   A = (A + f(B,C,D) + X[i]) <<< s\nmacro_rules! md4round1 {\n    ( $a:expr, $b:expr, $c:expr, $d:expr, $i:expr, $s:expr, $x:expr) => {\n        {\n            // Rust defaults to non-overflowing arithmetic, so we need to specify wrapping add.\n            $a = ($a.wrapping_add( f($b, $c, $d) ).wrapping_add( $x[$i] ) ).rotate_left($s);\n        }\n    };\n}\n\n// Round 2 macro\n// Let [A B C D i s] denote the operation\n//   A = (A + g(B,C,D) + X[i] + 5A827999) <<< s .\nmacro_rules! md4round2 {\n    ( $a:expr, $b:expr, $c:expr, $d:expr, $i:expr, $s:expr, $x:expr) => {\n        {\n            $a = ($a.wrapping_add( g($b, $c, $d)).wrapping_add($x[$i]).wrapping_add(0x5a827999_u32)).rotate_left($s);\n        }\n    };\n}\n\n// Round 3 macro\n// Let [A B C D i s] denote the operation\n//   A = (A + h(B,C,D) + X[i] + 6ED9EBA1) <<< s .\nmacro_rules! md4round3 {\n    ( $a:expr, $b:expr, $c:expr, $d:expr, $i:expr, $s:expr, $x:expr) => {\n        {\n            $a = ($a.wrapping_add(h($b, $c, $d)).wrapping_add($x[$i]).wrapping_add(0x6ed9eba1_u32)).rotate_left($s);\n        }\n    };\n}\n\nfn convert_byte_vec_to_u32(mut bytes: Vec<u8>) -> Vec<u32> {\n\n    bytes.shrink_to_fit();\n    let num_bytes = bytes.len();\n    let num_words = num_bytes / 4;\n    unsafe {\n        let words = Vec::from_raw_parts(bytes.as_mut_ptr() as *mut u32, num_words, num_words);\n        mem::forget(bytes);\n        words\n    }\n}\n\n// Returns a 128-bit MD4 hash as an array of four 32-bit words.\n// Based on RFC 1186 from https://www.ietf.org/rfc/rfc1186.txt\nfn md4<T: Into<Vec<u8>>>(input: T) -> [u32; 4] {\n\n    let mut bytes = input.into().to_vec();\n    let initial_bit_len = (bytes.len() << 3) as u64;\n\n    // Step 1. Append padding bits\n    // Append one '1' bit, then append 0 ≤ k < 512 bits '0', such that the resulting message\n    // length in bis is congruent to 448 (mod 512).\n    // Since our message is in bytes, we use one byte with a set high-order bit (0x80) plus\n    // a variable number of zero bytes.\n\n    // Append zeros\n    // Number of padding bytes needed is 448 bits (56 bytes) modulo 512 bits (64 bytes)\n    bytes.push(0x80_u8);\n    while (bytes.len() % 64) != 56 {\n        bytes.push(0_u8);\n    }\n\n    // Everything after this operates on 32-bit words, so reinterpret the buffer.\n    let mut w = convert_byte_vec_to_u32(bytes);\n\n    // Step 2. Append length\n    // A 64-bit representation of b (the length of the message before the padding bits were added)\n    // is appended to the result of the previous step, low-order bytes first.\n    w.push(initial_bit_len as u32); // Push low-order bytes first\n    w.push((initial_bit_len >> 32) as u32);\n\n    // Step 3. Initialize MD buffer\n    let mut a = 0x67452301_u32;\n    let mut b = 0xefcdab89_u32;\n    let mut c = 0x98badcfe_u32;\n    let mut d = 0x10325476_u32;\n\n    // Step 4. Process message in 16-word blocks\n    let n = w.len();\n    for i in 0..n / 16 {\n\n        // Select the next 512-bit (16-word) block to process.\n        let x = &w[i * 16..i * 16 + 16];\n\n        let aa = a;\n        let bb = b;\n        let cc = c;\n        let dd = d;\n\n        // [Round 1]\n        md4round1!(a, b, c, d, 0, 3, x);  // [A B C D 0 3]\n        md4round1!(d, a, b, c, 1, 7, x);  // [D A B C 1 7]\n        md4round1!(c, d, a, b, 2, 11, x); // [C D A B 2 11]\n        md4round1!(b, c, d, a, 3, 19, x); // [B C D A 3 19]\n        md4round1!(a, b, c, d, 4, 3, x);  // [A B C D 4 3]\n        md4round1!(d, a, b, c, 5, 7, x);  // [D A B C 5 7]\n        md4round1!(c, d, a, b, 6, 11, x); // [C D A B 6 11]\n        md4round1!(b, c, d, a, 7, 19, x); // [B C D A 7 19]\n        md4round1!(a, b, c, d, 8, 3, x);  // [A B C D 8 3]\n        md4round1!(d, a, b, c, 9, 7, x);  // [D A B C 9 7]\n        md4round1!(c, d, a, b, 10, 11, x);// [C D A B 10 11]\n        md4round1!(b, c, d, a, 11, 19, x);// [B C D A 11 19]\n        md4round1!(a, b, c, d, 12, 3, x); // [A B C D 12 3]\n        md4round1!(d, a, b, c, 13, 7, x); // [D A B C 13 7]\n        md4round1!(c, d, a, b, 14, 11, x);// [C D A B 14 11]\n        md4round1!(b, c, d, a, 15, 19, x);// [B C D A 15 19]\n\n        // [Round 2]\n        md4round2!(a, b, c, d, 0, 3, x);  //[A B C D 0  3]\n        md4round2!(d, a, b, c, 4, 5, x);  //[D A B C 4  5]\n        md4round2!(c, d, a, b, 8, 9, x);  //[C D A B 8  9]\n        md4round2!(b, c, d, a, 12, 13, x);//[B C D A 12 13]\n        md4round2!(a, b, c, d, 1, 3, x);  //[A B C D 1  3]\n        md4round2!(d, a, b, c, 5, 5, x);  //[D A B C 5  5]\n        md4round2!(c, d, a, b, 9, 9, x);  //[C D A B 9  9]\n        md4round2!(b, c, d, a, 13, 13, x);//[B C D A 13 13]\n        md4round2!(a, b, c, d, 2, 3, x);  //[A B C D 2  3]\n        md4round2!(d, a, b, c, 6, 5, x);  //[D A B C 6  5]\n        md4round2!(c, d, a, b, 10, 9, x); //[C D A B 10 9]\n        md4round2!(b, c, d, a, 14, 13, x);//[B C D A 14 13]\n        md4round2!(a, b, c, d, 3, 3, x);  //[A B C D 3  3]\n        md4round2!(d, a, b, c, 7, 5, x);  //[D A B C 7  5]\n        md4round2!(c, d, a, b, 11, 9, x); //[C D A B 11 9]\n        md4round2!(b, c, d, a, 15, 13, x);//[B C D A 15 13]\n\n        // [Round 3]\n        md4round3!(a, b, c, d, 0, 3, x);  //[A B C D 0  3]\n        md4round3!(d, a, b, c, 8, 9, x);  //[D A B C 8  9]\n        md4round3!(c, d, a, b, 4, 11, x); //[C D A B 4  11]\n        md4round3!(b, c, d, a, 12, 15, x);//[B C D A 12 15]\n        md4round3!(a, b, c, d, 2, 3, x);  //[A B C D 2  3]\n        md4round3!(d, a, b, c, 10, 9, x); //[D A B C 10 9]\n        md4round3!(c, d, a, b, 6, 11, x); //[C D A B 6  11]\n        md4round3!(b, c, d, a, 14, 15, x);//[B C D A 14 15]\n        md4round3!(a, b, c, d, 1, 3, x);  //[A B C D 1  3]\n        md4round3!(d, a, b, c, 9, 9, x);  //[D A B C 9  9]\n        md4round3!(c, d, a, b, 5, 11, x); //[C D A B 5  11]\n        md4round3!(b, c, d, a, 13, 15, x);//[B C D A 13 15]\n        md4round3!(a, b, c, d, 3, 3, x);  //[A B C D 3  3]\n        md4round3!(d, a, b, c, 11, 9, x); //[D A B C 11 9]\n        md4round3!(c, d, a, b, 7, 11, x); //[C D A B 7  11]\n        md4round3!(b, c, d, a, 15, 15, x);//[B C D A 15 15]\n\n        a = a.wrapping_add(aa);\n        b = b.wrapping_add(bb);\n        c = c.wrapping_add(cc);\n        d = d.wrapping_add(dd);\n    }\n\n    // Step 5. Output\n    // The message digest produced as output is A, B, C, D. That is, we begin with the low-order\n    // byte of A, and end with the high-order byte of D.\n    [u32::from_be(a), u32::from_be(b), u32::from_be(c), u32::from_be(d)]\n}\n\nfn digest_to_str(digest: &[u32]) -> String {\n    let mut s = String::new();\n    for &word in digest {\n        write!(&mut s, \"{:08x}\", word).unwrap();\n    }\n    s\n}\n\nfn main() {\n    let val = \"Rosetta Code\";\n    println!(\"md4(\\\"{}\\\") = {}\", val, digest_to_str(&md4(val)));\n}",
    "title": "MD4",
    "url": "http://rosettacode.org/wiki/MD4"
  },
  {
    "local_code": "use md5::{Digest, Md5};\nfn main() {\n    // digest is a convenience function\n    // when you have the full value to hash\n    let hash = Md5::digest(b\"The quick brown fox jumped over the lazy dog's back\");\n    // print the hashed value\n    // with the handy formatting traits:\n    // https://doc.rust-lang.org/std/fmt/index.html#formatting-traits\n    println!(\"{:x}\", hash);\n}\n//! Ported from C - Simple MD5 implementation\n//! on Wikipedia: <https://en.wikipedia.org/wiki/MD5>\n\nuse std::fmt::{Debug, Formatter, Result};\nuse std::num::Wrapping as wr;\n\nfn main() {\n    let inputs = [\n        &b\"a\"[..],\n        &b\"abc\"[..],\n        &b\"message digest\"[..],\n        &b\"abcdefghijklmnopqrstuvwxyz\"[..],\n        &b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"[..],\n        &b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"[..],\n    ];\n\n    for &input in &inputs {\n        println!(\"{:?}\", md5(input));\n    }\n}\n\n/// Constants are the integer part of the sines of integers (in radians) * 2^32.\nconst K: [u32; 64] = [\n    0xd76a_a478,\n    0xe8c7_b756,\n    0x2420_70db,\n    0xc1bd_ceee,\n    0xf57c_0faf,\n    0x4787_c62a,\n    0xa830_4613,\n    0xfd46_9501,\n    0x6980_98d8,\n    0x8b44_f7af,\n    0xffff_5bb1,\n    0x895c_d7be,\n    0x6b90_1122,\n    0xfd98_7193,\n    0xa679_438e,\n    0x49b4_0821,\n    0xf61e_2562,\n    0xc040_b340,\n    0x265e_5a51,\n    0xe9b6_c7aa,\n    0xd62f_105d,\n    0x0244_1453,\n    0xd8a1_e681,\n    0xe7d3_fbc8,\n    0x21e1_cde6,\n    0xc337_07d6,\n    0xf4d5_0d87,\n    0x455a_14ed,\n    0xa9e3_e905,\n    0xfcef_a3f8,\n    0x676f_02d9,\n    0x8d2a_4c8a,\n    0xfffa_3942,\n    0x8771_f681,\n    0x6d9d_6122,\n    0xfde5_380c,\n    0xa4be_ea44,\n    0x4bde_cfa9,\n    0xf6bb_4b60,\n    0xbebf_bc70,\n    0x289b_7ec6,\n    0xeaa1_27fa,\n    0xd4ef_3085,\n    0x0488_1d05,\n    0xd9d4_d039,\n    0xe6db_99e5,\n    0x1fa2_7cf8,\n    0xc4ac_5665,\n    0xf429_2244,\n    0x432a_ff97,\n    0xab94_23a7,\n    0xfc93_a039,\n    0x655b_59c3,\n    0x8f0c_cc92,\n    0xffef_f47d,\n    0x8584_5dd1,\n    0x6fa8_7e4f,\n    0xfe2c_e6e0,\n    0xa301_4314,\n    0x4e08_11a1,\n    0xf753_7e82,\n    0xbd3a_f235,\n    0x2ad7_d2bb,\n    0xeb86_d391,\n];\n\n/// R specifies the per-round shift amounts\nconst R: [u32; 64] = [\n    7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9,\n    14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15,\n    21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21,\n];\n\n/// \"newtype\" for [u8; 16] to specify it's a MD5 hash\nstruct MD5([u8; 16]);\n\nimpl Debug for MD5 {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        let MD5(md5) = *self;\n        for b in &md5 {\n            write!(f, \"{:02x}\", *b)?;\n        }\n        Ok(())\n    }\n}\n\nfn to_bytes(val: u64) -> [u8; 8] {\n    let mut tmp: [u8; 8] = [0u8; 8];\n    for (i, byte) in tmp.iter_mut().enumerate() {\n        *byte = (val >> (8 * i)) as u8;\n    }\n    tmp\n}\n\n#[cfg_attr(feature = \"cargo-clippy\", allow(many_single_char_names))]\nfn md5(initial_msg: &[u8]) -> MD5 {\n    let initial_len = initial_msg.len() as u64;\n\n    // These vars will contain the hash\n    let mut h: [wr<u32>; 4] = [\n        wr(0x6745_2301),\n        wr(0xefcd_ab89),\n        wr(0x98ba_dcfe),\n        wr(0x1032_5476),\n    ];\n\n    // Pre-processing:\n    // append \"1\" bit to message\n    // append \"0\" bits until message length in bits ≡ 448 (mod 512)\n    // append length mod (2^64) to message\n    let mut new_len = initial_len;\n    while new_len % (512 / 8) != 448 / 8 {\n        new_len += 1;\n    }\n\n    let mut msg = initial_msg.to_vec();\n    msg.push(0x80u8); // append the \"1\" bit; most significant bit is \"first\"\n\n    for _ in (initial_len + 1)..new_len {\n        msg.push(0); // append \"0\" bits\n    }\n\n    // append the len in bits at the end of the buffer.\n    msg.extend_from_slice(&to_bytes(initial_len << 3));\n\n    assert_eq!(msg.len() % 64, 0);\n\n    let mut w: [u32; 16] = [0u32; 16];\n    // Process the message in successive 512-bit chunks:\n    // for each 512-bit chunk of message:\n    for offset in (0u64..new_len).step_by(512 / 8) {\n        // break chunk into sixteen 32-bit words w[j], 0 ≤ j ≤ 15\n        for i in 0u32..16 {\n            let j = i as usize * 4 + offset as usize;\n            w[i as usize] = u32::from(msg[j])\n                | u32::from(msg[j + 1]) << 8\n                | u32::from(msg[j + 2]) << 16\n                | u32::from(msg[j + 3]) << 24;\n        }\n\n        // Initialize hash value for this chunk:\n        let (mut a, mut b, mut c, mut d) = (h[0], h[1], h[2], h[3]);\n\n        // Main loop:\n        for ind in 0..64 {\n            let (f, g) = match ind {\n                i @ 0..=15 => ((b & c) | ((!b) & d) /* f */, i), //g\n                i @ 16..=31 => ((d & b) | ((!d) & c), (5 * i + 1) % 16),\n                i @ 32..=47 => (b ^ c ^ d, (3 * i + 5) % 16),\n                i => (c ^ (b | (!d)), (7 * i) % 16),\n            };\n\n            let temp = d;\n            d = c;\n            c = b;\n            b += wr((a + f + wr(K[ind]) + wr(w[g])).0.rotate_left(R[ind]));\n            a = temp;\n        }\n\n        // Add this chunk's hash to result so far:\n        h[0] += a;\n        h[1] += b;\n        h[2] += c;\n        h[3] += d;\n    }\n    drop(msg); // cleanup, msg is freed\n\n    // var char digest[16] := h0 append h1 append h2 append h3 //(Output is in little-endian)\n    let mut digest = [0u8; 16];\n    for (i, s) in h.iter().enumerate() {\n        digest[i * 4] = (*s).0 as u8;\n        digest[i * 4 + 1] = (*s >> 8).0 as u8;\n        digest[i * 4 + 2] = (*s >> 16).0 as u8;\n        digest[i * 4 + 3] = (*s >> 24).0 as u8;\n    }\n    MD5(digest)\n}\n\n#[test]\nfn helper_fns() {\n    assert_eq!(64, 8u32.rotate_left(3));\n\n    let exp: [u8; 8] = [64u8, 226, 1, 0, 0, 0, 0, 0];\n    assert!(to_bytes(123456) == exp);\n}\n\n#[test]\nfn known_hashes() {\n    let in_out: &[(&[u8], &str)] = &[\n        (b\"\", \"d41d8cd98f00b204e9800998ecf8427e\"),\n        (b\"a\", \"0cc175b9c0f1b6a831c399e269772661\"),\n        (b\"abc\", \"900150983cd24fb0d6963f7d28e17f72\"),\n        (b\"message digest\", \"f96b697d7cb7938d525a2f31aaf161d0\"),\n        (\n            b\"abcdefghijklmnopqrstuvwxyz\",\n            \"c3fcd3d76192e4007dfb496cca67e13b\",\n        ),\n        (\n            b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n            \"d174ab98d277d9f5a5611c2c9f419d9f\",\n        ),\n        (\n            b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\",\n            \"57edf4a22be3c955ac49da2e2107b67a\",\n        ),\n    ];\n\n    for &(i, o) in in_out {\n        let m = md5(i);\n        assert_eq!(format!(\"{:?}\", m), o.to_string());\n    }\n}\n",
    "path": "tasks/md5",
    "remote_code": "\nextern crate crypto;\n\nuse crypto::digest::Digest;\nuse crypto::md5::Md5;\n\nfn main() {\n    let mut sh = Md5::new();\n    sh.input_str(\"The quick brown fox jumped over the lazy dog's back\");\n    println!(\"{}\", sh.result_str());\n}\n",
    "title": "MD5",
    "url": "http://rosettacode.org/wiki/MD5"
  },
  {
    "local_code": "//! Ported from C - Simple MD5 implementation\n//! on Wikipedia: <https://en.wikipedia.org/wiki/MD5>\n\nuse std::fmt::{Debug, Formatter, Result};\nuse std::num::Wrapping as wr;\n\nfn main() {\n    let inputs = [\n        &b\"a\"[..],\n        &b\"abc\"[..],\n        &b\"message digest\"[..],\n        &b\"abcdefghijklmnopqrstuvwxyz\"[..],\n        &b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"[..],\n        &b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"[..],\n    ];\n\n    for &input in &inputs {\n        println!(\"{:?}\", md5(input));\n    }\n}\n\n/// Constants are the integer part of the sines of integers (in radians) * 2^32.\nconst K: [u32; 64] = [\n    0xd76a_a478,\n    0xe8c7_b756,\n    0x2420_70db,\n    0xc1bd_ceee,\n    0xf57c_0faf,\n    0x4787_c62a,\n    0xa830_4613,\n    0xfd46_9501,\n    0x6980_98d8,\n    0x8b44_f7af,\n    0xffff_5bb1,\n    0x895c_d7be,\n    0x6b90_1122,\n    0xfd98_7193,\n    0xa679_438e,\n    0x49b4_0821,\n    0xf61e_2562,\n    0xc040_b340,\n    0x265e_5a51,\n    0xe9b6_c7aa,\n    0xd62f_105d,\n    0x0244_1453,\n    0xd8a1_e681,\n    0xe7d3_fbc8,\n    0x21e1_cde6,\n    0xc337_07d6,\n    0xf4d5_0d87,\n    0x455a_14ed,\n    0xa9e3_e905,\n    0xfcef_a3f8,\n    0x676f_02d9,\n    0x8d2a_4c8a,\n    0xfffa_3942,\n    0x8771_f681,\n    0x6d9d_6122,\n    0xfde5_380c,\n    0xa4be_ea44,\n    0x4bde_cfa9,\n    0xf6bb_4b60,\n    0xbebf_bc70,\n    0x289b_7ec6,\n    0xeaa1_27fa,\n    0xd4ef_3085,\n    0x0488_1d05,\n    0xd9d4_d039,\n    0xe6db_99e5,\n    0x1fa2_7cf8,\n    0xc4ac_5665,\n    0xf429_2244,\n    0x432a_ff97,\n    0xab94_23a7,\n    0xfc93_a039,\n    0x655b_59c3,\n    0x8f0c_cc92,\n    0xffef_f47d,\n    0x8584_5dd1,\n    0x6fa8_7e4f,\n    0xfe2c_e6e0,\n    0xa301_4314,\n    0x4e08_11a1,\n    0xf753_7e82,\n    0xbd3a_f235,\n    0x2ad7_d2bb,\n    0xeb86_d391,\n];\n\n/// R specifies the per-round shift amounts\nconst R: [u32; 64] = [\n    7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9,\n    14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15,\n    21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21,\n];\n\n/// \"newtype\" for [u8; 16] to specify it's a MD5 hash\nstruct MD5([u8; 16]);\n\nimpl Debug for MD5 {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        let MD5(md5) = *self;\n        for b in &md5 {\n            write!(f, \"{:02x}\", *b)?;\n        }\n        Ok(())\n    }\n}\n\nfn to_bytes(val: u64) -> [u8; 8] {\n    let mut tmp: [u8; 8] = [0u8; 8];\n    for (i, byte) in tmp.iter_mut().enumerate() {\n        *byte = (val >> (8 * i)) as u8;\n    }\n    tmp\n}\n\n#[cfg_attr(feature = \"cargo-clippy\", allow(many_single_char_names))]\nfn md5(initial_msg: &[u8]) -> MD5 {\n    let initial_len = initial_msg.len() as u64;\n\n    // These vars will contain the hash\n    let mut h: [wr<u32>; 4] = [\n        wr(0x6745_2301),\n        wr(0xefcd_ab89),\n        wr(0x98ba_dcfe),\n        wr(0x1032_5476),\n    ];\n\n    // Pre-processing:\n    // append \"1\" bit to message\n    // append \"0\" bits until message length in bits ≡ 448 (mod 512)\n    // append length mod (2^64) to message\n    let mut new_len = initial_len;\n    while new_len % (512 / 8) != 448 / 8 {\n        new_len += 1;\n    }\n\n    let mut msg = initial_msg.to_vec();\n    msg.push(0x80u8); // append the \"1\" bit; most significant bit is \"first\"\n\n    for _ in (initial_len + 1)..new_len {\n        msg.push(0); // append \"0\" bits\n    }\n\n    // append the len in bits at the end of the buffer.\n    msg.extend_from_slice(&to_bytes(initial_len << 3));\n\n    assert_eq!(msg.len() % 64, 0);\n\n    let mut w: [u32; 16] = [0u32; 16];\n    // Process the message in successive 512-bit chunks:\n    // for each 512-bit chunk of message:\n    for offset in (0u64..new_len).step_by(512 / 8) {\n        // break chunk into sixteen 32-bit words w[j], 0 ≤ j ≤ 15\n        for i in 0u32..16 {\n            let j = i as usize * 4 + offset as usize;\n            w[i as usize] = u32::from(msg[j])\n                | u32::from(msg[j + 1]) << 8\n                | u32::from(msg[j + 2]) << 16\n                | u32::from(msg[j + 3]) << 24;\n        }\n\n        // Initialize hash value for this chunk:\n        let (mut a, mut b, mut c, mut d) = (h[0], h[1], h[2], h[3]);\n\n        // Main loop:\n        for ind in 0..64 {\n            let (f, g) = match ind {\n                i @ 0..=15 => ((b & c) | ((!b) & d) /* f */, i), //g\n                i @ 16..=31 => ((d & b) | ((!d) & c), (5 * i + 1) % 16),\n                i @ 32..=47 => (b ^ c ^ d, (3 * i + 5) % 16),\n                i => (c ^ (b | (!d)), (7 * i) % 16),\n            };\n\n            let temp = d;\n            d = c;\n            c = b;\n            b += wr((a + f + wr(K[ind]) + wr(w[g])).0.rotate_left(R[ind]));\n            a = temp;\n        }\n\n        // Add this chunk's hash to result so far:\n        h[0] += a;\n        h[1] += b;\n        h[2] += c;\n        h[3] += d;\n    }\n    drop(msg); // cleanup, msg is freed\n\n    // var char digest[16] := h0 append h1 append h2 append h3 //(Output is in little-endian)\n    let mut digest = [0u8; 16];\n    for (i, s) in h.iter().enumerate() {\n        digest[i * 4] = (*s).0 as u8;\n        digest[i * 4 + 1] = (*s >> 8).0 as u8;\n        digest[i * 4 + 2] = (*s >> 16).0 as u8;\n        digest[i * 4 + 3] = (*s >> 24).0 as u8;\n    }\n    MD5(digest)\n}\n\n#[test]\nfn helper_fns() {\n    assert_eq!(64, 8u32.rotate_left(3));\n\n    let exp: [u8; 8] = [64u8, 226, 1, 0, 0, 0, 0, 0];\n    assert!(to_bytes(123456) == exp);\n}\n\n#[test]\nfn known_hashes() {\n    let in_out: &[(&[u8], &str)] = &[\n        (b\"\", \"d41d8cd98f00b204e9800998ecf8427e\"),\n        (b\"a\", \"0cc175b9c0f1b6a831c399e269772661\"),\n        (b\"abc\", \"900150983cd24fb0d6963f7d28e17f72\"),\n        (b\"message digest\", \"f96b697d7cb7938d525a2f31aaf161d0\"),\n        (\n            b\"abcdefghijklmnopqrstuvwxyz\",\n            \"c3fcd3d76192e4007dfb496cca67e13b\",\n        ),\n        (\n            b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n            \"d174ab98d277d9f5a5611c2c9f419d9f\",\n        ),\n        (\n            b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\",\n            \"57edf4a22be3c955ac49da2e2107b67a\",\n        ),\n    ];\n\n    for &(i, o) in in_out {\n        let m = md5(i);\n        assert_eq!(format!(\"{:?}\", m), o.to_string());\n    }\n}\n",
    "path": "tasks/md5/implementation",
    "remote_code": null,
    "title": "MD5/Implementation",
    "url": "http://rosettacode.org/wiki/MD5/Implementation"
  },
  {
    "local_code": "extern crate libc;\n\n#[cfg(all(\n    target_os = \"linux\",\n    any(target_pointer_width = \"32\", target_pointer_width = \"64\")\n))]\nfn main() {\n    use std::mem;\n    use std::ptr;\n\n    let page_size: usize = 4096;\n    let (bytes, size): (Vec<u8>, usize) = if cfg!(target_pointer_width = \"32\") {\n        (\n            vec![0x8b, 0x44, 0x24, 0x04, 0x03, 0x44, 0x24, 0x08, 0xc3],\n            9,\n        )\n    } else {\n        (vec![0x48, 0x89, 0xf8, 0x48, 0x01, 0xf0, 0xc3], 7)\n    };\n    let f: fn(u8, u8) -> u8 = unsafe {\n        let mut page: *mut libc::c_void = ptr::null_mut();\n        libc::posix_memalign(&mut page, page_size, size);\n        libc::mprotect(\n            page,\n            size,\n            libc::PROT_EXEC | libc::PROT_READ | libc::PROT_WRITE,\n        );\n        let contents: *mut u8 = page as *mut u8;\n        ptr::copy(bytes.as_ptr(), contents, 9);\n        mem::transmute(contents)\n    };\n\n    let return_value = f(7, 12);\n    println!(\"Returned value: {}\", return_value);\n    assert_eq!(return_value, 19);\n}\n\n#[cfg(any(\n    not(target_os = \"linux\"),\n    not(any(target_pointer_width = \"32\", target_pointer_width = \"64\"))\n))]\nfn main() {\n    println!(\"Not supported on this platform.\");\n}\n",
    "path": "tasks/machine-code",
    "remote_code": null,
    "title": "Machine code",
    "url": "http://rosettacode.org/wiki/Machine_code"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate regex;\n\nuse regex::Regex;\nuse std::collections::HashMap;\nuse std::io;\n\nfn main() {\n    let mut input_line = String::new();\n    let mut template = String::new();\n\n    println!(\"Please enter a multi-line story template with <parts> to replace, terminated by a blank line.\\n\");\n    loop {\n        io::stdin()\n            .read_line(&mut input_line)\n            .expect(\"The read line failed.\");\n        if input_line.trim().is_empty() {\n            break;\n        }\n        template.push_str(&input_line);\n        input_line.clear();\n    }\n\n    let re = Regex::new(r\"<[^>]+>\").unwrap();\n    let mut parts: HashMap<_, _> = re\n        .captures_iter(&template)\n        .map(|x| (x.get(0).unwrap().as_str().to_string(), \"\".to_string()))\n        .collect();\n    if parts.is_empty() {\n        println!(\"No <parts> to replace.\\n\");\n    } else {\n        for (k, v) in parts.iter_mut() {\n            println!(\"Please provide a replacement for {}: \", k);\n            io::stdin()\n                .read_line(&mut input_line)\n                .expect(\"The read line failed.\");\n            *v = input_line.trim().to_string();\n            println!();\n            template = template.replace(k, v);\n            input_line.clear();\n        }\n    }\n    println!(\"Resulting story:\\n\\n{}\", template);\n}",
    "title": "Mad Libs",
    "url": "http://rosettacode.org/wiki/Mad_Libs"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::env;\n\nfn main() {\n    let n: usize = match env::args()\n        .nth(1)\n        .and_then(|arg| arg.parse().ok())\n        .ok_or(\"Please specify the size of the magic square, as a positive multiple of 4.\")\n    {\n        Ok(arg) if arg >= 4 && arg % 4 == 0 => arg,\n        Err(e) => panic!(e),\n        _ => panic!(\"Argument must be a positive multiple of 4.\"),\n    };\n\n    let mc = (n * n + 1) * n / 2;\n    println!(\"Magic constant: {}\\n\", mc);\n    let bits = 0b1001_0110_0110_1001u32;\n    let size = n * n;\n    let width = size.to_string().len() + 1;\n    let mult = n / 4;\n    let mut i = 0;\n    for r in 0..n {\n        for c in 0..n {\n            let bit_pos = c / mult + (r / mult) * 4;\n            print!(\n                \"{e:>w$}\",\n                e = if bits & (1 << bit_pos) != 0 {\n                    i + 1\n                } else {\n                    size - i\n                },\n                w = width\n            );\n            i += 1;\n        }\n        println!();\n    }\n}",
    "title": "Magic squares of doubly even order",
    "url": "http://rosettacode.org/wiki/Magic_squares_of_doubly_even_order"
  },
  {
    "local_code": "fn main() {\n    let n = 9;\n    let mut square = vec![vec![0; n]; n];\n    for (i, row) in square.iter_mut().enumerate() {\n        for (j, e) in row.iter_mut().enumerate() {\n            *e = n * (((i + 1) + (j + 1) - 1 + (n >> 1)) % n)\n                + (((i + 1) + (2 * (j + 1)) - 2) % n)\n                + 1;\n            print!(\"{:3} \", e);\n        }\n        println!();\n    }\n    let sum = n * (((n * n) + 1) / 2);\n    println!(\"The sum of the square is {}.\", sum);\n}\n",
    "path": "tasks/magic-squares-of-odd-order",
    "remote_code": "fn main() {\n    let n = 9;\n    let mut square = vec![vec![0; n]; n];\n    for (i, row) in square.iter_mut().enumerate() {\n        for (j, e) in row.iter_mut().enumerate() {\n            *e = n * (((i + 1) + (j + 1) - 1 + (n >> 1)) % n) + (((i + 1) + (2 * (j + 1)) - 2) % n) + 1;\n            print!(\"{:3} \", e);\n        }\n        println!(\"\");\n    }\n    let sum = n * (((n * n) + 1) / 2);\n    println!(\"The sum of the square is {}.\", sum);\n}",
    "title": "Magic squares of odd order",
    "url": "http://rosettacode.org/wiki/Magic_squares_of_odd_order"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::env;\n\nfn main() {\n    let n: usize =\n        match env::args().nth(1).and_then(|arg| arg.parse().ok()).ok_or(\n            \"Please specify the size of the magic square, as a positive multiple of 4 plus 2.\",\n        ) {\n            Ok(arg) if arg % 2 == 1 || arg >= 6 && (arg - 2) % 4 == 0 => arg,\n            Err(e) => panic!(e),\n            _ => panic!(\"Argument must be a positive multiple of 4 plus 2.\"),\n        };\n\n    let (ms, mc) = magic_square_singly_even(n);\n    println!(\"n: {}\", n);\n    println!(\"Magic constant: {}\\n\", mc);\n    let width = (n * n).to_string().len() + 1;\n    for row in ms {\n        for elem in row {\n            print!(\"{e:>w$}\", e = elem, w = width);\n        }\n        println!();\n    }\n}\n\nfn magic_square_singly_even(n: usize) -> (Vec<Vec<usize>>, usize) {\n    let size = n * n;\n    let half = n / 2;\n    let sub_square_size = size / 4;\n    let sub_square = magic_square_odd(half);\n    let quadrant_factors = [0, 2, 3, 1];\n    let cols_left = half / 2;\n    let cols_right = cols_left - 1;\n\n    let ms = (0..n)\n        .map(|r| {\n            (0..n)\n                .map(|c| {\n                    let localr = if (c < cols_left\n                        || c >= n - cols_right\n                        || c == cols_left && r % half == cols_left)\n                        && !(c == 0 && r % half == cols_left)\n                    {\n                        if r >= half {\n                            r - half\n                        } else {\n                            r + half\n                        }\n                    } else {\n                        r\n                    };\n                    let quadrant = localr / half * 2 + c / half;\n                    let v = sub_square[localr % half][c % half];\n                    v + quadrant_factors[quadrant] * sub_square_size\n                })\n                .collect()\n        })\n        .collect::<Vec<Vec<_>>>();\n    (ms, (n * n + 1) * n / 2)\n}\n\nfn magic_square_odd(n: usize) -> Vec<Vec<usize>> {\n    (0..n)\n        .map(|r| {\n            (0..n)\n                .map(|c| {\n                    n * (((c + 1) + (r + 1) - 1 + (n >> 1)) % n)\n                        + (((c + 1) + (2 * (r + 1)) - 2) % n)\n                        + 1\n                })\n                .collect::<Vec<_>>()\n        })\n        .collect::<Vec<Vec<_>>>()\n}",
    "title": "Magic squares of singly even order",
    "url": "http://rosettacode.org/wiki/Magic_squares_of_singly_even_order"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::convert::TryInto;\nuse std::env;\nuse std::num::Wrapping;\n\nconst REPLACEMENT_TABLE: [[u8; 16]; 8] = [\n    [4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3],\n    [14, 11, 4, 12, 6, 13, 15, 10, 2, 3, 8, 1, 0, 7, 5, 9],\n    [5, 8, 1, 13, 10, 3, 4, 2, 14, 15, 12, 7, 6, 0, 9, 11],\n    [7, 13, 10, 1, 0, 8, 9, 15, 14, 4, 6, 12, 11, 2, 5, 3],\n    [6, 12, 7, 1, 5, 15, 13, 8, 4, 10, 9, 14, 0, 3, 11, 2],\n    [4, 11, 10, 0, 7, 2, 1, 13, 3, 6, 8, 5, 9, 12, 15, 14],\n    [13, 11, 4, 1, 3, 15, 5, 9, 0, 10, 14, 7, 6, 8, 2, 12],\n    [1, 15, 13, 0, 5, 7, 10, 4, 9, 2, 3, 14, 6, 11, 8, 12],\n];\nconst KEYS: [u32; 8] = [\n    0xE2C1_04F9,\n    0xE41D_7CDE,\n    0x7FE5_E857,\n    0x0602_65B4,\n    0x281C_CC85,\n    0x2E2C_929A,\n    0x4746_4503,\n    0xE00_CE510,\n];\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        let plain_text: Vec<u8> = vec![0x04, 0x3B, 0x04, 0x21, 0x04, 0x32, 0x04, 0x30];\n        println!(\n            \"Before one step: {}\\n\",\n            plain_text\n                .iter()\n                .cloned()\n                .fold(\"\".to_string(), |b, y| b + &format!(\"{:02X} \", y))\n        );\n        let encoded_text = main_step(plain_text, KEYS[0]);\n        println!(\n            \"After one step : {}\\n\",\n            encoded_text\n                .iter()\n                .cloned()\n                .fold(\"\".to_string(), |b, y| b + &format!(\"{:02X} \", y))\n        );\n    } else {\n        let mut t = args[1].clone(); // \"They call him... Баба Яга\"\n        t += &\" \".repeat((8 - t.len() % 8) % 8);\n        let text_bytes = t.bytes().collect::<Vec<_>>();\n        let plain_text = text_bytes.chunks(8).collect::<Vec<_>>();\n        println!(\n            \"Plain text  : {}\\n\",\n            plain_text.iter().cloned().fold(\"\".to_string(), |a, x| a\n                + \"[\"\n                + &x.iter()\n                    .fold(\"\".to_string(), |b, y| b + &format!(\"{:02X} \", y))[..23]\n                + \"]\")\n        );\n        let encoded_text = plain_text\n            .iter()\n            .map(|c| encode(c.to_vec()))\n            .collect::<Vec<_>>();\n        println!(\n            \"Encoded text: {}\\n\",\n            encoded_text.iter().cloned().fold(\"\".to_string(), |a, x| a\n                + \"[\"\n                + &x.into_iter()\n                    .fold(\"\".to_string(), |b, y| b + &format!(\"{:02X} \", y))[..23]\n                + \"]\")\n        );\n        let decoded_text = encoded_text\n            .iter()\n            .map(|c| decode(c.to_vec()))\n            .collect::<Vec<_>>();\n        println!(\n            \"Decoded text: {}\\n\",\n            decoded_text.iter().cloned().fold(\"\".to_string(), |a, x| a\n                + \"[\"\n                + &x.into_iter()\n                    .fold(\"\".to_string(), |b, y| b + &format!(\"{:02X} \", y))[..23]\n                + \"]\")\n        );\n        let recovered_text =\n            String::from_utf8(decoded_text.iter().cloned().flatten().collect::<Vec<_>>()).unwrap();\n        println!(\"Recovered text: {}\\n\", recovered_text);\n    }\n}\n\nfn encode(text_block: Vec<u8>) -> Vec<u8> {\n    let mut step = text_block;\n    for i in 0..24 {\n        step = main_step(step, KEYS[i % 8]);\n    }\n    for i in (0..8).rev() {\n        step = main_step(step, KEYS[i]);\n    }\n    step\n}\n\nfn decode(text_block: Vec<u8>) -> Vec<u8> {\n    let mut step = text_block[4..].to_vec();\n    let mut temp = text_block[..4].to_vec();\n    step.append(&mut temp);\n    for key in &KEYS {\n        step = main_step(step, *key);\n    }\n    for i in (0..24).rev() {\n        step = main_step(step, KEYS[i % 8]);\n    }\n    let mut ans = step[4..].to_vec();\n    let mut temp = step[..4].to_vec();\n    ans.append(&mut temp);\n    ans\n}\n\nfn main_step(text_block: Vec<u8>, key_element: u32) -> Vec<u8> {\n    let mut n = text_block;\n    let mut s = (Wrapping(\n        u32::from(n[0]) << 24 | u32::from(n[1]) << 16 | u32::from(n[2]) << 8 | u32::from(n[3]),\n    ) + Wrapping(key_element))\n    .0;\n    let mut new_s: u32 = 0;\n    for mid in 0..4 {\n        let cell = (s >> (mid << 3)) & 0xFF;\n        new_s += (u32::from(REPLACEMENT_TABLE[(mid * 2) as usize][(cell & 0x0f) as usize])\n            + (u32::from(REPLACEMENT_TABLE[(mid * 2 + 1) as usize][(cell >> 4) as usize]) << 4))\n            << (mid << 3);\n    }\n    s = ((new_s << 11) + (new_s >> 21))\n        ^ (u32::from(n[4]) << 24 | u32::from(n[5]) << 16 | u32::from(n[6]) << 8 | u32::from(n[7]));\n    n[4] = n[0];\n    n[5] = n[1];\n    n[6] = n[2];\n    n[7] = n[3];\n    n[0] = (s >> 24).try_into().unwrap();\n    n[1] = ((s >> 16) & 0xFF).try_into().unwrap();\n    n[2] = ((s >> 8) & 0xFF).try_into().unwrap();\n    n[3] = (s & 0xFF).try_into().unwrap();\n    n\n}",
    "title": "Main step of GOST 28147-89",
    "url": "http://rosettacode.org/wiki/Main_step_of_GOST_28147-89"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::fs;\n\nfn main() {\n    fs::create_dir_all(\"./path/to/dir\").expect(\"An Error Occured!\")\n}",
    "title": "Make directory path",
    "url": "http://rosettacode.org/wiki/Make_directory_path"
  },
  {
    "local_code": "//! As originally [posted] by Kimundi on Reddit\n//!\n//! [posted]: http://www.reddit.com/r/rust/comments/2t80mw/the_man_or_boy_test_in_rust/\n\nuse std::cell::Cell;\n\nfn a(\n    k: i32,\n    x1: &dyn Fn() -> i32,\n    x2: &dyn Fn() -> i32,\n    x3: &dyn Fn() -> i32,\n    x4: &dyn Fn() -> i32,\n    x5: &dyn Fn() -> i32,\n) -> i32 {\n    let k = Cell::new(k);\n\n    let (b, tmp): (Cell<Option<&dyn Fn() -> i32>>, _);\n    b = Cell::new(None);\n    tmp = || {\n        k.set(k.get() - 1);\n        a(k.get(), &*b.get().unwrap(), x1, x2, x3, x4)\n    };\n    b.set(Some(&tmp));\n\n    if k.get() <= 0 {\n        x4() + x5()\n    } else {\n        b.get().unwrap()()\n    }\n}\n\nfn main() {\n    println!(\"%{}\", a(10, &|| 1, &|| -1, &|| -1, &|| 1, &|| 0));\n}\n\n#[test]\nfn result() {\n    assert_eq!(a(10, &|| 1, &|| -1, &|| -1, &|| 1, &|| 0), -67)\n}\n",
    "path": "tasks/man-or-boy-test",
    "remote_code": "use std::cell::Cell;\n\ntrait Arg {\n    fn run(&self) -> i32;\n}\n\nimpl Arg for i32 {\n    fn run(&self) -> i32 { *self }\n}\n\nstruct B<'a> {\n    k: &'a Cell<i32>,\n    x1: &'a Arg,\n    x2: &'a Arg,\n    x3: &'a Arg,\n    x4: &'a Arg,\n}\n\nimpl<'a> Arg for B<'a> {\n    fn run(&self) -> i32 {\n        self.k.set(self.k.get() - 1);\n        a(self.k.get(), self, self.x1, self.x2, self.x3, self.x4)\n    }\n}\n\nfn a(k: i32, x1: &Arg, x2: &Arg, x3: &Arg, x4: &Arg, x5: &Arg) -> i32 {\n    if k <= 0 {\n        x4.run() + x5.run()\n    } else {\n        B{\n            k: &Cell::new(k),\n            x1, x2, x3, x4\n        }.run()\n    }\n}\n\npub fn main() {\n    println!(\"{}\", a(10, &1, &-1, &-1, &1, &0));\n}",
    "title": "Man or boy test",
    "url": "http://rosettacode.org/wiki/Man_or_boy_test"
  },
  {
    "local_code": "extern crate image;\nextern crate num_complex;\n\nuse num_complex::Complex;\n\nfn main() {\n    let max_iterations = 256u16;\n    let img_side = 800u32;\n    let cxmin = -2f32;\n    let cxmax = 1f32;\n    let cymin = -1.5f32;\n    let cymax = 1.5f32;\n    let scalex = (cxmax - cxmin) / img_side as f32;\n    let scaley = (cymax - cymin) / img_side as f32;\n\n    // Create a new ImgBuf\n    let mut imgbuf = image::ImageBuffer::new(img_side, img_side);\n\n    // Calculate for each pixel\n    for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {\n        let cx = cxmin + x as f32 * scalex;\n        let cy = cymin + y as f32 * scaley;\n\n        let c = Complex::new(cx, cy);\n        let mut z = Complex::new(0f32, 0f32);\n\n        let mut i = 0;\n        for t in 0..max_iterations {\n            if z.norm() > 2.0 {\n                break;\n            }\n            z = z * z + c;\n            i = t;\n        }\n\n        *pixel = image::Luma([i as u8]);\n    }\n\n    image::ImageLuma8(imgbuf).save(\"fractal.png\").unwrap();\n}\n",
    "path": "tasks/mandelbrot-set",
    "remote_code": "extern crate image;\nextern crate num_complex;\n\nuse std::fs::File;\nuse num_complex::Complex;\n\nfn main() {\n    let max_iterations = 256u16;\n    let img_side = 800u32;\n    let cxmin = -2f32;\n    let cxmax = 1f32;\n    let cymin = -1.5f32;\n    let cymax = 1.5f32;\n    let scalex = (cxmax - cxmin) / img_side as f32;\n    let scaley = (cymax - cymin) / img_side as f32;\n\n    // Create a new ImgBuf\n    let mut imgbuf = image::ImageBuffer::new(img_side, img_side);\n\n    // Calculate for each pixel\n    for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {\n        let cx = cxmin + x as f32 * scalex;\n        let cy = cymin + y as f32 * scaley;\n\n        let c = Complex::new(cx, cy);\n        let mut z = Complex::new(0f32, 0f32);\n\n        let mut i = 0;\n        for t in 0..max_iterations {\n            if z.norm() > 2.0 {\n                break;\n            }\n            z = z * z + c;\n            i = t;\n        }\n\n        *pixel = image::Luma([i as u8]);\n    }\n\n    // Save image\n    let fout = &mut File::create(\"fractal.png\").unwrap();\n    image::ImageLuma8(imgbuf).save(fout, image::PNG).unwrap();\n}",
    "title": "Mandelbrot set",
    "url": "http://rosettacode.org/wiki/Mandelbrot_set"
  },
  {
    "local_code": "use std::f64;\n\nfn map_range(from_range: (f64, f64), to_range: (f64, f64), s: f64) -> f64 {\n    to_range.0 + (s - from_range.0) * (to_range.1 - to_range.0) / (from_range.1 - from_range.0)\n}\n\nfn main() {\n    let input: Vec<f64> = vec![0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0];\n    let result = input\n        .into_iter()\n        .map(|x| map_range((0.0, 10.0), (-1.0, 0.0), x))\n        .collect::<Vec<f64>>();\n    print!(\"{:?}\", result);\n}\n\n#[test]\nfn test_basic() {\n    assert!((map_range((1.0, 5.0), (10.0, 50.0), 2.0) - 20.0) < f64::EPSILON);\n}\n",
    "path": "tasks/map-range",
    "remote_code": "use std::f64;\n\nfn map_range(from_range: (f64, f64), to_range: (f64, f64), s: f64) -> f64 {\n    to_range.0 + (s - from_range.0) * (to_range.1 - to_range.0) / (from_range.1 - from_range.0)\n}\n\nfn main() {\n    let input: Vec<f64> = vec![0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0];\n    let result = input.into_iter()\n        .map(|x| map_range((0.0, 10.0), (-1.0, 0.0), x))\n        .collect::<Vec<f64>>();\n    print!(\"{:?}\", result);\n}",
    "title": "Map range",
    "url": "http://rosettacode.org/wiki/Map_range"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate rand;\n\nuse rand::prelude::*;\nuse std::io;\n\nfn main() {\n    let mut input_line = String::new();\n    let colors_n;\n    let code_len;\n    let guesses_max;\n    let colors_dup;\n\n    loop {\n        println!(\"Please enter the number of colors to be used in the game (2 - 20): \");\n        input_line.clear();\n        io::stdin()\n            .read_line(&mut input_line)\n            .expect(\"The read line failed.\");\n        match (input_line.trim()).parse::<i32>() {\n            Ok(n) => {\n                if n >= 2 && n <= 20 {\n                    colors_n = n;\n                    break;\n                } else {\n                    println!(\"Outside of range (2 - 20).\");\n                }\n            }\n            Err(_) => println!(\"Invalid input.\"),\n        }\n    }\n    let colors = &\"ABCDEFGHIJKLMNOPQRST\"[..colors_n as usize];\n\n    println!(\"Playing with colors {}.\\n\", colors);\n\n    loop {\n        println!(\"Are duplicated colors allowed in the code? (Y/N): \");\n        input_line.clear();\n        io::stdin()\n            .read_line(&mut input_line)\n            .expect(\"The read line failed.\");\n        if [\"Y\", \"N\"].contains(&&input_line.trim().to_uppercase()[..]) {\n            colors_dup = input_line.trim().to_uppercase() == \"Y\";\n            break;\n        } else {\n            println!(\"Invalid input.\");\n        }\n    }\n    println!(\n        \"Duplicated colors {}allowed.\\n\",\n        if colors_dup { \"\" } else { \"not \" }\n    );\n    loop {\n        let min_len = if colors_dup { 4 } else { 4.min(colors_n) };\n        let max_len = if colors_dup { 10 } else { 10.min(colors_n) };\n        println!(\n            \"Please enter the length of the code ({} - {}): \",\n            min_len, max_len\n        );\n        input_line.clear();\n        io::stdin()\n            .read_line(&mut input_line)\n            .expect(\"The read line failed.\");\n        match (input_line.trim()).parse::<i32>() {\n            Ok(n) => {\n                if n >= min_len && n <= max_len {\n                    code_len = n;\n                    break;\n                } else {\n                    println!(\"Outside of range ({} - {}).\", min_len, max_len);\n                }\n            }\n            Err(_) => println!(\"Invalid input.\"),\n        }\n    }\n    println!(\"Code of length {}.\\n\", code_len);\n    loop {\n        println!(\"Please enter the number of guesses allowed (7 - 20): \");\n        input_line.clear();\n        io::stdin()\n            .read_line(&mut input_line)\n            .expect(\"The read line failed.\");\n        match (input_line.trim()).parse::<i32>() {\n            Ok(n) => {\n                if n >= 7 && n <= 20 {\n                    guesses_max = n;\n                    break;\n                } else {\n                    println!(\"Outside of range (7 - 20).\");\n                }\n            }\n            Err(_) => println!(\"Invalid input.\"),\n        }\n    }\n    println!(\"{} guesses allowed.\\n\", guesses_max);\n\n    let mut rng = rand::thread_rng();\n    let mut code;\n    if colors_dup {\n        code = (0..code_len)\n            .map(|_| ((65 + rng.gen_range(0, colors_n) as u8) as char))\n            .collect::<Vec<_>>();\n    } else {\n        code = colors.chars().collect::<Vec<_>>();\n        code.shuffle(&mut rng);\n        code = code[..code_len as usize].to_vec();\n    }\n    //code = vec!['J', 'A', 'R', 'D', 'A', 'N', 'I'];\n    //println!(\"Secret code: {:?}\", code);\n    let mut guesses: Vec<(String, String)> = vec![];\n    let mut i = 1;\n    loop {\n        println!(\"Your guess ({}/{})?: \", i, guesses_max);\n        input_line.clear();\n        io::stdin()\n            .read_line(&mut input_line)\n            .expect(\"The read line failed.\");\n        let mut guess = input_line.trim().to_uppercase();\n        if guess.len() as i32 > code_len {\n            guess = guess[..code_len as usize].to_string();\n        }\n        let guess_v = guess.chars().collect::<Vec<char>>();\n        let res = evaluate(&code, &guess_v);\n        guesses.push((guess, res.clone()));\n        let width = 8 + guesses_max.to_string().len() + code_len as usize * 2;\n        println!(\"{}\", \"-\".repeat(width));\n        for (i, guess) in guesses.iter().enumerate() {\n            let line = format!(\n                \" {:w1$} : {:w2$} : {:w2$} \",\n                i + 1,\n                guess.0,\n                guess.1,\n                w1 = guesses_max.to_string().len(),\n                w2 = code_len as usize\n            );\n            println!(\"{}\", line);\n        }\n        println!(\"{}\", \"-\".repeat(width));\n        if res == \"X\".repeat(code_len as usize) {\n            println!(\"You won! Code: {}\", code.into_iter().collect::<String>());\n            break;\n        }\n        i += 1;\n        if i > guesses_max {\n            println!(\"You lost. Code: {}\", code.into_iter().collect::<String>());\n            break;\n        }\n    }\n}\n\nfn evaluate(code: &[char], guess: &[char]) -> String {\n    let mut res: Vec<char> = vec![];\n    for i in 0..guess.len() {\n        if guess[i] == code[i] {\n            res.push('X');\n        } else if code.contains(&guess[i]) {\n            res.push('O');\n        } else {\n            res.push('-');\n        }\n    }\n    res.sort_by(|a, b| b.cmp(a));\n    res.into_iter().collect()\n}",
    "title": "Mastermind",
    "url": "http://rosettacode.org/wiki/Mastermind"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Matrix Digital Rain",
    "url": "http://rosettacode.org/wiki/Matrix_Digital_Rain"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::collections::HashMap;\n\nfn main() {\n    println!(\"{}\\n\", mcm_display(vec![5, 6, 3, 1]));\n    println!(\n        \"{}\\n\",\n        mcm_display(vec![1, 5, 25, 30, 100, 70, 2, 1, 100, 250, 1, 1000, 2])\n    );\n    println!(\n        \"{}\\n\",\n        mcm_display(vec![1000, 1, 500, 12, 1, 700, 2500, 3, 2, 5, 14, 10])\n    );\n}\n\nfn mcm_display(dims: Vec<i32>) -> String {\n    let mut costs: HashMap<Vec<i32>, (i32, Vec<usize>)> = HashMap::new();\n    let mut line = format!(\"Dims : {:?}\\n\", dims);\n    let ans = mcm(dims, &mut costs);\n    let mut mats = (1..=ans.1.len() + 1)\n        .map(|x| x.to_string())\n        .collect::<Vec<String>>();\n    for i in 0..ans.1.len() {\n        let mat_taken = mats[ans.1[i]].clone();\n        mats.remove(ans.1[i]);\n        mats[ans.1[i]] = \"(\".to_string() + &mat_taken + \"*\" + &mats[ans.1[i]] + \")\";\n    }\n    line += &format!(\"Order: {}\\n\", mats[0]);\n    line += &format!(\"Cost : {}\", ans.0);\n    line\n}\n\nfn mcm(dims: Vec<i32>, costs: &mut HashMap<Vec<i32>, (i32, Vec<usize>)>) -> (i32, Vec<usize>) {\n    match costs.get(&dims) {\n        Some(c) => c.clone(),\n        None => {\n            let ans = if dims.len() == 3 {\n                (dims[0] * dims[1] * dims[2], vec![0])\n            } else {\n                let mut min_cost = std::i32::MAX;\n                let mut min_path = Vec::new();\n                for i in 1..dims.len() - 1 {\n                    let taken = dims[(i - 1)..(i + 2)].to_vec();\n                    let mut rest = dims[..i].to_vec();\n                    rest.extend_from_slice(&dims[(i + 1)..]);\n                    let a1 = mcm(taken, costs);\n                    let a2 = mcm(rest, costs);\n                    if a1.0 + a2.0 < min_cost {\n                        min_cost = a1.0 + a2.0;\n                        min_path = vec![i - 1];\n                        min_path.extend_from_slice(&a2.1);\n                    }\n                }\n                (min_cost, min_path)\n            };\n            costs.insert(dims, ans.clone());\n            ans\n        }\n    }\n}",
    "title": "Matrix chain multiplication",
    "url": "http://rosettacode.org/wiki/Matrix_chain_multiplication"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nstruct Matrix {\n    dat: [[f32; 3]; 3]\n}\n\nimpl Matrix {\n    pub fn mult_m(a: Matrix, b: Matrix) -> Matrix\n    {\n        let mut out = Matrix {\n            dat: [[0., 0., 0.],\n                  [0., 0., 0.],\n                  [0., 0., 0.]\n                  ]\n        };\n\n        for i in 0..3{\n            for j in 0..3 {\n                for k in 0..3 {\n                    out.dat[i][j] += a.dat[i][k] * b.dat[k][j];\n                }\n            }\n        }\n\n        out\n    }\n\n    pub fn print(self)\n    {\n        for i in 0..3 {\n            for j in 0..3 {\n                print!(\"{} \", self.dat[i][j]);\n            }\n            print!(\"\\n\");\n        }\n    }\n}\n\nfn main()\n{\n    let  a = Matrix {\n        dat: [[1., 2., 3.],\n              [4., 5., 6.],\n              [7., 8., 9.]\n              ]\n    };\n\n    let  b = Matrix {\n        dat: [[1., 0., 0.],\n              [0., 1., 0.],\n              [0., 0., 1.]]\n    };\n\t\n\n    \n        let c = Matrix::mult_m(a, b);\n    \n\n    c.print();\n}\n\n",
    "title": "Matrix multiplication",
    "url": "http://rosettacode.org/wiki/Matrix_multiplication"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nstruct Matrix {\n    dat: [[i32; 3]; 3]\n}\n \n\n \nimpl Matrix {\n    pub fn transpose_m(a: Matrix) -> Matrix\n    {\n        let mut out = Matrix {\n            dat: [[0, 0, 0],\n                  [0, 0, 0],\n                  [0, 0, 0]\n                  ]\n        };\n        \n        for i in 0..3{\n            for j in 0..3{\n                \n                    out.dat[i][j] = a.dat[j][i];\n            }\n        }\n \n        out\n    }\n \n    pub fn print(self)\n    {\n        for i in 0..3 {\n            for j in 0..3 {\n                print!(\"{} \", self.dat[i][j]);\n            }\n            print!(\"\\n\");\n        }\n    }\n}\n \nfn main()\n{\n    let  a = Matrix {\n        dat: [[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9] ]\n    };\n\nlet c = Matrix::transpose_m(a);\n    c.print();\n}\n",
    "title": "Matrix transposition",
    "url": "http://rosettacode.org/wiki/Matrix_transposition"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::fmt;\nuse std::ops;\nconst WIDTH: usize = 6;\n\n#[derive(Clone)]\nstruct SqMat {\n    data: Vec<Vec<i64>>,\n}\n\nimpl fmt::Debug for SqMat {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut row = \"\".to_string();\n        for i in &self.data {\n            for j in i {\n                row += &format!(\"{:>w$} \", j, w = WIDTH);\n            }\n            row += &\"\\n\";\n        }\n        write!(f, \"{}\", row)\n    }\n}\n\nimpl ops::BitXor<u32> for SqMat {\n    type Output = Self;\n\n    fn bitxor(self, n: u32) -> Self::Output {\n        let mut aux = self.data.clone();\n        let mut ans: SqMat = SqMat {\n            data: vec![vec![0; aux.len()]; aux.len()],\n        };\n        for i in 0..aux.len() {\n            ans.data[i][i] = 1;\n        }\n        let mut b = n;\n        while b > 0 {\n            if b & 1 > 0 {\n                // ans = ans * aux\n                let mut tmp = aux.clone();\n                for i in 0..aux.len() {\n                    for j in 0..aux.len() {\n                        tmp[i][j] = 0;\n                        for k in 0..aux.len() {\n                            tmp[i][j] += ans.data[i][k] * aux[k][j];\n                        }\n                    }\n                }\n                ans.data = tmp;\n            }\n            b >>= 1;\n            if b > 0 {\n                // aux = aux * aux\n                let mut tmp = aux.clone();\n                for i in 0..aux.len() {\n                    for j in 0..aux.len() {\n                        tmp[i][j] = 0;\n                        for k in 0..aux.len() {\n                            tmp[i][j] += aux[i][k] * aux[k][j];\n                        }\n                    }\n                }\n                aux = tmp;\n            }\n        }\n        ans\n    }\n}\n\nfn main() {\n    let sm: SqMat = SqMat {\n        data: vec![vec![1, 2, 0], vec![0, 3, 1], vec![1, 0, 0]],\n    };\n    for i in 0..11 {\n        println!(\"Power of {}:\\n{:?}\", i, sm.clone() ^ i);\n    }\n}",
    "title": "Matrix-exponentiation operator",
    "url": "http://rosettacode.org/wiki/Matrix-exponentiation_operator"
  },
  {
    "local_code": "use std::cmp;\n\nconst TRIANGLE: &str = r\"55\n94 48\n95 30 96\n77 71 26 67\n97 13 76 38 45\n07 36 79 16 37 68\n48 07 09 18 70 26 06\n18 72 79 46 59 79 29 90\n20 76 87 11 32 07 07 49 18\n27 83 58 35 71 11 25 57 29 85\n14 64 36 96 27 11 58 56 92 18 55\n02 90 03 60 48 49 41 46 33 36 47 23\n92 50 48 02 36 59 42 79 72 20 82 77 42\n56 78 38 80 39 75 02 71 66 66 01 03 55 72\n44 25 67 84 71 67 11 61 40 57 58 89 40 56 36\n85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52\n06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15\n27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93\";\n\nfn max_path(vector: &mut Vec<Vec<u32>>) -> u32 {\n    while vector.len() > 1 {\n        let last = vector.pop().unwrap();\n        let ante = vector.pop().unwrap();\n\n        let mut new: Vec<u32> = Vec::new();\n\n        for (i, value) in ante.iter().enumerate() {\n            new.push(cmp::max(last[i], last[i + 1]) + value);\n        }\n\n        vector.push(new);\n    }\n\n    vector[0][0]\n}\n\nfn main() {\n    let mut vector = TRIANGLE\n        .split('\\n')\n        .map(|x| {\n            x.split(' ')\n                .map(|s: &str| s.parse::<u32>().unwrap())\n                .collect::<Vec<u32>>()\n        })\n        .collect::<Vec<Vec<u32>>>();\n\n    let max_value = max_path(&mut vector);\n\n    println!(\"{}\", max_value);\n}\n\n#[test]\nfn test_maximum_triangle_path_sum() {\n    let mut vector = TRIANGLE\n        .split('\\n')\n        .map(|x| {\n            x.split(' ')\n                .map(|s: &str| s.parse::<u32>().unwrap())\n                .collect::<Vec<u32>>()\n        })\n        .collect::<Vec<Vec<u32>>>();\n\n    let max_value = max_path(&mut vector);\n\n    assert_eq!(1320, max_value);\n}\n",
    "path": "tasks/maximum-triangle-path-sum",
    "remote_code": "use std::cmp::max;\n\nfn max_path(vector: &mut Vec<Vec<u32>>) -> u32 {\n    \n    while vector.len() > 1 {\n        \n        let last = vector.pop().unwrap();\n        let ante = vector.pop().unwrap();\n        \n        let mut new: Vec<u32> = Vec::new();\n        \n        for (i, value) in ante.iter().enumerate() {\n            new.push(max(last[i], last[i+1]) + value);\n        };\n        \n        vector.push(new);\n    };\n    \n    vector[0][0]\n}\n\nfn main() {\n    let mut data = \"55\n94 48\n95 30 96\n77 71 26 67\n97 13 76 38 45\n07 36 79 16 37 68\n48 07 09 18 70 26 06\n18 72 79 46 59 79 29 90\n20 76 87 11 32 07 07 49 18\n27 83 58 35 71 11 25 57 29 85\n14 64 36 96 27 11 58 56 92 18 55\n02 90 03 60 48 49 41 46 33 36 47 23\n92 50 48 02 36 59 42 79 72 20 82 77 42\n56 78 38 80 39 75 02 71 66 66 01 03 55 72\n44 25 67 84 71 67 11 61 40 57 58 89 40 56 36\n85 32 25 85 57 48 84 35 47 62 17 01 01 99 89 52\n06 71 28 75 94 48 37 10 23 51 06 48 53 18 74 98 15\n27 02 92 23 08 71 76 84 15 52 92 63 81 10 44 10 69 93\";\n\n    let mut vector = data.split(\"\\n\").map(|x| x.split(\" \").map(|s: &str| s.parse::<u32>().unwrap())\n        .collect::<Vec<u32>>()).collect::<Vec<Vec<u32>>>();\n    \n    let max_value = max_path(&mut vector);\n    \n    println!(\"{}\", max_value);\n    //=> 7273\n}",
    "title": "Maximum triangle path sum",
    "url": "http://rosettacode.org/wiki/Maximum_triangle_path_sum"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "const ONE: &str = \"●\";\nconst FIVE: &str = \"——\";\nconst ZERO: &str = \"Θ\";\n\nfn main() {\n    println!(\"{}\", mayan(4005));\n    println!(\"{}\", mayan(8017));\n    println!(\"{}\", mayan(326_205));\n    println!(\"{}\", mayan(886_205));\n    println!(\"{}\", mayan(69));\n    println!(\"{}\", mayan(420));\n    println!(\"{}\", mayan(1_063_715_456));\n}\n\nfn mayan(dec: i64) -> String {\n    let mut digits = vec![];\n    let mut num = dec;\n    while num > 0 {\n        digits.push(num % 20);\n        num /= 20;\n    }\n    digits = digits.into_iter().rev().collect();\n    let mut boxes = vec![\"\".to_string(); 6];\n    let n = digits.len();\n    for (i, digit) in digits.iter().enumerate() {\n        if i == 0 {\n            boxes[0] = \"┏━━━━\".to_string();\n            if i == n - 1 {\n                boxes[0] += \"┓\";\n            }\n        } else if i == n - 1 {\n            boxes[0] += \"┳━━━━┓\";\n        } else {\n            boxes[0] += \"┳━━━━\";\n        }\n        for j in 1..5 {\n            boxes[j] += \"┃\";\n            let elem = 0.max(digit - (4 - j as i64) * 5);\n            if elem >= 5 {\n                boxes[j] += &format!(\"{: ^4}\", FIVE);\n            } else if elem > 0 {\n                boxes[j] += &format!(\"{: ^4}\", ONE.repeat(elem as usize % 15));\n            } else if j == 4 {\n                boxes[j] += &format!(\"{: ^4}\", ZERO);\n            } else {\n                boxes[j] += &\"    \";\n            }\n            if i == n - 1 {\n                boxes[j] += \"┃\";\n            }\n        }\n        if i == 0 {\n            boxes[5] = \"┗━━━━\".to_string();\n            if i == n - 1 {\n                boxes[5] += \"┛\";\n            }\n        } else if i == n - 1 {\n            boxes[5] += \"┻━━━━┛\";\n        } else {\n            boxes[5] += \"┻━━━━\";\n        }\n    }\n\n    let mut mayan = format!(\"Mayan {}:\\n\", dec);\n    for b in boxes {\n        mayan += &(b + \"\\n\");\n    }\n    mayan\n}",
    "title": "Mayan numerals",
    "url": "http://rosettacode.org/wiki/Mayan_numerals"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use rand::{thread_rng, Rng, rngs::ThreadRng};\n\nconst WIDTH: usize = 16;\nconst HEIGHT: usize = 16;\n\n#[derive(Clone, Copy)]\nstruct Cell {\n    col: usize,\n    row: usize,\n}\n\nimpl Cell {\n    fn from(col: usize, row: usize) -> Cell {\n        Cell {col, row}\n    }\n}\n\nstruct Maze {\n    cells: [[bool; HEIGHT]; WIDTH],         //cell visited/non visited\n    walls_h: [[bool; WIDTH]; HEIGHT + 1],   //horizontal walls existing/removed\n    walls_v: [[bool; WIDTH + 1]; HEIGHT],   //vertical walls existing/removed\n    thread_rng: ThreadRng,                  //Random numbers generator\n}\n\nimpl Maze {\n\n    ///Inits the maze, with all the cells unvisited and all the walls active\n    fn new() -> Maze {\n        Maze { \n            cells: [[true; HEIGHT]; WIDTH], \n            walls_h: [[true; WIDTH]; HEIGHT + 1],\n            walls_v: [[true; WIDTH + 1]; HEIGHT],\n            thread_rng: thread_rng(),\n        }\n    }\n\n    ///Randomly chooses the starting cell\n    fn first(&mut self) -> Cell {\n        Cell::from(self.thread_rng.gen_range(0, WIDTH), self.thread_rng.gen_range(0, HEIGHT))\n    }\n\n    ///Opens the enter and exit doors\n    fn open_doors(&mut self) {\n        let from_top: bool = self.thread_rng.gen();\n        let limit = if from_top { WIDTH } else { HEIGHT };\n        let door = self.thread_rng.gen_range(0, limit);\n        let exit = self.thread_rng.gen_range(0, limit);\n        if from_top { \n            self.walls_h[0][door] = false;\n            self.walls_h[HEIGHT][exit] = false;\n        } else {\n            self.walls_v[door][0] = false;\n            self.walls_v[exit][WIDTH] = false;\n        }\n    }\n\n    ///Removes a wall between the two Cell arguments\n    fn remove_wall(&mut self, cell1: &Cell, cell2: &Cell) {\n        if cell1.row == cell2.row {\n            self.walls_v[cell1.row][if cell1.col > cell2.col { cell1.col } else { cell2.col }] = false;\n        } else { \n            self.walls_h[if cell1.row > cell2.row { cell1.row } else { cell2.row }][cell1.col] = false;\n        };\n    }\n\n    ///Returns a random non-visited neighbor of the Cell passed as argument\n    fn neighbor(&mut self, cell: &Cell) -> Option<Cell> {\n        self.cells[cell.col][cell.row] = false;\n        let mut neighbors = Vec::new();\n        if cell.col > 0 && self.cells[cell.col - 1][cell.row] { neighbors.push(Cell::from(cell.col - 1, cell.row)); }\n        if cell.row > 0 && self.cells[cell.col][cell.row - 1] { neighbors.push(Cell::from(cell.col, cell.row - 1)); }\n        if cell.col < WIDTH - 1 && self.cells[cell.col + 1][cell.row] { neighbors.push(Cell::from(cell.col + 1, cell.row)); }\n        if cell.row < HEIGHT - 1 && self.cells[cell.col][cell.row + 1] { neighbors.push(Cell::from(cell.col, cell.row + 1)); }\n        if neighbors.is_empty() {\n            None\n        } else {\n            let next = neighbors.get(self.thread_rng.gen_range(0, neighbors.len())).unwrap();\n            self.remove_wall(cell, next);\n            Some(*next)\n        }\n    }\n\n    ///Builds the maze (runs the Depth-first search algorithm)\n    fn build(&mut self) {\n        let mut cell_stack: Vec<Cell> = Vec::new();\n        let mut next = self.first();\n        loop {\n            while let Some(cell) = self.neighbor(&next) {\n                cell_stack.push(cell);\n                next = cell;\n            }\n            match cell_stack.pop() {\n                Some(cell) => next = cell,\n                None => break,\n            }\n        }\n    }\n\n    ///Displays a wall\n    fn paint_wall(h_wall: bool, active: bool) {\n        if h_wall {\n            print!(\"{}\", if active { \"+---\" } else { \"+   \" });\n        } else {\n            print!(\"{}\", if active { \"|   \" } else { \"    \" });\n        }\n    }\n\n    ///Displays a final wall for a row\n    fn paint_close_wall(h_wall: bool) {\n        if h_wall { println!(\"+\") } else { println!() }\n    }\n\n    ///Displays a whole row of walls\n    fn paint_row(&self, h_walls: bool, index: usize) {\n        let iter = if h_walls { self.walls_h[index].iter() } else { self.walls_v[index].iter() };\n        for &wall in iter {\n            Maze::paint_wall(h_walls, wall);\n        }\n        Maze::paint_close_wall(h_walls);\n    } \n\n    ///Paints the maze\n    fn paint(&self) {\n        for i in 0 .. HEIGHT {\n            self.paint_row(true, i);\n            self.paint_row(false, i);\n        }\n        self.paint_row(true, HEIGHT);\n    }\n}\n\nfn main() {\n    let mut maze = Maze::new();\n    maze.build();\n    maze.open_doors();\n    maze.paint();\n}",
    "title": "Maze generation",
    "url": "http://rosettacode.org/wiki/Maze_generation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use rand::{thread_rng, Rng, rngs::ThreadRng};\n \nconst WIDTH: usize = 16;\nconst HEIGHT: usize = 16;\n \n#[derive(Clone, Copy, PartialEq)]\nstruct Cell {\n    col: usize,\n    row: usize,\n}\n\nimpl Cell {\n    fn from(col: usize, row: usize) -> Cell {\n        Cell {col, row}\n    }\n}\n \nstruct Maze {\n    cells: [[bool; HEIGHT]; WIDTH],         //cell visited/non visited\n    walls_h: [[bool; WIDTH]; HEIGHT + 1],   //horizontal walls existing/removed\n    walls_v: [[bool; WIDTH + 1]; HEIGHT],   //vertical walls existing/removed\n    thread_rng: ThreadRng,                  //Random numbers generator\n}\n \nimpl Maze {\n \n    ///Inits the maze, with all the cells unvisited and all the walls active\n    fn new() -> Maze {\n        Maze { \n            cells: [[true; HEIGHT]; WIDTH], \n            walls_h: [[true; WIDTH]; HEIGHT + 1],\n            walls_v: [[true; WIDTH + 1]; HEIGHT],\n            thread_rng: thread_rng(),\n        }\n    }\n \n    ///Randomly chooses the starting cell\n    fn first(&mut self) -> Cell {\n        Cell::from(self.thread_rng.gen_range(0, WIDTH), self.thread_rng.gen_range(0, HEIGHT))\n    }\n \n    ///Opens the enter and exit doors\n    fn open_doors(&mut self) {\n        let from_top: bool = self.thread_rng.gen();\n        let limit = if from_top { WIDTH } else { HEIGHT };\n        let door = self.thread_rng.gen_range(0, limit);\n        let exit = self.thread_rng.gen_range(0, limit);\n        if from_top { \n            self.walls_h[0][door] = false;\n            self.walls_h[HEIGHT][exit] = false;\n        } else {\n            self.walls_v[door][0] = false;\n            self.walls_v[exit][WIDTH] = false;\n        }\n    }\n \n    ///Removes a wall between the two Cell arguments\n    fn remove_wall(&mut self, cell1: &Cell, cell2: &Cell) {\n        if cell1.row == cell2.row {\n            self.walls_v[cell1.row][if cell1.col > cell2.col { cell1.col } else { cell2.col }] = false;\n        } else { \n            self.walls_h[if cell1.row > cell2.row { cell1.row } else { cell2.row }][cell1.col] = false;\n        };\n    }\n \n    ///Returns a random non-visited neighbor of the Cell passed as argument\n    fn neighbor(&mut self, cell: &Cell) -> Option<Cell> {\n        self.cells[cell.col][cell.row] = false;\n        let mut neighbors = Vec::new();\n        if cell.col > 0 && self.cells[cell.col - 1][cell.row] { neighbors.push(Cell::from(cell.col - 1, cell.row)); }\n        if cell.row > 0 && self.cells[cell.col][cell.row - 1] { neighbors.push(Cell::from(cell.col, cell.row - 1)); }\n        if cell.col < WIDTH - 1 && self.cells[cell.col + 1][cell.row] { neighbors.push(Cell::from(cell.col + 1, cell.row)); }\n        if cell.row < HEIGHT - 1 && self.cells[cell.col][cell.row + 1] { neighbors.push(Cell::from(cell.col, cell.row + 1)); }\n        if neighbors.is_empty() {\n            None\n        } else {\n            let next = neighbors.get(self.thread_rng.gen_range(0, neighbors.len())).unwrap();\n            self.remove_wall(cell, next);\n            Some(*next)\n        }\n    }\n \n    ///Builds the maze (runs the Depth-first search algorithm)\n    fn build(&mut self) {\n        let mut cell_stack: Vec<Cell> = Vec::new();\n        let mut next = self.first();\n        loop {\n            while let Some(cell) = self.neighbor(&next) {\n                cell_stack.push(cell);\n                next = cell;\n            }\n            match cell_stack.pop() {\n                Some(cell) => next = cell,\n                None => break,\n            }\n        }\n    }\n \n    ///MAZE SOLVING: Find the starting cell of the solution\n    fn solution_first(&self) -> Option<Cell> {\n        for (i, wall) in self.walls_h[0].iter().enumerate() {\n            if !wall {\n                return Some(Cell::from(i, 0));\n            }\n        }\n        for (i, wall) in self.walls_v.iter().enumerate() {\n            if !wall[0] {\n                return Some(Cell::from(0, i));\n            }\n        }\n        None\n    }\n\n    ///MAZE SOLVING: Find the last cell of the solution\n    fn solution_last(&self) -> Option<Cell> {\n        for (i, wall) in self.walls_h[HEIGHT].iter().enumerate() {\n            if !wall {\n                return Some(Cell::from(i, HEIGHT - 1));\n            }\n        }\n        for (i, wall) in self.walls_v.iter().enumerate() {\n            if !wall[WIDTH] {\n                return Some(Cell::from(WIDTH - 1, i));\n            }\n        }\n        None\n    }\n\n    ///MAZE SOLVING: Get the next candidate cell\n    fn solution_next(&mut self, cell: &Cell) -> Option<Cell> {\n        self.cells[cell.col][cell.row] = false;\n        let mut neighbors = Vec::new();\n        if cell.col > 0 && self.cells[cell.col - 1][cell.row] && !self.walls_v[cell.row][cell.col] { neighbors.push(Cell::from(cell.col - 1, cell.row)); }\n        if cell.row > 0 && self.cells[cell.col][cell.row - 1] && !self.walls_h[cell.row][cell.col] { neighbors.push(Cell::from(cell.col, cell.row - 1)); }\n        if cell.col < WIDTH - 1 && self.cells[cell.col + 1][cell.row] && !self.walls_v[cell.row][cell.col + 1] { neighbors.push(Cell::from(cell.col + 1, cell.row)); }\n        if cell.row < HEIGHT - 1 && self.cells[cell.col][cell.row + 1] && !self.walls_h[cell.row + 1][cell.col] { neighbors.push(Cell::from(cell.col, cell.row + 1)); }\n        if neighbors.is_empty() {\n            None\n        } else {\n            let next = neighbors.get(self.thread_rng.gen_range(0, neighbors.len())).unwrap();\n            Some(*next)\n        }\n    }\n\n    ///MAZE SOLVING: solve the maze\n    ///Uses self.cells to store the solution cells (true)\n    fn solve(&mut self) {\n        self.cells = [[true; HEIGHT]; WIDTH];\n        let mut solution: Vec<Cell> = Vec::new();\n        let mut next = self.solution_first().unwrap();\n        solution.push(next);\n        let last = self.solution_last().unwrap();\n        'main: loop {\n            while let Some(cell) = self.solution_next(&next) {\n                solution.push(cell);\n                if cell == last {\n                    break 'main;\n                }\n                next = cell;\n            }\n            solution.pop().unwrap();\n            next = *solution.last().unwrap();\n        }\n        self.cells = [[false; HEIGHT]; WIDTH];\n        for cell in solution {\n            self.cells[cell.col][cell.row] = true;\n        }\n    }\n\n    ///MAZE SOLVING: Ask if cell is part of the solution (cells[col][row] == true)\n    fn is_solution(&self, col: usize, row: usize) -> bool {\n        self.cells[col][row]\n    }\n\n    ///Displays a wall\n    ///MAZE SOLVING: Leave space for printing '*' if cell is part of the solution \n    /// (only when painting vertical walls)\n    /// \n    // fn paint_wall(h_wall: bool, active: bool) {\n    //     if h_wall {\n    //         print!(\"{}\", if active { \"+---\" } else { \"+   \" });\n    //     } else {\n    //         print!(\"{}\", if active { \"|   \" } else { \"    \" });\n    //     }\n    // }\n    fn paint_wall(h_wall: bool, active: bool, with_solution: bool) {\n        if h_wall {\n            print!(\"{}\", if active { \"+---\" } else { \"+   \" });\n        } else {\n            print!(\"{}{}\", if active { \"|\" } else { \" \" }, if with_solution { \"\" } else { \"   \" });\n        }\n    }\n    \n    ///MAZE SOLVING: Paint * if cell is part of the solution\n    fn paint_solution(is_part: bool) {\n        print!(\"{}\", if is_part { \" * \" } else {\"   \"});\n    }\n\n    ///Displays a final wall for a row\n    fn paint_close_wall(h_wall: bool) {\n        if h_wall { println!(\"+\") } else { println!() }\n    }\n \n    ///Displays a whole row of walls\n    ///MAZE SOLVING: Displays a whole row of walls and, optionally, the included solution cells.\n    // fn paint_row(&self, h_walls: bool, index: usize) {\n    //     let iter = if h_walls { self.walls_h[index].iter() } else { self.walls_v[index].iter() };\n    //     for &wall in iter {\n    //         Maze::paint_wall(h_walls, wall);\n    //     }\n    //     Maze::paint_close_wall(h_walls);\n    // }\n    fn paint_row(&self, h_walls: bool, index: usize, with_solution: bool) {\n        let iter = if h_walls { self.walls_h[index].iter() } else { self.walls_v[index].iter() };\n        for (col, &wall) in iter.enumerate() {\n            Maze::paint_wall(h_walls, wall, with_solution);\n            if !h_walls && with_solution && col < WIDTH  {\n                Maze::paint_solution(self.is_solution(col, index));\n            }\n        }\n        Maze::paint_close_wall(h_walls);\n    }\n\n    ///Paints the maze\n    ///MAZE SOLVING: Displaying the solution is an option\n    // fn paint(&self) {\n    //     for i in 0 .. HEIGHT {\n    //         self.paint_row(true, i);\n    //         self.paint_row(false, i);\n    //     }\n    //     self.paint_row(true, HEIGHT);\n    // }\n    fn paint(&self, with_solution: bool) {\n        for i in 0 .. HEIGHT {\n            self.paint_row(true, i, with_solution);\n            self.paint_row(false, i, with_solution);\n        }\n        self.paint_row(true, HEIGHT, with_solution);\n    }\n}\n\nfn main() {\n    let mut maze = Maze::new();\n    maze.build();\n    maze.open_doors();\n    \n    println!(\"The maze:\");\n    maze.paint(false);\n\n    maze.solve();\n    println!(\"The maze, solved:\");\n    maze.paint(true);\n}",
    "title": "Maze solving",
    "url": "http://rosettacode.org/wiki/Maze_solving"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let test_cases = vec![\n        [6, 9, 20],\n        [12, 14, 17],\n        [12, 13, 34],\n        [5, 9, 21],\n        [10, 18, 21],\n        [71, 98, 99],\n        [7_074_047, 8_214_596, 9_098_139],\n        [582_795_988, 1_753_241_221, 6_814_151_015],\n        [4, 30, 16],\n        [12, 12, 13],\n        [6, 15, 1],\n    ];\n    for case in &test_cases {\n        print!(\"g({}, {}, {}) = \", case[0], case[1], case[2]);\n        println!(\n            \"{}\",\n            match frobenius(case.to_vec()) {\n                Ok(g) => format!(\"{}\", g),\n                Err(e) => e,\n            }\n        );\n    }\n}\n\nfn frobenius(unsorted_a: Vec<i64>) -> Result<i64, String> {\n    let mut a = unsorted_a;\n    a.sort();\n    assert!(a[0] >= 1);\n    if gcd(gcd(a[0], a[1]), a[2]) > 1 {\n        return Err(\"Undefined\".to_string());\n    }\n    let d12 = gcd(a[0], a[1]);\n    let d13 = gcd(a[0] / d12, a[2]);\n    let d23 = gcd(a[1] / d12, a[2] / d13);\n    let mut a_prime = vec![a[0] / d12 / d13, a[1] / d12 / d23, a[2] / d13 / d23];\n    a_prime.sort();\n    let rod = if a_prime[0] == 1 {\n        -1\n    } else {\n        // Rødseth’s Algorithm\n        let mut a1 = a_prime[0];\n        let mut s0 = congruence(a_prime[1], a_prime[2], a_prime[0]);\n        let mut s = vec![a1];\n        let mut q: Vec<i64> = vec![];\n        while s0 != 0 {\n            s.push(s0);\n            let s1 = if s0 == 1 { 0 } else { s0 - (a1 % s0) };\n            let q1 = (a1 + s1) / s0;\n            q.push(q1);\n            a1 = s0;\n            s0 = s1;\n        }\n        let mut p = vec![0, 1];\n        let mut r = (s[1] * a_prime[1] - p[1] * a_prime[2]) / a_prime[0];\n        let mut i = 1;\n        while r > 0 {\n            let p_next = q[i - 1] * p[i] - p[i - 1];\n            p.push(p_next);\n            r = (s[i + 1] * a_prime[1] - p_next * a_prime[2]) / a_prime[0];\n            i += 1;\n        }\n        let v = i - 1;\n        -a_prime[0] + a_prime[1] * (s[v] - 1) + a_prime[2] * (p[v + 1] - 1)\n            - (a_prime[1] * s[v + 1]).min(a_prime[2] * p[v])\n    };\n    Ok(rod * d12 * d13 * d23 + a[0] * (d23 - 1) + a[1] * (d13 - 1) + a[2] * (d12 - 1))\n}\n\nfn gcd(a: i64, b: i64) -> i64 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nfn congruence(a: i64, c: i64, m: i64) -> i64 {\n    // Solves ax ≡ c mod m\n    let aa = a % m;\n    let cc = (c + a * m) % m;\n    if aa == 1 {\n        cc\n    } else {\n        let y = congruence(m, -cc, aa);\n        (m * y + cc) / aa\n    }\n}",
    "title": "McNuggets Problem",
    "url": "http://rosettacode.org/wiki/McNuggets_Problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Median filter",
    "url": "http://rosettacode.org/wiki/Median_filter"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "// we have to use `unsafe` here because \n// we will be dereferencing a raw pointer\nunsafe {\n    use std::alloc::{Layout, alloc, dealloc};\n    // define a layout of a block of memory\n    let int_layout = Layout::new::<i32>();\n\n    // memory is allocated here\n    let ptr = alloc(int_layout);\n\n    // let us point to some data\n    *ptr = 123;\n    assert_eq!(*ptr, 123);\n\n    // deallocate `ptr` with associated layout `int_layout`\n    dealloc(ptr, int_layout);\n}",
    "title": "Memory allocation",
    "url": "http://rosettacode.org/wiki/Memory_allocation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Memory layout of a data structure",
    "url": "http://rosettacode.org/wiki/Memory_layout_of_a_data_structure"
  },
  {
    "local_code": "use std::io;\n\n/// Print the menu followed by the prompt\nfn print_both(menu: &[&str], prompt: &str) {\n    // Iterate through array and print index, period, and menu item\n    for (i, item) in menu.iter().enumerate() {\n        println!(\"{}. {}\", i, item);\n    }\n\n    // Print the prompt\n    println!(\"{}\", prompt);\n}\n\n/// Grab the next line of input\nfn next_input() -> Option<usize> {\n    let mut in_s = String::new();\n    if io::stdin().read_line(&mut in_s).is_ok() {\n        in_s.trim().parse().ok()\n    } else {\n        None\n    }\n}\n\nfn select<'a>(menu: &'a [&str], prompt: &str) -> &'a str {\n    if menu.is_empty() {\n        return \"\";\n    }\n\n    // Loop until user inputs a valid menu index\n    loop {\n        print_both(menu, prompt);\n\n        let input = next_input();\n\n        let num = match input {\n            Some(num) => num,\n            None => continue,\n        };\n\n        if num < menu.len() {\n            return menu[num];\n        }\n    }\n}\n\nfn main() {\n    let prompt = \"Choose one.\";\n    let menu = &[\"fee fie\", \"huff and puff\", \"mirror mirror\", \"tick tock\"];\n    println!(\"{}\", select(menu, prompt));\n}\n\n#[test]\nfn test_empty_menu() {\n    let prompt = \"Choose one.\";\n    let menu = &[];\n    assert_eq!(select(menu, prompt), \"\");\n}\n",
    "path": "tasks/menu",
    "remote_code": "\nfn menu_select<'a>(items: &'a [&'a str]) -> &'a str {\n    if items.len() == 0 {\n        return \"\";\n    }\n\n    let stdin = std::io::stdin();\n    let mut buffer = String::new();\n\n    loop {\n        for (i, item) in items.iter().enumerate() {\n            println!(\"{}) {}\", i + 1, item);\n        }\n        print!(\"Pick a number from 1 to {}: \", items.len());\n\n        // Read the user input:\n        stdin.read_line(&mut buffer).unwrap();\n        println!();\n\n        if let Ok(selected_index) = buffer.trim().parse::<usize>() {\n            if 0 < selected_index {\n                if let Some(selected_item) = items.get(selected_index - 1) {\n                    return selected_item;\n                }\n            }\n        }\n\n        // The buffer will contain the old input, so we need to clear it before we can reuse it.\n        buffer.clear();\n    }\n}\n\nfn main() {\n    // Empty list:\n    let selection = menu_select(&[]);\n    println!(\"No choice: {:?}\", selection);\n\n    // List with items:\n    let items = [\n        \"fee fie\",\n        \"huff and puff\",\n        \"mirror mirror\",\n        \"tick tock\",\n    ];\n\n    let selection = menu_select(&items);\n    println!(\"You chose: {}\", selection);\n}\n",
    "title": "Menu",
    "url": "http://rosettacode.org/wiki/Menu"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Metallic ratios",
    "url": "http://rosettacode.org/wiki/Metallic_ratios"
  },
  {
    "local_code": "//! Rust supports extensive metaprogramming via macros. Note that rust macros differ from, say, C\n//! preprocessor macros in that they are not mere text substitution (so operator precedence is\n//! preserved and name shadowing is not an issue). Here is an example from [rustbyexample.com] that\n//! implements and tests the `+=`, `-=`, and `*=` operators for Vectors.\n\nuse std::ops::{Add, Mul, Sub};\n\nmacro_rules! assert_equal_len {\n    // The `tt` (token tree) designator is used for\n    // operators and tokens.\n    ($a:ident, $b:ident, $func:ident, $op:tt) => {\n        assert!(\n            $a.len() == $b.len(),\n            \"{:?}: dimension mismatch: {:?} {:?} {:?}\",\n            stringify!($func),\n            ($a.len(),),\n            stringify!($op),\n            ($b.len(),)\n        );\n    };\n}\n\nmacro_rules! op {\n    ($func:ident, $bound:ident, $op:tt, $method:ident) => {\n        fn $func<T: $bound<T, Output = T> + Copy>(xs: &mut [T], ys: &[T]) {\n            assert_equal_len!(xs, ys, $func, $op);\n\n            for (x, y) in xs.iter_mut().zip(ys.iter()) {\n                // *x = x.$method(*y);\n                *x = $bound::$method(*x, *y);\n            }\n        }\n    };\n}\n\n// Implement `add_assign`, `mul_assign`, and `sub_assign` functions.\nop!(add_assign, Add, +=, add);\nop!(mul_assign, Mul, *=, mul);\nop!(sub_assign, Sub, -=, sub);\n\nfn main() {\n    let mut x = vec![2; 3];\n    let a = vec![1, 2, 3];\n    let b = vec![4, 5, 6];\n    let c = vec![7, 8, 9];\n\n    add_assign(&mut x, &a);\n    mul_assign(&mut x, &b);\n    sub_assign(&mut x, &c);\n\n    println!(\"{:?}\", x);\n}\n\nmod test {\n    macro_rules! test {\n        ($func:ident, $x:expr, $y:expr, $z:expr) => {\n            #[test]\n            fn $func() {\n                use std::iter;\n\n                for size in 0usize..10 {\n                    let mut x: Vec<_> = iter::repeat($x).take(size).collect();\n                    let y: Vec<_> = iter::repeat($y).take(size).collect();\n                    let z: Vec<_> = iter::repeat($z).take(size).collect();\n\n                    super::$func(&mut x, &y);\n\n                    assert_eq!(x, z);\n                }\n            }\n        };\n    }\n\n    // Test `add_assign`, `mul_assign` and `sub_assign`\n    test!(add_assign, 1u32, 2u32, 3u32);\n    test!(mul_assign, 2u32, 3u32, 6u32);\n    test!(sub_assign, 3u32, 2u32, 1u32);\n}\n",
    "path": "tasks/metaprogramming",
    "remote_code": "// dry.rs\nuse std::ops::{Add, Mul, Sub};\n\nmacro_rules! assert_equal_len {\n    // The `tt` (token tree) designator is used for\n    // operators and tokens.\n    ($a:ident, $b: ident, $func:ident, $op:tt) => (\n        assert!($a.len() == $b.len(),\n                \"{:?}: dimension mismatch: {:?} {:?} {:?}\",\n                stringify!($func),\n                ($a.len(),),\n                stringify!($op),\n                ($b.len(),));\n    )\n}\n\nmacro_rules! op {\n    ($func:ident, $bound:ident, $op:tt, $method:ident) => (\n        fn $func<T: $bound<T, Output=T> + Copy>(xs: &mut Vec<T>, ys: &Vec<T>) {\n            assert_equal_len!(xs, ys, $func, $op);\n\n            for (x, y) in xs.iter_mut().zip(ys.iter()) {\n                *x = $bound::$method(*x, *y);\n                // *x = x.$method(*y);\n            }\n        }\n    )\n}\n\n// Implement `add_assign`, `mul_assign`, and `sub_assign` functions.\nop!(add_assign, Add, +=, add);\nop!(mul_assign, Mul, *=, mul);\nop!(sub_assign, Sub, -=, sub);\n\nmod test {\n    use std::iter;\n    macro_rules! test {\n        ($func: ident, $x:expr, $y:expr, $z:expr) => {\n            #[test]\n            fn $func() {\n                for size in 0usize..10 {\n                    let mut x: Vec<_> = iter::repeat($x).take(size).collect();\n                    let y: Vec<_> = iter::repeat($y).take(size).collect();\n                    let z: Vec<_> = iter::repeat($z).take(size).collect();\n\n                    super::$func(&mut x, &y);\n\n                    assert_eq!(x, z);\n                }\n            }\n        }\n    }\n\n    // Test `add_assign`, `mul_assign` and `sub_assign`\n    test!(add_assign, 1u32, 2u32, 3u32);\n    test!(mul_assign, 2u32, 3u32, 6u32);\n    test!(sub_assign, 3u32, 2u32, 1u32);\n}",
    "title": "Metaprogramming",
    "url": "http://rosettacode.org/wiki/Metaprogramming"
  },
  {
    "local_code": "//! Rust has a perfectly good Semaphore type already. It lacks count(), though, so we can't use it\n//! directly.\n\nuse std::sync::atomic::AtomicUsize;\nuse std::sync::atomic::Ordering::SeqCst;\nuse std::sync::mpsc::channel;\nuse std::sync::Arc;\nuse std::thread::{self, spawn};\nuse std::time::Duration;\n\npub struct CountingSemaphore {\n    /// Remaining resource count\n    count: AtomicUsize,\n\n    /// How long to sleep if a resource is being contended\n    backoff: Duration,\n}\n\npub struct CountingSemaphoreGuard<'a> {\n    /// A reference to the owning semaphore.\n    sem: &'a CountingSemaphore,\n}\n\nimpl CountingSemaphore {\n    /// Create a semaphore with `max` available resources and a linearly increasing backoff of\n    /// `backoff` (used during spinlock contention).\n    pub fn new(max: usize, backoff: Duration) -> CountingSemaphore {\n        CountingSemaphore {\n            count: AtomicUsize::new(max),\n            backoff: backoff,\n        }\n    }\n\n    /// Acquire a resource, returning a RAII CountingSemaphoreGuard.\n    pub fn acquire(&self) -> CountingSemaphoreGuard {\n        // Spinlock until remaining resource count is at least 1\n        let mut backoff = self.backoff;\n        loop {\n            // Probably don't need SeqCst here, but it doesn't hurt.\n            let count = self.count.load(SeqCst);\n            // The check for 0 is necessary to make sure we don't go negative, which is why this\n            // must be a compare-and-swap rather than a straight decrement.\n            if count == 0 || self.count.compare_and_swap(count, count - 1, SeqCst) != count {\n                // Linear backoff a la Servo's spinlock contention.\n                thread::sleep(backoff);\n                backoff += self.backoff;\n            } else {\n                // We successfully acquired the resource.\n                break;\n            }\n        }\n        CountingSemaphoreGuard { sem: self }\n    }\n\n    // Return remaining resource count\n    pub fn count(&self) -> usize {\n        self.count.load(SeqCst)\n    }\n}\n\nimpl<'a> Drop for CountingSemaphoreGuard<'a> {\n    /// When the guard is dropped, a resource is released back to the pool.\n    fn drop(&mut self) {\n        self.sem.count.fetch_add(1, SeqCst);\n    }\n}\n\nfn metered(duration: Duration) {\n    static MAX_COUNT: usize = 4; // Total available resources\n    static NUM_WORKERS: u8 = 10; // Number of workers contending for the resources\n    let backoff = Duration::from_millis(1); // Linear backoff time\n                                            // Create a shared reference to the semaphore\n    let sem = Arc::new(CountingSemaphore::new(MAX_COUNT, backoff));\n    // Create a channel for notifying the main task that the workers are done\n    let (tx, rx) = channel();\n    for i in 0..NUM_WORKERS {\n        let sem = Arc::clone(&sem);\n        let tx = tx.clone();\n        spawn(move || -> () {\n            // Acquire the resource\n            let guard = sem.acquire();\n            let count = sem.count();\n            // Make sure the count is legal\n            assert!(count < MAX_COUNT);\n            println!(\"Worker {} after acquire: count = {}\", i, count);\n            // Sleep for `duration`\n            thread::sleep(duration);\n            // Release the resource\n            drop(guard);\n            // Make sure the count is legal\n            let count = sem.count();\n            assert!(count <= MAX_COUNT);\n            println!(\"Worker {} after release: count = {}\", i, count);\n            // Notify the main task of completion\n            tx.send(()).unwrap();\n        });\n    }\n    drop(tx);\n    // Wait for all the subtasks to finish\n    for _ in 0..NUM_WORKERS {\n        rx.recv().unwrap();\n    }\n}\n\n#[test]\nfn test_metered_concurrency() {\n    // Hold each resource for 1/20 of a second per worker\n    metered(Duration::from_secs(1) / 20);\n}\n\nfn main() {\n    // Hold each resource for 2 seconds per worker\n    metered(Duration::from_secs(2));\n}\n",
    "path": "tasks/metered-concurrency",
    "remote_code": null,
    "title": "Metered concurrency",
    "url": "http://rosettacode.org/wiki/Metered_concurrency"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Metronome",
    "url": "http://rosettacode.org/wiki/Metronome"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Mian-Chowla sequence",
    "url": "http://rosettacode.org/wiki/Mian-Chowla_sequence"
  },
  {
    "local_code": "#![cfg_attr(feature = \"cargo-clippy\", allow(unreadable_literal))]\n\nfn middle_three_digits(x: i32) -> Result<String, String> {\n    let s: String = x.abs().to_string();\n    let len = s.len();\n    if len < 3 {\n        Err(\"Too short\".into())\n    } else if len % 2 == 0 {\n        Err(\"Even number of digits\".into())\n    } else {\n        Ok(s[len / 2 - 1..len / 2 + 2].to_owned())\n    }\n}\n\nfn print_result(x: i32) {\n    print!(\"middle_three_digits({}) returned: \", x);\n    match middle_three_digits(x) {\n        Ok(s) => println!(\"Success, {}\", s),\n        Err(s) => println!(\"Failure, {}\", s),\n    }\n}\n\nfn main() {\n    let passing = [\n        123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345,\n    ];\n    let failing = [1, 2, -1, -10, 2002, -2002, 0];\n    for i in &passing {\n        print_result(*i);\n    }\n    for i in &failing {\n        print_result(*i);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::middle_three_digits;\n\n    #[test]\n    fn positive() {\n        assert_eq!(middle_three_digits(123), Ok(\"123\".into()));\n        assert_eq!(middle_three_digits(12345), Ok(\"234\".into()));\n        assert_eq!(middle_three_digits(1234567), Ok(\"345\".into()));\n        assert_eq!(middle_three_digits(987654321), Ok(\"654\".into()));\n        assert_eq!(middle_three_digits(10001), Ok(\"000\".into()));\n        assert_eq!(middle_three_digits(100), Ok(\"100\".into()));\n    }\n\n    #[test]\n    fn negative() {\n        assert_eq!(middle_three_digits(-10001), Ok(\"000\".into()));\n        assert_eq!(middle_three_digits(-123), Ok(\"123\".into()));\n        assert_eq!(middle_three_digits(-100), Ok(\"100\".into()));\n        assert_eq!(middle_three_digits(-12345), Ok(\"234\".into()));\n    }\n\n    #[test]\n    fn failures() {\n        assert_eq!(middle_three_digits(1), Err(\"Too short\".into()));\n        assert_eq!(middle_three_digits(2), Err(\"Too short\".into()));\n        assert_eq!(middle_three_digits(-1), Err(\"Too short\".into()));\n        assert_eq!(middle_three_digits(-10), Err(\"Too short\".into()));\n        assert_eq!(\n            middle_three_digits(2002),\n            Err(\"Even number of digits\".into())\n        );\n        assert_eq!(\n            middle_three_digits(-2002),\n            Err(\"Even number of digits\".into())\n        );\n        assert_eq!(middle_three_digits(0), Err(\"Too short\".into()));\n    }\n}\n",
    "path": "tasks/middle-three-digits",
    "remote_code": "fn middle_three_digits(x: i32) -> Result<String, String> {\n    let s: String = x.abs().to_string();\n    let len = s.len();\n    if len < 3 {\n        Err(\"Too short\".into())\n    } else if len % 2 == 0 {\n        Err(\"Even number of digits\".into())\n    } else {\n        Ok(s[len/2 - 1 .. len/2 + 2].to_owned())\n    }\n}\n\nfn print_result(x: i32) {\n    print!(\"middle_three_digits({}) returned: \", x);\n    match middle_three_digits(x) {\n        Ok(s) => println!(\"Success, {}\", s),\n        Err(s) => println!(\"Failure, {}\", s)\n    }\n}\n\nfn main() {\n    let passing = [123, 12345, 1234567, 987654321, 10001, -10001, -123, -100, 100, -12345];\n    let failing = [1, 2, -1, -10, 2002, -2002, 0];\n    for i in passing.iter() {\n        print_result(*i);\n    }\n    for i in failing.iter() {\n        print_result(*i);\n    }\n}",
    "title": "Middle three digits",
    "url": "http://rosettacode.org/wiki/Middle_three_digits"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "/* Add these lines to the [dependencies] section of your Cargo.toml file:\nnum = \"0.2.0\"\nrand = \"0.6.5\"\n*/\n \nuse num::bigint::BigInt;\nuse num::bigint::ToBigInt;\n \n \n// The modular_exponentiation() function takes three identical types\n// (which get cast to BigInt), and returns a BigInt:\nfn modular_exponentiation<T: ToBigInt>(n: &T, e: &T, m: &T) -> BigInt {\n    // Convert n, e, and m to BigInt:\n    let n = n.to_bigint().unwrap();\n    let e = e.to_bigint().unwrap();\n    let m = m.to_bigint().unwrap();\n \n    // Sanity check:  Verify that the exponent is not negative:\n    assert!(e >= Zero::zero());\n \n    use num::traits::{Zero, One};\n \n    // As most modular exponentiations do, return 1 if the exponent is 0:\n    if e == Zero::zero() {\n        return One::one()\n    }\n \n    // Now do the modular exponentiation algorithm:\n    let mut result: BigInt = One::one();\n    let mut base = n % &m;\n    let mut exp = e;\n \n    loop {  // Loop until we can return our result.\n        if &exp % 2 == One::one() {\n            result *= &base;\n            result %= &m;\n        }\n \n        if exp == One::one() {\n            return result\n        }\n \n        exp /= 2;\n        base *= base.clone();\n        base %= &m;\n    }\n}\n \n \n// is_prime() checks the passed-in number against many known small primes.\n// If that doesn't determine if the number is prime or not, then the number\n// will be passed to the is_rabin_miller_prime() function:\nfn is_prime<T: ToBigInt>(n: &T) -> bool {\n    let n = n.to_bigint().unwrap();\n    if n.clone() < 2.to_bigint().unwrap() {\n        return false\n    }\n \n    let small_primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\n                            47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101,\n                            103, 107, 109, 113, 127, 131, 137, 139, 149, 151,\n                            157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\n                            211, 223, 227, 229, 233, 239, 241, 251, 257, 263,\n                            269, 271, 277, 281, 283, 293, 307, 311, 313, 317,\n                            331, 337, 347, 349, 353, 359, 367, 373, 379, 383,\n                            389, 397, 401, 409, 419, 421, 431, 433, 439, 443,\n                            449, 457, 461, 463, 467, 479, 487, 491, 499, 503,\n                            509, 521, 523, 541, 547, 557, 563, 569, 571, 577,\n                            587, 593, 599, 601, 607, 613, 617, 619, 631, 641,\n                            643, 647, 653, 659, 661, 673, 677, 683, 691, 701,\n                            709, 719, 727, 733, 739, 743, 751, 757, 761, 769,\n                            773, 787, 797, 809, 811, 821, 823, 827, 829, 839,\n                            853, 857, 859, 863, 877, 881, 883, 887, 907, 911,\n                            919, 929, 937, 941, 947, 953, 967, 971, 977, 983,\n                            991, 997, 1009, 1013];\n \n    use num::traits::Zero;  // for Zero::zero()\n \n    // Check to see if our number is a small prime (which means it's prime),\n    // or a multiple of a small prime (which means it's not prime):\n    for sp in small_primes {\n        let sp = sp.to_bigint().unwrap();\n \n        if n.clone() == sp {\n            return true\n        } else if n.clone() % sp == Zero::zero() {\n            return false\n        }\n    }\n \n    is_rabin_miller_prime(&n, None)\n}\n \n \n// Note:  \"use bigint::RandBigInt;\"  (which is needed for gen_bigint_range())\n//        fails to work in the Rust playground ( https://play.rust-lang.org ).\n//        Therefore, I'll create my own here:\nfn get_random_bigint(low: &BigInt, high: &BigInt) -> BigInt {\n    if low == high {  // base case\n        return low.clone()\n    }\n \n    let middle = (low.clone() + high) / 2.to_bigint().unwrap();\n \n    let go_low: bool = rand::random();\n \n    if go_low {\n        return get_random_bigint(low, &middle)\n    } else {\n        return get_random_bigint(&middle, high)\n    }\n}\n \n \n// k is the number of times for testing (pass in None to use 5 (the default)).\nfn is_rabin_miller_prime<T: ToBigInt>(n: &T, k: Option<usize>) -> bool {\n    let n = n.to_bigint().unwrap();\n    let k = k.unwrap_or(10);  // number of times for testing (defaults to 10)\n \n    use num::traits::{Zero, One};  // for Zero::zero() and One::one()\n    let zero: BigInt = Zero::zero();\n    let one: BigInt = One::one();\n    let two: BigInt = 2.to_bigint().unwrap();\n \n    // The call to is_prime() should have already checked this,\n    // but check for two, less than two, and multiples of two:\n    if n <= one {\n        return false\n    } else if n == two {\n        return true  // 2 is prime\n    } else if n.clone() % &two == Zero::zero() {\n        return false  // even number (that's not 2) is not prime\n    }\n\n    let mut t: BigInt = zero.clone();\n    let n_minus_one: BigInt = n.clone() - &one;\n    let mut s = n_minus_one.clone();\n    while &s % &two == one {\n        s /= &two;\n        t += &one;\n    }\n \n    // Try k times to test if our number is non-prime:\n    'outer: for _ in 0..k {\n        let a = get_random_bigint(&two, &n_minus_one);\n        let mut v = modular_exponentiation(&a, &s, &n);\n        if v == one {\n            continue 'outer;\n        }\n        let mut i: BigInt = zero.clone();\n        'inner: while &i < &t {\n            v = (v.clone() * &v) % &n;\n            if &v == &n_minus_one {\n                continue 'outer;\n            }\n            i += &one;\n        }\n        return false;\n    }\n    // If we get here, then we have a degree of certainty\n    // that n really is a prime number, so return true:\n    true\n}",
    "title": "Miller–Rabin primality test",
    "url": "http://rosettacode.org/wiki/Miller%E2%80%93Rabin_primality_test"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate rand; // 0.5.5\nuse rand::Rng;\nuse std::iter::repeat;\n\n#[derive(Debug, Eq, PartialEq, Clone)]\nenum Colour {\n    Black,\n    Red,\n}\nuse Colour::*;\n\nfn main() {\n    let mut rng = rand::thread_rng();\n    \n    //Create our deck.\n    let mut deck: Vec<_> = repeat(Black).take(26)\n        .chain(repeat(Red).take(26))\n        .collect();\n    \n    rng.shuffle(&mut deck);\n    \n    let mut black_stack = vec![];\n    let mut red_stack = vec![];\n    let mut discarded = vec![];\n    \n    //Deal our cards.\n    print!(\"Discarding:\");\n    while let (Some(card), Some(next)) = (deck.pop(), deck.pop()) {\n        print!(\" {}\", if card == Black { \"B\" } else { \"R\" });\n        match card {\n            Red => red_stack.push(next),\n            Black => black_stack.push(next),\n        }\n        discarded.push(card);\n    }\n    println!();\n    \n    // Choose how many to swap.\n    let max = red_stack.len().min(black_stack.len());\n    let num = rng.gen_range(1, max);\n    println!(\"Exchanging {} cards\", num);\n    \n    // Actually swap our cards.\n    for _ in 0..num {\n        let red = rng.choose_mut(&mut red_stack).unwrap();\n        let black = rng.choose_mut(&mut black_stack).unwrap();\n        std::mem::swap(red, black);\n    }\n    \n    //Count how many are red and black.\n    let num_black = black_stack.iter()\n        .filter(|&c| c == &Black)\n        .count();\n    let num_red = red_stack.iter()\n        .filter(|&c| c == &Red)\n        .count();\n        \n    println!(\"Number of black cards in black stack: {}\", num_black);\n    println!(\"Number of red cards in red stack: {}\", num_red);\n}",
    "title": "Mind boggling card trick",
    "url": "http://rosettacode.org/wiki/Mind_boggling_card_trick"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Minesweeper game",
    "url": "http://rosettacode.org/wiki/Minesweeper_game"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Minimal steps down to 1",
    "url": "http://rosettacode.org/wiki/Minimal_steps_down_to_1"
  },
  {
    "local_code": "extern crate num;\n\nuse num::bigint::ToBigUint;\nuse num::integer::Integer;\nuse num::{BigUint, One};\n\nfn mod_exp<T: Integer + Clone>(mut a: T, mut b: T, m: &T) -> T {\n    let one: T = One::one();\n    let two = one.clone() + one.clone();\n\n    let mut res = one;\n    while !b.is_zero() {\n        if b.is_odd() {\n            res = (res * a.clone()) % m.clone();\n        }\n        a = (a.clone() * a.clone()) % m.clone();\n        b = b.div_floor(&two);\n    }\n\n    res\n}\n\nfn main() {\n    use num::pow;\n\n    let a_str = \"2988348162058574136915891421498819466320163312926952423791023078876139\";\n    let b_str = \"2351399303373464486466122544523690094744975233415544072992656881240319\";\n    let a: BigUint = BigUint::parse_bytes(a_str.as_bytes(), 10).unwrap();\n    let b: BigUint = BigUint::parse_bytes(b_str.as_bytes(), 10).unwrap();\n    let m: BigUint = pow(10.to_biguint().unwrap(), 40);\n    println!(\"{}\", mod_exp(a, b, &m));\n}\n\n#[test]\nfn test_mod_exp() {\n    let tests = [\n        (0, 10, 10, 0),\n        (1, 10, 10, 1),\n        (2, 1000, 2, 0),\n        (2, 10, 2147483647, 1024),\n        (1337, 100, 2147483647, 1398068914),\n        (18, 112994442, 1000000001, 59108659),\n    ];\n\n    for &(a, b, m, expected) in &tests {\n        let a = a.to_biguint().unwrap();\n        let b = b.to_biguint().unwrap();\n        let m = m.to_biguint().unwrap();\n        let ans: BigUint = mod_exp(a, b, &m);\n\n        assert_eq!(ans, expected.to_biguint().unwrap());\n    }\n}\n",
    "path": "tasks/modular-exponentiation",
    "remote_code": "/* Add this line to the [dependencies] section of your Cargo.toml file:\nnum = \"0.2.0\"\n*/\n\n\nuse num::bigint::BigInt;\nuse num::bigint::ToBigInt;\n\n\n// The modular_exponentiation() function takes three identical types\n// (which get cast to BigInt), and returns a BigInt:\nfn modular_exponentiation<T: ToBigInt>(n: &T, e: &T, m: &T) -> BigInt {\n    // Convert n, e, and m to BigInt:\n    let n = n.to_bigint().unwrap();\n    let e = e.to_bigint().unwrap();\n    let m = m.to_bigint().unwrap();\n\n    // Sanity check:  Verify that the exponent is not negative:\n    assert!(e >= Zero::zero());\n\n    use num::traits::{Zero, One};\n\n    // As most modular exponentiations do, return 1 if the exponent is 0:\n    if e == Zero::zero() {\n        return One::one()\n    }\n\n    // Now do the modular exponentiation algorithm:\n    let mut result: BigInt = One::one();\n    let mut base = n % &m;\n    let mut exp = e;\n\n    // Loop until we can return out result:\n    loop {\n        if &exp % 2 == One::one() {\n            result *= &base;\n            result %= &m;\n        }\n\n        if exp == One::one() {\n            return result\n        }\n\n        exp /= 2;\n        base *= base.clone();\n        base %= &m;\n    }\n}",
    "title": "Modular exponentiation",
    "url": "http://rosettacode.org/wiki/Modular_exponentiation"
  },
  {
    "local_code": "fn main() {\n    println!(\"{:?}\", mul_inv(42, 2017));\n}\n\nfn mul_inv(a: i32, b: i32) -> Option<i32> {\n    let (gcd, mut x, _) = egcd(a, b);\n    if gcd != 1 {\n        // No multiplicative inverse exists\n        return None;\n    }\n    if x < 0 {\n        x += b;\n    }\n    Some(x % b)\n}\n\n#[cfg_attr(feature = \"cargo-clippy\", allow(many_single_char_names))]\nfn egcd(a: i32, b: i32) -> (i32, i32, i32) {\n    if a == 0 {\n        return (b, 0, 1);\n    }\n\n    let (g, y, x) = egcd(b % a, a);\n    (g, x - (b / a) * y, y)\n}\n\n#[test]\nfn test() {\n    assert_eq!(mul_inv(42, 2017), Some(1969));\n}\n",
    "path": "tasks/modular-inverse",
    "remote_code": "fn mod_inv(a: isize, module: isize) -> isize {\n  let mut mn = (module, a);\n  let mut xy = (0, 1);\n  \n  while mn.1 != 0 {\n    xy = (xy.1, xy.0 - (mn.0 / mn.1) * xy.1);\n    mn = (mn.1, mn.0 % mn.1);\n  }\n  \n  while xy.0 < 0 {\n    xy.0 += module;\n  }\n  xy.0\n}\n\nfn main() {\n  println!(\"{}\", mod_inv(42, 2017))\n}",
    "title": "Modular inverse",
    "url": "http://rosettacode.org/wiki/Modular_inverse"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::prelude::*;\nuse std::f64::consts::PI;\n\n// `(f32, f32)` may be faster for some RNGs (including `rand::XorShiftRng`),\n// but less accurate.\nfn is_inside_circle((x, y): (f64, f64)) -> bool {\n    x * x + y * y <= 1.0\n}\n\nfn simulate<R: Rng>(rng: &mut R, samples: usize) -> f64 {\n    let count = (0..samples).filter(|_| is_inside_circle(rng.gen())).count();\n    // A branchless method might be faster\n    /*for _ in 0..samples {\n        count += is_inside_circle(rng.gen()) as usize;\n    }*/\n    (count as f64) / (samples as f64)\n}\n\nfn main() {\n    let mut rng = StdRng::from_entropy();\n\n    println!(\"Real pi: {}\", PI);\n\n    for samples in (3..9).map(|e| 10_usize.pow(e)) {\n        let estimate = 4.0 * simulate(&mut rng, samples);\n        let deviation = 100.0 * (1.0 - estimate / PI).abs();\n        println!(\"{:9}: {:<11} dev: {:.5}%\", samples, estimate, deviation);\n    }\n}\n",
    "path": "tasks/monte-carlo-methods",
    "remote_code": null,
    "title": "Monte Carlo methods",
    "url": "http://rosettacode.org/wiki/Monte_Carlo_methods"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate rand;\nuse rand::Rng;\n\n#[derive(Clone, Copy, PartialEq)]\nenum Prize {Goat , Car}\n\nconst GAMES: usize = 3_000_000;\nfn main() {\n    let mut switch_wins = 0;\n    let mut rng = rand::thread_rng();\n    \n    for _ in 0..GAMES {\n        let mut doors = [Prize::Goat; 3];\n        *rng.choose_mut(&mut doors).unwrap() = Prize::Car;\n\n        // You only lose by switching if you pick the car the first time\n        if rng.choose(&doors).unwrap() != &Prize::Car {\n            switch_wins += 1;\n        }\n    }\n    println!(\"I played the game {total} times and won {wins} times ({percent}%).\", \n             total   = GAMES, \n             wins    = switch_wins, \n             percent = switch_wins as f64 / GAMES as f64 * 100.0\n    );\n}",
    "title": "Monty Hall problem",
    "url": "http://rosettacode.org/wiki/Monty_Hall_problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\n//!\n//! morse_code/src/main.rs\n//!\n//! Michael G. Cummings\n//! 2019-08-26\n//!\n//! Since Rust doesn't have build-in audio support text output is used.\n//!\n\nuse std::process;\nuse structopt::StructOpt;\nuse morse_code::{Config, Opt, run};\n\n/// Core of the command-line binary.\n///\n/// By default expects input from stdin and outputs resulting morse code to stdout, but can also\n/// read and/or write to files.\n/// Use `morse_code --help` for more information about options.\nfn main() {\n    let opts = Opt::from_args();\n    let mut config = Config::new(opts).unwrap_or_else(|err| {\n        eprintln!(\"Problem parsing arguments: {}\", err);\n        process::exit(1);\n    });\n    if let Err(err) = run(&mut config) {\n        eprintln!(\"Application error: {}\", err);\n        process::exit(2);\n    }\n}\n",
    "title": "Morse code",
    "url": "http://rosettacode.org/wiki/Morse_code"
  },
  {
    "local_code": "#[cfg(all(target_os = \"linux\", feature = \"x11\"))]\nextern crate x11;\n\n#[cfg(windows)]\nextern crate winapi;\n\nuse std::thread;\nuse std::time::Duration;\n\n#[cfg(all(target_os = \"linux\", feature = \"x11\"))]\nfn get_mouse_position() -> (usize, usize) {\n    use std::ffi::CString;\n    use std::mem;\n    use std::ptr;\n    use std::slice;\n\n    use x11::xlib::{self, AnyPropertyType, False, True};\n\n    let display = unsafe { xlib::XOpenDisplay(ptr::null()) };\n    if display.is_null() {\n        panic!(\"Could not open display!\");\n    }\n\n    let active_window = unsafe {\n        let mut actual_type_ret = mem::uninitialized();\n        let mut actual_format_ret = mem::uninitialized();\n        let mut n_items_ret = mem::uninitialized();\n        let mut bytes_after_ret = mem::uninitialized();\n        let mut prop_ret = mem::uninitialized();\n\n        xlib::XGetWindowProperty(\n            display,\n            xlib::XDefaultRootWindow(display),\n            xlib::XInternAtom(\n                display,\n                CString::new(\"_NET_ACTIVE_WINDOW\").unwrap().as_ptr(),\n                True,\n            ),\n            0,\n            1,\n            False,\n            AnyPropertyType as u64,\n            &mut actual_type_ret,\n            &mut actual_format_ret,\n            &mut n_items_ret,\n            &mut bytes_after_ret,\n            &mut prop_ret,\n        );\n        let windows: &[xlib::Window] =\n            slice::from_raw_parts_mut(mem::transmute(prop_ret), n_items_ret as usize);\n        windows[0]\n    };\n\n    let (x, y) = unsafe {\n        let mut root_x = mem::uninitialized();\n        let mut root_y = mem::uninitialized();\n        let mut win_x = mem::uninitialized();\n        let mut win_y = mem::uninitialized();\n        let mut mask = mem::uninitialized();\n        let mut child_ret = mem::uninitialized();\n        let mut root_ret = mem::uninitialized();\n\n        xlib::XQueryPointer(\n            display,\n            active_window,\n            &mut root_ret,\n            &mut child_ret,\n            &mut root_x,\n            &mut root_y,\n            &mut win_x,\n            &mut win_y,\n            &mut mask,\n        );\n\n        (win_x, win_y)\n    };\n\n    (x as usize, y as usize)\n}\n\n#[cfg(all(target_os = \"macos\"))]\nfn get_mouse_position() -> (usize, usize) {\n    panic!(\"unsupported platform!\");\n}\n\n#[cfg(all(target_os = \"linux\", not(feature = \"x11\")))]\nfn get_mouse_position() -> (usize, usize) {\n    panic!(\"requires xlib!\");\n}\n\n#[cfg(windows)]\nfn get_mouse_position() -> (i64, i64) {\n    use winapi::shared::windef::POINT;\n    use winapi::um::winuser::{GetCursorPos, GetForegroundWindow, ScreenToClient};\n\n    let h = unsafe { GetForegroundWindow() };\n\n    let (x, y) = unsafe {\n        let mut point = POINT::default();\n        GetCursorPos(&mut point);\n        ScreenToClient(h, &mut point);\n        (point.x, point.y)\n    };\n\n    (x as i64, y as i64)\n}\n\nfn main() {\n    loop {\n        let (x, y) = get_mouse_position();\n        thread::sleep(Duration::from_millis(100));\n        println!(\"x: {}, y: {}\", x, y);\n    }\n}\n",
    "path": "tasks/mouse-position",
    "remote_code": "// rustc 0.9 (7613b15 2014-01-08 18:04:43 -0800)\n\nuse std::libc::{BOOL, HANDLE, LONG};\nuse std::ptr::mut_null;\n\ntype HWND = HANDLE;\n\n#[deriving(Eq)]\nstruct POINT {\n    x: LONG,\n    y: LONG\n}\n\n#[link_name = \"user32\"]\nextern \"system\" {\n    fn GetCursorPos(lpPoint:&mut POINT) -> BOOL;\n    fn GetForegroundWindow() -> HWND;\n    fn ScreenToClient(hWnd:HWND, lpPoint:&mut POINT);\n}\n\nfn main() {\n    let mut pt = POINT{x:0, y:0};\n    loop {\n        std::io::timer::sleep(100); // sleep duration in milliseconds\n\n        let pt_prev = pt;\n        unsafe { GetCursorPos(&mut pt) };\n        if pt != pt_prev {\n            let h = unsafe { GetForegroundWindow() };\n            if h == mut_null() { continue }\n\n            let mut pt_client = pt;\n            unsafe { ScreenToClient(h, &mut pt_client) };\n            println!(\"x: {}, y: {}\", pt_client.x, pt_client.y);\n        }\n    }\n}",
    "title": "Mouse position",
    "url": "http://rosettacode.org/wiki/Mouse_position"
  },
  {
    "local_code": "fn main() {\n    let examples = vec![\"broood\", \"bananaaa\", \"hiphophiphop\"];\n    for example in examples {\n        let encoded = encode(example);\n        let decoded = decode(&encoded);\n        println!(\n            \"{} encodes to {:?} decodes to {}\",\n            example, encoded, decoded\n        );\n    }\n}\n\nfn get_symbols() -> Vec<u8> {\n    (b'a'..b'z').collect()\n}\n\nfn encode(input: &str) -> Vec<usize> {\n    input\n        .as_bytes()\n        .iter()\n        .fold((Vec::new(), get_symbols()), |(mut o, mut s), x| {\n            let i = s.iter().position(|c| c == x).unwrap();\n            let c = s.remove(i);\n            s.insert(0, c);\n            o.push(i);\n            (o, s)\n        })\n        .0\n}\n\nfn decode(input: &[usize]) -> String {\n    input\n        .iter()\n        .fold((Vec::new(), get_symbols()), |(mut o, mut s), x| {\n            o.push(s[*x]);\n            let c = s.remove(*x);\n            s.insert(0, c);\n            (o, s)\n        })\n        .0\n        .into_iter()\n        .map(|c| c as char)\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::*;\n\n    #[test]\n    fn correct_encode() {\n        let encoded = encode(\"broood\");\n        assert_eq!(encoded, vec![1, 17, 15, 0, 0, 5]);\n    }\n\n    #[test]\n    fn correct_decode() {\n        let decoded = decode(&[1, 17, 15, 0, 0, 5]);\n        assert_eq!(decoded, \"broood\");\n    }\n}\n",
    "path": "tasks/move-to-front",
    "remote_code": "fn main() {\n    let examples = vec![\"broood\", \"bananaaa\", \"hiphophiphop\"];\n    for example in examples {\n        let encoded = encode(example);\n        let decoded = decode(&encoded);\n        println!(\n            \"{} encodes to {:?} decodes to {}\",\n            example, encoded, decoded\n        );\n    }\n}\n\nfn get_symbols() -> Vec<u8> {\n    (b'a'..b'z').collect()\n}\n\nfn encode(input: &str) -> Vec<usize> {\n    input\n        .as_bytes()\n        .iter()\n        .fold((Vec::new(), get_symbols()), |(mut o, mut s), x| {\n            let i = s.iter().position(|c| c == x).unwrap();\n            let c = s.remove(i);\n            s.insert(0, c);\n            o.push(i);\n            (o, s)\n        })\n        .0\n}\n\nfn decode(input: &[usize]) -> String {\n    input\n        .iter()\n        .fold((Vec::new(), get_symbols()), |(mut o, mut s), x| {\n            o.push(s[*x]);\n            let c = s.remove(*x);\n            s.insert(0, c);\n            (o, s)\n        })\n        .0\n        .into_iter()\n        .map(|c| c as char)\n        .collect()\n}",
    "title": "Move-to-front algorithm",
    "url": "http://rosettacode.org/wiki/Move-to-front_algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Multi-dimensional array",
    "url": "http://rosettacode.org/wiki/Multi-dimensional_array"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Multifactorial",
    "url": "http://rosettacode.org/wiki/Multifactorial"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Multiple distinct objects",
    "url": "http://rosettacode.org/wiki/Multiple_distinct_objects"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Multiple regression",
    "url": "http://rosettacode.org/wiki/Multiple_regression"
  },
  {
    "local_code": "const LIMIT: i32 = 12;\n\nfn main() {\n    for i in 1..=LIMIT {\n        print!(\"{:3} \", i);\n    }\n    println!();\n\n    for _ in 0..LIMIT {\n        print!(\"----\");\n    }\n    println!(\"+\");\n\n    for i in 1..=LIMIT {\n        for j in 1..=LIMIT {\n            if j < i {\n                print!(\"    \")\n            } else {\n                print!(\"{:3} \", j * i)\n            }\n        }\n        println!(\"| {}\", i);\n    }\n}\n",
    "path": "tasks/multiplication-tables",
    "remote_code": "const LIMIT: i32 = 12;\n\nfn main() {\n    for i in 1..LIMIT+1 {\n        print!(\"{:3}{}\", i, if LIMIT - i == 0 {'\\n'} else {' '})\n    }\n    for i in 0..LIMIT+1 {\n        print!(\"{}\", if LIMIT - i == 0 {\"+\\n\"} else {\"----\"});\n    }\n\n    for i in 1..LIMIT+1 {\n        for j in 1..LIMIT+1 {\n            if j < i {\n                print!(\"    \")\n            } else { \n                print!(\"{:3} \", j * i)\n            }\n        }\n        println!(\"| {}\", i);\n    }\n\n\n}",
    "title": "Multiplication tables",
    "url": "http://rosettacode.org/wiki/Multiplication_tables"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Multiplicative order",
    "url": "http://rosettacode.org/wiki/Multiplicative_order"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Multisplit",
    "url": "http://rosettacode.org/wiki/Multisplit"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let mut solutions = Vec::new();\n\n    for num in 1..5_000 {\n        let power_sum = num.to_string()\n            .chars()\n            .map(|c| {\n                let digit = c.to_digit(10).unwrap();\n                (digit as f64).powi(digit as i32) as usize\n            })\n            .sum::<usize>();\n\n        if power_sum == num {\n            solutions.push(num);\n        }\n    }\n\n    println!(\"Munchausen numbers below 5_000 : {:?}\", solutions);\n}",
    "title": "Munchausen numbers",
    "url": "http://rosettacode.org/wiki/Munchausen_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate image;\n\nuse image::{ImageBuffer, Pixel, Rgb};\n\nfn main() {\n    let mut img = ImageBuffer::new(256, 256);\n\n    for x in 0..256 {\n        for y in 0..256 {\n            let pixel = Rgb::from_channels(0, x as u8 ^ y as u8, 0, 0);\n            img.put_pixel(x, y, pixel);\n        }\n    }\n\n    let _ = img.save(\"output.png\");\n}",
    "title": "Munching squares",
    "url": "http://rosettacode.org/wiki/Munching_squares"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Mutex",
    "url": "http://rosettacode.org/wiki/Mutex"
  },
  {
    "local_code": "fn f(n: usize) -> usize {\n    match n {\n        0 => 1,\n        _ => n - m(f(n - 1)),\n    }\n}\n\nfn m(n: usize) -> usize {\n    match n {\n        0 => 0,\n        _ => n - f(m(n - 1)),\n    }\n}\n\nfn main() {\n    for i in (0..20).map(f) {\n        print!(\"{} \", i);\n    }\n    println!();\n\n    for i in (0..20).map(m) {\n        print!(\"{} \", i);\n    }\n    println!();\n}\n\n#[test]\nfn test_mutual_recursion() {\n    let f_expected = [\n        1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 8, 8, 9, 9, 10, 11, 11, 12,\n    ];\n    let m_expected = [\n        0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 9, 9, 10, 11, 11, 12,\n    ];\n    let f_m_zipped = f_expected.iter().zip(m_expected.iter());\n    for (i, (f_expect, m_expect)) in f_m_zipped.enumerate() {\n        assert!(f(i) == *f_expect);\n        assert!(m(i) == *m_expect);\n    }\n}\n",
    "path": "tasks/mutual-recursion",
    "remote_code": "fn f(n: u32) -> u32 {\n    match n {\n        0 => 1,\n        _ => n - m(f(n - 1))\n    }\n}\n\nfn m(n: u32) -> u32 {\n    match n {\n        0 => 0,\n        _ => n - f(m(n - 1))\n    }\n}\n\nfn main() {\n    for i in (0..20).map(f) {\n        print!(\"{} \", i);\n    }\n    println!(\"\");\n\n    for i in (0..20).map(m) {\n        print!(\"{} \", i);\n    }\n    println!(\"\")\n}",
    "title": "Mutual recursion",
    "url": "http://rosettacode.org/wiki/Mutual_recursion"
  },
  {
    "local_code": "fn nth(num: i32) -> String {\n    format!(\n        \"{}{}\",\n        num,\n        match num % 10 {\n            1 if num % 100 != 11 => \"st\",\n            2 if num % 100 != 12 => \"nd\",\n            3 if num % 100 != 13 => \"rd\",\n            _ => \"th\",\n        }\n    )\n}\n\nfn main() {\n    let ranges = vec![(0, 26), (250, 266), (1000, 1026)];\n    for &(s, e) in &ranges {\n        println!(\"[{}, {}) :\", s, e);\n        for i in s..e {\n            print!(\"{}, \", nth(i));\n        }\n        println!();\n    }\n}\n",
    "path": "tasks/nth",
    "remote_code": "fn nth(num: isize) -> String {\n    format!(\"{}{}\", num, match (num % 10, num % 100) {\n        (1, 11) | (2, 12) | (3, 13) => \"th\",\n        (1, _) => \"st\",\n        (2, _) => \"nd\",\n        (3, _) => \"rd\",\n        _ => \"th\",\n    })\n}\n\nfn main() {\n    let ranges = [(0, 26), (250, 266), (1000, 1026)];\n    for &(s, e) in &ranges {\n        println!(\"[{}, {}) :\", s, e);\n        for i in s..e {\n            print!(\"{}, \", nth(i));\n        }\n        println!();\n    }\n}",
    "title": "N'th",
    "url": "http://rosettacode.org/wiki/N'th"
  },
  {
    "local_code": "#![feature(test)]\nextern crate test;\n\nuse std::sync::mpsc::channel;\nuse std::thread::spawn;\nuse std::vec::Vec;\n\nfn main() {\n    for num in 0i32..16 {\n        println!(\"Sequential: {}: {}\", num, n_queens(num));\n    }\n    for num in 0i32..16 {\n        println!(\"Parallel: {}: {}\", num, semi_parallel_n_queens(num));\n    }\n}\n\n/// Solves n-queens using a depth-first, backtracking solution. Returns the number of solutions for\n/// a given n.\nfn n_queens(n: i32) -> usize {\n    // Pass off to our helper function.\n    n_queens_helper((1 << n as usize) - 1, 0, 0, 0)\n}\n\n/// The meat of the algorithm is in here, a recursive helper function that actually computes the\n/// answer using a depth-first, backtracking algorithm.\n///\n/// The 30,000 foot overview is as follows:\n///\n/// This function takes only 3 important parameters: three integers which represent the spots on\n/// the current row that are blocked by previous queens.\n///\n/// The \"secret sauce\" here is that we can avoid passing around the board or even the locations of\n/// the previous queens and instead we use this information to infer the conflicts for the next\n/// row.\n///\n/// Once we know the conflicts in our current row we can simply recurse over all of the open spots\n/// and profit.\n///\n/// This implementation is optimized for speed and memory by using integers and bit shifting\n/// instead of arrays for storing the conflicts.\nfn n_queens_helper(all_ones: i32, left_diags: i32, columns: i32, right_diags: i32) -> usize {\n    // all_ones is a special value that simply has all 1s in the first n positions\n    // and 0s elsewhere. We can use it to clear out areas that we don't care about.\n\n    // Our solution count.\n    // This will be updated by the recursive calls to our helper.\n    let mut solutions = 0;\n\n    // We get validSpots with some bit trickery. Effectively, each of the parameters\n    // can be ORed together to create an integer with all the conflicts together,\n    // which we then invert and limit by ANDing with all_ones, our special value\n    // from earlier.\n    let mut valid_spots = !(left_diags | columns | right_diags) & all_ones;\n\n    // Since valid_spots contains 1s in all of the locations that\n    // are conflict-free, we know we have gone through all of\n    // those locations when valid_spots is all 0s, i.e. when it is 0.\n    while valid_spots != 0 {\n        // This is just bit trickery. For reasons involving the weird\n        // behavior of two's complement integers, this creates an integer\n        // which is all 0s except for a single 1 in the position of the\n        // LSB of valid_spots.\n        let spot = -valid_spots & valid_spots;\n\n        // We then XOR that integer with the validSpots to flip it to 0\n        // in valid_spots.\n        valid_spots ^= spot;\n\n        // Make a recursive call. This is where we infer the conflicts\n        // for the next row.\n        solutions += n_queens_helper(\n            all_ones,\n            // We add a conflict in the current spot and then shift left,\n            // which has the desired effect of moving all of the conflicts\n            // that are created by left diagonals to the left one square.\n            (left_diags | spot) << 1,\n            // For columns we simply mark this column as filled by ORing\n            // in the currentSpot.\n            columns | spot,\n            // This is the same as the left_diag shift, except we shift\n            // right because these conflicts are caused by right diagonals.\n            (right_diags | spot) >> 1,\n        );\n    }\n\n    // If columns is all blocked (i.e. if it is all ones) then we\n    // have arrived at a solution because we have placed n queens.\n    solutions + ((columns == all_ones) as usize)\n}\n\n/// This is the same as the regular nQueens except it creates n threads in which to to do the work.\n///\n/// This is much slower for smaller numbers (under 16~17) but outperforms the sequential algorithm\n/// after that.\nfn semi_parallel_n_queens(n: i32) -> usize {\n    let all_ones = (1 << n as usize) - 1;\n    let (columns, left_diags, right_diags) = (0, 0, 0);\n\n    let mut receivers = Vec::new();\n    let mut valid_spots = !(left_diags | columns | right_diags) & all_ones;\n    while valid_spots != 0 {\n        let (tx, rx) = channel();\n        let spot = -valid_spots & valid_spots;\n        valid_spots ^= spot;\n        receivers.push(rx);\n\n        spawn(move || -> () {\n            tx.send(n_queens_helper(\n                all_ones,\n                (left_diags | spot) << 1,\n                columns | spot,\n                (right_diags | spot) >> 1,\n            ))\n            .unwrap();\n        });\n    }\n\n    receivers\n        .iter()\n        .map(|r| r.recv().unwrap())\n        .fold(0, |a, b| a + b)\n        + ((columns == all_ones) as usize)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::test::{self, Bencher};\n    use super::{n_queens, semi_parallel_n_queens};\n\n    #[test]\n    fn test_n_queens() {\n        let real = vec![1, 1, 0, 0, 2, 10, 4, 40, 92];\n        for num in 0..9i32 {\n            assert_eq!(n_queens(num), real[num as usize]);\n        }\n    }\n\n    #[ignore]\n    #[test]\n    fn test_parallel_n_queens() {\n        let real = vec![1, 1, 0, 0, 2, 10, 4, 40, 92];\n        for num in 0..9i32 {\n            assert_eq!(semi_parallel_n_queens(num), real[num as usize]);\n        }\n    }\n\n    #[ignore]\n    #[bench]\n    fn bench_n_queens(b: &mut Bencher) {\n        b.iter(|| {\n            test::black_box(n_queens(16));\n        });\n    }\n\n    #[ignore]\n    #[bench]\n    fn bench_semi_parallel_n_queens(b: &mut Bencher) {\n        b.iter(|| {\n            test::black_box(semi_parallel_n_queens(16));\n        });\n    }\n}\n",
    "path": "tasks/n-queens-problem",
    "remote_code": "const N: usize = 8;\n\nfn try(mut board: &mut [[bool; N]; N], row: usize, mut count: &mut i64) {\n   if row == N {\n       *count += 1;\n       for r in board.iter() {\n           println!(\"{}\", r.iter().map(|&x| if x {\"x\"} else {\".\"}.to_string()).collect::<Vec<String>>().join(\" \"))\n       }\n       println!(\"\");\n       return\n   }\n   for i in 0..N {\n       let mut ok: bool = true;\n       for j in 0..row {\n           if board[j][i]\n               || i+j >= row && board[j][i+j-row]\n               || i+row < N+j && board[j][i+row-j]\n           { ok = false }\n       }\n       if ok {\n           board[row][i] = true;\n           try(&mut board, row+1, &mut count);\n           board[row][i] = false;\n       }\n   }\n}\n\nfn main() {\n   let mut board: [[bool; N]; N] = [[false; N]; N];\n   let mut count: i64 = 0;\n   try (&mut board, 0, &mut count);\n   println!(\"Found {} solutions\", count)\n}",
    "title": "N-queens problem",
    "url": "http://rosettacode.org/wiki/N-queens_problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "N-smooth numbers",
    "url": "http://rosettacode.org/wiki/N-smooth_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Named parameters",
    "url": "http://rosettacode.org/wiki/Named_parameters"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Naming conventions",
    "url": "http://rosettacode.org/wiki/Naming_conventions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Narcissist",
    "url": "http://rosettacode.org/wiki/Narcissist"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Narcissistic decimal number",
    "url": "http://rosettacode.org/wiki/Narcissistic_decimal_number"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Natural sorting",
    "url": "http://rosettacode.org/wiki/Natural_sorting"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Nautical bell",
    "url": "http://rosettacode.org/wiki/Nautical_bell"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Negative base numbers",
    "url": "http://rosettacode.org/wiki/Negative_base_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Nested function",
    "url": "http://rosettacode.org/wiki/Nested_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Nested templated data",
    "url": "http://rosettacode.org/wiki/Nested_templated_data"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::io;\n\nfn main() {\n    let mut tokens = 12;\n    println!(\"Nim game\");\n    println!(\"Starting with {} tokens.\", tokens);\n    println!(\"\");\n    \n    loop {\n        tokens = p_turn(&tokens);\n        print_remaining(&tokens);\n        tokens = c_turn(&tokens);\n        print_remaining(&tokens);\n        \n        if tokens == 0 {\n            println!(\"Computer wins!\");\n            break;\n        }\n    }\n}\n\nfn p_turn(tokens: &i32) -> i32 {\n    loop {  //try until we get a good number\n        println!(\"How many tokens would you like to take?\");\n        \n        let mut take = String::new();\n        io::stdin().read_line(&mut take)\n            .expect(\"Sorry, I didn't understand that.\");\n        \n        let take: i32 = match take.trim().parse() {\n            Ok(num) => num,\n            Err(_) => {\n                println!(\"Invalid input\");\n                println!(\"\");\n                continue;\n            }\n        };\n        \n        if take > 3 || take < 1 {\n            println!(\"Take must be between 1 and 3.\");\n            println!(\"\");\n            continue;\n        }\n        \n        return tokens - take;\n    }\n}\n\nfn c_turn(tokens: &i32) -> i32 {\n    let take = tokens % 4;\n    \n    println!(\"Computer takes {} tokens.\", take);\n    \n    return tokens - take;\n}\n\nfn print_remaining(tokens: &i32) {\n    println!(\"{} tokens remaining.\", tokens);\n    println!(\"\");\n}\n",
    "title": "Nim Game",
    "url": "http://rosettacode.org/wiki/Nim_Game"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Non-continuous subsequences",
    "url": "http://rosettacode.org/wiki/Non-continuous_subsequences"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Non-decimal radices/Convert",
    "url": "http://rosettacode.org/wiki/Non-decimal_radices/Convert"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Non-decimal radices/Input",
    "url": "http://rosettacode.org/wiki/Non-decimal_radices/Input"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Non-decimal radices/Output",
    "url": "http://rosettacode.org/wiki/Non-decimal_radices/Output"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "struct Nonoblock {\n  width: usize,\n  config: Vec<usize>,\n  spaces: Vec<usize>,\n}\n\nimpl Nonoblock {\n  pub fn new(width: usize, config: Vec<usize>) -> Nonoblock {\n    Nonoblock {\n      width: width,\n      config: config,\n      spaces: Vec::new(),\n    }\n  }\n\n  pub fn solve(&mut self) -> Vec<Vec<i32>> {\n    let mut output: Vec<Vec<i32>> = Vec::new();\n    self.spaces = (0..self.config.len()).fold(Vec::new(), |mut s, i| {\n      s.push(match i {\n        0 => 0,\n        _ => 1,\n      });\n      s\n    });\n    if self.spaces.iter().sum::<usize>() + self.config.iter().sum::<usize>() <= self.width {\n      'finished: loop {\n        match self.spaces.iter().enumerate().fold((0, vec![0; self.width]), |mut a, (i, s)| {\n            (0..self.config[i]).for_each(|j| a.1[a.0 + j + *s] = 1 + i as i32);\n            return (a.0 + self.config[i] + *s, a.1);\n          }) {\n          (_, out) => output.push(out),\n        }\n        let mut i: usize = 1;\n        'calc: loop {\n          let len = self.spaces.len();\n          if i > len {\n            break 'finished;\n          } else {\n            self.spaces[len - i] += 1\n          }\n          if self.spaces.iter().sum::<usize>() + self.config.iter().sum::<usize>() > self.width {\n            self.spaces[len - i] = 1;\n            i += 1;\n          } else {\n            break 'calc;\n          }\n        }\n      }\n    }\n    output\n  }\n}\n\nfn main() {\n  let mut blocks = [\n    Nonoblock::new(5, vec![2, 1]),\n    Nonoblock::new(5, vec![]),\n    Nonoblock::new(10, vec![8]),\n    Nonoblock::new(15, vec![2, 3, 2, 3]),\n    Nonoblock::new(5, vec![2, 3]),\n  ];\n\n  for block in blocks.iter_mut() {\n    println!(\"{} cells and {:?} blocks\", block.width, block.config);\n    println!(\"{}\",(0..block.width).fold(String::from(\"=\"), |a, _| a + \"==\"));\n    let solutions = block.solve();\n    if solutions.len() > 0 {\n      for solution in solutions.iter() {\n        println!(\"{}\", solution.iter().fold(String::from(\"|\"), |s, f| s + &match f {\n          i if *i > 0 => (('A' as u8 + ((*i - 1) as u8) % 26) as char).to_string(),\n          _ => String::from(\"_\"),\n        }+ \"|\"));\n      }\n    } else {\n      println!(\"No solutions. \");\n    }\n    println!();\n  }\n}",
    "title": "Nonoblock",
    "url": "http://rosettacode.org/wiki/Nonoblock"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Nonogram solver",
    "url": "http://rosettacode.org/wiki/Nonogram_solver"
  },
  {
    "local_code": "const EPSILON: f64 = 1e-10;\n\nfn nth_root(x: f64, n: f64) -> f64 {\n    let mut x0: f64 = x;\n    loop {\n        let delta = (x / x0.powf(n - 1.0) - x0) / n;\n        x0 += delta;\n        if delta.abs() < EPSILON {\n            return x0;\n        }\n    }\n}\n\nfn main() {\n    println!(\"{}\", nth_root(8.0, 3.0));\n    println!(\"{}\", nth_root(4.0, 2.0));\n    println!(\"{}\", nth_root(169.0, 2.0));\n    println!(\"{}\", nth_root(81.0, 4.0));\n}\n\n#[cfg(test)]\nmod tests {\n    extern crate rand;\n\n    use self::rand::distributions::Uniform;\n    use self::rand::Rng;\n    use super::{nth_root, EPSILON};\n\n    #[test]\n    fn check_nth_root() {\n        let mut rng = rand::thread_rng();\n        let range = Uniform::new(1.0, 1e5);\n        for _ in 1..1000 {\n            let x = rng.sample(range);\n            let n = rng.sample(range);\n            assert!((nth_root(x, n) - x.powf(n.recip())).abs() < EPSILON)\n        }\n    }\n}\n",
    "path": "tasks/nth-root",
    "remote_code": null,
    "title": "Nth root",
    "url": "http://rosettacode.org/wiki/Nth_root"
  },
  {
    "local_code": "// If an option may return null - or nothing - in Rust, it's wrapped\n// in an Optional which may return either the type of object specified\n// in <> or None. We can check this using .is_some() and .is_none() on\n// the Option.\n\nfn check_number(num: &Option<u8>) {\n    if num.is_none() {\n        println!(\"Number is: None\");\n    } else {\n        println!(\"Number is: {}\", num.unwrap());\n    }\n}\n\nfn main() {\n    let mut possible_number: Option<u8> = None;\n    check_number(&possible_number);\n\n    possible_number = Some(31);\n    check_number(&possible_number);\n}\n",
    "path": "tasks/null-object",
    "remote_code": "// If an option may return null - or nothing - in Rust, it's wrapped\n// in an Optional which may return either the type of object specified\n// in <> or None. We can check this using .is_some() and .is_none() on\n// the Option.\n\nfn check_number(num: &Option<u8>) {\n    if num.is_none() {\n        println!(\"Number is: None\");\n    } else {\n        println!(\"Number is: {}\", num.unwrap());\n    }\n}\n\nfn main() {\n    let mut possible_number: Option<u8> = None;\n    check_number(&possible_number);\n\n    possible_number = Some(31);\n    check_number(&possible_number);\n}",
    "title": "Null object",
    "url": "http://rosettacode.org/wiki/Null_object"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::io::{self, Write, stdout};\n\nconst SMALL: &[&str] = &[\n    \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n    \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\",\n    \"nineteen\",\n];\n\nconst TENS: &[&str] = &[\n    \"PANIC\", \"PANIC\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\",\n];\n\nconst MAGNITUDE: &[&str] = &[\n    \"PANIC\", \"thousand\", \"million\", \"billion\", \"trillion\", \"quadrillion\", \"quintillion\",\n];\n\nfn wordify<W: Write>(w: &mut W, mut number: i64) -> Result<(), io::Error> {\n    if number == 0 {\n        return write!(w, \"zero\");\n    }\n    if number < 0 {\n        write!(w, \"negative \")?;\n        number = -number;\n    }\n    while number != 0 {\n        if number < 20 {\n            write!(w, \"{}\", SMALL[number as usize])?;\n            break;\n        } else if number < 100 {\n            write!(w, \"{}\", TENS[number as usize / 10])?;\n            number %= 10;\n            if number != 0 {\n                write!(w, \"-\")?;\n            }\n        } else if number < 1_000 {\n            write!(w, \"{} hundred\", SMALL[number as usize / 100])?;\n            number %= 100;\n            if number != 0 {\n                write!(w, \" and \")?;\n            }\n        } else {\n            let mut top = number;\n            let mut magnitude = 0i64;\n            let mut magnitude_pow = 1i64;\n            while top >= 1_000 {\n                top /= 1_000;\n                magnitude += 1;\n                magnitude_pow *= 1_000;\n            }\n            wordify(w, top)?;\n            number %= magnitude_pow;\n            if number == 0 {\n                write!(w, \" {}\", MAGNITUDE[magnitude as usize])?;\n            } else if number > 100 {\n                write!(w, \" {}, \", MAGNITUDE[magnitude as usize])?;\n            } else {\n                write!(w, \" {} and \", MAGNITUDE[magnitude as usize])?;\n            }\n        }\n    }\n    Ok(())\n}\n\nfn main() {\n    let stdout = stdout();\n    let mut stdout = stdout.lock();\n    for &n in &[12, 1048576, 9_000_000_000_000_000_000, -2, 0, 5_000_000_000_000_000_001, -555_555_555_555] {\n        wordify(&mut stdout, n).unwrap();\n        write!(&mut stdout, \"\\n\").unwrap();\n    }\n}",
    "title": "Number names",
    "url": "http://rosettacode.org/wiki/Number_names"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Number reversal game",
    "url": "http://rosettacode.org/wiki/Number_reversal_game"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Numeric error propagation",
    "url": "http://rosettacode.org/wiki/Numeric_error_propagation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Numerical and alphabetical suffixes",
    "url": "http://rosettacode.org/wiki/Numerical_and_alphabetical_suffixes"
  },
  {
    "local_code": "//! This is a partial solution and only implements trapezium integration.\n\nfn trapezium_integral<F>(f: F, range: &std::ops::Range<f64>, n_steps: u32) -> f64\nwhere\n    F: Fn(f64) -> f64,\n{\n    let step_size = (range.end - range.start) / f64::from(n_steps);\n\n    let mut integral = (f(range.start) + f(range.end)) / 2.;\n    let mut pos = range.start + step_size;\n    while pos < range.end {\n        integral += f(pos);\n        pos += step_size;\n    }\n    integral * step_size\n}\n\nfn main() {\n    println!(\"{}\", trapezium_integral(|x| x.powi(3), &(0.0..1.0), 100));\n    println!(\"{}\", trapezium_integral(|x| 1.0 / x, &(1.0..100.0), 1000));\n    println!(\"{}\", trapezium_integral(|x| x, &(0.0..5000.0), 5_000_000));\n    println!(\"{}\", trapezium_integral(|x| x, &(0.0..6000.0), 6_000_000));\n}\n",
    "path": "tasks/numerical-integration",
    "remote_code": "fn integral<F>(f: F, range: std::ops::Range<f64>, n_steps: u32) -> f64\n    where F: Fn(f64) -> f64\n{\n    let step_size = (range.end - range.start)/n_steps as f64;\n\n    let mut integral = (f(range.start) + f(range.end))/2.;\n    let mut pos = range.start + step_size;\n    while pos < range.end {\n        integral += f(pos);\n        pos += step_size;\n    }\n    integral * step_size\n}\n\nfn main() {\n    println!(\"{}\", integral(|x| x.powi(3), 0.0..1.0, 100));\n    println!(\"{}\", integral(|x| 1.0/x, 1.0..100.0, 1000));\n    println!(\"{}\", integral(|x| x, 0.0..5000.0, 5_000_000));\n    println!(\"{}\", integral(|x| x, 0.0..6000.0, 6_000_000));\n}",
    "title": "Numerical integration",
    "url": "http://rosettacode.org/wiki/Numerical_integration"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Numerical integration/Gauss-Legendre Quadrature",
    "url": "http://rosettacode.org/wiki/Numerical_integration/Gauss-Legendre_Quadrature"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "OLE Automation",
    "url": "http://rosettacode.org/wiki/OLE_Automation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Object serialization",
    "url": "http://rosettacode.org/wiki/Object_serialization"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Odd word problem",
    "url": "http://rosettacode.org/wiki/Odd_word_problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "enum Action {Once, Every, Die}\nuse Action::*;\n\nfn main() {\n    let animals = [ (\"horse\" , Die  , \"She's dead, of course!\")\n                  , (\"donkey\", Once , \"It was rather wonky. To swallow a donkey.\")\n                  , (\"cow\"   , Once , \"I don't know how. To swallow a cow.\")\n                  , (\"goat\"  , Once , \"She just opened her throat. To swallow a goat.\")\n                  , (\"pig\"   , Once , \"Her mouth was so big. To swallow a pig.\")\n                  , (\"dog\"   , Once , \"What a hog. To swallow a dog.\")\n                  , (\"cat\"   , Once , \"Fancy that. To swallow a cat.\")\n                  , (\"bird\"  , Once , \"Quite absurd. To swallow a bird.\")\n                  , (\"spider\", Once , \"That wriggled and jiggled and tickled inside her.\")\n                  , (\"fly\"   , Every, \"I don't know why she swallowed the fly.\")\n                  ];\n\n    for (i, a) in animals.iter().enumerate().rev() {\n        println!(\"There was an old lady who swallowed a {}\\n{}\", a.0, a.2);\n\n        if let Die = a.1 {break}\n\n        for (swallowed, to_catch) in animals[i..].iter().zip(&animals[i+1..]) {\n            println!(\"She swallowed the {} to catch the {}.\", swallowed.0, to_catch.0);\n\n            if let Every = to_catch.1 {\n                println!(\"{}\", to_catch.2);\n            }\n        }\n\n        println!(\"Perhaps she'll die.\\n\");\n    }\n}",
    "title": "Old lady swallowed a fly",
    "url": "http://rosettacode.org/wiki/Old_lady_swallowed_a_fly"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::{thread_rng, Rng};\n\nfn one_of_n<R: Rng>(rng: &mut R, n: usize) -> usize {\n    (1..n).fold(0, |keep, cand| {\n        // Note that this will break if n is larger than u32::MAX\n        if rng.gen_range(0, cand as u32 + 1) == 0 {\n            cand\n        } else {\n            keep\n        }\n    })\n}\n\nfn main() {\n    const LINES: usize = 10;\n\n    let mut dist = [0; LINES];\n    let mut rng = thread_rng();\n\n    for _ in 0..1_000_000 {\n        let num = one_of_n(&mut rng, LINES);\n        dist[num] += 1;\n    }\n\n    println!(\"{:?}\", dist);\n}\n",
    "path": "tasks/one-of-n-lines-in-a-file",
    "remote_code": "extern crate rand;\n\nuse rand::{Rng, thread_rng};\n\nfn one_of_n<R: Rng>(rng: &mut R, n: usize) -> usize {\n    (1..n).fold(0, |keep, cand| {\n        // Note that this will break if n is larger than u32::MAX\n        if rng.gen_weighted_bool(cand as u32 + 1) {\n            cand\n        } else {\n            keep\n        }\n    })\n}\n\nfn main() {\n    const LINES: usize = 10;\n\n    let mut dist = [0; LINES];\n    let mut rng = thread_rng();\n\n    for _ in 0..1_000_000 {\n        let num = one_of_n(&mut rng, LINES);\n        dist[num] += 1;\n    }\n\n    println!(\"{:?}\", dist);\n}\n",
    "title": "One of n lines in a file",
    "url": "http://rosettacode.org/wiki/One_of_n_lines_in_a_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn get_new_state(windowed: &[bool]) -> bool {\n    match windowed {\n        [false, true, true] | [true, true, false] => true,\n        _ => false\n    }\n}\n\nfn next_gen(cell: &mut [bool]) {\n    let mut v = Vec::with_capacity(cell.len());\n    v.push(cell[0]);\n    for i in cell.windows(3) {\n        v.push(get_new_state(i));\n    }\n    v.push(cell[cell.len() - 1]);\n    cell.copy_from_slice(&v);\n}\n\nfn print_cell(cell: &[bool]) {\n    for v in cell {\n        print!(\"{} \", if *v {'#'} else {' '});\n    }\n    println!();\n}\n\nfn main() {\n\n    const MAX_GENERATION: usize = 10;\n    const CELLS_LENGTH: usize = 30;\n\n    let mut cell: [bool; CELLS_LENGTH] = rand::random();\n\n    for i in 1..=MAX_GENERATION {\n        print!(\"Gen {:2}: \", i);\n        print_cell(&cell);\n        next_gen(&mut cell);\n    }\n}\n",
    "title": "One-dimensional cellular automata",
    "url": "http://rosettacode.org/wiki/One-dimensional_cellular_automata"
  },
  {
    "local_code": "//! This example uses the `glium` library, a high level, safe wrapper for OpenGL.\n//!\n//! It is based off the example in the [official tutorial].\n//!\n//! [official tutorial]: http://tomaka.github.io/glium/book/index.html\n\n#![cfg_attr(feature = \"cargo-clippy\", allow(forget_copy))]\n\n#[macro_use]\nextern crate glium;\n\nuse glium::{glutin, Surface};\n\n/// Define a struct to store vertices. This struct will be used by `glium` directly.\n#[derive(Copy, Clone)]\nstruct Vertex {\n    position: [f32; 2],\n}\n\nimplement_vertex!(Vertex, position);\n\nfn main() {\n    let mut events_loop = glutin::EventsLoop::new();\n    let window = glutin::WindowBuilder::new();\n    let context = glutin::ContextBuilder::new();\n    let display = glium::Display::new(window, context, &events_loop).unwrap();\n\n    let vertex1 = Vertex {\n        position: [0.0, 0.0],\n    };\n    let vertex2 = Vertex {\n        position: [0.5, 0.0],\n    };\n    let vertex3 = Vertex {\n        position: [0.0, 0.5],\n    };\n    let shape = vec![vertex1, vertex2, vertex3];\n\n    let vertex_buffer = glium::VertexBuffer::new(&display, &shape).unwrap();\n    let indices = glium::index::NoIndices(glium::index::PrimitiveType::TrianglesList);\n\n    // Define the shaders.\n    let vertex_shader_src = r#\"\n        #version 140\n\n        in vec2 position;\n        out vec2 a_color;\n\n        void main() {\n            a_color = position;\n            gl_Position = vec4(position, 0.0, 1.0);\n        }\n    \"#;\n\n    let fragment_shader_src = r#\"\n        #version 140\n\n        in vec2 a_color;\n        out vec4 color;\n\n        void main() {\n            color = vec4(a_color, 0.0, 1.0);\n        }\n    \"#;\n\n    let program =\n        glium::Program::from_source(&display, vertex_shader_src, fragment_shader_src, None)\n            .unwrap();\n\n    let draw = || {\n        let mut target = display.draw();\n        target.clear_color(0.3, 0.3, 0.3, 0.0);\n        target\n            .draw(\n                &vertex_buffer,\n                &indices,\n                &program,\n                &glium::uniforms::EmptyUniforms,\n                &Default::default(),\n            )\n            .unwrap();\n        target.finish().unwrap();\n    };\n\n    // Finally, draw the triangle!\n    draw();\n\n    events_loop.run_forever(|event| {\n        if let glutin::Event::WindowEvent { event, .. } = event {\n            match event {\n                glutin::WindowEvent::CloseRequested => return glutin::ControlFlow::Break,\n                glutin::WindowEvent::Resized(..) => draw(),\n                _ => (),\n            }\n        }\n        glutin::ControlFlow::Continue\n    });\n}\n",
    "path": "tasks/opengl",
    "remote_code": null,
    "title": "OpenGL",
    "url": "http://rosettacode.org/wiki/OpenGL"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "OpenWebNet Password",
    "url": "http://rosettacode.org/wiki/OpenWebNet_Password"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Operator precedence",
    "url": "http://rosettacode.org/wiki/Operator_precedence"
  },
  {
    "local_code": "use std::cmp::Ordering;\n\npub struct Table {\n    rows: Vec<Vec<String>>,\n    ordering_function: fn(&str, &str) -> Ordering,\n    ordering_column: usize,\n    reverse: bool,\n}\n\nimpl Table {\n    pub fn new(rows: Vec<Vec<String>>) -> Table {\n        Table {\n            rows: rows,\n            ordering_column: 0,\n            reverse: false,\n            ordering_function: |str1, str2| str1.cmp(str2),\n        }\n    }\n}\n\nimpl Table {\n    pub fn with_ordering_column(&mut self, ordering_column: usize) -> &mut Table {\n        self.ordering_column = ordering_column;\n        self\n    }\n\n    pub fn with_reverse(&mut self, reverse: bool) -> &mut Table {\n        self.reverse = reverse;\n        self\n    }\n\n    pub fn with_ordering_fun(&mut self, compare: fn(&str, &str) -> Ordering) -> &mut Table {\n        self.ordering_function = compare;\n        self\n    }\n\n    pub fn sort(&mut self) {\n        let fun = &mut self.ordering_function;\n        let idx = self.ordering_column;\n        if self.reverse {\n            self.rows\n                .sort_unstable_by(|vec1, vec2| (fun)(&vec1[idx], &vec2[idx]).reverse());\n        } else {\n            self.rows\n                .sort_unstable_by(|vec1, vec2| (fun)(&vec1[idx], &vec2[idx]));\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::Table;\n\n    fn generate_test_table() -> Table {\n        Table::new(vec![\n            vec![\"0\".to_string(), \"fff\".to_string()],\n            vec![\"2\".to_string(), \"aab\".to_string()],\n            vec![\"1\".to_string(), \"ccc\".to_string()],\n        ])\n    }\n\n    #[test]\n    fn test_simple_sort() {\n        let mut table = generate_test_table();\n        table.sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"0\".to_string(), \"fff\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"2\".to_string(), \"aab\".to_string()],\n            ],\n        )\n    }\n\n    #[test]\n    fn test_ordering_column() {\n        let mut table = generate_test_table();\n        table.with_ordering_column(1).sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"2\".to_string(), \"aab\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"0\".to_string(), \"fff\".to_string()],\n            ],\n        )\n    }\n\n    #[test]\n    fn test_with_reverse() {\n        let mut table = generate_test_table();\n        table.with_reverse(true).sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"2\".to_string(), \"aab\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"0\".to_string(), \"fff\".to_string()],\n            ],\n        )\n    }\n\n    #[test]\n    fn test_custom_ordering_fun() {\n        let mut table = generate_test_table();\n        // Simple ordering function that reverses stuff.\n        // Should operate like the test before.\n        table.with_ordering_fun(|x, y| x.cmp(y).reverse()).sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"2\".to_string(), \"aab\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"0\".to_string(), \"fff\".to_string()],\n            ],\n        )\n    }\n\n    #[test]\n    fn test_everything_together() {\n        let mut table = generate_test_table();\n        // Using the reversing cmp function, then reverse (= don't do anything)\n        // then sort from column 1.\n        table\n            .with_ordering_fun(|x, y| x.cmp(y).reverse())\n            .with_reverse(true)\n            .with_ordering_column(1)\n            .sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"2\".to_string(), \"aab\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"0\".to_string(), \"fff\".to_string()],\n            ],\n        )\n    }\n}\n",
    "path": "tasks/optional-parameters",
    "remote_code": "use std::cmp::Ordering;\n\nstruct Table {\n    rows: Vec<Vec<String>>,\n    ordering_function: fn(&str, &str) -> Ordering,\n    ordering_column: usize,\n    reverse: bool,\n}\n\nimpl Table {\n    fn new(rows: Vec<Vec<String>>) -> Table {\n        Table {\n            rows: rows,\n            ordering_column: 0,\n            reverse: false,\n            ordering_function: |str1, str2| str1.cmp(str2),\n        }\n    }\n}\n\nimpl Table {\n    fn with_ordering_column(&mut self, ordering_column: usize) -> &mut Table {\n        self.ordering_column = ordering_column;\n        self\n    }\n\n    fn with_reverse(&mut self, reverse: bool) -> &mut Table {\n        self.reverse = reverse;\n        self\n    }\n\n    fn with_ordering_fun(&mut self, compare: fn(&str, &str) -> Ordering) -> &mut Table {\n        self.ordering_function = compare;\n        self\n    }\n\n    fn sort(&mut self) {\n        let fun = &mut self.ordering_function;\n        let idx = self.ordering_column;\n        if self.reverse {\n            self.rows\n                .sort_unstable_by(|vec1, vec2| (fun)(&vec1[idx], &vec2[idx]).reverse());\n        } else {\n            self.rows\n                .sort_unstable_by(|vec1, vec2| (fun)(&vec1[idx], &vec2[idx]));\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::Table;\n\n    fn generate_test_table() -> Table {\n        Table::new(vec![\n            vec![\"0\".to_string(), \"fff\".to_string()],\n            vec![\"2\".to_string(), \"aab\".to_string()],\n            vec![\"1\".to_string(), \"ccc\".to_string()],\n        ])\n    }\n\n    #[test]\n    fn test_simple_sort() {\n        let mut table = generate_test_table();\n        table.sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"0\".to_string(), \"fff\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"2\".to_string(), \"aab\".to_string()],\n            ],\n        )\n    }\n\n    #[test]\n    fn test_ordering_column() {\n        let mut table = generate_test_table();\n        table.with_ordering_column(1).sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"2\".to_string(), \"aab\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"0\".to_string(), \"fff\".to_string()],\n            ],\n        )\n    }\n\n    #[test]\n    fn test_with_reverse() {\n        let mut table = generate_test_table();\n        table.with_reverse(true).sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"2\".to_string(), \"aab\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"0\".to_string(), \"fff\".to_string()],\n            ],\n        )\n    }\n\n    #[test]\n    fn test_custom_ordering_fun() {\n        let mut table = generate_test_table();\n        // Simple ordering function that reverses stuff.\n        // Should operate like the test before.\n        table.with_ordering_fun(|x, y| x.cmp(y).reverse()).sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"2\".to_string(), \"aab\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"0\".to_string(), \"fff\".to_string()],\n            ],\n        )\n    }\n\n    #[test]\n    fn test_everything_together() {\n        let mut table = generate_test_table();\n        // Using the reversing cmp function, then reverse (= don't do anything)\n        // then sort from column 1.\n        table\n            .with_ordering_fun(|x, y| x.cmp(y).reverse())\n            .with_reverse(true)\n            .with_ordering_column(1)\n            .sort();\n        assert_eq!(\n            table.rows,\n            vec![\n                vec![\"2\".to_string(), \"aab\".to_string()],\n                vec![\"1\".to_string(), \"ccc\".to_string()],\n                vec![\"0\".to_string(), \"fff\".to_string()],\n            ],\n        )\n    }\n}\n",
    "title": "Optional parameters",
    "url": "http://rosettacode.org/wiki/Optional_parameters"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Order disjoint list items",
    "url": "http://rosettacode.org/wiki/Order_disjoint_list_items"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Order two numerical lists",
    "url": "http://rosettacode.org/wiki/Order_two_numerical_lists"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Ordered Partitions",
    "url": "http://rosettacode.org/wiki/Ordered_Partitions"
  },
  {
    "local_code": "use std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn is_ordered(s: &str) -> bool {\n    let mut prev = '\\x00';\n    for c in s.chars() {\n        if c < prev {\n            return false;\n        }\n        prev = c;\n    }\n\n    true\n}\n\nfn find_longest_ordered_words(dict: Vec<String>) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut longest_length = 0;\n\n    for s in dict {\n        if is_ordered(&s) {\n            let n = s.len();\n            if n > longest_length {\n                longest_length = n;\n                result.truncate(0);\n            }\n            if n == longest_length {\n                result.push(s.to_owned());\n            }\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let lines = BufReader::new(File::open(\"unixdict.txt\").unwrap())\n        .lines()\n        .map(|l| l.unwrap())\n        .collect();\n\n    let longest_ordered = find_longest_ordered_words(lines);\n\n    for s in &longest_ordered {\n        println!(\"{}\", s.to_string());\n    }\n}\n",
    "path": "tasks/ordered-words",
    "remote_code": "const FILE: &'static str = include_str!(\"./unixdict.txt\");\n\nfn is_ordered(s: &str) -> bool {\n    let mut prev = '\\x00';\n    for c in s.to_lowercase().chars() {\n        if c < prev {\n            return false;\n        }\n        prev = c;\n    }\n\n    return true;\n}\n\nfn find_longest_ordered_words(dict: Vec<&str>) -> Vec<&str> {\n    let mut result = Vec::new();\n    let mut longest_length = 0;\n\n    for s in dict.into_iter() {\n        if is_ordered(&s) {\n            let n = s.len();\n            if n > longest_length {\n                longest_length = n;\n                result.truncate(0);\n            }\n            if n == longest_length {\n                result.push(s);\n            }\n        }\n    }\n\n    return result;\n}\n\nfn main() {\n    let lines = FILE.lines().collect();\n\n    let longest_ordered = find_longest_ordered_words(lines);\n\n    for s in longest_ordered.iter() {\n        println!(\"{}\", s.to_string());\n    }\n}",
    "title": "Ordered words",
    "url": "http://rosettacode.org/wiki/Ordered_words"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "P-value correction",
    "url": "http://rosettacode.org/wiki/P-value_correction"
  },
  {
    "local_code": "/// Returns true if the string is a palindrome\nfn palindrome(string: &str) -> bool {\n    // The first part of the string\n    let forward = string.chars().take(string.len() / 2);\n\n    // The second part of the string in reverse order\n    let reverse = string.chars().rev().take(string.len() / 2);\n\n    // We group the two parts of the string in tuples\n    let mut both_directions = forward.zip(reverse);\n\n    // The word is a palindrome if each tuple contains two times\n    // the same character\n    both_directions.all(|(a, b)| a == b)\n}\n\nfn main() {\n    let test_strings = [\"nope\", \"eevee\", \"lalala\", \"rust\", \"lalalal\"];\n    for &string in &test_strings {\n        println!(\"{}: {}\", string, palindrome(string));\n    }\n}\n\n#[test]\nfn test_palindromes() {\n    let palindromes = [\"eevee\", \"lalalal\", \"オオオオ\", \"\", \"anna\"];\n    let non_palindromes = [\"nope\", \"lalala\", \"car\", \"rain\", \"house\", \"computer\", \"rust\"];\n\n    assert!(palindromes.iter().all(|&s| palindrome(s)));\n    assert!(non_palindromes.iter().all(|&s| !palindrome(s)));\n}\n",
    "path": "tasks/palindrome-detection",
    "remote_code": "\nfn is_palindrome(string: &str) -> bool {\n    let half_len = string.len()/2;\n    string.chars().take(half_len).eq(string.chars().rev().take(half_len))\n}\n\nmacro_rules! test {\n    ( $( $x:tt ),* ) => { $( println!(\"'{}': {}\", $x, is_palindrome($x)); )* };\n}\n\nfn main() {\n    test!(\"\",\n          \"a\",\n          \"ada\",\n          \"adad\",\n          \"ingirumimusnocteetconsumimurigni\",\n          \"人人為我,我為人人\",\n          \"Я иду с мечем, судия\",\n          \"아들딸들아\",\n          \"The quick brown fox\");\n}\n",
    "title": "Palindrome detection",
    "url": "http://rosettacode.org/wiki/Palindrome_detection"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Palindromic gapful numbers",
    "url": "http://rosettacode.org/wiki/Palindromic_gapful_numbers"
  },
  {
    "local_code": "#![feature(test)]\n\nextern crate test;\n\nuse std::collections::HashSet;\n\npub fn is_pangram_via_bitmask(s: &str) -> bool {\n    // Create a mask of set bits and convert to false as we find characters.\n    let mut mask = (1 << 26) - 1;\n\n    for chr in s.chars() {\n        let val = chr as u32 & !0x20; /* 0x20 converts lowercase to upper */\n        if val <= 'Z' as u32 && val >= 'A' as u32 {\n            mask &= !(1 << (val - 'A' as u32));\n        }\n    }\n\n    mask == 0\n}\n\npub fn is_pangram_via_hashset(s: &str) -> bool {\n    // Insert lowercase letters into a HashSet, then check if we have at least 26.\n    let letters = s\n        .chars()\n        .flat_map(|chr| chr.to_lowercase())\n        .filter(|&chr| chr >= 'a' && chr <= 'z')\n        .fold(HashSet::new(), |mut letters, chr| {\n            letters.insert(chr);\n            letters\n        });\n\n    letters.len() == 26\n}\n\npub fn is_pangram_via_sort(s: &str) -> bool {\n    // Copy chars into a vector, convert to lowercase, sort, and remove duplicates.\n    let mut chars: Vec<char> = s\n        .chars()\n        .flat_map(|chr| chr.to_lowercase())\n        .filter(|&chr| chr >= 'a' && chr <= 'z')\n        .collect();\n\n    chars.sort();\n    chars.dedup();\n\n    chars.len() == 26\n}\n\nfn main() {\n    let examples = [\n        \"The quick brown fox jumps over the lazy dog\",\n        \"The quick white cat jumps over the lazy dog\",\n    ];\n\n    for &text in &examples {\n        let is_pangram_sort = is_pangram_via_sort(text);\n        println!(\"Is \\\"{}\\\" a pangram via sort? - {}\", text, is_pangram_sort);\n\n        let is_pangram_bitmask = is_pangram_via_bitmask(text);\n        println!(\n            \"Is \\\"{}\\\" a pangram via bitmask? - {}\",\n            text, is_pangram_bitmask\n        );\n\n        let is_pangram_hashset = is_pangram_via_hashset(text);\n        println!(\n            \"Is \\\"{}\\\" a pangram via bitmask? - {}\",\n            text, is_pangram_hashset\n        );\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use test::Bencher;\n\n    #[test]\n    fn test_sort() {\n        assert!(is_pangram_via_sort(\n            \"The quick brown fox jumps over the lazy dog\"\n        ));\n        assert!(!is_pangram_via_sort(\n            \"The quick white cat jumps over the lazy dog\"\n        ));\n    }\n\n    #[test]\n    fn test_bitmask() {\n        assert!(is_pangram_via_bitmask(\n            \"The quick brown fox jumps over the lazy dog\"\n        ));\n        assert!(!is_pangram_via_bitmask(\n            \"The quick white cat jumps over the lazy dog\"\n        ));\n    }\n\n    #[test]\n    fn test_hashset() {\n        assert!(is_pangram_via_hashset(\n            \"The quick brown fox jumps over the lazy dog\"\n        ));\n        assert!(!is_pangram_via_hashset(\n            \"The quick white cat jumps over the lazy dog\"\n        ));\n    }\n\n    #[bench]\n    fn sort_speed(b: &mut Bencher) {\n        b.iter(|| is_pangram_via_sort(\"The quick brown fox jumps over the lazy dog\"));\n    }\n\n    #[bench]\n    fn bitmask_speed(b: &mut Bencher) {\n        b.iter(|| is_pangram_via_bitmask(\"The quick brown fox jumps over the lazy dog\"));\n    }\n\n    #[bench]\n    fn hashset_speed(b: &mut Bencher) {\n        b.iter(|| is_pangram_via_hashset(\"The quick brown fox jumps over the lazy dog\"));\n    }\n}\nuse std::collections::HashSet;\n\n/// Returns true if the sentence uses all 26 letters in the English\n/// alphabet at least once.\nfn is_pangram(sentence: &str) -> bool {\n    sentence\n        .chars()\n        .map(|c| c.to_lowercase().next().unwrap())\n        .filter(|&c| c >= 'a' && c <= 'z')\n        .collect::<HashSet<char>>()\n        .len()\n        == 26\n}\n\nfn main() {\n    let test_sentences = [\n        \"The quick brown fox jumps over the lazy dog.\",\n        \"The quick brown frog jumps over the lazy dog.\",\n    ];\n    for &sentence in &test_sentences {\n        println!(\n            \"\\\"{}\\\" {} a pangram\",\n            sentence,\n            if is_pangram(sentence) { \"is\" } else { \"is not\" }\n        );\n    }\n}\n\n#[test]\nfn test_empty() {\n    assert_eq!(is_pangram(\"\"), false);\n}\n\n#[test]\nfn test_one_letter() {\n    assert_eq!(is_pangram(\"A\"), false);\n}\n\n#[test]\nfn test_pangram() {\n    assert_eq!(\n        is_pangram(\"The quick brown fox jumps over the lazy dog\"),\n        true\n    );\n}\n\n#[test]\nfn test_non_pangram() {\n    assert_eq!(\n        is_pangram(\"The quick brown fox jumps over the lurking dog\"),\n        false\n    );\n}\n\n#[test]\nfn test_pangram_unicode() {\n    assert_eq!(\n        is_pangram(\"The quick brown fox (狐狸) jumps over the lazy dog\"),\n        true\n    );\n}\n\n#[test]\nfn test_non_pangram_unicode() {\n    assert_eq!(\n        is_pangram(\"The quick brown 狐狸 jumps over the lazy dog\"),\n        false\n    );\n}\n",
    "path": "tasks/pangram-checker",
    "remote_code": "#![feature(test)]\n\nextern crate test;\n\nuse std::collections::HashSet;\n\npub fn is_pangram_via_bitmask(s: &str) -> bool {\n\n    // Create a mask of set bits and convert to false as we find characters.\n    let mut mask = (1 << 26) - 1;\n\n    for chr in s.chars() {\n        let val = chr as u32 & !0x20; /* 0x20 converts lowercase to upper */\n        if val <= 'Z' as u32 && val >= 'A' as u32 {\n            mask = mask & !(1 << (val - 'A' as u32));\n        }\n    }\n\n    mask == 0\n}\n\npub fn is_pangram_via_hashset(s: &str) -> bool {\n\n    // Insert lowercase letters into a HashSet, then check if we have at least 26.\n    let letters = s.chars()\n        .flat_map(|chr| chr.to_lowercase())\n        .filter(|&chr| chr >= 'a' && chr <= 'z')\n        .fold(HashSet::new(), |mut letters, chr| {\n            letters.insert(chr);\n            letters\n        });\n\n    letters.len() == 26\n}\n\npub fn is_pangram_via_sort(s: &str) -> bool {\n\n    // Copy chars into a vector, convert to lowercase, sort, and remove duplicates.\n    let mut chars: Vec<char> = s.chars()\n        .flat_map(|chr| chr.to_lowercase())\n        .filter(|&chr| chr >= 'a' && chr <= 'z')\n        .collect();\n\n    chars.sort();\n    chars.dedup();\n\n    chars.len() == 26\n}\n\nfn main() {\n\n    let examples = [\"The quick brown fox jumps over the lazy dog\",\n                    \"The quick white cat jumps over the lazy dog\"];\n\n    for &text in examples.iter() {\n        let is_pangram_sort = is_pangram_via_sort(text);\n        println!(\"Is \\\"{}\\\" a pangram via sort? - {}\", text, is_pangram_sort);\n\n        let is_pangram_bitmask = is_pangram_via_bitmask(text);\n        println!(\"Is \\\"{}\\\" a pangram via bitmask? - {}\",\n                 text,\n                 is_pangram_bitmask);\n\n        let is_pangram_hashset = is_pangram_via_hashset(text);\n        println!(\"Is \\\"{}\\\" a pangram via bitmask? - {}\",\n                 text,\n                 is_pangram_hashset);\n    }\n}",
    "title": "Pangram checker",
    "url": "http://rosettacode.org/wiki/Pangram_checker"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Paraffins",
    "url": "http://rosettacode.org/wiki/Paraffins"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Parallel Brute Force",
    "url": "http://rosettacode.org/wiki/Parallel_Brute_Force"
  },
  {
    "local_code": "//! This solution uses [rayon](https://github.com/rayon-rs/rayon), a data-parallelism library.\n//! Since Rust guarantees that a program has no data races, adding parallelism to a sequential\n//! computation is as easy as importing the rayon traits and calling the `par_iter()` method.\n\nextern crate rayon;\n\nextern crate prime_decomposition;\n\nuse rayon::prelude::*;\n\n/// Returns the largest minimal factor of the numbers in a slice\npub fn largest_min_factor(numbers: &[usize]) -> usize {\n    numbers\n        .par_iter()\n        .map(|n| {\n            // `factor` returns a sorted vector, so we just take the first element.\n            prime_decomposition::factor(*n)[0]\n        })\n        .max()\n        .unwrap()\n}\n\nfn main() {\n    let numbers = &[\n        1_122_725, 1_125_827, 1_122_725, 1_152_800, 1_157_978, 1_099_726,\n    ];\n    let max = largest_min_factor(numbers);\n    println!(\"The largest minimal factor is {}\", max);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::largest_min_factor;\n\n    #[test]\n    fn test_basic() {\n        let numbers = &[25, 80, 256, 55, 18, 19];\n        assert_eq!(largest_min_factor(numbers), 19);\n    }\n}\n",
    "path": "tasks/parallel-calculations",
    "remote_code": null,
    "title": "Parallel calculations",
    "url": "http://rosettacode.org/wiki/Parallel_calculations"
  },
  {
    "local_code": "struct TreeNode<T> {\n    value: T,\n    left: Option<Box<TreeNode<T>>>,\n    right: Option<Box<TreeNode<T>>>,\n}\n\nimpl<T> TreeNode<T> {\n    fn my_map<U, F>(&self, f: &F) -> TreeNode<U>\n    where\n        F: Fn(&T) -> U,\n    {\n        TreeNode {\n            value: f(&self.value),\n            left: match self.left {\n                None => None,\n                Some(ref n) => Some(Box::new(n.my_map(f))),\n            },\n            right: match self.right {\n                None => None,\n                Some(ref n) => Some(Box::new(n.my_map(f))),\n            },\n        }\n    }\n}\n\nfn main() {\n    let root = TreeNode {\n        value: 3,\n        left: Some(Box::new(TreeNode {\n            value: 55,\n            left: None,\n            right: None,\n        })),\n        right: Some(Box::new(TreeNode {\n            value: 234,\n            left: Some(Box::new(TreeNode {\n                value: 0,\n                left: None,\n                right: None,\n            })),\n            right: None,\n        })),\n    };\n    root.my_map(&|x| println!(\"{}\", x));\n    println!(\"---------------\");\n    let new_root = root.my_map(&|x| f64::from(*x) * 333.333);\n    new_root.my_map(&|x| println!(\"{}\", x));\n}\n",
    "path": "tasks/parametric-polymorphism",
    "remote_code": "struct TreeNode<T> {\n    value: T,\n    left: Option<Box<TreeNode<T>>>,\n    right: Option<Box<TreeNode<T>>>,\n}\n\nimpl <T> TreeNode<T> {\n    fn my_map<U,F>(&self, f: &F) -> TreeNode<U> where\n            F: Fn(&T) -> U {\n        TreeNode {\n            value: f(&self.value),\n            left: match self.left {\n                None => None,\n                Some(ref n) => Some(Box::new(n.my_map(f))),\n            },\n            right: match self.right {\n                None => None,\n                Some(ref n) => Some(Box::new(n.my_map(f))),\n            },\n        }\n    }\n}\n\nfn main() {\n    let root = TreeNode {\n        value: 3,\n        left: Some(Box::new(TreeNode {\n            value: 55,\n            left: None,\n            right: None,\n        })),\n        right: Some(Box::new(TreeNode {\n            value: 234,\n            left: Some(Box::new(TreeNode {\n                value: 0,\n                left: None,\n                right: None,\n            })),\n            right: None,\n        })),\n    };\n    root.my_map(&|x| { println!(\"{}\" , x)});\n    println!(\"---------------\");\n    let new_root = root.my_map(&|x| *x as f64 * 333.333f64);\n    new_root.my_map(&|x| { println!(\"{}\" , x) });\n}",
    "title": "Parametric polymorphism",
    "url": "http://rosettacode.org/wiki/Parametric_polymorphism"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Parametrized SQL statement",
    "url": "http://rosettacode.org/wiki/Parametrized_SQL_statement"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Parse an IP Address",
    "url": "http://rosettacode.org/wiki/Parse_an_IP_Address"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Parsing/RPN calculator algorithm",
    "url": "http://rosettacode.org/wiki/Parsing/RPN_calculator_algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Parsing/RPN to infix conversion",
    "url": "http://rosettacode.org/wiki/Parsing/RPN_to_infix_conversion"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "type Number = f64;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Operator {\n    token: char,\n    operation: fn(Number, Number) -> Number,\n    precedence: u8,\n    is_left_associative: bool,\n}\n\n#[derive(Debug, Clone, PartialEq)]\nenum Token {\n    Digit(Number),\n    Operator(Operator),\n    LeftParen,\n    RightParen,\n}\n\nimpl Operator {\n    fn new_token(\n        token: char,\n        precedence: u8,\n        is_left_associative: bool,\n        operation: fn(Number, Number) -> Number,\n    ) -> Token {\n        Token::Operator(Operator {\n            token: token,\n            operation: operation,\n            precedence: precedence,\n            is_left_associative,\n        })\n    }\n\n    fn apply(&self, x: Number, y: Number) -> Number {\n        (self.operation)(x, y)\n    }\n}\n\ntrait Stack<T> {\n    fn top(&self) -> Option<T>;\n}\n\nimpl<T: Clone> Stack<T> for Vec<T> {\n    fn top(&self) -> Option<T> {\n        if self.is_empty() {\n            return None;\n        }\n        self.get(self.len() - 1).map(|value| value.clone())\n    }\n}\nfn lex_token(input: char) -> Result<Token, char> {\n    match input {\n        '0'...'9' => Ok(Token::Digit(input.to_digit(10).unwrap() as Number)),\n        '+' => Ok(Operator::new_token('+', 1, true, |x, y| x + y)),\n        '-' => Ok(Operator::new_token('-', 1, true, |x, y| x - y)),\n        '*' => Ok(Operator::new_token('*', 2, true, |x, y| x * y)),\n        '/' => Ok(Operator::new_token('/', 2, true, |x, y| x / y)),\n        '^' => Ok(Operator::new_token('^', 3, false, |x, y| x.powf(y))),\n        '(' => Ok(Token::LeftParen),\n        ')' => Ok(Token::RightParen),\n        _ => Err(input),\n    }\n}\n\nfn lex(input: String) -> Result<Vec<Token>, char> {\n    input\n        .chars()\n        .filter(|c| !c.is_whitespace())\n        .map(lex_token)\n        .collect()\n}\n\nfn tilt_until(operators: &mut Vec<Token>, output: &mut Vec<Token>, stop: Token) -> bool {\n    while let Some(token) = operators.pop() {\n        if token == stop {\n            return true;\n        }\n        output.push(token)\n    }\n    false\n}\n\nfn shunting_yard(tokens: Vec<Token>) -> Result<Vec<Token>, String> {\n    let mut output: Vec<Token> = Vec::new();\n    let mut operators: Vec<Token> = Vec::new();\n\n    for token in tokens {\n        match token {\n            Token::Digit(_) => output.push(token),\n            Token::LeftParen => operators.push(token),\n            Token::Operator(operator) => {\n                while let Some(top) = operators.top() {\n                    match top {\n                        Token::LeftParen => break,\n                        Token::Operator(top_op) => {\n                            let p = top_op.precedence;\n                            let q = operator.precedence;\n                            if (p > q) || (p == q && operator.is_left_associative) {\n                                output.push(operators.pop().unwrap());\n                            } else {\n                                break;\n                            }\n                        }\n                        _ => unreachable!(\"{:?} must not be on operator stack\", token),\n                    }\n                }\n                operators.push(token);\n            }\n            Token::RightParen => {\n                if !tilt_until(&mut operators, &mut output, Token::LeftParen) {\n                    return Err(String::from(\"Mismatched ')'\"));\n                }\n            }\n        }\n    }\n\n    if tilt_until(&mut operators, &mut output, Token::LeftParen) {\n        return Err(String::from(\"Mismatched '('\"));\n    }\n\n    assert!(operators.is_empty());\n    Ok(output)\n}\n\nfn calculate(postfix_tokens: Vec<Token>) -> Result<Number, String> {\n    let mut stack = Vec::new();\n\n    for token in postfix_tokens {\n        match token {\n            Token::Digit(number) => stack.push(number),\n            Token::Operator(operator) => {\n                if let Some(y) = stack.pop() {\n                    if let Some(x) = stack.pop() {\n                        stack.push(operator.apply(x, y));\n                        continue;\n                    }\n                }\n                return Err(format!(\"Missing operand for operator '{}'\", operator.token));\n            }\n            _ => unreachable!(\"Unexpected token {:?} during calculation\", token),\n        }\n    }\n\n    assert!(stack.len() == 1);\n    Ok(stack.pop().unwrap())\n}\n\nfn run(input: String) -> Result<Number, String> {\n    let tokens = match lex(input) {\n        Ok(tokens) => tokens,\n        Err(c) => return Err(format!(\"Invalid character: {}\", c)),\n    };\n    let postfix_tokens = match shunting_yard(tokens) {\n        Ok(tokens) => tokens,\n        Err(message) => return Err(message),\n    };\n\n    calculate(postfix_tokens)\n}",
    "title": "Parsing/Shunting-yard algorithm",
    "url": "http://rosettacode.org/wiki/Parsing/Shunting-yard_algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Partial function application",
    "url": "http://rosettacode.org/wiki/Partial_function_application"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Partition an integer X into N primes",
    "url": "http://rosettacode.org/wiki/Partition_an_integer_X_into_N_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pascal matrix generation",
    "url": "http://rosettacode.org/wiki/Pascal_matrix_generation"
  },
  {
    "local_code": "fn pascaltriangle(rows: usize) -> Vec<Vec<usize>> {\n    let mut all_rows = Vec::with_capacity(rows);\n\n    for row in 0..rows {\n        let mut row_vals = Vec::with_capacity(row + 1);\n        let mut value = 1;\n\n        for col in 0..row + 1 {\n            row_vals.push(value);\n            value = value * (row - col) / (col + 1)\n        }\n\n        all_rows.push(row_vals);\n    }\n\n    all_rows\n}\n\nfn printpascal(rows: &[Vec<usize>]) {\n    let mut i = 0;\n    for row in rows.iter() {\n        for _ in 0..(rows.len() - i) {\n            print!(\" \");\n        }\n\n        for col in row.iter() {\n            print!(\"{} \", col);\n        }\n\n        println!();\n\n        i += 1;\n    }\n}\n\nfn main() {\n    printpascal(&pascaltriangle(5));\n}\n\n#[test]\nfn test_triangle() {\n    assert_eq!(\n        pascaltriangle(5),\n        vec![\n            vec![1],\n            vec![1, 1],\n            vec![1, 2, 1],\n            vec![1, 3, 3, 1],\n            vec![1, 4, 6, 4, 1],\n        ]\n    );\n}\n",
    "path": "tasks/pascals-triangle",
    "remote_code": "\nfn pascal_triangle(n: u64)\n{\n\n  for i in 0..n {\n    let mut c = 1;\n    for _j in 1..2*(n-1-i)+1 {\n      print!(\" \");\n    }\n    for k in 0..i+1 {\n      print!(\"{:2} \", c);\n      c = c * (i-k)/(k+1);\n    }\n    println!();\n  }\n}\n",
    "title": "Pascal's triangle",
    "url": "http://rosettacode.org/wiki/Pascal's_triangle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pascal's triangle/Puzzle",
    "url": "http://rosettacode.org/wiki/Pascal's_triangle/Puzzle"
  },
  {
    "local_code": "use std::process::Command;\n// files in tests/ directory are integration tests\n#[test]\n// add test to verify we cannot generate a password < 30 characters\nfn validate_password_length() {\n    let output = Command::new(\"cargo\")\n        .args(&[\"run\", \"--release\", \"--quiet\", \"0\"])\n        .output()\n        .expect(\"could not run cargo\");\n    let output = String::from_utf8_lossy(&output.stderr);\n    assert_eq!(\n        \"Please provide a password length greater than or equal to 30\",\n        output.trim()\n    );\n}\nuse rand::distributions::Alphanumeric;\nuse rand::prelude::IteratorRandom;\nuse rand::{thread_rng, Rng};\nuse std::iter;\nuse std::process;\nuse structopt::StructOpt;\nconst OTHER_VALUES: &str = \"!\\\"#$%&'()*+,-./:;<=>?@[]^_{|}~\";\n\n// the core logic that creates our password\nfn generate_password(length: u8) -> String {\n    // cache thread_rng for better performance\n    let mut rng = thread_rng();\n    // the Alphanumeric struct provides 3/4\n    // of the characters for passwords\n    // so we can sample from it\n    let mut base_password: Vec<char> = iter::repeat(())\n        .map(|()| rng.sample(Alphanumeric))\n        .take(length as usize)\n        .collect();\n    let mut end_range = 10;\n    // if the user supplies a password length less than 10\n    // we need to adjust the random sample range\n    if length < end_range {\n        end_range = length;\n    }\n    // create a random count of how many other characters to add\n    let mut to_add = rng.gen_range(1, end_range as usize);\n    loop {\n        // create an iterator of required other characters\n        let special = OTHER_VALUES.chars().choose(&mut rng).unwrap();\n        to_add -= 1;\n        base_password[to_add] = special;\n        if to_add == 0 {\n            break;\n        }\n    }\n    base_password.iter().collect()\n}\n\n#[derive(StructOpt, Debug)]\n#[structopt(name = \"password-generator\", about = \"A simple password generator.\")]\nstruct Opt {\n    // make it SECURE by default\n    // https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html\n    /// The password length\n    #[structopt(default_value = \"160\")]\n    length: u8,\n    /// How many passwords to generate\n    #[structopt(default_value = \"1\")]\n    count: u8,\n}\n\nfn main() {\n    // instantiate the options and use them as\n    // arguments to our password generator\n    let opt = Opt::from_args();\n    const MINIMUM_LENGTH: u8 = 30;\n    if opt.length < MINIMUM_LENGTH {\n        eprintln!(\n            \"Please provide a password length greater than or equal to {}\",\n            MINIMUM_LENGTH\n        );\n        process::exit(1);\n    }\n    for index in 0..opt.count {\n        let password = generate_password(opt.length);\n        // do not print a newline after the last password\n        match index + 1 == opt.count {\n            true => print!(\"{}\", password),\n            _ => println!(\"{}\", password),\n        };\n    }\n}\n\n// keep it within this file for convenience\n#[cfg(test)]\nmod tests {\n    use super::generate_password;\n    use super::OTHER_VALUES;\n\n    // test our core password logic according to the rules described in the wiki\n    #[test]\n    fn generate_password_customizes_length() {\n        let a_password = generate_password(50);\n        assert_eq!(a_password.len(), 50);\n    }\n\n    #[test]\n    fn generate_password_has_numerals() {\n        assert!(generate_password(50).chars().any(|c| c.is_ascii_digit()));\n    }\n\n    #[test]\n    fn generate_password_has_upper_and_lowercase_characters() {\n        let password = generate_password(50);\n        // the following line only prints when this test fails\n        // you can see it printed by running `cargo test -- --nocapture`\n        println!(\"{}\", password);\n        assert!(password.chars().any(|c| c.is_ascii_lowercase()));\n        assert!(generate_password(50)\n            .chars()\n            .any(|c| c.is_ascii_uppercase()));\n    }\n\n    #[test]\n    fn generate_password_has_other_characters() {\n        let password = generate_password(10);\n        println!(\"{}\", password);\n        assert!(password.chars().any(|c| OTHER_VALUES.contains(c)));\n    }\n}\n",
    "path": "tasks/password-generator",
    "remote_code": null,
    "title": "Password generator",
    "url": "http://rosettacode.org/wiki/Password_generator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pathological floating point problems",
    "url": "http://rosettacode.org/wiki/Pathological_floating_point_problems"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#![feature(box_patterns, box_syntax)]\nuse self::Color::*;\nuse std::cmp::Ordering::*;\n\nenum Color {R,B}\n\ntype Link<T> = Option<Box<N<T>>>;\nstruct N<T> {\n    c: Color,\n    l: Link<T>,\n    val: T,\n    r: Link<T>,\n}\n\n\nimpl<T: Ord> N<T> {\n    fn balance(col: Color, n1: Link<T>, z: T, n2: Link<T>) -> Link<T> {\n        Some(box \n             match (col,n1,n2) {\n                   (B, Some(box N {c: R, l: Some(box N {c: R, l: a, val: x, r: b}), val: y, r: c}), d)\n                |  (B, Some(box N {c: R, l: a, val: x, r: Some (box N {c: R, l: b, val: y, r: c})}), d)\n                => N {c: R, l: Some(box N {c: B, l: a, val: x, r: b}), val: y, r: Some(box N {c: B, l: c, val: z, r: d})},\n                   (B, a, Some(box N {c: R, l: Some(box N {c: R, l: b, val: y, r: c}), val: v, r: d}))\n                |  (B, a, Some(box N {c: R, l: b, val: y, r: Some(box N {c: R, l: c, val: v, r: d})}))\n                => N {c: R, l: Some(box N {c: B, l: a, val: z, r: b}), val: y, r: Some(box N {c: B, l: c, val: v, r: d})},\n                (col, a, b) => N {c: col, l: a, val: z, r: b},\n        })\n    }\n    fn insert(x: T, n: Link<T>) -> Link<T> {\n        match n {\n            None => Some(box N { c: R, l: None, val: x, r: None }),\n            Some(n) =>  {\n                let n = *n;\n                let N {c: col, l: a, val: y, r: b} = n;\n                match x.cmp(&y) {\n                    Greater => Self::balance(col, a,y,Self::insert(x,b)),\n                    Less    => Self::balance(col, Self::insert(x,a),y,b),\n                    Equal   => Some(box N {c: col, l: a, val: y, r: b})\n                }\n            }\n        }\n    }\n}",
    "title": "Pattern matching",
    "url": "http://rosettacode.org/wiki/Pattern_matching"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Peaceful chess queen armies",
    "url": "http://rosettacode.org/wiki/Peaceful_chess_queen_armies"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Peano curve",
    "url": "http://rosettacode.org/wiki/Peano_curve"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pell's equation",
    "url": "http://rosettacode.org/wiki/Pell's_equation"
  },
  {
    "local_code": "extern crate rand;\n\nuse std::io::{stdin, stdout, Write};\nuse std::thread;\nuse std::time::Duration;\n\nuse rand::Rng;\n\nfn toss_coin<R: Rng>(rng: &mut R, print: bool) -> char {\n    let c = if rng.gen() { 'H' } else { 'T' };\n    if print {\n        print!(\"{}\", c);\n        stdout().flush().expect(\"Could not flush stdout\");\n    }\n    c\n}\n\nfn gen_sequence<R: Rng>(rng: &mut R, seed: Option<&str>) -> String {\n    let mut seq = String::new();\n    match seed {\n        Some(s) => {\n            let mut iter = s.chars();\n            let c0 = iter.next().unwrap();\n            let next = if c0 == 'H' { 'T' } else { 'H' };\n            seq.push(next);\n            seq.push(c0);\n            seq.push(iter.next().unwrap());\n        }\n        None => {\n            for _ in 0..3 {\n                seq.push(toss_coin(rng, false))\n            }\n        }\n    }\n    seq\n}\n\nfn read_sequence(used_seq: Option<&str>) -> String {\n    let mut seq = String::new();\n    loop {\n        seq.clear();\n        println!(\"Please, enter sequence of 3 coins: H (heads) or T (tails): \");\n        stdin().read_line(&mut seq).expect(\"failed to read line\");\n        seq = seq.trim().to_uppercase();\n        // do the cheapest test first\n        if seq.len() == 3\n            && seq.chars().all(|c| c == 'H' || c == 'T')\n            && seq != used_seq.unwrap_or(\"\")\n        {\n            return seq;\n        }\n\n        println!(\"Please enter correct sequence!\");\n    }\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n\n    println!(\"--Penney's game--\");\n    loop {\n        let useq: String;\n        let aiseq: String;\n        if rng.gen::<bool>() {\n            println!(\"You choose first!\");\n            useq = read_sequence(None);\n            println!(\"Your sequence: {}\", useq);\n            aiseq = gen_sequence(&mut rng, Some(&useq));\n            println!(\"My sequence: {}\", aiseq);\n        } else {\n            println!(\"I choose first!\");\n            aiseq = gen_sequence(&mut rng, None);\n            println!(\"My sequence: {}\", aiseq);\n            useq = read_sequence(Some(&aiseq));\n            println!(\"Your sequence: {}\", useq);\n        }\n        println!(\"Tossing coins...\");\n        let mut coins = String::new();\n        for _ in 0..2 {\n            // toss first 2 coins\n            coins.push(toss_coin(&mut rng, true));\n            thread::sleep(Duration::from_millis(500));\n        }\n        loop {\n            coins.push(toss_coin(&mut rng, true));\n            thread::sleep(Duration::from_millis(500));\n            if coins.contains(&useq) {\n                println!(\"\\nYou win!\");\n                break;\n            }\n            if coins.contains(&aiseq) {\n                println!(\"\\nI win!\");\n                break;\n            }\n        }\n\n        println!(\" Play again? 'Y' to play, 'Q' to exit.\");\n        let mut input = String::new();\n        stdin().read_line(&mut input).expect(\"failed to read line\");\n        match input.trim_start().chars().next().unwrap() {\n            'Y' | 'y' => continue,\n            _ => break,\n        }\n    }\n}\n",
    "path": "tasks/penneys-game",
    "remote_code": null,
    "title": "Penney's game",
    "url": "http://rosettacode.org/wiki/Penney's_game"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pentagram",
    "url": "http://rosettacode.org/wiki/Pentagram"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate image;\n\nuse image::{GenericImageView, Rgba};\n\nfn diff_rgba3(rgba1 : Rgba<u8>, rgba2 : Rgba<u8>) -> i32 {\n    (rgba1[0] as i32 - rgba2[0] as i32).abs()\n    + (rgba1[1] as i32 - rgba2[1] as i32).abs()\n    + (rgba1[2] as i32 - rgba2[2] as i32).abs()\n}\n\nfn main() {\n    let img1 = image::open(\"Lenna100.jpg\").unwrap();\n    let img2 = image::open(\"Lenna50.jpg\").unwrap();\n    let mut accum = 0;\n    let zipper = img1.pixels().zip(img2.pixels());\n    for (pixel1, pixel2) in zipper {\n        accum += diff_rgba3(pixel1.2, pixel2.2);\n    }\n    println!(\"Percent difference {}\", accum as f64 * 100.0/ (255.0 * 3.0 * (img1.width() * img1.height()) as f64));\n}",
    "title": "Percentage difference between images",
    "url": "http://rosettacode.org/wiki/Percentage_difference_between_images"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Percolation/Bond percolation",
    "url": "http://rosettacode.org/wiki/Percolation/Bond_percolation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Percolation/Mean cluster density",
    "url": "http://rosettacode.org/wiki/Percolation/Mean_cluster_density"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Percolation/Mean run density",
    "url": "http://rosettacode.org/wiki/Percolation/Mean_run_density"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Percolation/Site percolation",
    "url": "http://rosettacode.org/wiki/Percolation/Site_percolation"
  },
  {
    "local_code": "fn perfect_number(n: usize) -> bool {\n    (1..(n / 2) + 1)\n        .filter(|&i| n % i == 0)\n        .fold(0, |a, b| a + b)\n        == n\n}\n\nfn main() {\n    for n in (2..10_000).filter(|&n| perfect_number(n)) {\n        println!(\"{}\", n);\n    }\n}\n\n#[test]\nfn test_first_four() {\n    let nums = (2..10_000)\n        .filter(|&n| perfect_number(n))\n        .collect::<Vec<usize>>();\n    assert_eq!(nums, [6, 28, 496, 8128]);\n}\n\n#[test]\nfn test_high_number() {\n    assert!(perfect_number(33550336));\n}\n",
    "path": "tasks/perfect-numbers",
    "remote_code": "\nfn main ( ) {\n\tfn factor_sum(n: i32) -> i32 {\n\t    let mut v = Vec::new(); //create new empty array\n\t    for  x in 1..n-1 {      //test vaules 1 to n-1\n\t    \tif n%x == 0 {   //if current x is a factor of n\n\t    \t\tv.push(x);      //add x to the array\n\t    \t}\n\t    }\n    let mut sum = v.iter().sum(); //iterate over array and sum it up \n    return sum;\n    }\n    \n    fn perfect_nums(n: i32) {\n    \tfor x in 2..n {       //test numbers from 1-n\n    \t\tif factor_sum(x) == x {//call factor_sum on each value of x, if return value is = x\n    \t\t\tprintln!(\"{} is a perfect number.\", x); //print value of x \n    \t\t}\n    \t}\n    }\n    perfect_nums(10000);\n}\n",
    "title": "Perfect numbers",
    "url": "http://rosettacode.org/wiki/Perfect_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Perfect shuffle",
    "url": "http://rosettacode.org/wiki/Perfect_shuffle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Perfect totient numbers",
    "url": "http://rosettacode.org/wiki/Perfect_totient_numbers"
  },
  {
    "local_code": "fn main() {\n    let treatment = vec![85, 88, 75, 66, 25, 29, 83, 39, 97];\n    let control = vec![68, 41, 10, 49, 16, 65, 32, 92, 28, 98];\n\n    let mut data_set = control.clone();\n    data_set.extend_from_slice(&treatment);\n\n    let greater = combinations(treatment.iter().sum(), treatment.len() as i64, &data_set) as f64;\n    let lesser = combinations(control.iter().sum(), control.len() as i64, &data_set) as f64;\n    let total = binomial(data_set.len() as i64, treatment.len() as i64) as f64;\n\n    println!(\"<= : {}%\", (lesser / total * 100.0));\n    println!(\" > : {}%\", (greater / total * 100.0));\n}\n\nfn factorial(x: i64) -> i64 {\n    let mut product = 1;\n    for a in 1..(x + 1) {\n        product = product * a;\n    }\n    product\n}\n\nfn binomial(n: i64, k: i64) -> i64 {\n    let numerator = factorial(n);\n    let denominator = factorial(k) * factorial(n - k);\n    numerator / denominator\n}\n\nfn combinations(total: i64, number: i64, data: &[i64]) -> i64 {\n    if total < 0 {\n        return binomial(data.len() as i64, number);\n    }\n\n    if number == 0 {\n        return 0;\n    }\n\n    if number > data.len() as i64 {\n        return 0;\n    }\n\n    if number == data.len() as i64 {\n        if total < data.iter().sum() {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    let tail = &data[1..];\n    return combinations(total - data[0], number - 1, &tail) + combinations(total, number, &tail);\n}\n\n#[cfg(test)]\nmod test {\n    use self::super::*;\n\n    #[test]\n    fn test_factorial() {\n        assert_eq!(factorial(5), 120);\n        assert_eq!(factorial(8), 40320);\n    }\n\n    #[test]\n    //Test 64-bit values\n    fn test_large_factorial() {\n        assert_eq!(factorial(13), 6227020800);\n        assert_eq!(factorial(20), 2432902008176640000);\n    }\n\n    #[test]\n    fn test_binomial() {\n        assert_eq!(binomial(4, 3), 4);\n        assert_eq!(binomial(8, 5), 56);\n        assert_eq!(binomial(10, 7), 120);\n    }\n\n    #[test]\n    //Test 64-bit values\n    fn test_large_binomial() {\n        assert_eq!(binomial(12, 5), 792);\n        assert_eq!(binomial(15, 5), 3003);\n        assert_eq!(binomial(18, 3), 816);\n    }\n}\n",
    "path": "tasks/permutation-test",
    "remote_code": null,
    "title": "Permutation test",
    "url": "http://rosettacode.org/wiki/Permutation_test"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "pub fn permutations(size: usize) -> Permutations {\n    Permutations { idxs: (0..size).collect(), swaps: vec![0; size], i: 0 }\n}\n\npub struct Permutations {\n    idxs: Vec<usize>,\n    swaps: Vec<usize>,\n    i: usize,\n}\n\nimpl Iterator for Permutations {\n    type Item = Vec<usize>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.i > 0 {\n            loop {\n                if self.i >= self.swaps.len() { return None; }\n                if self.swaps[self.i] < self.i { break; }\n                self.swaps[self.i] = 0;\n                self.i += 1;\n            }\n            self.idxs.swap(self.i, (self.i & 1) * self.swaps[self.i]);\n            self.swaps[self.i] += 1;\n        }\n        self.i = 1;\n        Some(self.idxs.clone())\n    }\n}\n\nfn main() {\n    let perms = permutations(3).collect::<Vec<_>>();\n    assert_eq!(perms, vec![\n        vec![0, 1, 2],\n        vec![1, 0, 2],\n        vec![2, 0, 1],\n        vec![0, 2, 1],\n        vec![1, 2, 0],\n        vec![2, 1, 0],\n    ]);\n}",
    "title": "Permutations",
    "url": "http://rosettacode.org/wiki/Permutations"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Permutations by swapping",
    "url": "http://rosettacode.org/wiki/Permutations_by_swapping"
  },
  {
    "local_code": "struct PermutationIterator<'a, T: 'a> {\n    universe: &'a [T],\n    size: usize,\n    prev: Option<Vec<usize>>,\n}\n\nfn permutations<T>(universe: &[T], size: usize) -> PermutationIterator<T> {\n    PermutationIterator {\n        universe: universe,\n        size: size,\n        prev: None,\n    }\n}\n\nfn map<T>(values: &[T], ixs: &[usize]) -> Vec<T>\nwhere\n    T: Clone,\n{\n    ixs.iter().map(|&i| values[i].clone()).collect()\n}\n\nimpl<'a, T> Iterator for PermutationIterator<'a, T>\nwhere\n    T: Clone,\n{\n    type Item = Vec<T>;\n\n    fn next(&mut self) -> Option<Vec<T>> {\n        let n = self.universe.len();\n\n        if n == 0 {\n            return None;\n        }\n\n        match self.prev {\n            None => {\n                let zeroes: Vec<usize> = std::iter::repeat(0).take(self.size).collect();\n                let result = Some(map(self.universe, &zeroes[..]));\n                self.prev = Some(zeroes);\n                result\n            }\n            Some(ref mut indexes) => match indexes.iter().position(|&i| i + 1 < n) {\n                None => None,\n                Some(position) => {\n                    for index in indexes.iter_mut().take(position) {\n                        *index = 0;\n                    }\n                    indexes[position] += 1;\n                    Some(map(self.universe, &indexes[..]))\n                }\n            },\n        }\n    }\n}\n\nfn main() {\n    let universe = [\"Annie\", \"Barbie\"];\n    for p in permutations(&universe[..], 3) {\n        for element in &p {\n            print!(\"{} \", element);\n        }\n        println!();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::permutations;\n\n    #[test]\n    fn test_len() {\n        let universe = [1, 132, 323];\n        assert!(permutations(&universe[..], 4).count() == 81);\n    }\n}\n",
    "path": "tasks/permutations-with-repetitions",
    "remote_code": null,
    "title": "Permutations with repetitions",
    "url": "http://rosettacode.org/wiki/Permutations_with_repetitions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Permutations/Derangements",
    "url": "http://rosettacode.org/wiki/Permutations/Derangements"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Permutations/Rank of a permutation",
    "url": "http://rosettacode.org/wiki/Permutations/Rank_of_a_permutation"
  },
  {
    "local_code": "extern crate aks_test_for_primes;\n\nuse std::iter::Filter;\nuse std::ops::RangeFrom;\n\nuse aks_test_for_primes::is_prime;\n\nfn main() {\n    for i in pernicious().take(25) {\n        print!(\"{} \", i);\n    }\n    println!();\n    for i in (888_888_877u64..888_888_888).filter(is_pernicious) {\n        print!(\"{} \", i);\n    }\n}\n\nfn pernicious() -> Filter<RangeFrom<u64>, fn(&u64) -> bool> {\n    (0u64..).filter(is_pernicious as fn(&u64) -> bool)\n}\n\nfn is_pernicious(n: &u64) -> bool {\n    is_prime(n.count_ones())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{is_pernicious, pernicious};\n\n    #[test]\n    fn pernicious_iter() {\n        let exp = &[\n            3u64, 5, 6, 7, 9, 10, 11, 12, 13, 14, 17, 18, 19, 20, 21, 22, 24, 25, 26, 28, 31, 33,\n            34, 35, 36,\n        ];\n        for (act, &exp) in pernicious().take(30).zip(exp.iter()) {\n            assert_eq!(act, exp);\n        }\n    }\n\n    #[test]\n    fn is_pernicious_range() {\n        let exp = &[\n            888888877u64,\n            888888878,\n            888888880,\n            888888883,\n            888888885,\n            888888886,\n        ];\n        for (act, &exp) in (888_888_877u64..888_888_888)\n            .filter(is_pernicious)\n            .zip(exp.iter())\n        {\n            assert_eq!(act, exp);\n        }\n    }\n}\n",
    "path": "tasks/pernicious-numbers",
    "remote_code": null,
    "title": "Pernicious numbers",
    "url": "http://rosettacode.org/wiki/Pernicious_numbers"
  },
  {
    "local_code": "fn reverse_string(string: &str) -> String {\n    string.chars().rev().collect::<String>()\n}\n\nfn reverse_words(string: &str) -> String {\n    string\n        .split_whitespace()\n        .map(|x| x.chars().rev().collect::<String>())\n        .collect::<Vec<String>>()\n        .join(\" \")\n}\n\nfn reverse_word_order(string: &str) -> String {\n    string\n        .split_whitespace()\n        .rev()\n        .collect::<Vec<&str>>()\n        .join(\" \")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_reverse_string() {\n        let string = \"rosetta code phrase reversal\";\n        assert_eq!(\n            reverse_string(string.clone()),\n            \"lasrever esarhp edoc attesor\"\n        );\n    }\n\n    #[test]\n    fn test_reverse_words() {\n        let string = \"rosetta code phrase reversal\";\n        assert_eq!(\n            reverse_words(string.clone()),\n            \"attesor edoc esarhp lasrever\"\n        );\n    }\n\n    #[test]\n    fn test_reverse_word_order() {\n        let string = \"rosetta code phrase reversal\";\n        assert_eq!(\n            reverse_word_order(string.clone()),\n            \"reversal phrase code rosetta\"\n        );\n    }\n}\n",
    "path": "tasks/phrase-reversals",
    "remote_code": "fn reverse_string(string: &str) -> String {\n    string.chars().rev().collect::<String>()\n}\n\nfn reverse_words(string: &str) -> String {\n    string\n        .split_whitespace()\n        .map(|x| x.chars().rev().collect::<String>())\n        .collect::<Vec<String>>()\n        .join(\" \")\n}\n\nfn reverse_word_order(string: &str) -> String {\n    string\n        .split_whitespace()\n        .rev()\n        .collect::<Vec<&str>>()\n        .join(\" \")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_reverse_string() {\n        let string = \"rosetta code phrase reversal\";\n        assert_eq!(\n            reverse_string(string.clone()),\n            \"lasrever esarhp edoc attesor\"\n        );\n    }\n\n    #[test]\n    fn test_reverse_words() {\n        let string = \"rosetta code phrase reversal\";\n        assert_eq!(\n            reverse_words(string.clone()),\n            \"attesor edoc esarhp lasrever\"\n        );\n    }\n\n    #[test]\n    fn test_reverse_word_order() {\n        let string = \"rosetta code phrase reversal\";\n        assert_eq!(\n            reverse_word_order(string.clone()),\n            \"reversal phrase code rosetta\"\n        );\n    }\n}\n",
    "title": "Phrase reversals",
    "url": "http://rosettacode.org/wiki/Phrase_reversals"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pi",
    "url": "http://rosettacode.org/wiki/Pi"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::{thread_rng, Rng};\n\nfn pick_random_e(a: &[u8]) -> u8 {\n    // thread-local random number generator\n    let mut rng = thread_rng();\n\n    let ri = rng.gen_range(0, a.len());\n\n    a[ri]\n}\n\nfn main() {\n    let xs: [u8; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    println!(\"{}\", pick_random_e(&xs));\n}\n\n#[test]\nfn test_pick_random_e() {\n    let xs: [u8; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    let picked = pick_random_e(&xs);\n\n    assert!(xs.contains(&picked));\n}\n",
    "path": "tasks/pick-random-element",
    "remote_code": "extern crate rand;\n\nuse rand::Rng;\n\nfn main() {\n    let array = [5,1,2,5,6,7,8,1,2,4,5];\n    let mut rng = rand::thread_rng();\n    \n    println!(\"{}\", rng.choose(&array).unwrap());\n}",
    "title": "Pick random element",
    "url": "http://rosettacode.org/wiki/Pick_random_element"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pierpont primes",
    "url": "http://rosettacode.org/wiki/Pierpont_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pig the dice game",
    "url": "http://rosettacode.org/wiki/Pig_the_dice_game"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pig the dice game/Player",
    "url": "http://rosettacode.org/wiki/Pig_the_dice_game/Player"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pinstripe/Display",
    "url": "http://rosettacode.org/wiki/Pinstripe/Display"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pinstripe/Printer",
    "url": "http://rosettacode.org/wiki/Pinstripe/Printer"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Plasma effect",
    "url": "http://rosettacode.org/wiki/Plasma_effect"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Play recorded sounds",
    "url": "http://rosettacode.org/wiki/Play_recorded_sounds"
  },
  {
    "local_code": "extern crate rand;\n\nuse std::fmt;\n\nuse rand::prelude::*;\n\nuse Pip::*;\nuse Suit::*;\n\n#[derive(Copy, Clone, Debug)]\nenum Pip {\n    Ace,\n    Two,\n    Three,\n    Four,\n    Five,\n    Six,\n    Seven,\n    Eight,\n    Nine,\n    Ten,\n    Jack,\n    Queen,\n    King,\n}\nstatic PIPS: [Pip; 13] = [\n    Ace, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King,\n];\n\n#[derive(Copy, Clone, Debug)]\nenum Suit {\n    Spades,\n    Hearts,\n    Diamonds,\n    Clubs,\n}\nstatic SUITS: [Suit; 4] = [Spades, Hearts, Diamonds, Clubs];\n\nstruct Card {\n    pip: Pip,\n    suit: Suit,\n}\n\nimpl fmt::Display for Card {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{:?} of {:?}\", self.pip, self.suit)\n    }\n}\n\nstruct Deck(Vec<Card>);\n\nimpl Deck {\n    fn new() -> Deck {\n        let mut cards: Vec<Card> = Vec::with_capacity(52);\n        for &suit in &SUITS {\n            for &pip in &PIPS {\n                cards.push(Card { pip, suit });\n            }\n        }\n        Deck(cards)\n    }\n\n    fn deal(&mut self) -> Option<Card> {\n        self.0.pop()\n    }\n\n    fn shuffle(&mut self) {\n        self.0.shuffle(&mut thread_rng());\n    }\n}\n\nimpl Default for Deck {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl fmt::Display for Deck {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for card in &self.0 {\n            writeln!(f, \"{}\", card)?;\n        }\n        Ok(())\n    }\n}\n\nfn main() {\n    let mut deck = Deck::new();\n    deck.shuffle();\n    for _ in 0..5 {\n        println!(\"{}\", deck.deal().unwrap());\n    }\n}\n",
    "path": "tasks/playing-cards",
    "remote_code": "extern crate rand;\n\nuse std::fmt;\nuse rand::Rng;\nuse Pip::*;\nuse Suit::*;\n\n#[derive(Copy, Clone, Debug)]\nenum Pip { Ace, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King }\n\n#[derive(Copy, Clone, Debug)]\nenum Suit { Spades, Hearts, Diamonds, Clubs }\n\nstruct Card {\n\tpip: Pip,\n\tsuit: Suit\n}\n\nimpl fmt::Display for Card {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{:?} of {:?}\", self.pip, self.suit)\n    }\n}\n\nstruct Deck(Vec<Card>);\n\nimpl Deck {\n    fn new() -> Deck {\n        let mut cards:Vec<Card> = Vec::with_capacity(52);\n        for &suit in &[Spades, Hearts, Diamonds, Clubs] {\n            for &pip in &[Ace, Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King] {\n                cards.push( Card{pip: pip, suit: suit} );\n            }\n        }\n        Deck(cards)\n    }\n\n    fn deal(&mut self) -> Option<Card> {\n        self.0.pop()\n    }\n\n    fn shuffle(&mut self) {\n        rand::thread_rng().shuffle(&mut self.0)\n    }\n}\n\nimpl fmt::Display for Deck {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for card in self.0.iter() {\n            writeln!(f, \"{}\", card);\n        }\n        write!(f, \"\")\n    }\n}\n\nfn main() {\n    let mut deck = Deck::new();\n    deck.shuffle();\n    //println!(\"{}\", deck);\n    for _ in 0..5 {\n        println!(\"{}\", deck.deal().unwrap());\n    }\n}",
    "title": "Playing cards",
    "url": "http://rosettacode.org/wiki/Playing_cards"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Plot coordinate pairs",
    "url": "http://rosettacode.org/wiki/Plot_coordinate_pairs"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pointers and references",
    "url": "http://rosettacode.org/wiki/Pointers_and_references"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Poker hand analyser",
    "url": "http://rosettacode.org/wiki/Poker_hand_analyser"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Polymorphic copy",
    "url": "http://rosettacode.org/wiki/Polymorphic_copy"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Polymorphism",
    "url": "http://rosettacode.org/wiki/Polymorphism"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Polynomial long division",
    "url": "http://rosettacode.org/wiki/Polynomial_long_division"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Polynomial regression",
    "url": "http://rosettacode.org/wiki/Polynomial_regression"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Polyspiral",
    "url": "http://rosettacode.org/wiki/Polyspiral"
  },
  {
    "local_code": "use std::iter::{Filter, Map};\nuse std::ops::RangeFrom;\n\nfn main() {\n    fn print_30<T: Iterator<Item = u32>>(it: T) {\n        for i in it.take(30) {\n            print!(\"{} \", i);\n        }\n    }\n\n    println!(\"Pow. of 3\");\n    print_30(pow_3());\n\n    println!(\"\\nEvil\");\n    print_30(evil());\n\n    println!(\"\\nOdious\");\n    print_30(odious());\n}\n\ntype EvilOdiousIter = Filter<RangeFrom<u32>, fn(&u32) -> bool>;\n\nfn even_ones(i: &u32) -> bool {\n    i.count_ones() % 2 == 0\n}\n\nfn odious() -> EvilOdiousIter {\n    fn odds(n: &u32) -> bool {\n        !even_ones(n)\n    }\n    (0..).filter(odds as fn(&u32) -> bool)\n}\n\nfn evil() -> EvilOdiousIter {\n    (0..).filter(even_ones as fn(&u32) -> bool)\n}\n\nfn pow_3() -> Map<RangeFrom<u32>, fn(u32) -> u32> {\n    fn pw(n: u32) -> u32 {\n        3u64.pow(n).count_ones()\n    }\n\n    (0..).map(pw as fn(u32) -> u32)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{evil, odious, pow_3};\n    #[test]\n    fn test_odious() {\n        let exp = vec![\n            1, 2, 4, 7, 8, 11, 13, 14, 16, 19, 21, 22, 25, 26, 28, 31, 32, 35, 37, 38, 41, 42, 44,\n            47, 49, 50, 52, 55, 56, 59,\n        ];\n        let act = odious().take(30).collect::<Vec<u32>>();\n        assert_eq!(act, exp);\n    }\n\n    #[test]\n    fn test_evil() {\n        let exp = vec![\n            0, 3, 5, 6, 9, 10, 12, 15, 17, 18, 20, 23, 24, 27, 29, 30, 33, 34, 36, 39, 40, 43, 45,\n            46, 48, 51, 53, 54, 57, 58,\n        ];\n        let act = evil().take(30).collect::<Vec<u32>>();\n        assert_eq!(act, exp);\n    }\n\n    #[test]\n    fn test_pow_3() {\n        let exp = vec![\n            1, 2, 2, 4, 3, 6, 6, 5, 6, 8, 9, 13, 10, 11, 14, 15, 11, 14, 14, 17, 17, 20, 19, 22,\n            16, 18, 24, 30, 25, 25,\n        ];\n        let act = pow_3().take(30).collect::<Vec<u32>>();\n        assert_eq!(act, exp);\n    }\n}\n",
    "path": "tasks/population-count",
    "remote_code": null,
    "title": "Population count",
    "url": "http://rosettacode.org/wiki/Population_count"
  },
  {
    "local_code": "//! Given a set, generate its power set, which is the set of all subsets of that set.\n\nuse std::slice::Iter;\nuse std::vec::Vec;\n\n// If set == {}\n//   return {{}}\n// else if set == {a} U rest\n//   return power_set(rest) U ({a} U each set in power_set(rest))\nfn power_set<T>(items: &mut Iter<T>) -> Vec<Vec<T>>\nwhere\n    T: Clone,\n{\n    let mut power = Vec::new();\n    match items.next() {\n        None => power.push(Vec::new()),\n        Some(item) => {\n            for mut set in power_set(items) {\n                power.push(set.clone());\n                set.push(item.clone());\n                power.push(set);\n            }\n        }\n    }\n    power\n}\n\n#[test]\nfn test() {\n    let set = Vec::<i32>::new();\n    let power = power_set(&mut set.iter());\n    assert!(power == vec![vec![]]);\n\n    let mut set = Vec::<i32>::new();\n    set.push(1);\n    set.push(2);\n    set.push(3);\n    let power = power_set(&mut set.iter());\n    assert!(\n        power\n            == vec![\n                vec![],\n                vec![1],\n                vec![2],\n                vec![2, 1],\n                vec![3],\n                vec![3, 1],\n                vec![3, 2],\n                vec![3, 2, 1],\n            ]\n    );\n}\n\nfn main() {\n    let mut set = Vec::<i32>::new();\n    set.push(1);\n    set.push(2);\n    set.push(3);\n    set.push(4);\n    let power = power_set(&mut set.iter());\n    println!(\"Set      : {:?}\", set);\n    println!(\"Power Set: {:?}\", power);\n}\n",
    "path": "tasks/power-set",
    "remote_code": null,
    "title": "Power set",
    "url": "http://rosettacode.org/wiki/Power_set"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pragmatic directives",
    "url": "http://rosettacode.org/wiki/Pragmatic_directives"
  },
  {
    "local_code": "fn fix_price(num: f64) -> f64 {\n    let cents = (num.fract() * 100_f64) as u16;\n\n    match cents {\n        96..=100 => 1.00,\n        91..=95 => 0.98,\n        86..=90 => 0.94,\n        81..=85 => 0.90,\n        76..=80 => 0.86,\n        71..=75 => 0.82,\n        66..=70 => 0.78,\n        61..=65 => 0.74,\n        56..=60 => 0.70,\n        51..=55 => 0.66,\n        46..=50 => 0.62,\n        41..=45 => 0.58,\n        36..=40 => 0.54,\n        31..=35 => 0.50,\n        26..=30 => 0.44,\n        21..=25 => 0.38,\n        16..=20 => 0.32,\n        11..=15 => 0.26,\n        6..=10 => 0.18,\n        0..=5 => 0.10,\n        // panics on invalid value\n        _ => panic!(\"price out of range\"),\n    }\n}\n\nfn main() {\n    let mut n: f64 = 0.04;\n    while n <= 1.00 {\n        println!(\"{:.2} => {:.2}\", n, fix_price(n));\n        n += 0.04;\n    }\n}\n\n// typically this could be included in the match as those check for exhaustiveness already\n// by explicitly listing all remaining ranges / values instead of a catch-all underscore (_)\n// but f64::NaN, f64::INFINITY and f64::NEG_INFINITY can't be matched like this\n#[test]\nfn exhaustiveness_check() {\n    let mut input_price = 0.;\n    while input_price <= 1. {\n        fix_price(input_price);\n        input_price += 0.01;\n    }\n}\n",
    "path": "tasks/price-fraction",
    "remote_code": "fn fix_price(num: f64) -> f64 {\n    match num {\n        0.96...1.00 => 1.00,\n        0.91...0.96 => 0.98,\n        0.86...0.91 => 0.94,\n        0.81...0.86 => 0.90,\n        0.76...0.81 => 0.86,\n        0.71...0.76 => 0.82,\n        0.66...0.71 => 0.78,\n        0.61...0.66 => 0.74,\n        0.56...0.61 => 0.70,\n        0.51...0.56 => 0.66,\n        0.46...0.51 => 0.62,\n        0.41...0.46 => 0.58,\n        0.36...0.41 => 0.54,\n        0.31...0.36 => 0.50,\n        0.26...0.31 => 0.44,\n        0.21...0.26 => 0.38,\n        0.16...0.21 => 0.32,\n        0.11...0.16 => 0.26,\n        0.06...0.11 => 0.18,\n        0.00...0.06 => 0.10,\n        // panics on invalid value\n        _ => unreachable!(),\n    }\n}\n\nfn main() {\n    let mut n: f64 = 0.04;\n    while n <= 1.00 {\n        println!(\"{:.2} => {}\", n, fix_price(n));\n        n += 0.04;\n    }\n}\n\n// and a unit test to check that we haven't forgotten a branch, use 'cargo test' to execute test.\n//\n// typically this could be included in the match as those check for exhaustiveness already\n// by explicitly listing all remaining ranges / values instead of a catch-all underscore (_)\n// but f64::NaN, f64::INFINITY and f64::NEG_INFINITY can't be matched like this\n#[test]\nfn exhaustiveness_check() {\n    let mut input_price = 0.;\n    while input_price <= 1. {\n        fix_price(input_price);\n        input_price += 0.01;\n    }\n}",
    "title": "Price fraction",
    "url": "http://rosettacode.org/wiki/Price_fraction"
  },
  {
    "local_code": "fn is_prime(number: i32) -> bool {\n    if number % 2 == 0 && number != 2 || number == 1 {\n        return false;\n    }\n\n    let limit = (number as f32).sqrt() as i32 + 1;\n\n    // We test if the number is divisible by any odd number up to the limit\n    (3..limit).step_by(2).all(|x| number % x != 0)\n}\n\nfn main() {\n    println!(\"{}\", is_prime(15_485_863)); // The 1 000 000th prime.\n    println!(\"{}\", is_prime(62_773_913)); // The product of the 1000th and 1001st primes.\n}\n\n#[test]\nfn test_one() {\n    // https://primes.utm.edu/notes/faq/one.html\n    assert!(!is_prime(1));\n}\n\n#[test]\nfn test_two() {\n    assert!(is_prime(2));\n}\n\n#[test]\nfn test_many() {\n    let primes = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31];\n    assert!(primes.iter().all(|&x| is_prime(x)));\n}\n",
    "path": "tasks/primality-by-trial-division",
    "remote_code": "fn is_prime(n: u64) -> bool {\n    match n {\n        0 | 1 => false,\n        2 => true,\n        _even if n % 2 == 0 => false,\n        _ => {\n            let sqrt_limit = (n as f64).sqrt() as u64;\n            (3..=sqrt_limit).step_by(2).find(|i| n % i == 0).is_none()\n        }\n    }\n}\n\nfn main() {\n    for i in (1..30).filter(|i| is_prime(*i)) {\n        println!(\"{} \", i);\n    }\n}",
    "title": "Primality by trial division",
    "url": "http://rosettacode.org/wiki/Primality_by_trial_division"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Prime conspiracy",
    "url": "http://rosettacode.org/wiki/Prime_conspiracy"
  },
  {
    "local_code": "extern crate prime_decomposition;\n\nuse prime_decomposition::factor;\n\nfn main() {\n    println!(\"Factors of 5: {:?}\", factor(5));\n    println!(\"Factors of 15: {:?}\", factor(15));\n    println!(\"Factors of 16: {:?}\", factor(16));\n    println!(\"Factors of 10287: {:?}\", factor(10_287));\n}\npub fn factor(mut nb: usize) -> Vec<usize> {\n    let mut result = vec![];\n\n    // First we take out all even factors.\n    while nb % 2 == 0 {\n        result.push(2);\n        nb /= 2;\n    }\n\n    // Then (if any left) we take out the odd ones.\n    let mut cand = 3;\n    let mut max_bound = (nb as f32).sqrt() as usize + 1;\n\n    while cand <= max_bound {\n        while nb % cand == 0 {\n            result.push(cand);\n            nb /= cand;\n        }\n        max_bound = (nb as f32).sqrt() as usize + 1;\n        cand += 2;\n    }\n\n    if nb > 1 {\n        result.push(nb);\n    }\n\n    result\n}\n#[test]\nfn test_basic() {\n    assert!(factor(5) == vec![5]);\n    assert!(factor(15) == vec![3, 5]);\n    assert!(factor(16) == vec![2, 2, 2, 2]);\n    assert!(factor(10287) == vec![3, 3, 3, 3, 127]);\n}\n",
    "path": "tasks/prime-decomposition",
    "remote_code": null,
    "title": "Prime decomposition",
    "url": "http://rosettacode.org/wiki/Prime_decomposition"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Primes - allocate descendants to their ancestors",
    "url": "http://rosettacode.org/wiki/Primes_-_allocate_descendants_to_their_ancestors"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Primorial numbers",
    "url": "http://rosettacode.org/wiki/Primorial_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::collections::BinaryHeap;\nuse std::cmp::Ordering;\nuse std::borrow::Cow;\n\n#[derive(Eq, PartialEq)]\nstruct Item<'a> {\n    priority: usize,\n    task: Cow<'a, str>, // Takes either borrowed or owned string\n}\n\nimpl<'a> Item<'a> {\n    fn new<T>(p: usize, t: T) -> Self\n        where T: Into<Cow<'a, str>>\n    {\n        Item {\n            priority: p,\n            task: t.into(),\n        }\n    }\n}\n\n// Manually implpement Ord so we have a min heap\nimpl<'a> Ord for Item<'a> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        other.priority.cmp(&self.priority)\n    }\n}\n\n// PartialOrd is required by Ord\nimpl<'a> PartialOrd for Item<'a> {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n\nfn main() {\n    let mut queue = BinaryHeap::with_capacity(5);\n    queue.push(Item::new(3, \"Clear drains\"));\n    queue.push(Item::new(4, \"Feed cat\"));\n    queue.push(Item::new(5, \"Make tea\"));\n    queue.push(Item::new(1, \"Solve RC tasks\"));\n    queue.push(Item::new(2, \"Tax return\"));\n\n    for item in queue {\n        println!(\"{}\", item.task);\n    }\n}",
    "title": "Priority queue",
    "url": "http://rosettacode.org/wiki/Priority_queue"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::distributions::{weighted::alias_method::WeightedIndex, Distribution};\nuse rand::prelude::*;\n\nconst DATA: [(&str, f64); 8] = [\n    (\"aleph\", 1.0 / 5.0),\n    (\"beth\", 1.0 / 6.0),\n    (\"gimel\", 1.0 / 7.0),\n    (\"daleth\", 1.0 / 8.0),\n    (\"he\", 1.0 / 9.0),\n    (\"waw\", 1.0 / 10.0),\n    (\"zayin\", 1.0 / 11.0),\n    (\"heth\", 1759.0 / 27720.0),\n];\n\nconst SAMPLES: usize = 1_000_000;\n\n/// Generate a weighted distribution for choosing an index.\nfn distribution() -> impl Distribution<usize> {\n    WeightedIndex::new(DATA.iter().map(|(_, p)| *p).collect()).unwrap()\n}\n\nfn take_samples<R: Rng>(rng: &mut R, wc: &impl Distribution<usize>) -> [usize; 8] {\n    let mut counts = [0; 8];\n    for _ in 0..SAMPLES {\n        let sample = rng.sample(wc);\n        counts[sample] += 1;\n    }\n    counts\n}\n\nfn print_mapping(counts: &[usize]) {\n    println!(\"Item   | Expected | Actual   \");\n    println!(\"-------+----------+----------\");\n    for (&(name, expected), &count) in DATA.iter().zip(counts.iter()) {\n        let real = count as f64 / SAMPLES as f64;\n        println!(\"{:06} | {:.6} | {:.6}\", name, expected, real);\n    }\n}\n\nfn main() {\n    let counts = take_samples(&mut thread_rng(), &distribution());\n    print_mapping(&counts);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[ignore]\n    fn deviation() {\n        let mut rng = thread_rng();\n        let dist = distribution();\n\n        let counts = take_samples(&mut rng, &dist);\n        for (&(_, expected), &count) in DATA.iter().zip(counts.iter()) {\n            let real = count as f64 / SAMPLES as f64;\n            let dev = (1.0 - real / expected).abs();\n            assert!(dev < 0.01, \"{}\", dev);\n        }\n    }\n}\n",
    "path": "tasks/probabilistic-choice",
    "remote_code": null,
    "title": "Probabilistic choice",
    "url": "http://rosettacode.org/wiki/Probabilistic_choice"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Problem of Apollonius",
    "url": "http://rosettacode.org/wiki/Problem_of_Apollonius"
  },
  {
    "local_code": "fn main() {\n    println!(\"Program: {}\", std::env::args().next().unwrap());\n}\n",
    "path": "tasks/program-name",
    "remote_code": "fn main() {\n    println!(\"Program: {}\", std::env::args().next().unwrap());\n}",
    "title": "Program name",
    "url": "http://rosettacode.org/wiki/Program_name"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    println!(\"The program is running\");\n    return;\n    println!(\"This line won't be printed\");\n}",
    "title": "Program termination",
    "url": "http://rosettacode.org/wiki/Program_termination"
  },
  {
    "local_code": "/// Populate input vector with prime numbers < maxvalue\nfn add_more_prime_numbers(v: &mut Vec<usize>, maxvalue: usize) {\n    let mut prime: usize = v[v.len() - 1];\n    if prime <= 2 {\n        prime = 1;\n    } // start with odd number\n    loop {\n        prime += 2;\n        if prime >= maxvalue {\n            break;\n        }\n        let mut isprime = true;\n        let ceiling = (prime as f64).sqrt() as usize;\n        // check below sqrt(prime)\n        for i in v.iter().skip(1).take_while(|&i| *i <= ceiling) {\n            if prime % *i == 0 {\n                isprime = false;\n                break;\n            }\n        }\n        if isprime {\n            v.push(prime);\n        }\n    }\n}\n\n/// Get proper divisors\nfn find_divisors(primes: &mut Vec<usize>, num: usize) -> Vec<usize> {\n    assert!(num > 0);\n    if num == 1 {\n        return Vec::new();\n    }\n    let mut kprime_factors = vec![1];\n    let ceiling = ((num as f64).sqrt() as usize) + 1;\n    add_more_prime_numbers(primes, ceiling);\n    // Filter all primes num % p == 0\n    let prime_factors: Vec<usize> = primes.iter().filter(|&p| num % *p == 0).cloned().collect();\n    // Check all k*p p..ceiling\n    // Following code is ineffective (due to duplicates) but simple\n    for p in prime_factors {\n        let mut kp = p;\n        while kp < ceiling {\n            if num % kp == 0 {\n                kprime_factors.push(kp);\n                kprime_factors.push(num / kp)\n            }\n            kp += p;\n        }\n    }\n    kprime_factors.sort();\n    kprime_factors.dedup();\n    kprime_factors\n}\n\nfn main() {\n    let mut primes: Vec<usize> = vec![2, 3]; // reusable prime number array\n\n    // Show the proper divisors of the numbers 1 to 10 inclusive.\n    for i in 1..11 {\n        print!(\"{}: \", i);\n        println!(\"{:?}\", find_divisors(&mut primes, i));\n    }\n\n    // Find a number in the range 1 to 20,000\n    // with the most proper divisors.\n    let mut max_divs: (usize, Vec<usize>) = (0, Vec::new());\n    for n in 1..20_001 {\n        let div_q = find_divisors(&mut primes, n).len();\n        if div_q > max_divs.0 {\n            max_divs.0 = div_q;\n            max_divs.1.clear();\n            max_divs.1.push(n);\n        } else if div_q == max_divs.0 {\n            max_divs.1.push(n);\n        }\n    }\n    println!(\n        \"Most divisors a number within 1 to 20000 has: {}\",\n        max_divs.0\n    );\n    print!(\"Numbers with {} divisors: \", max_divs.0);\n    println!(\"{:?}\", max_divs.1);\n}\n\n#[test]\nfn test_divisors() {\n    fn proper_divisors(num: usize) -> Vec<usize> {\n        let mut primes: Vec<usize> = vec![2, 3];\n        find_divisors(&mut primes, num)\n    }\n\n    assert!(proper_divisors(6) == vec![1, 2, 3]);\n    assert!(proper_divisors(100) == vec![1, 2, 4, 5, 10, 20, 25, 50]);\n}\n",
    "path": "tasks/proper-divisors",
    "remote_code": "trait ProperDivisors {\n    fn proper_divisors(&self) -> Option<Vec<u64>>;\n}\n\nimpl ProperDivisors for u64 {\n    fn proper_divisors(&self) -> Option<Vec<u64>> {\n        if self.le(&1) {\n            return None;\n        }\n        let mut divisors: Vec<u64> = Vec::new();\n\n        for i in 1..*self {\n            if *self % i == 0 {\n                divisors.push(i);\n            }\n        }\n        Option::from(divisors)\n    }\n}\n\nfn main() {\n    for i in 1..11 {\n        println!(\"Proper divisors of {:2}: {:?}\", i,\n                 i.proper_divisors().unwrap_or(vec![]));\n    }\n\n    let mut most_idx: u64 = 0;\n    let mut most_divisors: Vec<u64> = Vec::new();\n    for i in 1..20_001 {\n        let divs = i.proper_divisors().unwrap_or(vec![]);\n        if divs.len() > most_divisors.len() {\n            most_divisors = divs;\n            most_idx = i;\n        }\n    }\n    println!(\"In 1 to 20000, {} has the most proper divisors at {}\", most_idx,\n             most_divisors.len());\n}\n",
    "title": "Proper divisors",
    "url": "http://rosettacode.org/wiki/Proper_divisors"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Pythagoras tree",
    "url": "http://rosettacode.org/wiki/Pythagoras_tree"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse std::collections::BinaryHeap;\n\nfn a094958_iter() -> Vec<u16> {\n    (0..12)\n        .map(|n| vec![1 << n, 5 * (1 << n)])\n        .flatten()\n        .filter(|x| x < &2200)\n        .collect::<BinaryHeap<u16>>()\n        .into_sorted_vec()\n}\n\nfn a094958_filter() -> Vec<u16> {\n    (1..2200) // ported from Sidef\n        .filter(|n| ((n & (n - 1) == 0) || (n % 5 == 0 && ((n / 5) & (n / 5 - 1) == 0))))\n        .collect()\n}\n\nfn a094958_loop() -> Vec<u16> {\n    let mut v = vec![];\n    for n in 0..12 {\n        v.push(1 << n);\n        if 5 * (1 << n) < 2200 {\n            v.push(5 * (1 << n));\n        }\n    }\n    v.sort();\n    return v;\n}\n\nfn main() {\n    println!(\"{:?}\", a094958_iter());\n    println!(\"{:?}\", a094958_loop());\n    println!(\"{:?}\", a094958_filter());\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    static HAPPY: &str = \"[1, 2, 4, 5, 8, 10, 16, 20, 32, 40, 64, 80, 128, 160, 256, 320, 512, 640, 1024, 1280, 2048]\";\n    #[test]\n    fn test_a094958_iter() {\n        assert!(format!(\"{:?}\", a094958_iter()) == HAPPY);\n    }\n    #[test]\n    fn test_a094958_loop() {\n        assert!(format!(\"{:?}\", a094958_loop()) == HAPPY);\n    }\n    #[test]\n    fn test_a094958_filter() {\n        assert!(format!(\"{:?}\", a094958_filter()) == HAPPY);\n    }\n}\n",
    "title": "Pythagorean quadruples",
    "url": "http://rosettacode.org/wiki/Pythagorean_quadruples"
  },
  {
    "local_code": "use std::collections::LinkedList;\n\n/// Count the number of Pythagorean triples whose sum are below the specified limit (inclusive).\n/// Does a BFS over the tree of primitive Pythagorean triples (see [0]), and uses the fact that\n/// each child has a bigger sum than its parent.\n///\n/// [0]: http://en.wikipedia.org/wiki/Tree_of_Pythagorean_triples\nfn count_pythagorean_triples(below: u64) -> (u64, u64) {\n    let mut tot_cnt = 0;\n    let mut prim_cnt = 0;\n    let mut queue = LinkedList::new();\n\n    // Initiate the BFS with the root of the tree: (3, 4, 5)\n    queue.push_back((3i64, 4i64, 5i64));\n\n    while let Some((a, b, c)) = queue.pop_back() {\n        // We found a new primitive Pythagorean triplet: (a, b, c).\n        // (k*a, k*b, k*c) is a (not necessarily primitive) Pythagorean triplet for any positive\n        // integer k.\n        // We're interested in those with k*a + k*b + k*c <= below, and the number of them are\n        // exactly below / (a + b + c)\n        let cur = below / (a + b + c) as u64;\n        if cur > 0 {\n            tot_cnt += cur;\n            prim_cnt += 1;\n\n            // Explore the children of the current node\n            queue.push_back((a - 2 * b + 2 * c, 2 * a - b + 2 * c, 2 * a - 2 * b + 3 * c));\n            queue.push_back((a + 2 * b + 2 * c, 2 * a + b + 2 * c, 2 * a + 2 * b + 3 * c));\n            queue.push_back((\n                -a + 2 * b + 2 * c,\n                -2 * a + b + 2 * c,\n                -2 * a + 2 * b + 3 * c,\n            ));\n        }\n    }\n\n    (tot_cnt, prim_cnt)\n}\n\nfn main() {\n    for n in 1..9 {\n        let (tot, prim) = count_pythagorean_triples(10u64.pow(n));\n        println!(\n            \"Up to 10^{}: {:>10} triples {:>10} primitives\",\n            n, tot, prim\n        );\n    }\n}\n\n#[test]\nfn test_count_pythagorean_triples() {\n    assert_eq!(count_pythagorean_triples(10u64.pow(6)), (808950, 70229));\n}\n",
    "path": "tasks/pythagorean-triples",
    "remote_code": "use std::thread;\n\nfn f1 (a : u64, b : u64, c : u64, d : u64) -> u64 {\n    let mut primitive_count = 0;\n    for triangle in [[a - 2*b + 2*c, 2*a - b + 2*c, 2*a - 2*b + 3*c], \n                     [a + 2*b + 2*c, 2*a + b + 2*c, 2*a + 2*b + 3*c],\n                     [2*b + 2*c - a, b + 2*c - 2*a, 2*b + 3*c - 2*a]] .iter() {\n        let l  = triangle[0] + triangle[1] + triangle[2];\n        if l > d { continue; }\n        primitive_count +=  1 + f1(triangle[0], triangle[1], triangle[2], d);\n    }\n    primitive_count\n}\n\nfn f2 (a : u64, b : u64, c : u64, d : u64) -> u64 {\n    let mut triplet_count = 0;\n    for triangle in [[a - 2*b + 2*c, 2*a - b + 2*c, 2*a - 2*b + 3*c], \n                     [a + 2*b + 2*c, 2*a + b + 2*c, 2*a + 2*b + 3*c],\n                     [2*b + 2*c - a, b + 2*c - 2*a, 2*b + 3*c - 2*a]] .iter() {\n        let l  = triangle[0] + triangle[1] + triangle[2];\n        if l > d { continue; }\n        triplet_count +=  (d/l) + f2(triangle[0], triangle[1], triangle[2], d);\n    }\n    triplet_count\n}\n\nfn main () {\n    let new_th_1 = thread::Builder::new().stack_size(32 * 1024 * 1024).spawn (move || {\n        let mut i = 100;\n        while i <= 100_000_000_000 {\n            println!(\" Primitive triples below {} : {}\", i, f1(3, 4, 5, i) + 1);\n            i *= 10;\n        }\n    }).unwrap();\n\n    let new_th_2 =thread::Builder::new().stack_size(32 * 1024 * 1024).spawn (move || {\n        let mut i = 100;\n        while i <= 100_000_000_000 {\n            println!(\" Triples below {} : {}\", i, f2(3, 4, 5, i) + i/12);\n            i *= 10;\n        }\n    }).unwrap();\n\n    new_th_1.join().unwrap();\n    new_th_2.join().unwrap();\n}",
    "title": "Pythagorean triples",
    "url": "http://rosettacode.org/wiki/Pythagorean_triples"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "QR decomposition",
    "url": "http://rosettacode.org/wiki/QR_decomposition"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::fmt::{Display, Error, Formatter};\nuse std::ops::{Add, Mul, Neg};\n\n#[derive(Clone,Copy,Debug)]\nstruct Quaternion {\n    a: f64,\n    b: f64,\n    c: f64,\n    d: f64\n}\n\nimpl Quaternion {\n    pub fn new(a: f64, b: f64, c: f64, d: f64) -> Quaternion {\n        Quaternion {\n            a: a,\n            b: b,\n            c: c,\n            d: d\n        }\n    }\n\n    pub fn norm(&self) -> f64 {\n        (self.a.powi(2) + self.b.powi(2) + self.c.powi(2) + self.d.powi(2)).sqrt()\n    }\n\n    pub fn conjugate(&self) -> Quaternion {\n        Quaternion {\n            a: self.a,\n            b: -self.b,\n            c: -self.c,\n            d: -self.d\n        }\n    }\n}\n\nimpl Add for Quaternion {\n    type Output = Quaternion;\n\n    #[inline]\n    fn add(self, other: Quaternion) -> Self::Output {\n        Quaternion {\n            a: self.a + other.a,\n            b: self.b + other.b,\n            c: self.c + other.c,\n            d: self.d + other.d\n        }\n    }\n}\n\nimpl Add<f64> for Quaternion {\n    type Output = Quaternion;\n\n    #[inline]\n    fn add(self, other: f64) -> Self::Output {\n        Quaternion {\n            a: self.a + other,\n            b: self.b,\n            c: self.c,\n            d: self.d\n        }\n    }\n}\n\nimpl Add<Quaternion> for f64 {\n    type Output = Quaternion;\n\n    #[inline]\n    fn add(self, other: Quaternion) -> Self::Output {\n        Quaternion {\n            a: other.a + self,\n            b: other.b,\n            c: other.c,\n            d: other.d\n        }\n    }\n}\n\nimpl Display for Quaternion {\n    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n        write!(f, \"({} + {}i + {}j + {}k)\", self.a, self.b, self.c, self.d)\n    }\n}\n\nimpl Mul for Quaternion {\n    type Output = Quaternion;\n\n    #[inline]\n    fn mul(self, rhs: Quaternion) -> Self::Output {\n        Quaternion {\n            a: self.a * rhs.a - self.b * rhs.b - self.c * rhs.c - self.d * rhs.d,\n            b: self.a * rhs.b + self.b * rhs.a + self.c * rhs.d - self.d * rhs.c,\n            c: self.a * rhs.c - self.b * rhs.d + self.c * rhs.a + self.d * rhs.b,\n            d: self.a * rhs.d + self.b * rhs.c - self.c * rhs.b + self.d * rhs.a,\n        }\n    }\n}\n\nimpl Mul<f64> for Quaternion {\n    type Output = Quaternion;\n\n    #[inline]\n    fn mul(self, other: f64) -> Self::Output {\n        Quaternion {\n            a: self.a * other,\n            b: self.b * other,\n            c: self.c * other,\n            d: self.d * other\n        }\n    }\n}\n\nimpl Mul<Quaternion> for f64 {\n    type Output = Quaternion;\n\n    #[inline]\n    fn mul(self, other: Quaternion) -> Self::Output {\n        Quaternion {\n            a: other.a * self,\n            b: other.b * self,\n            c: other.c * self,\n            d: other.d * self\n        }\n    }\n}\n\nimpl Neg for Quaternion {\n    type Output = Quaternion;\n\n    #[inline]\n    fn neg(self) -> Self::Output {\n        Quaternion {\n            a: -self.a,\n            b: -self.b,\n            c: -self.c,\n            d: -self.d\n        }\n    }\n}\n\nfn main() {\n    let q0 = Quaternion { a: 1., b: 2., c: 3., d: 4. };\n    let q1 = Quaternion::new(2., 3., 4., 5.);\n    let q2 = Quaternion::new(3., 4., 5., 6.);\n    let r: f64 = 7.;\n\n    println!(\"q0 = {}\", q0);\n    println!(\"q1 = {}\", q1);\n    println!(\"q2 = {}\", q2);\n    println!(\"r  = {}\", r);\n    println!();\n    println!(\"-q0 = {}\", -q0);\n    println!(\"conjugate of q0 = {}\", q0.conjugate());\n    println!();\n    println!(\"r + q0 = {}\", r + q0);\n    println!(\"q0 + r = {}\", q0 + r);\n    println!();\n    println!(\"r * q0 = {}\", r * q0);\n    println!(\"q0 * r = {}\", q0 * r);\n    println!();\n    println!(\"q0 + q1 = {}\", q0 + q1);\n    println!(\"q0 * q1 = {}\", q0 * q1);\n    println!();\n    println!(\"q0 * (conjugate of q0) = {}\", q0 * q0.conjugate());\n    println!();\n    println!(\" q0 + q1  * q2 = {}\", q0 + q1 * q2);\n    println!(\"(q0 + q1) * q2 = {}\", (q0 + q1) * q2);\n    println!();\n    println!(\" q0 *  q1  * q2  = {}\", q0 *q1 * q2);\n    println!(\"(q0 *  q1) * q2  = {}\", (q0 * q1) * q2);\n    println!(\" q0 * (q1  * q2) = {}\", q0 * (q1 * q2));\n    println!();\n    println!(\"normal of q0 = {}\", q0.norm());\n}",
    "title": "Quaternion type",
    "url": "http://rosettacode.org/wiki/Quaternion_type"
  },
  {
    "local_code": "//! This shows the implementation of a singly-linked queue with dequeue and enqueue. There are two\n//! peek implementations, one returns an immutable reference, the other returns a mutable one. This\n//! implementation also shows iteration over the Queue by value (consumes queue), immutable\n//! reference, and mutable reference.\n\nuse std::ptr;\n\npub struct Queue<T> {\n    head: Link<T>,\n\n    /// Raw, C-like pointer. Cannot be guaranteed safe\n    tail: *mut Item<T>,\n}\n\ntype Link<T> = Option<Box<Item<T>>>;\n\nstruct Item<T> {\n    elem: T,\n    next: Link<T>,\n}\n\npub struct IntoIter<T>(Queue<T>);\n\npub struct Iter<'a, T: 'a> {\n    next: Option<&'a Item<T>>,\n}\n\npub struct IterMut<'a, T: 'a> {\n    next: Option<&'a mut Item<T>>,\n}\n\nimpl<T> Queue<T> {\n    pub fn new() -> Self {\n        Queue {\n            head: None,\n            tail: ptr::null_mut(),\n        }\n    }\n\n    pub fn enqueue(&mut self, elem: T) {\n        let mut new_tail = Box::new(Item {\n            elem: elem,\n            next: None,\n        });\n\n        let raw_tail: *mut _ = &mut *new_tail;\n\n        if !self.tail.is_null() {\n            unsafe {\n                (*self.tail).next = Some(new_tail);\n            }\n        } else {\n            self.head = Some(new_tail);\n        }\n\n        self.tail = raw_tail;\n    }\n\n    pub fn dequeue(&mut self) -> Option<T> {\n        self.head.take().map(|head| {\n            let head = *head;\n            self.head = head.next;\n\n            if self.head.is_none() {\n                self.tail = ptr::null_mut();\n            }\n\n            head.elem\n        })\n    }\n\n    pub fn peek(&self) -> Option<&T> {\n        self.head.as_ref().map(|item| &item.elem)\n    }\n\n    pub fn peek_mut(&mut self) -> Option<&mut T> {\n        self.head.as_mut().map(|item| &mut item.elem)\n    }\n\n    pub fn iter(&self) -> Iter<T> {\n        Iter {\n            next: self.head.as_ref().map(|item| &**item),\n        }\n    }\n\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut {\n            next: self.head.as_mut().map(|item| &mut **item),\n        }\n    }\n}\n\nimpl<T> Default for Queue<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl<T> Drop for Queue<T> {\n    fn drop(&mut self) {\n        let mut cur_link = self.head.take();\n        while let Some(mut boxed_item) = cur_link {\n            cur_link = boxed_item.next.take();\n        }\n    }\n}\n\nimpl<T> IntoIterator for Queue<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        IntoIter(self)\n    }\n}\n\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.dequeue()\n    }\n}\n\nimpl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next.map(|item| {\n            self.next = item.next.as_ref().map(|item| &**item);\n            &item.elem\n        })\n    }\n}\n\nimpl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next.take().map(|item| {\n            self.next = item.next.as_mut().map(|item| &mut **item);\n            &mut item.elem\n        })\n    }\n}\n\nfn main() {\n    // The standard library has a double-ended queue implementation\n    // (VecDeque<T>) which will work here.\n    use std::collections::VecDeque;\n\n    let mut deque = VecDeque::new();\n    deque.push_back(\"Element1\");\n    deque.push_back(\"Element2\");\n    deque.push_back(\"Element3\");\n\n    assert_eq!(Some(&\"Element1\"), deque.front());\n    assert_eq!(Some(\"Element1\"), deque.pop_front());\n    assert_eq!(Some(\"Element2\"), deque.pop_front());\n    assert_eq!(Some(\"Element3\"), deque.pop_front());\n    assert_eq!(None, deque.pop_front());\n\n    let mut queue = Queue::new();\n    queue.enqueue(\"Element1\");\n    queue.enqueue(\"Element2\");\n    queue.enqueue(\"Element3\");\n\n    assert_eq!(Some(&\"Element1\"), queue.peek());\n    assert_eq!(Some(\"Element1\"), queue.dequeue());\n    assert_eq!(Some(\"Element2\"), queue.dequeue());\n    assert_eq!(Some(\"Element3\"), queue.dequeue());\n    assert_eq!(None, queue.dequeue());\n}\n\n#[test]\nfn test_queue() {\n    let mut queue = Queue::new();\n    queue.enqueue(\"Element1\");\n    queue.enqueue(\"Element2\");\n    queue.enqueue(\"Element3\");\n\n    assert_eq!(Some(&\"Element1\"), queue.peek());\n    assert_eq!(Some(\"Element1\"), queue.dequeue());\n    assert_eq!(Some(\"Element2\"), queue.dequeue());\n    assert_eq!(Some(\"Element3\"), queue.dequeue());\n    assert_eq!(None, queue.dequeue());\n}\n",
    "path": "tasks/queue/definition",
    "remote_code": "use std::collections::VecDeque;\nfn main() {\n    let mut stack = VecDeque::new();\n    stack.push_back(\"Element1\");\n    stack.push_back(\"Element2\");\n    stack.push_back(\"Element3\");\n\n    assert_eq!(Some(&\"Element1\"), stack.front());\n    assert_eq!(Some(\"Element1\"), stack.pop_front());\n    assert_eq!(Some(\"Element2\"), stack.pop_front());\n    assert_eq!(Some(\"Element3\"), stack.pop_front());\n    assert_eq!(None, stack.pop_front());\n}",
    "title": "Queue/Definition",
    "url": "http://rosettacode.org/wiki/Queue/Definition"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Queue/Usage",
    "url": "http://rosettacode.org/wiki/Queue/Usage"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Quickselect algorithm",
    "url": "http://rosettacode.org/wiki/Quickselect_algorithm"
  },
  {
    "local_code": "fn main() {\n    let x = \"fn main() {\\n    let x = \";\n    let y = \"print!(\\\"{}{:?};\\n    let y = {:?};\\n    {}\\\", x, x, y, y)\\n}\\n\";\n    print!(\"{}{:?};\n    let y = {:?};\n    {}\", x, x, y, y)\n}\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::path::PathBuf;\nuse std::process::Command;\n\n#[test]\nfn validate_quine() {\n    let contents = {\n        let path = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\")).join(\"src/main.rs\");\n        let mut code = File::open(path).unwrap();\n        let mut contents = String::new();\n        code.read_to_string(&mut contents).unwrap();\n        contents\n    };\n\n    let output = Command::new(\"cargo\")\n        .args(&[\"run\", \"--release\"])\n        .output()\n        .expect(\"failed to execute binary\");\n\n    let output = String::from_utf8_lossy(&output.stdout);\n\n    assert_eq!(contents, output);\n}\n",
    "path": "tasks/quine",
    "remote_code": "fn main() {\n    let x = \"fn main() {\\n    let x = \";\n    let y = \"print!(\\\"{}{:?};\\n    let y = {:?};\\n    {}\\\", x, x, y, y)\\n}\\n\";\n    print!(\"{}{:?};\n    let y = {:?};\n    {}\", x, x, y, y)\n}",
    "title": "Quine",
    "url": "http://rosettacode.org/wiki/Quine"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "RCRPG",
    "url": "http://rosettacode.org/wiki/RCRPG"
  },
  {
    "local_code": "use ripemd160::{Digest, Ripemd160};\n\n/// Create a lowercase hexadecimal string using the\n/// RIPEMD160 hashing algorithm\nfn ripemd160(text: &str) -> String {\n    // create a lowercase hexadecimal string\n    // using the shortand for the format macro\n    // https://doc.rust-lang.org/std/fmt/trait.LowerHex.html\n    format!(\"{:x}\", Ripemd160::digest(text.as_bytes()))\n}\n\nfn main() {\n    println!(\"{}\", ripemd160(\"Rosetta Code\"));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::ripemd160;\n\n    #[test]\n    fn test_ripemd160() {\n        assert_eq!(\n            ripemd160(\"Rosetta Code\"),\n            \"b3be159860842cebaa7174c8fff0aa9e50a5199f\"\n        );\n        assert_eq!(ripemd160(\"\"), \"9c1185a5c5e9fc54612808977ee8f548b2258d31\");\n        assert_eq!(\n            ripemd160(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"),\n            \"b0e20b6e3116640286ed3a87a5713079b21f5189\"\n        );\n    }\n}\n",
    "path": "tasks/ripemd-160",
    "remote_code": null,
    "title": "RIPEMD-160",
    "url": "http://rosettacode.org/wiki/RIPEMD-160"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse rand::distributions::Uniform;\nuse rand::prelude::{thread_rng, ThreadRng};\nuse rand::Rng;\n\nfn main() {\n    for _ in 0..=10 {\n        attributes_engine();\n    }\n}\n\n#[derive(Copy, Clone, Debug)]\npub struct Dice {\n    amount: i32,\n    range: Uniform<i32>,\n    rng: ThreadRng,\n}\n\nimpl Dice {\n    //  Modeled after d20 polyhederal dice use and notation.\n    //  roll_pool() - returns Vec<i32> with length of vector determined by dice amount.\n    //  attribute_out() - returns i32, by sorting a dice pool of 4d6, dropping the lowest integer, and summing all elements.\n    pub fn new(amount: i32, size: i32) -> Self {\n        Self {\n            amount,\n            range: Uniform::new(1, size + 1),\n            rng: thread_rng(),\n        }\n    }\n\n    fn roll_pool(mut self) -> Vec<i32> {\n        (0..self.amount)\n            .map(|_| self.rng.sample(self.range))\n            .collect()\n    }\n\n    fn attribute_out(&self) -> i32 {\n        // Sort dice pool lowest to high and drain all results to exclude the lowest before summing.\n        let mut attribute_array: Vec<i32> = self.roll_pool();\n        attribute_array.sort();\n        attribute_array.drain(1..=3).sum()\n    }\n}\n\nfn attributes_finalizer() -> (Vec<i32>, i32, bool) {\n    let die: Dice = Dice::new(4, 6);\n    let mut attributes: Vec<i32> = Vec::new();\n\n    for _ in 0..6 {\n        attributes.push(die.attribute_out())\n    }\n    \n    let attributes_total: i32 = attributes.iter().sum();\n\n    let numerical_condition: bool = attributes\n        .iter()\n        .filter(|attribute| **attribute >= 15)\n        .count()\n        >= 2;\n\n    (attributes, attributes_total, numerical_condition)\n}\n\nfn attributes_engine() {\n    loop {\n        let (attributes, attributes_total, numerical_condition) = attributes_finalizer();\n        if (attributes_total >= 75) && (numerical_condition) {\n            println!(\n                \"{:?} | sum: {:?}\",\n                attributes, attributes_total\n            );\n            break;\n        } else {\n            continue;\n        }\n    }\n}\n",
    "title": "RPG Attributes Generator",
    "url": "http://rosettacode.org/wiki/RPG_Attributes_Generator"
  },
  {
    "local_code": "extern crate num;\n\nuse num::bigint::BigUint;\nuse num::integer::Integer;\nuse num::traits::{One, Zero};\n\nfn mod_exp(b: &BigUint, e: &BigUint, n: &BigUint) -> Result<BigUint, &'static str> {\n    if n.is_zero() {\n        return Err(\"modulus is zero\");\n    }\n    if b >= n {\n        // base is too large and should be split into blocks\n        return Err(\"base is >= modulus\");\n    }\n    if b.gcd(n) != BigUint::one() {\n        return Err(\"base and modulus are not relatively prime\");\n    }\n\n    let mut bb = b.clone();\n    let mut ee = e.clone();\n    let mut result = BigUint::one();\n    while !ee.is_zero() {\n        if ee.is_odd() {\n            result = (result * &bb) % n;\n        }\n        ee >>= 1;\n        bb = (&bb * &bb) % n;\n    }\n    Ok(result)\n}\n\nfn main() {\n    let msg = \"Rosetta Code\";\n\n    let n = \"9516311845790656153499716760847001433441357\"\n        .parse()\n        .unwrap();\n    let e = \"65537\".parse().unwrap();\n    let d = \"5617843187844953170308463622230283376298685\"\n        .parse()\n        .unwrap();\n\n    let msg_int = BigUint::from_bytes_be(msg.as_bytes());\n    let enc = mod_exp(&msg_int, &e, &n).unwrap();\n    let dec = mod_exp(&enc, &d, &n).unwrap();\n    let msg_dec = String::from_utf8(dec.to_bytes_be()).unwrap();\n\n    println!(\"msg as txt: {}\", msg);\n    println!(\"msg as num: {}\", msg_int);\n    println!(\"enc as num: {}\", enc);\n    println!(\"dec as num: {}\", dec);\n    println!(\"dec as txt: {}\", msg_dec);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::mod_exp;\n    use num::bigint::BigUint;\n    use num::integer::Integer;\n    use num::traits::{FromPrimitive, Zero};\n\n    const N: &'static str = \"9516311845790656153499716760847001433441357\";\n    const E: &'static str = \"65537\";\n    const D: &'static str = \"5617843187844953170308463622230283376298685\";\n\n    fn rsa_numbers() -> (BigUint, BigUint, BigUint) {\n        let n = N.parse().unwrap();\n        let e = E.parse().unwrap();\n        let d = D.parse().unwrap();\n        (n, e, d)\n    }\n\n    #[test]\n    fn test_enc_dec() {\n        let (n, e, d) = rsa_numbers();\n        let msg = \"Rosetta Code\";\n        let msg_int = BigUint::from_bytes_be(msg.as_bytes());\n        let enc = mod_exp(&msg_int, &e, &n).unwrap();\n        let dec = mod_exp(&enc, &d, &n).unwrap();\n        let msg_dec = String::from_utf8(dec.to_bytes_be()).unwrap();\n        assert_eq!(msg, msg_dec);\n    }\n\n    #[test]\n    fn test_enc_too_large_base() {\n        let (n, e, _) = rsa_numbers();\n        let msg = \"I am too large for this modulus!\";\n        let msg_int = BigUint::from_bytes_be(msg.as_bytes());\n        assert!(msg_int > n);\n        let result = mod_exp(&msg_int, &e, &n);\n        assert_eq!(Err(\"base is >= modulus\"), result);\n    }\n\n    #[test]\n    fn test_enc_zero_modulus() {\n        let (_, e, _) = rsa_numbers();\n        let msg_int = BigUint::from_bytes_be(b\"msg\");\n        let result = mod_exp(&msg_int, &e, &BigUint::zero());\n        assert_eq!(Err(\"modulus is zero\"), result);\n    }\n\n    #[test]\n    fn test_base_modulus_not_relatively_prime() {\n        let (_, e, _) = rsa_numbers();\n        let b = BigUint::from_u8(12).unwrap();\n        let n = BigUint::from_u8(18).unwrap();\n        assert_eq!(&BigUint::from_u8(6).unwrap(), &b.gcd(&n));\n        let result = mod_exp(&b, &e, &n);\n        assert_eq!(Err(\"base and modulus are not relatively prime\"), result);\n    }\n}\n",
    "path": "tasks/rsa-code",
    "remote_code": null,
    "title": "RSA code",
    "url": "http://rosettacode.org/wiki/RSA_code"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Ramer-Douglas-Peucker line simplification",
    "url": "http://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::prelude::*;\nuse rand::rngs::OsRng;\n\nfn main() {\n    let mut rng = OsRng;\n    let rand_num: u32 = rng.gen();\n    println!(\"{}\", rand_num);\n}\n",
    "path": "tasks/random-number-generator/device",
    "remote_code": "extern crate rand;\n\nuse rand::{OsRng, Rng};\n\nfn main() {\n    // because `OsRng` opens files, it may fail\n    let mut rng = match OsRng::new() {\n        Ok(v) => v,\n        Err(e) => panic!(\"Failed to obtain OS RNG: {}\", e)\n    };\n\n    let rand_num: u32 = rng.gen();\n    println!(\"{}\", rand_num);\n}",
    "title": "Random number generator (device)",
    "url": "http://rosettacode.org/wiki/Random_number_generator_(device)"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Random number generator (included)",
    "url": "http://rosettacode.org/wiki/Random_number_generator_(included)"
  },
  {
    "local_code": "use rand::Rng;\nuse rand_distr::Normal;\n\nfn main() {\n    let normal = Normal::new(1.0, 0.5).unwrap();\n    let mut rng = rand::thread_rng();\n\n    let rands = (0..1000).map(|_| rng.sample(normal)).collect::<Vec<_>>();\n    println!(\"{:?}\", rands);\n}\n",
    "path": "tasks/random-numbers",
    "remote_code": "extern crate rand;\nuse rand::distributions::{Normal, IndependentSample};\n\nfn main() {\n    let mut rands = [0.0; 1000];\n    let normal = Normal::new(1.0, 0.5);\n    let mut rng = rand::thread_rng();\n    for num in rands.iter_mut() {\n        *num = normal.ind_sample(&mut rng);\n    }\n}",
    "title": "Random numbers",
    "url": "http://rosettacode.org/wiki/Random_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Range consolidation",
    "url": "http://rosettacode.org/wiki/Range_consolidation"
  },
  {
    "local_code": "extern crate regex;\n\nuse regex::Regex;\n\nfn main() {\n    let range = \"-6,-3-1,3-5,7-11,14,15,17-20\";\n    println!(\"Expanded range: {:?}\", expand_range(range));\n}\n\n/// Expand a string containing numbers and ranges, into a vector of numbers\nfn expand_range(range: &str) -> Vec<isize> {\n    let mut result = vec![];\n\n    for item in range.split(',') {\n        result.extend(expand_item(item).into_iter());\n    }\n\n    result\n}\n\n/// Expand a single element, which can be a number or a range.\nfn expand_item(item: &str) -> Vec<isize> {\n    // Handle the case of a single number\n    if let Some(cap) = Regex::new(r\"^(-?\\d+)$\").unwrap().captures(item) {\n        return vec![cap.get(0).and_then(|s| s.as_str().parse().ok()).unwrap()];\n    }\n\n    // Handle the case of a range\n    if let Some(cap) = Regex::new(r\"^(-?\\d+)-(-?\\d+)$\").unwrap().captures(item) {\n        let left: isize = cap.get(1).and_then(|s| s.as_str().parse().ok()).unwrap();\n        let right: isize = cap.get(2).and_then(|s| s.as_str().parse().ok()).unwrap();\n\n        // Generate and collect a range between them\n        return (left..right + 1).collect();\n    }\n\n    panic!(\"The item `{}` is not a number or a range!\", item);\n}\n\n#[test]\nfn test_basic() {\n    let range = \"1-5,6\";\n    assert!(expand_range(range) == vec![1, 2, 3, 4, 5, 6]);\n\n    let range = \"-6,-3-1,3-5,7-11,14,15,17-20\";\n    assert!(\n        expand_range(range)\n            == vec![-6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20,]\n    );\n}\n\n#[test]\n#[should_panic]\nfn test_wrong() {\n    let range = \"one-five,six\";\n    assert!(expand_range(range) == vec![1, 2, 3, 4, 5, 6]);\n}\n",
    "path": "tasks/range-expansion",
    "remote_code": "use std::str::FromStr;\n\n// Precondition: range doesn't contain multibyte UTF-8 characters\nfn range_expand(range : &str) -> Vec<i32> {\n   range.split(',').flat_map(|item| {\n        match i32::from_str(item) {\n            Ok(n) => n..n+1,\n            _ => {\n                let dashpos=\n                    match item.rfind(\"--\") {\n                        Some(p) => p,\n                        None => item.rfind('-').unwrap(),\n                    };\n                let rstart=i32::from_str(\n                    unsafe{ item.slice_unchecked(0,dashpos)} ).unwrap();\n                let rend=i32::from_str(\n                    unsafe{ item.slice_unchecked(dashpos+1,item.len()) } ).unwrap();\n                rstart..rend+1\n            },\n        }\n    }).collect()\n}\n\nfn main() {\n    println!(\"{:?}\", range_expand(\"-6,-3--1,3-5,7-11,14,15,17-20\"));\n}\n",
    "title": "Range expansion",
    "url": "http://rosettacode.org/wiki/Range_expansion"
  },
  {
    "local_code": "extern crate num;\n\nuse num::One;\n\nuse std::ops::Add;\n\nstruct RangeFinder<'a, T: 'a> {\n    index: usize,\n    length: usize,\n    arr: &'a [T],\n}\n\nimpl<'a, T> Iterator for RangeFinder<'a, T>\nwhere\n    T: PartialEq + Add<T, Output = T> + Copy + One,\n{\n    type Item = (T, Option<T>);\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.index == self.length {\n            return None;\n        }\n        let lo = self.index;\n        while self.index < self.length - 1\n            && self.arr[self.index + 1] == self.arr[self.index] + T::one()\n        {\n            self.index += 1\n        }\n        let hi = self.index;\n        self.index += 1;\n        if hi - lo > 1 {\n            Some((self.arr[lo], Some(self.arr[hi])))\n        } else {\n            if hi - lo == 1 {\n                self.index -= 1\n            }\n            Some((self.arr[lo], None))\n        }\n    }\n}\n\nimpl<'a, T> RangeFinder<'a, T> {\n    fn new(a: &'a [T]) -> Self {\n        RangeFinder {\n            index: 0,\n            arr: a,\n            length: a.len(),\n        }\n    }\n}\n\nfn main() {\n    let n = &[\n        0, 1, 2, 4, 6, 7, 8, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 27, 28, 29,\n        30, 31, 32, 33, 35, 36, 37, 38, 39,\n    ];\n\n    for (i, (lo, hi)) in RangeFinder::new(n).enumerate() {\n        if i > 0 {\n            print!(\", \")\n        }\n        print!(\"{}\", lo);\n        if hi.is_some() {\n            print!(\"-{}\", hi.unwrap())\n        }\n    }\n    println!();\n}\n\n#[test]\nfn test_solution() {\n    let n: &[u8] = &[\n        0, 1, 2, 4, 6, 7, 8, 11, 12, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 27, 28, 29,\n        30, 31, 32, 33, 35, 36, 37, 38, 39,\n    ];\n\n    let actual: Vec<(u8, Option<u8>)> = RangeFinder::new(n).collect();\n    let expected = &[\n        (0, Some(2)),\n        (4, None),\n        (6, Some(8)),\n        (11, None),\n        (12, None),\n        (14, Some(25)),\n        (27, Some(33)),\n        (35, Some(39)),\n    ];\n\n    assert_eq!(&actual, expected);\n}\n",
    "path": "tasks/range-extraction",
    "remote_code": "use std::ops::Add;\n \nstruct RangeFinder<'a, T: 'a> {\n    index: usize,\n    length: usize,\n    arr: &'a [T],\n}\n \nimpl<'a, T> Iterator for RangeFinder<'a, T> where T: PartialEq + Add<i8, Output=T> + Copy {\n    type Item = (T,  Option<T>);\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.index == self.length {\n            return None;\n        }\n        let lo = self.index;\n        while self.index < self.length - 1 && self.arr[self.index + 1] == self.arr[self.index] + 1 {\n            self.index += 1\n        }\n        let hi = self.index;\n        self.index += 1;\n        if hi - lo > 1 {\n            Some((self.arr[lo], Some(self.arr[hi])))\n        } else {\n            if hi - lo == 1 {\n                self.index -= 1\n            }\n            Some((self.arr[lo], None))\n        }\n    }\n}\n \nimpl<'a, T> RangeFinder<'a, T> {\n    fn new(a: &'a [T]) -> Self {\n        RangeFinder {\n            index: 0,\n            arr: a,\n            length: a.len(),\n        }\n    }\n}\n\nfn main() {\n    let input_numbers : &[i8] = &[0,  1,  2,  4,  6,  7,  8, 11, 12, 14,\n                                  15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n                                  25, 27, 28, 29, 30, 31, 32, 33, 35, 36,\n                                  37, 38, 39];\n    for (i, (lo, hi)) in RangeFinder::new(&input_numbers).enumerate() {\n        if i > 0 {print!(\",\")}\n        print!(\"{}\", lo);\n        if hi.is_some() {print!(\"-{}\", hi.unwrap())}\n    }\n    println!(\"\");\n}",
    "title": "Range extraction",
    "url": "http://rosettacode.org/wiki/Range_extraction"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Ranking methods",
    "url": "http://rosettacode.org/wiki/Ranking_methods"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Rare numbers",
    "url": "http://rosettacode.org/wiki/Rare_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Rate counter",
    "url": "http://rosettacode.org/wiki/Rate_counter"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "use std::f64;\n\nconst _EPS: f64 = 0.00001;\nconst _MIN: f64 = f64::MIN_POSITIVE;\nconst _MAX: f64 = f64::MAX;\n\n#[derive(Clone)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n#[derive(Clone)]\nstruct Edge {\n    pt1: Point,\n    pt2: Point,\n}\n\nimpl Edge {\n    fn new(pt1: (f64, f64), pt2: (f64, f64)) -> Edge {\n        Edge {\n            pt1: Point { x: pt1.0, y: pt1.1 },\n            pt2: Point { x: pt2.0, y: pt2.1 },\n        }\n    }\n}\n\nstruct Polygon {\n    edges: Vec<Edge>, // Polygon has to be created with counter-clockwise coordinates\n}\n\nfn pt_in_polygon(pt: &Point, poly: &Polygon) -> bool {\n    let count = poly.edges\n        .iter()\n        .filter(|edge| ray_intersect_seg(pt, edge))\n        .count();\n\n    count % 2 == 1\n}\n\nfn ray_intersect_seg(p: &Point, edge: &Edge) -> bool {\n    let mut pt = p.clone();\n    let (mut a, mut b): (&Point, &Point) = (&edge.pt1, &edge.pt2);\n    if a.y > b.y {\n        std::mem::swap(&mut a, &mut b);\n    }\n    if pt.y == a.y || pt.y == b.y {\n        pt.y += _EPS;\n    }\n\n    if (pt.y > b.y || pt.y < a.y) || pt.x > a.x.max(b.x) {\n        false\n    } else if pt.x < a.x.min(b.x) {\n        true\n    } else {\n        let m_red = if (a.x - b.x).abs() > _MIN {\n            (b.y - a.y) / (b.x - a.x)\n        } else {\n            _MAX\n        };\n        let m_blue = if (a.x - pt.x).abs() > _MIN {\n            (pt.y - a.y) / (pt.x - a.x)\n        } else {\n            _MAX\n        };\n        m_blue >= m_red\n    }\n}\n\nfn main() {\n    let p = |x, y| Point { x, y };\n    let testpoints = [p(5.0, 5.0), p(5.0, 8.0), p(-10.0, 5.0), p(0.0, 5.0), p(10.0, 5.0), p(8.0, 5.0), p(10.0, 10.0)];\n    let poly_square = Polygon {\n        edges: vec![\n            Edge::new((0.0, 0.0), (10.0, 0.0)),\n            Edge::new((10.0, 0.0), (10.0, 10.0)),\n            Edge::new((10.0, 10.0), (0.0, 10.0)),\n            Edge::new((0.0, 10.0), (0.0, 0.0)),\n        ],\n    };\n    let poly_square_hole = Polygon {\n        edges: vec![\n            Edge::new((0.0, 0.0), (10.0, 0.0)),\n            Edge::new((10.0, 0.0), (10.0, 10.0)),\n            Edge::new((10.0, 10.0), (0.0, 10.0)),\n            Edge::new((0.0, 10.0), (0.0, 0.0)),\n            Edge::new((2.5, 2.5), (7.5, 2.5)),\n            Edge::new((7.5, 2.5), (7.5, 7.5)),\n            Edge::new((7.5, 7.5), (2.5, 7.5)),\n            Edge::new((2.5, 7.5), (2.5, 2.5)),\n        ],\n    };\n    let poly_strange = Polygon {\n        edges: vec![\n            Edge::new((0.0, 0.0), (2.5, 2.5)),\n            Edge::new((2.5, 2.5), (0.0, 10.0)),\n            Edge::new((0.0, 10.0), (2.5, 7.5)),\n            Edge::new((2.5, 7.5), (7.5, 7.5)),\n            Edge::new((7.5, 7.5), (10.0, 10.0)),\n            Edge::new((10.0, 10.0), (10.0, 0.0)),\n            Edge::new((10.0, 0.0), (2.5, 2.5)),\n        ],\n    };\n    let poly_hexagon = Polygon {\n        edges: vec![\n            Edge::new((3.0, 0.0), (7.0, 0.0)),\n            Edge::new((7.0, 0.0), (10.0, 5.0)),\n            Edge::new((10.0, 5.0), (7.0, 10.0)),\n            Edge::new((7.0, 10.0), (3.0, 10.0)),\n            Edge::new((3.0, 10.0), (0.0, 5.0)),\n            Edge::new((0.0, 5.0), (3.0, 0.0)),\n        ],\n    };\n    print!(\"\\nSquare :\");\n    for pt in &testpoints {\n        print!(\" {:?}\", pt_in_polygon(pt, &poly_square));\n    }\n    print!(\"\\nSquare with hole:\");\n    for pt in &testpoints {\n        print!(\" {:?}\", pt_in_polygon(pt, &poly_square_hole));\n    }\n    print!(\"\\nStrange polygon :\");\n    for pt in &testpoints {\n        print!(\" {:?}\", pt_in_polygon(pt, &poly_strange));\n    }\n    print!(\"\\nHexagon :\");\n    for pt in &testpoints {\n        print!(\" {:?}\", pt_in_polygon(pt, &poly_hexagon));\n    }\n    println!();\n}",
    "title": "Ray-casting algorithm",
    "url": "http://rosettacode.org/wiki/Ray-casting_algorithm"
  },
  {
    "local_code": "use std::collections::HashMap;\nuse std::fs::File;\nuse std::io::{self, BufRead, BufReader};\nuse std::path::Path;\n\n#[derive(Debug)]\nenum ConfigVariable {\n    String(String),\n    Boolean(bool),\n    Vector(Vec<String>),\n}\n\ntrait FromConfig: Sized {\n    fn from_config(param: &ConfigParams, key: &str) -> Result<Self, String>;\n}\n\nimpl FromConfig for String {\n    fn from_config(param: &ConfigParams, key: &str) -> Result<String, String> {\n        match param.params.get(key) {\n            Some(&ConfigVariable::String(ref value)) => Ok(value.clone()),\n            _ => Err(format!(\"Unknown configuration parameter: {:?}\", key)),\n        }\n    }\n}\n\nimpl FromConfig for bool {\n    fn from_config(param: &ConfigParams, key: &str) -> Result<bool, String> {\n        match param.params.get(key) {\n            Some(&ConfigVariable::Boolean(value)) => Ok(value),\n            _ => Ok(false),\n        }\n    }\n}\n\nimpl FromConfig for Vec<String> {\n    fn from_config(param: &ConfigParams, key: &str) -> Result<Vec<String>, String> {\n        match param.params.get(key) {\n            Some(&ConfigVariable::Vector(ref value)) => Ok(value.clone()),\n            _ => Err(format!(\"Unknown configuration parameter: {:?}\", key)),\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct ConfigParams {\n    params: HashMap<String, ConfigVariable>,\n}\n\nimpl ConfigParams {\n    fn new() -> ConfigParams {\n        ConfigParams {\n            params: HashMap::new(),\n        }\n    }\n\n    fn parse<P: AsRef<Path>>(path: P) -> ConfigParams {\n        let conf_file = File::open(path).unwrap();\n        let content = BufReader::new(conf_file);\n\n        let is_not_comment = |x: &Result<String, io::Error>| match *x {\n            Err(_) => false,\n            Ok(ref line) => {\n                let comment_chars = ['#', ';'];\n                !(line.starts_with(&comment_chars[..]) || line.is_empty())\n            }\n        };\n        let mut params = ConfigParams::new();\n        for line in content.lines().filter(is_not_comment) {\n            if line.is_ok() {\n                params.update_config(&line.unwrap());\n            }\n        }\n\n        params\n    }\n    // Will parse the line and update the internal structure\n    fn update_config(&mut self, line: &str) {\n        let mut parts = line.splitn(2, ' ').map(|x| x.to_owned());\n        let key = parts.next().unwrap().to_lowercase();\n        match parts.next() {\n            None => {\n                self.params.insert(key, ConfigVariable::Boolean(true));\n            }\n            Some(value) => {\n                if value.contains(',') {\n                    self.params.insert(\n                        key,\n                        ConfigVariable::Vector(\n                            value\n                                .split(',')\n                                .map(|item| item.trim().to_owned())\n                                .collect(),\n                        ),\n                    );\n                } else {\n                    self.params.insert(key, ConfigVariable::String(value));\n                }\n            }\n        }\n    }\n\n    fn param<T: FromConfig>(&self, key: &str) -> Result<T, String> {\n        key.to_lowercase();\n        FromConfig::from_config(self, key)\n    }\n}\n\nfn main() {\n    const CONF: &str = \"test.conf\";\n    let params = ConfigParams::parse(CONF);\n\n    println!(\"{:?}\", params.param::<String>(\"fullname\"));\n    println!(\"{:?}\", params.param::<String>(\"favouritefruit\"));\n    println!(\"{:?}\", params.param::<bool>(\"needspeeling\"));\n    println!(\"{:?}\", params.param::<bool>(\"seedsremoved\"));\n    println!(\"{:?}\", params.param::<Vec<String>>(\"otherfamily\"));\n}\n\n#[cfg(test)]\nmod tests {\n\n    #[test]\n    fn main_test() {\n        const CONF: &'static str = \"test.conf\";\n        let params = super::ConfigParams::parse(CONF);\n        assert_eq!(params.param::<String>(\"fullname\").unwrap(), \"Foo Barber\");\n        assert_eq!(params.param::<String>(\"favouritefruit\").unwrap(), \"banana\");\n        assert!(params.param::<bool>(\"needspeeling\").unwrap());\n        assert!(!params.param::<bool>(\"seedsremoved\").unwrap());\n        assert_eq!(\n            params.param::<Vec<String>>(\"otherfamily\").unwrap(),\n            vec![\"Rhu Barber\", \"Harry Barber\"]\n        );\n    }\n}\n",
    "path": "tasks/read-a-configuration-file",
    "remote_code": null,
    "title": "Read a configuration file",
    "url": "http://rosettacode.org/wiki/Read_a_configuration_file"
  },
  {
    "local_code": "use std::borrow::ToOwned;\nuse std::env::args;\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn main() {\n    let filename = {\n        if let Some(o_s) = args().nth(1) {\n            o_s.to_owned()\n        } else {\n            panic!(\"You must enter a filename to read line by line\")\n        }\n    };\n\n    let file = File::open(filename).unwrap();\n    let reader = BufReader::new(file);\n\n    for line in reader.lines() {\n        // Handle any errors that may arise\n        match line {\n            Ok(ln) => print!(\"{}\", ln),\n            Err(error) => print!(\"{}\", error),\n        }\n    }\n    println!();\n}\n",
    "path": "tasks/read-a-file-line-by-line",
    "remote_code": "use std::io::{BufReader,BufRead};\nuse std::fs::File;\n\nfn main() {\n    let file = File::open(\"file.txt\").unwrap();\n    for line in BufReader::new(file).lines() {\n        println!(\"{}\", line.unwrap());\n    }\n}",
    "title": "Read a file line by line",
    "url": "http://rosettacode.org/wiki/Read_a_file_line_by_line"
  },
  {
    "local_code": "use std::borrow::ToOwned;\nuse std::env::args;\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn main() {\n    let mut args = args();\n\n    let filename = {\n        if let Some(o_s) = args.nth(1) {\n            o_s.to_owned()\n        } else {\n            panic!(\"You must enter a filename to read line by line\")\n        }\n    };\n\n    let line_number = {\n        if let Some(o_s) = args.next() {\n            o_s.to_owned()\n                .parse::<usize>()\n                .expect(\"You must enter an integer as the line number\")\n        } else {\n            panic!(\"You must enter a filename to read line by line\")\n        }\n    };\n\n    let file = File::open(filename).unwrap();\n    let reader = BufReader::new(file);\n\n    match reader.lines().nth(line_number - 1) {\n        None => panic!(\"No such line (file is too short)\"),\n        Some(result) => {\n            match result {\n                // Handle any errors that may arise\n                Ok(ln) => print!(\"{}\", ln),\n                Err(error) => print!(\"{}\", error),\n            }\n        }\n    }\n}\n",
    "path": "tasks/read-a-specific-line-from-a-file",
    "remote_code": "use std::fs::File;\nuse std::io::BufRead;\nuse std::io::BufReader;\nuse std::io::Error;\nuse std::path::Path;\n \nfn main() {\n    let path = Path::new(\"file.txt\");\n    let line_num = 7usize;\n    let line = get_line_at(&path, line_num - 1);\n    println!(\"{}\", line.unwrap());\n}\n \nfn get_line_at(path: &Path, line_num: usize) -> Result<String, Error> {\n    let file = File::open(path).expect(\"File not found or cannot be opened\");\n    let content = BufReader::new(&file);\n    let mut lines = content.lines();\n    lines.nth(line_num).expect(\"No line found at that position\")\n}",
    "title": "Read a specific line from a file",
    "url": "http://rosettacode.org/wiki/Read_a_specific_line_from_a_file"
  },
  {
    "local_code": "use std::fs::File;\nuse std::io::Read;\n\nfn main() {\n    let mut file = File::open(\"resources/input.txt\").unwrap();\n\n    let mut contents: Vec<u8> = Vec::new();\n    // Returns amount of bytes read and append the result to the buffer\n    let result = file.read_to_end(&mut contents).unwrap();\n    println!(\"Read {} bytes\", result);\n\n    // To print the contents of the file\n    let filestr = String::from_utf8(contents).unwrap();\n    println!(\"{}\", filestr);\n}\n",
    "path": "tasks/read-entire-file",
    "remote_code": "use std::fs::File;\nuse std::io::Read;\n\nfn main() {\n    let mut file = File::open(\"somefile.txt\").unwrap();\n\n    let mut contents: Vec<u8> = Vec::new();\n    // Returns amount of bytes read and append the result to the buffer\n    let result = file.read_to_end(&mut contents).unwrap();\n    println!(\"Read {} bytes\", result);\n\n    // To print the contents of the file\n    let filestr = String::from_utf8(contents).unwrap();\n    println!(\"{}\", filestr);\n}",
    "title": "Read entire file",
    "url": "http://rosettacode.org/wiki/Read_entire_file"
  },
  {
    "local_code": "use std::f64::consts::*;\n\n#[cfg_attr(feature = \"cargo-clippy\", allow(float_cmp))]\nfn main() {\n    // e (base of the natural logarithm)\n    let mut x = E;\n    // π\n    x += PI;\n    // square root\n    x = x.sqrt();\n    // logarithm (any base allowed)\n    x = x.ln();\n    // ceiling (smallest integer not less than this number--not the same as round up)\n    x = x.ceil();\n    // exponential (ex)\n    x = x.exp();\n    // absolute value (a.k.a. \"magnitude\")\n    x = x.abs();\n    // floor (largest integer less than or equal to this number--not the same as truncate or int)\n    x = x.floor();\n    // power (xy)\n    x = x.powf(x);\n\n    assert_eq!(x, 4.0);\n}\n",
    "path": "tasks/real-constants-and-functions",
    "remote_code": "use std::f64::consts::*;\n\nfn main() {\n    // e (base of the natural logarithm)\n    let mut x = E;\n    // π\n    x += PI;\n    // square root\n    x = x.sqrt();\n    // logarithm (any base allowed)\n    x = x.ln();\n    // ceiling (smallest integer not less than this number--not the same as round up)\n    x = x.ceil();\n    // exponential (ex)\n    x = x.exp();\n    // absolute value (a.k.a. \"magnitude\")\n    x = x.abs();\n    // floor (largest integer less than or equal to this number--not the same as truncate or int)\n    x = x.floor();\n    // power (xy) \n    x = x.powf(x);\n\n    assert_eq!(x, 4.0);\n}",
    "title": "Real constants and functions",
    "url": "http://rosettacode.org/wiki/Real_constants_and_functions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Recaman's sequence",
    "url": "http://rosettacode.org/wiki/Recaman's_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Record sound",
    "url": "http://rosettacode.org/wiki/Record_sound"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Reduced row echelon form",
    "url": "http://rosettacode.org/wiki/Reduced_row_echelon_form"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Reflection/Get source",
    "url": "http://rosettacode.org/wiki/Reflection/Get_source"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Reflection/List methods",
    "url": "http://rosettacode.org/wiki/Reflection/List_methods"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Reflection/List properties",
    "url": "http://rosettacode.org/wiki/Reflection/List_properties"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Regular expressions",
    "url": "http://rosettacode.org/wiki/Regular_expressions"
  },
  {
    "local_code": "use std::collections::HashSet;\nuse std::hash::Hash;\n\n#[allow(dead_code)]\nfn remove_duplicate_elements_hashing<T: Hash + Eq>(elements: &mut Vec<T>) {\n    let set: HashSet<_> = elements.drain(..).collect();\n    elements.extend(set.into_iter());\n}\n\nfn remove_duplicate_elements_sorting<T: Ord>(elements: &mut Vec<T>) {\n    elements.sort_unstable(); // order does not matter\n    elements.dedup();\n}\n\nfn main() {\n    let mut sample_elements = vec![0, 0, 1, 1, 2, 3, 2];\n    println!(\"Before removal of duplicates : {:?}\", sample_elements);\n    remove_duplicate_elements_sorting(&mut sample_elements);\n    println!(\"After removal of duplicates : {:?}\", sample_elements);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_remove_duplicate_elements_hashing() {\n        let mut sample_elements = vec![0, 0, 1, 1, 2, 3, 2];\n        remove_duplicate_elements_hashing(&mut sample_elements);\n        sample_elements.sort_unstable();\n        assert_eq!(sample_elements, [0, 1, 2, 3])\n    }\n\n    #[test]\n    fn test_remove_duplicate_elements_sorting() {\n        let mut sample_elements = vec![0, 0, 1, 1, 2, 3, 2];\n        remove_duplicate_elements_sorting(&mut sample_elements);\n        assert_eq!(sample_elements, [0, 1, 2, 3])\n    }\n}\n",
    "path": "tasks/remove-duplicate-elements",
    "remote_code": "use std::collections::HashSet;\nuse std::hash::Hash;\n\nfn remove_duplicate_elements_hashing<T: Hash + Eq>(elements: &mut Vec<T>) {\n    let set: HashSet<_> = elements.drain(..).collect();\n    elements.extend(set.into_iter());\n}\n\nfn remove_duplicate_elements_sorting<T: Ord>(elements: &mut Vec<T>) {\n    elements.sort_unstable(); // order does not matter\n    elements.dedup();\n}\n\nfn main() {\n    let mut sample_elements = vec![0, 0, 1, 1, 2, 3, 2];\n    println!(\"Before removal of duplicates : {:?}\", sample_elements);\n    remove_duplicate_elements_sorting(&mut sample_elements);\n    println!(\"After removal of duplicates : {:?}\", sample_elements);\n}",
    "title": "Remove duplicate elements",
    "url": "http://rosettacode.org/wiki/Remove_duplicate_elements"
  },
  {
    "local_code": "extern crate structopt;\n\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\nuse std::path::PathBuf;\n\nuse structopt::StructOpt;\n\n#[derive(Debug, StructOpt)]\nstruct Opt {\n    /// The file that lines should be removed from\n    #[structopt(parse(from_os_str))]\n    file: PathBuf,\n\n    /// The first line number that should be removed (starting at 1)\n    start: usize,\n\n    /// The number of lines that should be removed\n    count: usize,\n}\n\nfn main() {\n    let opt = Opt::from_args();\n\n    let file = BufReader::new(File::open(opt.file).unwrap());\n\n    for (i, line) in file.lines().enumerate() {\n        let cur = i + 1;\n\n        if cur < opt.start || cur >= (opt.start + opt.count) {\n            println!(\"{}\", line.unwrap());\n        }\n    }\n}\n",
    "path": "tasks/remove-lines-from-a-file",
    "remote_code": "extern crate rustc_serialize;\nextern crate docopt;\n\nuse docopt::Docopt;\n\nuse std::io::{BufReader,BufRead};\nuse std::fs::File;\n\nconst USAGE: &'static str = \"\nUsage: rosetta <start> <count> <file>\n\";\n\n#[derive(Debug, RustcDecodable)]\nstruct Args {\n    arg_start: usize,\n    arg_count: usize,\n    arg_file: String,\n}\n\nfn main() {\n    let args: Args = Docopt::new(USAGE)\n        .and_then(|d| d.decode())\n        .unwrap_or_else(|e| e.exit());\n\n    let file = BufReader::new(File::open(args.arg_file).unwrap());\n\n    for (i, line) in file.lines().enumerate() {\n        let cur = i + 1;\n\n        if cur < args.arg_start || cur >= (args.arg_start + args.arg_count) {\n            println!(\"{}\", line.unwrap());\n        }\n    }\n}",
    "title": "Remove lines from a file",
    "url": "http://rosettacode.org/wiki/Remove_lines_from_a_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse std::fs;\n\nfn main() {\n    let err = \"File move error\";\n    fs::rename(\"input.txt\", \"output.txt\").ok().expect(err);\n    fs::rename(\"docs\", \"mydocs\").ok().expect(err);\n    fs::rename(\"/input.txt\", \"/output.txt\").ok().expect(err);\n    fs::rename(\"/docs\", \"/mydocs\").ok().expect(err);\n}\n",
    "title": "Rename a file",
    "url": "http://rosettacode.org/wiki/Rename_a_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Rendezvous",
    "url": "http://rosettacode.org/wiki/Rendezvous"
  },
  {
    "local_code": "fn main() {\n    for a_slice in &[\n        \"1001110011\",\n        \"1110111011\",\n        \"0010010010\",\n        \"1010101010\",\n        \"1111111111\",\n        \"0100101101\",\n        \"0100100\",\n        \"101\",\n        \"11\",\n        \"00\",\n        \"1\",\n    ] {\n        match rep_string(&a_slice) {\n            Some(repeated) => println!(\n                \"Longest rep-string for '{}' is '{}' ({} chars)\",\n                a_slice,\n                repeated,\n                repeated.len(),\n            ),\n            None => println!(\"No rep-string found for '{}'\", a_slice),\n        };\n    }\n}\n\nfn rep_string(string: &str) -> Option<&str> {\n    let index = string.len() / 2;\n\n    for split_index in (1..=index).rev() {\n        let mut is_rep_string = true;\n        let (first, last) = string.split_at(split_index);\n\n        let inter = last.chars().collect::<Vec<char>>();\n        let mut iter = inter.chunks_exact(split_index);\n        for chunk in iter.by_ref() {\n            if first != chunk.iter().collect::<String>() {\n                is_rep_string = false;\n                break;\n            }\n        }\n        let rmnd = iter.remainder().iter().collect::<String>();\n\n        // Check that the remainder starts with the rep-string\n        if !first.starts_with(rmnd.as_str()) {\n            is_rep_string = false;\n        }\n\n        if is_rep_string {\n            return Some(first);\n        }\n    }\n    None\n}\n\n#[cfg(test)]\nmod tests {\n    use super::rep_string;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_rep_string() {\n        let mut results = HashMap::new();\n        results.insert(String::from(\"1001110011\"), Some(\"10011\"));\n        results.insert(String::from(\"1110111011\"), Some(\"1110\"));\n        results.insert(String::from(\"0010010010\"), Some(\"001\"));\n        results.insert(String::from(\"1010101010\"), Some(\"1010\"));\n        results.insert(String::from(\"1111111111\"), Some(\"11111\"));\n        results.insert(String::from(\"0100101101\"), None);\n        results.insert(String::from(\"0100100\"), Some(\"010\"));\n        results.insert(String::from(\"101\"), None);\n        results.insert(String::from(\"11\"), Some(\"1\"));\n        results.insert(String::from(\"00\"), Some(\"0\"));\n        results.insert(String::from(\"1\"), None);\n\n        for (input, expected) in results {\n            assert_eq!(expected, rep_string(&input));\n        }\n    }\n}\n",
    "path": "tasks/rep-string",
    "remote_code": null,
    "title": "Rep-string",
    "url": "http://rosettacode.org/wiki/Rep-string"
  },
  {
    "local_code": "// Repeat the function f, n times.\nfn repeat<F>(f: &F, n: u32)\nwhere\n    F: Fn(),\n{\n    for _ in 0..n {\n        f();\n    }\n}\n\n// Repeat the mutable function f, n times.\nfn repeat_mut<F>(f: &mut F, n: u32)\nwhere\n    F: FnMut(),\n{\n    for _ in 0..n {\n        f();\n    }\n}\n\nfn static_fn() {\n    print!(\"Static \");\n}\n\nfn main() {\n    // Repeat a static function.\n    repeat(&static_fn, 4);\n\n    println!();\n\n    // Repeat an anonymous closure.\n    repeat(&|| print!(\"Closure \"), 5);\n\n    println!();\n\n    // Repeat a mutable closure (can modify local variables).\n    let mut x = 1;\n    println!(\"X is {}\", x);\n    repeat_mut(&mut || x += 1, 5);\n    println!(\"X is now {}\", x);\n}\n\n#[test]\nfn test_closure() {\n    let mut x = 1;\n\n    repeat_mut(&mut || x = x + 1, 5);\n\n    assert_eq!(x, 6);\n}\n",
    "path": "tasks/repeat",
    "remote_code": "// Repeat the function f, n times.\nfn repeat<F>(f: &F, n: u32)\n    where F: Fn() {\n    for _ in 0..n {\n        f();\n    }\n}\n\nfn static_fn() {\n    print!(\"Static \");\n}\n\nfn main() {\n    // Repeat a static function.\n    repeat(&static_fn, 4);\n\n    println!(\"\");\n\n    // Repeat an anonymous closure.\n    repeat(&|| print!(\"Closure \"), 5);\n}",
    "title": "Repeat",
    "url": "http://rosettacode.org/wiki/Repeat"
  },
  {
    "local_code": "use std::fs;\n\nfn main() {\n    fs::rename(\"input.txt\", \"output.txt\").unwrap();\n    fs::rename(\"docs\", \"mydocs\").unwrap();\n    fs::rename(\"/input.txt\", \"/output.txt\").unwrap();\n    fs::rename(\"/docs\", \"/mydocs\").unwrap();\n}\n",
    "path": "tasks/rename-a-file",
    "remote_code": "std::iter::repeat(\"ha\").take(5).collect::<String>(); // ==> \"hahahahaha\"",
    "title": "Repeat a string",
    "url": "http://rosettacode.org/wiki/Repeat_a_string"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Resistor mesh",
    "url": "http://rosettacode.org/wiki/Resistor_mesh"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Respond to an unknown method call",
    "url": "http://rosettacode.org/wiki/Respond_to_an_unknown_method_call"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Retrieve and search chat history",
    "url": "http://rosettacode.org/wiki/Retrieve_and_search_chat_history"
  },
  {
    "local_code": "fn multi_hello() -> (&'static str, i32) {\n    (\"Hello\", 42)\n}\n\nfn main() {\n    let (string, num) = multi_hello();\n    println!(\"{}, {}\", string, num);\n}\n",
    "path": "tasks/return-multiple-values",
    "remote_code": "fn multi_hello() -> (&'static str, i32) {\n    (\"Hello\",42)\n}\n\nfn main() {\n    let (str,num)=multi_hello();\n    println!(\"{},{}\",str,num);\n}\n",
    "title": "Return multiple values",
    "url": "http://rosettacode.org/wiki/Return_multiple_values"
  },
  {
    "local_code": "extern crate unicode_segmentation;\n\nuse unicode_segmentation::UnicodeSegmentation;\n\nfn main() {\n    let s = \"一二三四五六七八九十\";\n    let s2 = \"as⃝df̅\";\n    let reversed: String = s.chars().rev().collect();\n    let reversed2: String = UnicodeSegmentation::graphemes(s2, true).rev().collect();\n    println!(\"{}\", reversed);\n    println!(\"{}\", reversed2);\n}\n",
    "path": "tasks/reverse-a-string",
    "remote_code": "extern crate unicode_segmentation;\nuse unicode_segmentation::UnicodeSegmentation;\n\nfn main() {\n    let s = \"一二三四五六七八九十\";\n    let s2 = \"as⃝df̅\";\n    let reversed: String = s.chars().rev().collect();\n    let reversed2: String = UnicodeSegmentation::graphemes(s2, true)\n        .rev().collect();\n    println!(\"{}\", reversed);\n    println!(\"{}\", reversed2);\n}",
    "title": "Reverse a string",
    "url": "http://rosettacode.org/wiki/Reverse_a_string"
  },
  {
    "local_code": "fn rev_words(line: &str) -> String {\n    line.split_whitespace()\n        .rev()\n        .collect::<Vec<&str>>()\n        .join(\" \")\n}\n\nfn rev_words_on_lines(text: &str) -> String {\n    text.lines()\n        .map(rev_words)\n        .collect::<Vec<String>>()\n        .join(\"\\n\")\n}\n\nfn main() {\n    let text = r\"---------- Ice and Fire ------------\n\nfire, in end will world the say Some\nice. in say Some\ndesire of tasted I've what From\nfire. favor who those with hold I\n\n... elided paragraph last ...\n\nFrost Robert -----------------------\";\n\n    println!(\"{}\", rev_words_on_lines(text));\n}\n\n#[test]\nfn test_rev_words() {\n    let tests = [\n        (\"\", \"\"),\n        (\"a\", \"a\"),\n        (\"a b\", \"b a\"),\n        (\"cat dog\", \"dog cat\"),\n        // According to the problem, multiple spaces can be\n        // compressed into a single space.\n        (\"cat     dog\", \"dog cat\"),\n        (\"cat dog frog\", \"frog dog cat\"),\n    ];\n\n    for &(input, expected) in &tests {\n        let output = rev_words(input);\n        assert_eq!(expected, output);\n    }\n}\n\n#[test]\nfn test_rev_words_on_lines() {\n    // The tests from test_rev_words should have the same results, so\n    // we include them.\n    let tests = [\n        (\"\", \"\"),\n        (\"a\", \"a\"),\n        (\"a b\", \"b a\"),\n        (\"cat dog\", \"dog cat\"),\n        // According to the problem, multiple spaces can be\n        // compressed into a single space.\n        (\"cat     dog\", \"dog cat\"),\n        (\"cat dog frog\", \"frog dog cat\"),\n        // Multiple Lines\n        (\"a b\\nb a\", \"b a\\na b\"),\n        (\"a b\\nc d\\ne f\", \"b a\\nd c\\nf e\"),\n    ];\n\n    for &(input, expected) in &tests {\n        let output = rev_words_on_lines(input);\n        assert_eq!(expected, output);\n    }\n}\n",
    "path": "tasks/reverse-words-in-a-string",
    "remote_code": "const TEXT: &'static str = \n\"---------- Ice and Fire ------------\n \nfire, in end will world the say Some\nice. in say Some\ndesire of tasted I've what From\nfire. favor who those with hold I\n \n... elided paragraph last ...\n \nFrost Robert -----------------------\";\n \nfn main() {\n    println!(\"{}\", \n             TEXT.lines() // Returns iterator over lines\n             .map(|line|  // Applies closure to each item in iterator (for each line)\n                  line.split_whitespace() // Returns iterator of words\n                  .rev() // Reverses iterator of words\n                  .collect::<Vec<_>>() // Collects words into Vec<&str>\n                  .join(\" \")) // Convert vector of words back into line\n             .collect::<Vec<_>>() // Collect lines into Vec<String>\n             .join(\"\\n\")); // Concatenate lines into String\n}",
    "title": "Reverse words in a string",
    "url": "http://rosettacode.org/wiki/Reverse_words_in_a_string"
  },
  {
    "local_code": "extern crate rand;\n\nuse std::io;\n\nuse rand::distributions::{Standard, Uniform};\nuse rand::prelude::*;\n\nuse Choice::*;\n\n#[derive(PartialEq, Clone, Copy, Debug)]\nenum Choice {\n    Rock,\n    Paper,\n    Scissors,\n}\n\nimpl Distribution<Choice> for Standard {\n    fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Choice {\n        // Use `Uniform` rather than `gen_range`'s `Uniform::sample_single` for speed\n        let range = Uniform::new(0, 3);\n        match rng.sample(range) {\n            0 => Rock,\n            1 => Paper,\n            2 => Scissors,\n            _ => unreachable!(), // `_ | 2` would remove the check\n        }\n    }\n}\n\nfn beats(c1: Choice, c2: Choice) -> bool {\n    (c1 == Rock && c2 == Scissors) || (c1 == Scissors && c2 == Paper) || (c1 == Paper && c2 == Rock)\n}\n\nfn ai_move<R: Rng>(rng: &mut R, v: [usize; 3]) -> Choice {\n    // weighted random choice, a dynamic version of `rand::distributions::WeightedChoice`\n    let rand = rng.gen_range(0, v[0] + v[1] + v[2]);\n    if rand < v[0] {\n        Paper\n    } else if rand < v[0] + v[1] {\n        Scissors\n    } else {\n        Rock\n    }\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n\n    println!(\"Rock, paper, scissors!\");\n    let mut ai_choice: Choice = rng.gen();\n    let mut ucf = [0, 0, 0]; // user choice frequency\n    let mut score = [0, 0];\n\n    loop {\n        println!(\"Please input your move: 'r', 'p' or 's'. Type 'q' to quit\");\n\n        let mut input = String::new();\n        io::stdin()\n            .read_line(&mut input)\n            .expect(\"failed to read line\");\n        // trim leading whitespace, get first lowercase character\n        let u_choice = match input\n            .trim_start()\n            .chars()\n            .next()\n            .and_then(|c| c.to_lowercase().next())\n        {\n            Some('r') => {\n                ucf[0] += 1;\n                Rock\n            }\n            Some('p') => {\n                ucf[1] += 1;\n                Paper\n            }\n            Some('s') => {\n                ucf[2] += 1;\n                Scissors\n            }\n            Some('q') => break,\n            _ => {\n                println!(\"Please enter a correct choice!\");\n                continue;\n            }\n        };\n        println!(\"You chose {:?}, I chose {:?}.\", u_choice, ai_choice);\n        if beats(u_choice, ai_choice) {\n            score[0] += 1;\n            println!(\"You win!\");\n        } else if u_choice == ai_choice {\n            println!(\"It's a tie!\");\n        } else {\n            score[1] += 1;\n            println!(\"I win!\");\n        }\n        println!(\"-Score: You {}, Me {}\", score[0], score[1]);\n\n        // only after the 1st iteration the AI knows the stats and can make\n        // its weighted random move\n        ai_choice = ai_move(&mut rng, ucf);\n    }\n    println!(\"Thank you for the game!\");\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_victory() {\n        assert!(beats(Scissors, Paper));\n        assert!(beats(Rock, Scissors));\n        assert!(beats(Paper, Rock));\n    }\n\n    #[test]\n    fn rand_choice() {\n        let mut rng = thread_rng();\n        for _ in 0..4 {\n            rng.gen::<Choice>();\n        }\n    }\n}\n",
    "path": "tasks/rock-paper-scissors",
    "remote_code": null,
    "title": "Rock-paper-scissors",
    "url": "http://rosettacode.org/wiki/Rock-paper-scissors"
  },
  {
    "local_code": "struct RomanNumeral {\n    symbol: &'static str,\n    value: u32,\n}\n\nconst NUMERALS: [RomanNumeral; 13] = [\n    RomanNumeral {\n        symbol: \"M\",\n        value: 1000,\n    },\n    RomanNumeral {\n        symbol: \"CM\",\n        value: 900,\n    },\n    RomanNumeral {\n        symbol: \"D\",\n        value: 500,\n    },\n    RomanNumeral {\n        symbol: \"CD\",\n        value: 400,\n    },\n    RomanNumeral {\n        symbol: \"C\",\n        value: 100,\n    },\n    RomanNumeral {\n        symbol: \"XC\",\n        value: 90,\n    },\n    RomanNumeral {\n        symbol: \"L\",\n        value: 50,\n    },\n    RomanNumeral {\n        symbol: \"XL\",\n        value: 40,\n    },\n    RomanNumeral {\n        symbol: \"X\",\n        value: 10,\n    },\n    RomanNumeral {\n        symbol: \"IX\",\n        value: 9,\n    },\n    RomanNumeral {\n        symbol: \"V\",\n        value: 5,\n    },\n    RomanNumeral {\n        symbol: \"IV\",\n        value: 4,\n    },\n    RomanNumeral {\n        symbol: \"I\",\n        value: 1,\n    },\n];\n\nfn to_hindu(roman: &str) -> u32 {\n    match NUMERALS.iter().find(|num| roman.starts_with(num.symbol)) {\n        Some(num) => num.value + to_hindu(&roman[num.symbol.len()..]),\n        None => 0, // if string empty, add nothing\n    }\n}\n\nfn main() {\n    let roms = [\"MMXIV\", \"MCMXCIX\", \"XXV\", \"MDCLXVI\", \"MMMDCCCLXXXVIII\"];\n    for &r in &roms {\n        // 15 is minimum formatting width of the first argument, there for alignment\n        println!(\"{:2$} = {}\", r, to_hindu(r), 15);\n    }\n}\n",
    "path": "tasks/roman-numerals/decode",
    "remote_code": "struct RomanNumeral {\n    symbol: &'static str,\n    value: u32\n}\n\nconst NUMERALS: [RomanNumeral; 13] = [\n    RomanNumeral {symbol: \"M\",  value: 1000},\n    RomanNumeral {symbol: \"CM\", value: 900},\n    RomanNumeral {symbol: \"D\",  value: 500},\n    RomanNumeral {symbol: \"CD\", value: 400},\n    RomanNumeral {symbol: \"C\",  value: 100},\n    RomanNumeral {symbol: \"XC\", value: 90},\n    RomanNumeral {symbol: \"L\",  value: 50},\n    RomanNumeral {symbol: \"XL\", value: 40},\n    RomanNumeral {symbol: \"X\",  value: 10},\n    RomanNumeral {symbol: \"IX\", value: 9},\n    RomanNumeral {symbol: \"V\",  value: 5},\n    RomanNumeral {symbol: \"IV\", value: 4},\n    RomanNumeral {symbol: \"I\",  value: 1}\n];\n\nfn to_hindu(roman: &str) -> u32 {\n    match NUMERALS.iter().find(|num| roman.starts_with(num.symbol)) {\n        Some(num) => num.value + to_hindu(&roman[num.symbol.len()..]),\n        None => 0, // if string empty, add nothing\n    }\n}\n\nfn main() {\n    let roms = [\"MMXIV\", \"MCMXCIX\", \"XXV\", \"MDCLXVI\", \"MMMDCCCLXXXVIII\"];\n    for &r in &roms {\n        // 15 is minimum formatting width of the first argument, there for alignment\n        println!(\"{:2$} = {}\", r, to_hindu(r), 15);\n    }\n}",
    "title": "Roman numerals/Decode",
    "url": "http://rosettacode.org/wiki/Roman_numerals/Decode"
  },
  {
    "local_code": "struct RomanNumeral {\n    symbol: &'static str,\n    value: u32,\n}\n\nconst NUMERALS: [RomanNumeral; 13] = [\n    RomanNumeral {\n        symbol: \"M\",\n        value: 1000,\n    },\n    RomanNumeral {\n        symbol: \"CM\",\n        value: 900,\n    },\n    RomanNumeral {\n        symbol: \"D\",\n        value: 500,\n    },\n    RomanNumeral {\n        symbol: \"CD\",\n        value: 400,\n    },\n    RomanNumeral {\n        symbol: \"C\",\n        value: 100,\n    },\n    RomanNumeral {\n        symbol: \"XC\",\n        value: 90,\n    },\n    RomanNumeral {\n        symbol: \"L\",\n        value: 50,\n    },\n    RomanNumeral {\n        symbol: \"XL\",\n        value: 40,\n    },\n    RomanNumeral {\n        symbol: \"X\",\n        value: 10,\n    },\n    RomanNumeral {\n        symbol: \"IX\",\n        value: 9,\n    },\n    RomanNumeral {\n        symbol: \"V\",\n        value: 5,\n    },\n    RomanNumeral {\n        symbol: \"IV\",\n        value: 4,\n    },\n    RomanNumeral {\n        symbol: \"I\",\n        value: 1,\n    },\n];\n\nfn to_roman(mut number: u32) -> String {\n    let mut min_numeral = String::new();\n    for numeral in &NUMERALS {\n        while numeral.value <= number {\n            min_numeral += numeral.symbol;\n            number -= numeral.value;\n        }\n    }\n    min_numeral\n}\n\nfn main() {\n    let nums = [2014, 1999, 25, 1666, 3888];\n    for n in &nums {\n        // 4 is minimum printing width, for alignment\n        println!(\"{:2$} = {}\", n, to_roman(*n), 4);\n    }\n}\n",
    "path": "tasks/roman-numerals/encode",
    "remote_code": "struct RomanNumeral {\n    symbol: &'static str,\n    value: u32\n}\n\nconst NUMERALS: [RomanNumeral; 13] = [\n    RomanNumeral {symbol: \"M\",  value: 1000},\n    RomanNumeral {symbol: \"CM\", value: 900},\n    RomanNumeral {symbol: \"D\",  value: 500},\n    RomanNumeral {symbol: \"CD\", value: 400},\n    RomanNumeral {symbol: \"C\",  value: 100},\n    RomanNumeral {symbol: \"XC\", value: 90},\n    RomanNumeral {symbol: \"L\",  value: 50},\n    RomanNumeral {symbol: \"XL\", value: 40},\n    RomanNumeral {symbol: \"X\",  value: 10},\n    RomanNumeral {symbol: \"IX\", value: 9},\n    RomanNumeral {symbol: \"V\",  value: 5},\n    RomanNumeral {symbol: \"IV\", value: 4},\n    RomanNumeral {symbol: \"I\",  value: 1}\n];\n\nfn to_roman(mut number: u32) -> String {\n    let mut min_numeral = String::new();\n    for numeral in NUMERALS.iter() {\n        while numeral.value <= number {\n            min_numeral = min_numeral + numeral.symbol;\n            number -= numeral.value;\n        }\n    }\n    min_numeral\n}\n\nfn main() {\n    let nums = [2014, 1999, 25, 1666, 3888];\n    for &n in nums.iter() {\n        // 4 is minimum printing width, for alignment\n        println!(\"{:2$} = {}\", n, to_roman(n), 4);\n    }\n}",
    "title": "Roman numerals/Encode",
    "url": "http://rosettacode.org/wiki/Roman_numerals/Encode"
  },
  {
    "local_code": "extern crate num;\n\nuse num::Float;\n\n/// Note: We cannot use `range_step` here because Floats don't implement\n/// the `CheckedAdd` trait.\nfn find_roots<T, F>(f: F, start: T, stop: T, step: T, epsilon: T) -> Vec<T>\nwhere\n    T: Copy + PartialOrd + Float,\n    F: Fn(T) -> T,\n{\n    let mut ret = vec![];\n    let mut current = start;\n    while current < stop {\n        if f(current).abs() < epsilon {\n            ret.push(current);\n        }\n        current = current + step;\n    }\n    ret\n}\n\n#[test]\nfn test_find_roots() {\n    let roots = find_roots(\n        |x: f64| x * x * x - 3.0 * x * x + 2.0 * x,\n        -1.0,\n        3.0,\n        0.0001,\n        0.00000001,\n    );\n    let expected = [0.0f64, 1.0, 2.0];\n\n    for (&a, &b) in roots.iter().zip(expected.iter()) {\n        assert!((a - b).abs() < 0.0001);\n    }\n}\n\nfn main() {\n    let roots = find_roots(\n        |x: f64| x * x * x - 3.0 * x * x + 2.0 * x,\n        -1.0,\n        3.0,\n        0.0001,\n        0.00000001,\n    );\n\n    println!(\"roots of f(x) = x^3 - 3x^2 + 2x are: {:?}\", roots);\n}\n",
    "path": "tasks/roots-of-a-function",
    "remote_code": null,
    "title": "Roots of a function",
    "url": "http://rosettacode.org/wiki/Roots_of_a_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Roots of a quadratic function",
    "url": "http://rosettacode.org/wiki/Roots_of_a_quadratic_function"
  },
  {
    "local_code": "extern crate num;\n\nuse std::f32::consts;\n\nuse num::complex::{Complex, Complex32};\n\nfn main() {\n    let degree = 3;\n\n    for root in &roots_of_unity(degree) {\n        println!(\"{}\", root);\n    }\n}\n\nfn roots_of_unity(degree: usize) -> Vec<Complex32> {\n    (0..degree)\n        .map(|el| {\n            Complex::<f32>::from_polar(&1f32, &(2f32 * consts::PI * (el as f32) / (degree as f32)))\n        })\n        .collect::<Vec<Complex32>>()\n}\n\n#[test]\nfn test_result() {\n    let expected = vec![\n        Complex::new(1f32, 0.),\n        Complex::new(-0.5, 0.866025),\n        Complex::new(-0.5, -0.866025),\n    ];\n\n    for (root, &exp) in roots_of_unity(3).iter().zip(expected.iter()) {\n        assert!((*root - exp).norm() < 1e-6);\n    }\n}\n",
    "path": "tasks/roots-of-unity",
    "remote_code": null,
    "title": "Roots of unity",
    "url": "http://rosettacode.org/wiki/Roots_of_unity"
  },
  {
    "local_code": "extern crate count_examples;\nfn main() {\n    let all_tasks = count_examples::query_all_tasks();\n    for task in &all_tasks {\n        let count = count_examples::query_a_task(task);\n        println!(\"Task: {} has {} examples\", task.title, count);\n    }\n}\nuse reqwest::Url;\nuse serde::Deserialize;\nuse serde_json::Value;\n\n#[derive(Deserialize)]\npub struct Task {\n    #[serde(rename = \"pageid\")]\n    page_id: u64,\n    pub title: String,\n}\n\n#[derive(Debug)]\nenum ParseError {\n    /// Something went wrong with the HTTP request to the API.\n    Http(reqwest::Error),\n\n    /// There was a problem parsing the API response into JSON.\n    Json(serde_json::Error),\n\n    /// Unexpected JSON format from response\n    UnexpectedFormat,\n}\n\nimpl From<serde_json::Error> for ParseError {\n    fn from(error: serde_json::Error) -> Self {\n        ParseError::Json(error)\n    }\n}\n\nimpl From<reqwest::Error> for ParseError {\n    fn from(error: reqwest::Error) -> Self {\n        ParseError::Http(error)\n    }\n}\n\nfn construct_query_category(category: &str) -> Url {\n    let mut base_url = Url::parse(\"http://rosettacode.org/mw/api.php\").unwrap();\n    let cat = format!(\"Category:{}\", category);\n    let query_pairs = vec![\n        (\"action\", \"query\"),\n        (\"format\", \"json\"),\n        (\"list\", \"categorymembers\"),\n        (\"cmlimit\", \"500\"),\n        (\"cmtitle\", &cat),\n        (\"continue\", \"\"),\n    ];\n    base_url\n        .query_pairs_mut()\n        .extend_pairs(query_pairs.into_iter());\n    base_url\n}\n\nfn construct_query_task_content(task_id: &str) -> Url {\n    let mut base_url = Url::parse(\"http://rosettacode.org/mw/api.php\").unwrap();\n    let mut query_pairs = vec![\n        (\"action\", \"query\"),\n        (\"format\", \"json\"),\n        (\"prop\", \"revisions\"),\n        (\"rvprop\", \"content\"),\n    ];\n    query_pairs.push((\"pageids\", task_id));\n    base_url\n        .query_pairs_mut()\n        .extend_pairs(query_pairs.into_iter());\n    base_url\n}\n\nfn query_api(url: Url) -> Result<Value, ParseError> {\n    Ok(reqwest::get(url)?.json()?)\n}\n\nfn parse_all_tasks(reply: &Value) -> Result<Vec<Task>, ParseError> {\n    let tasks_json = reply\n        .pointer(\"/query/categorymembers\")\n        .and_then(|tasks| tasks.as_array())\n        .ok_or(ParseError::UnexpectedFormat)?;\n\n    tasks_json\n        .iter()\n        .map(|json| Task::deserialize(json).map_err(From::from))\n        .collect()\n}\n\nfn count_number_examples(task: &Value, task_id: u64) -> Result<u32, ParseError> {\n    let revisions = task\n        .pointer(&format!(\"/query/pages/{}/revisions\", task_id.to_string()))\n        .and_then(|content| content.as_array())\n        .ok_or(ParseError::UnexpectedFormat)?;\n    let content = revisions[0]\n        .get(\"*\")\n        .and_then(Value::as_str)\n        .ok_or(ParseError::UnexpectedFormat)?;\n    Ok(content.split(\"=={{header\").count() as u32)\n}\n\npub fn query_all_tasks() -> Vec<Task> {\n    let query = construct_query_category(\"Programming_Tasks\");\n    let json: Value = query_api(query).unwrap();\n    parse_all_tasks(&json).unwrap()\n}\n\npub fn query_a_task(task: &Task) -> u32 {\n    let query = construct_query_task_content(&task.page_id.to_string());\n    let json: Value = query_api(query).unwrap();\n    count_number_examples(&json, task.page_id).unwrap()\n}\n",
    "path": "tasks/rosetta-code/count-examples",
    "remote_code": "extern crate reqwest;\nextern crate url;\nextern crate rustc_serialize;\n\nuse std::io::Read;\nuse self::url::Url;\nuse rustc_serialize::json::{self, Json};\n\npub struct Task {\n    page_id: u64,\n    pub title: String,\n}\n\n#[derive(Debug)]\nenum ParseError {\n    /// Something went wrong with the HTTP request to the API.\n    Http(reqwest::Error),\n\n    /// There was a problem parsing the API response into JSON.\n    Json(json::ParserError),\n\n    /// Unexpected JSON format from response\n    UnexpectedFormat,\n}\nimpl From<json::ParserError> for ParseError {\n    fn from(error: json::ParserError) -> Self {\n        ParseError::Json(error)\n    }\n}\n\nimpl From<reqwest::Error> for ParseError {\n    fn from(error: reqwest::Error) -> Self {\n        ParseError::Http(error)\n    }\n}\n\n\nfn construct_query_category(category: &str) -> Url {\n    let mut base_url = Url::parse(\"http://rosettacode.org/mw/api.php\").unwrap();\n    let cat = format!(\"Category:{}\", category);\n    let query_pairs = vec![(\"action\", \"query\"),\n                           (\"format\", \"json\"),\n                           (\"list\", \"categorymembers\"),\n                           (\"cmlimit\", \"500\"),\n                           (\"cmtitle\", &cat),\n                           (\"continue\", \"\")];\n    base_url.query_pairs_mut().extend_pairs(query_pairs.into_iter());\n    base_url\n}\n\nfn construct_query_task_content(task_id: &str) -> Url {\n    let mut base_url = Url::parse(\"http://rosettacode.org/mw/api.php\").unwrap();\n    let mut query_pairs =\n        vec![(\"action\", \"query\"), (\"format\", \"json\"), (\"prop\", \"revisions\"), (\"rvprop\", \"content\")];\n    query_pairs.push((\"pageids\", task_id));\n    base_url.query_pairs_mut().extend_pairs(query_pairs.into_iter());\n    base_url\n}\n\nfn query_api(url: Url) -> Result<Json, ParseError> {\n    let mut response = try!(reqwest::get(url.as_str()));\n    // Build JSON\n    let mut body = String::new();\n    response.read_to_string(&mut body).unwrap();\n\n    Ok(try!(Json::from_str(&body)))\n}\n\nfn parse_all_tasks(reply: &Json) -> Result<Vec<Task>, ParseError> {\n    let json_to_task = |json: &Json| -> Result<Task, ParseError> {\n        let page_id: u64 = try!(json.find(\"pageid\")\n            .and_then(|id| id.as_u64())\n            .ok_or(ParseError::UnexpectedFormat));\n        let title: &str = try!(json.find(\"title\")\n            .and_then(|title| title.as_string())\n            .ok_or(ParseError::UnexpectedFormat));\n\n        Ok(Task {\n            page_id: page_id,\n            title: title.to_owned(),\n        })\n    };\n    let tasks_json = try!(reply.find_path(&[\"query\", \"categorymembers\"])\n        .and_then(|tasks| tasks.as_array())\n        .ok_or(ParseError::UnexpectedFormat));\n\n    // Convert into own type\n    tasks_json.iter().map(json_to_task).collect()\n}\nfn count_number_examples(task: &Json, task_id: u64) -> Result<u32, ParseError> {\n    let revisions =\n        try!(task.find_path(&[\"query\", \"pages\", task_id.to_string().as_str(), \"revisions\"])\n            .and_then(|content| content.as_array())\n            .ok_or(ParseError::UnexpectedFormat));\n    let content = try!(revisions[0]\n        .find(\"*\")\n        .and_then(|content| content.as_string())\n        .ok_or(ParseError::UnexpectedFormat));\n    Ok(content.split(\"=={{header\").count() as u32)\n}\n\npub fn query_all_tasks() -> Vec<Task> {\n    let query = construct_query_category(\"Programming_Tasks\");\n    let json: Json = query_api(query).unwrap();\n    parse_all_tasks(&json).unwrap()\n}\n\npub fn query_a_task(task: &Task) -> u32 {\n    let query = construct_query_task_content(&task.page_id.to_string());\n    let json: Json = query_api(query).unwrap();\n    count_number_examples(&json, task.page_id).unwrap()\n}",
    "title": "Rosetta Code/Count examples",
    "url": "http://rosettacode.org/wiki/Rosetta_Code/Count_examples"
  },
  {
    "local_code": "extern crate regex;\n\nuse std::io;\nuse std::io::prelude::*;\n\nuse regex::Regex;\n\nfn find_bare_lang_tags(input: &str) -> Vec<(Option<String>, i32)> {\n    let mut language_pairs = vec![];\n    let mut language = None;\n    let mut counter = 0_i32;\n\n    let header_re = Regex::new(r\"==\\{\\{header\\|(?P<lang>[[:alpha:]]+)\\}\\}==\").unwrap();\n\n    for line in input.lines() {\n        if let Some(captures) = header_re.captures(line) {\n            if let Some(header_lang) = captures.name(\"lang\") {\n                language_pairs.push((language, counter));\n                language = Some(header_lang.as_str().to_owned());\n                counter = 0;\n            }\n        }\n\n        if line.contains(\"<lang>\") {\n            counter += 1;\n        }\n    }\n\n    language_pairs.push((language, counter));\n    language_pairs\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut buf = String::new();\n    stdin.lock().read_to_string(&mut buf).unwrap();\n    let results = find_bare_lang_tags(&buf);\n    let total_bare = results.iter().map(|r| r.1).sum::<i32>();\n\n    println!(\"{} bare language tags.\\n\", total_bare);\n    for result in &results {\n        let num_bare = result.1;\n\n        if num_bare > 0 {\n            println!(\n                \"{} in {}\",\n                result.1,\n                result\n                    .0\n                    .to_owned()\n                    .unwrap_or_else(|| String::from(\"no language\"))\n            );\n        }\n    }\n}\n\n#[test]\nfn test_bare_tags() {\n    let input = r#\"\n    Description\n    <lang>Pseudocode</lang>\n\n    =={{header|C}}==\n    <lang C>printf(\"Hello world!\\n\");</lang>\n\n    =={{header|Perl}}==\n    <lang>print \"Hello world!\\n\"</lang>\"#;\n\n    let expected = vec![\n        (None, 1),\n        (Some(\"C\".to_owned()), 0),\n        (Some(\"Perl\".to_owned()), 1),\n    ];\n\n    assert_eq!(expected, find_bare_lang_tags(&input));\n}\n",
    "path": "tasks/rosetta-code/find-bare-lang-tags",
    "remote_code": null,
    "title": "Rosetta Code/Find bare lang tags",
    "url": "http://rosettacode.org/wiki/Rosetta_Code/Find_bare_lang_tags"
  },
  {
    "local_code": "use std::collections::{BTreeMap, HashSet};\n\nuse reqwest::Url;\nuse serde::Deserialize;\nuse serde_json::Value;\n\n/// A Rosetta Code task.\n#[derive(Clone, PartialEq, Eq, Hash, Debug, Deserialize)]\npub struct Task {\n    /// The ID of the page containing the task in the MediaWiki API.\n    #[serde(rename = \"pageid\")]\n    pub id: u64,\n\n    /// The human-readable title of the task.\n    pub title: String,\n}\n\n/// Encapsulates errors that might occur during JSON parsing.\n#[derive(Debug)]\nenum TaskParseError {\n    /// Something went wrong with the HTTP request to the API.\n    Http(reqwest::Error),\n\n    /// Could not parse a URL\n    Url(reqwest::UrlError),\n\n    /// There was a problem parsing the API response into JSON.\n    Json(serde_json::Error),\n\n    /// The response JSON contained unexpected keys or values.\n    UnexpectedFormat,\n}\n\nimpl From<serde_json::Error> for TaskParseError {\n    fn from(err: serde_json::Error) -> Self {\n        TaskParseError::Json(err)\n    }\n}\n\nimpl From<reqwest::UrlError> for TaskParseError {\n    fn from(err: reqwest::UrlError) -> Self {\n        TaskParseError::Url(err)\n    }\n}\n\nimpl From<reqwest::Error> for TaskParseError {\n    fn from(err: reqwest::Error) -> Self {\n        TaskParseError::Http(err)\n    }\n}\n\n/// Represents a category of pages on Rosetta Code, such as \"Rust\".\nstruct Category {\n    name: String,\n    continue_params: Option<BTreeMap<String, String>>,\n}\n\nimpl Category {\n    fn new(name: &str) -> Category {\n        let mut continue_params = BTreeMap::new();\n        continue_params.insert(\"continue\".to_owned(), \"\".to_owned());\n\n        Category {\n            name: name.to_owned(),\n            continue_params: Some(continue_params),\n        }\n    }\n}\n\n/// Sends a request to Rosetta Code through the MediaWiki API. If successful, returns the response\n/// as a JSON object.\nfn query_api(\n    category_name: &str,\n    continue_params: &BTreeMap<String, String>,\n) -> Result<Value, TaskParseError> {\n    let mut url = Url::parse(\"http://rosettacode.org/mw/api.php\")?;\n    url.query_pairs_mut()\n        .append_pair(\"action\", \"query\")\n        .append_pair(\"list\", \"categorymembers\")\n        .append_pair(\"cmtitle\", &format!(\"Category:{}\", category_name))\n        .append_pair(\"cmlimit\", \"500\")\n        .append_pair(\"format\", \"json\")\n        .extend_pairs(continue_params);\n\n    Ok(reqwest::get(url)?.json()?)\n}\n\n/// Given a JSON object, parses the task information from the MediaWiki API response.\nfn parse_tasks(json: &Value) -> Result<Vec<Task>, TaskParseError> {\n    let tasks_json = json\n        .pointer(\"/query/categorymembers\")\n        .and_then(Value::as_array)\n        .ok_or(TaskParseError::UnexpectedFormat)?;\n\n    tasks_json\n        .iter()\n        .map(|json| Task::deserialize(json).map_err(From::from))\n        .collect()\n}\n\nimpl Iterator for Category {\n    type Item = Vec<Task>;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.continue_params.is_none() {\n            return None;\n        }\n\n        query_api(&self.name, self.continue_params.as_ref().unwrap())\n            .and_then(|result| {\n                // If there are more pages of results to request, save them for the next iteration.\n                self.continue_params =\n                    result\n                        .get(\"continue\")\n                        .and_then(Value::as_object)\n                        .map(|continue_params| {\n                            continue_params\n                                .iter()\n                                .map(|(key, value)| {\n                                    (key.to_owned(), value.as_str().unwrap().to_owned())\n                                })\n                                .collect()\n                        });\n\n                parse_tasks(&result)\n            })\n            .map_err(|err| println!(\"Error parsing response: {:?}\", err))\n            .ok()\n    }\n}\n\npub fn all_tasks() -> Vec<Task> {\n    Category::new(\"Programming Tasks\")\n        .flat_map(|tasks| tasks)\n        .collect()\n}\n\npub fn unimplemented_tasks(lang: &str) -> Vec<Task> {\n    let all_tasks = all_tasks().iter().cloned().collect::<HashSet<_>>();\n    let implemented_tasks = Category::new(lang)\n        .flat_map(|tasks| tasks)\n        .collect::<HashSet<_>>();\n    let mut unimplemented_tasks = all_tasks\n        .difference(&implemented_tasks)\n        .cloned()\n        .collect::<Vec<Task>>();\n    unimplemented_tasks.sort_by(|a, b| a.title.cmp(&b.title));\n    unimplemented_tasks\n}\nextern crate find_unimplemented_tasks;\n\nfn main() {\n    for task in find_unimplemented_tasks::unimplemented_tasks(\"Rust\") {\n        println!(\"{:6} {}\", task.id, task.title);\n    }\n}\n",
    "path": "tasks/rosetta-code/find-unimplemented-tasks",
    "remote_code": null,
    "title": "Rosetta Code/Find unimplemented tasks",
    "url": "http://rosettacode.org/wiki/Rosetta_Code/Find_unimplemented_tasks"
  },
  {
    "local_code": "extern crate regex;\n\nuse std::io;\nuse std::io::prelude::*;\n\nuse regex::Regex;\n\nconst LANGUAGES: &str =\n    \"_div abap actionscript actionscript3 ada apache applescript apt_sources asm asp autoit \\\n     avisynth bash basic4gl bf blitzbasic bnf boo c c_mac caddcl cadlisp cfdg cfm cil cobol cpp \\\n     cpp-qt csharp css d delphi diff dos dot eiffel email fortran freebasic genero gettext glsl \\\n     gml gnuplot groovy haskell hq9plus html4strict idl ini inno intercal io java java5 \\\n     javascript kixtart klonec klonecpp latex lisp lolcode lotusformulas lotusscript lscript lua \\\n     m68k make matlab mirc modula3 mpasm mxml mysql nsis objc ocaml ocaml-brief oobas oracle11 \\\n     oracle8 pascal per perl php php-brief pic16 pixelbender plsql povray powershell progress \\\n     prolog providex python qbasic rails reg robots ruby rust sas scala scheme scilab sdlbasic \\\n     smalltalk smarty sql tcl teraterm text thinbasic tsql typoscript vb vbnet verilog vhdl vim \\\n     visualfoxpro visualprolog whitespace winbatch xml xorg_conf xpp z80\";\n\nfn fix_tags(languages: &[&str], text: &str) -> String {\n    let mut replaced_text = text.to_owned();\n\n    for lang in languages.iter() {\n        let bad_open = Regex::new(&format!(\"<{lang}>|<code {lang}>\", lang = lang)).unwrap();\n        let bad_close = Regex::new(&format!(\"</{lang}>|</code>\", lang = lang)).unwrap();\n        let open = format!(\"<lang {}>\", lang);\n        let close = \"</lang>\";\n\n        replaced_text = bad_open.replace_all(&replaced_text, &open[..]).into_owned();\n        replaced_text = bad_close\n            .replace_all(&replaced_text, &close[..])\n            .into_owned();\n    }\n\n    replaced_text.to_owned()\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut buf = String::new();\n    stdin.lock().read_to_string(&mut buf).unwrap();\n    println!(\n        \"{}\",\n        fix_tags(&LANGUAGES.split_whitespace().collect::<Vec<_>>(), &buf)\n    );\n}\n\n#[test]\nfn test_replace() {\n    let input = \"Lorem ipsum <code foo>saepe audire</code> elaboraret ne quo, id equidem atomorum \\\n                 inciderint usu. <foo>In sit inermis deleniti percipit</foo>, ius ex tale civibus \\\n                 omittam. <barf>Vix ut doctus cetero invenire</barf>, his eu altera electram. \\\n                 Tota adhuc altera te sea, <code bar>soluta appetere ut mel</bar>. Quo quis \\\n                 graecis vivendo te, <baz>posse nullam lobortis ex usu</code>. Eam volumus \\\n                 perpetua constituto id, mea an omittam fierent vituperatoribus.\";\n\n    let expected = \"Lorem ipsum <lang foo>saepe audire</lang> elaboraret ne quo, id equidem \\\n                    atomorum inciderint usu. <lang foo>In sit inermis deleniti percipit</lang>, \\\n                    ius ex tale civibus omittam. <barf>Vix ut doctus cetero invenire</barf>, his \\\n                    eu altera electram. Tota adhuc altera te sea, <lang bar>soluta appetere ut \\\n                    mel</lang>. Quo quis graecis vivendo te, <lang baz>posse nullam lobortis ex \\\n                    usu</lang>. Eam volumus perpetua constituto id, mea an omittam fierent \\\n                    vituperatoribus.\";\n\n    let languages = vec![\"foo\", \"bar\", \"baz\"];\n\n    assert_eq!(expected, fix_tags(&languages, &input));\n}\n",
    "path": "tasks/rosetta-code/fix-code-tags",
    "remote_code": null,
    "title": "Rosetta Code/Fix code tags",
    "url": "http://rosettacode.org/wiki/Rosetta_Code/Fix_code_tags"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Rosetta Code/Rank languages by popularity",
    "url": "http://rosettacode.org/wiki/Rosetta_Code/Rank_languages_by_popularity"
  },
  {
    "local_code": "fn rot13(string: &str) -> String {\n    fn rot13u8(c: char) -> char {\n        let d = c as u8;\n        match c {\n            'a'..='m' | 'A'..='M' => (d + 13) as char,\n            'n'..='z' | 'N'..='Z' => (d - 13) as char,\n            _ => c,\n        }\n    }\n\n    string.chars().map(rot13u8).collect()\n}\n\nfn main() {\n    let string = \"Do you love apples?\";\n\n    println!(\"Original: {}\", string);\n    println!(\"Encoded: {}\", rot13(string));\n}\n\n#[test]\nfn test_basic() {\n    assert_eq!(rot13(\"abc\"), \"nop\");\n}\n\n#[test]\nfn test_coherence() {\n    let coherence_test = (50000i32..50050).map(|x| format!(\"{}\", x)).all(|s| {\n        let encoded = rot13(&s[..]);\n        let decoded = rot13(&encoded[..]);\n        decoded == s\n    });\n\n    assert!(coherence_test);\n}\n",
    "path": "tasks/rot-13",
    "remote_code": "fn rot13 (string: String) -> String {\n    let mut bytes: Vec<u8> = string.into();\n    for byte in &mut bytes {\n        match *byte {\n            b'a'...b'm' | b'A'...b'M' => *byte += 13,\n            b'n'...b'z' | b'N'...b'Z' => *byte -= 13,\n            _ => (), // do nothing\n        }\n    }\n    String::from_utf8(bytes).unwrap()\n}\n\nfn main () {\n    let a =  rot13(\"abc\".to_owned());\n    assert_eq!(a, \"nop\");\n}",
    "title": "Rot-13",
    "url": "http://rosettacode.org/wiki/Rot-13"
  },
  {
    "local_code": "use std::iter::repeat;\n\npub const INPUT: &str = r\"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n\npub fn encode(value: &str) -> String {\n    let mut ret = String::new();\n    let mut chars = value.chars();\n\n    let (mut count, mut cur) = (1, chars.next());\n    if cur.is_none() {\n        return ret;\n    }\n\n    for chr in chars {\n        if cur == Some(chr) {\n            count += 1\n        } else {\n            ret.push_str(&(count.to_string())[..]);\n            ret.push(cur.unwrap());\n            count = 1;\n            cur = Some(chr);\n        }\n    }\n    ret.push_str(&(count.to_string())[..]);\n    ret.push(cur.unwrap());\n    ret\n}\n\npub fn decode(value: &str) -> Result<String, String> {\n    let mut result = String::new();\n    if value.is_empty() {\n        return Ok(result);\n    }\n\n    let mut start = 0;\n\n    for (i, c) in value.char_indices() {\n        if c.is_numeric() {\n            continue;\n        }\n        if i == start {\n            return Err(format!(\"expected digit, found {}\", c));\n        }\n\n        let ret_s = &value[start..i];\n        let ret = ret_s.parse::<usize>().unwrap();\n\n        let repeated: String = repeat(c).take(ret).collect();\n        start = i + 1;\n\n        result.push_str(&repeated[..]);\n    }\n    Ok(result)\n}\n\n#[test]\nfn test_encode_decode() {\n    assert_eq!(decode(&encode(INPUT)[..]).unwrap(), INPUT);\n    assert_eq!(decode(\"a\"), Err(\"expected digit, found a\".to_string()));\n}\nextern crate run_length_encoding;\n\nuse run_length_encoding::{decode, encode, INPUT};\n\nfn main() {\n    let enc = encode(INPUT);\n    println!(\"encoded {}\", enc);\n\n    let dec = decode(&enc[..]);\n    println!(\"decoded {}\", dec.unwrap());\n}\n",
    "path": "tasks/run-length-encoding",
    "remote_code": null,
    "title": "Run-length encoding",
    "url": "http://rosettacode.org/wiki/Run-length_encoding"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn runge_kutta4(fx: &Fn(f64, f64) -> f64, x: f64, y: f64, dx: f64) -> f64 {\n    let k1 = dx * fx(x, y);\n    let k2 = dx * fx(x + dx / 2.0, y + k1 / 2.0);\n    let k3 = dx * fx(x + dx / 2.0, y + k2 / 2.0);\n    let k4 = dx * fx(x + dx, y + k3);\n\n    y + (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n}\n\nfn f(x: f64, y: f64) -> f64 {\n    x * y.sqrt()\n}\n\nfn actual(x: f64) -> f64 {\n    (1.0 / 16.0) * (x * x + 4.0).powi(2)\n}\n\nfn main() {\n    let mut y = 1.0;\n    let mut x = 0.0;\n    let step = 0.1;\n    let max_steps = 101;\n    let sample_every_n = 10;\n\n    for steps in 0..max_steps {\n        if steps % sample_every_n == 0 {\n            println!(\"y({}):\\t{:.10}\\t\\t {:E}\", x, y, actual(x) - y)\n        }\n\n        y = runge_kutta4(&f, x, y, step);\n\n        x = ((x * 10.0) + (step * 10.0)) / 10.0;\n    }\n}",
    "title": "Runge-Kutta method",
    "url": "http://rosettacode.org/wiki/Runge-Kutta_method"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Runtime evaluation",
    "url": "http://rosettacode.org/wiki/Runtime_evaluation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Runtime evaluation/In an environment",
    "url": "http://rosettacode.org/wiki/Runtime_evaluation/In_an_environment"
  },
  {
    "local_code": "//! This implementation isn't based on anything in particular, although it's probably informed by a\n//! lot of Rust's JSON encoding code.  It should be very fast (both encoding and decoding the toy\n//! example here takes under a microsecond on my machine) and tries to avoid unnecessary allocation.\n//!\n//! In a real implementation, most of this would be private, with only a few visible functions, and\n//! there would be somewhat nicer signatures (in particular, the fact that `ParseContext` has to be\n//! mutable would get annoying in real code pretty quickly, so it would probably be split out).\n//!\n//! It supports the ability to read individual atoms, not just lists, although whether this is\n//! useful is questionable.\n//!\n//! Caveats: Does not support symbols vs. non-symbols (it wouldn't be hard, but it would greatly\n//! complicate setting up our test structure since we'd have to force it to go through functions\n//! that checked to make sure `Symbol`s couldn't have spaces, or slow down our parser by checking\n//! for this information each time, which is obnoxious).  Does not support string escaping, because\n//! the decoding technique doesn't allocate extra space for strings.  Does support numbers, but\n//! only float types (supporting more types is possible but would complicate the code\n//! significantly).\n#![feature(test)]\n\nextern crate test;\nextern crate typed_arena;\n\nuse typed_arena::Arena;\n\nuse self::Error::*;\nuse self::SExp::*;\nuse self::Token::*;\nuse std::io;\nuse std::num::FpCategory;\nuse std::str::FromStr;\n\n/// The actual `SExp` structure.  Supports `f64`s, lists, and string literals.  Note that it takes\n/// everything by reference, rather than owning it--this is mostly done just so we can allocate\n/// `SExp`s statically (since we don't have to call `Vec`).  It does complicate the code a bit,\n/// requiring us to have a `ParseContext` that holds an arena where lists are actually allocated.\n#[derive(PartialEq, Debug)]\nenum SExp<'a> {\n    /// Float literal: 0.5\n    F64(f64),\n\n    /// List of SExps: ( a b c)\n    List(&'a [SExp<'a>]),\n\n    /// Plain old string literal: \"abc\"\n    Str(&'a str),\n}\n\n/// Errors that can be thrown by the parser.\n#[derive(PartialEq, Debug)]\nenum Error {\n    /// If the float is `NaN`, `Infinity`, etc.\n    NoReprForFloat,\n\n    /// Missing an end double quote during string parsing\n    UnterminatedStringLiteral,\n\n    /// Some other kind of I/O error\n    Io,\n\n    /// ) appeared where it shouldn't (usually as the first token)\n    IncorrectCloseDelimiter,\n\n    /// Usually means a missing ), but could also mean there were no tokens at all.\n    UnexpectedEOF,\n\n    /// More tokens after the list is finished, or after a literal if there is no list.\n    ExpectedEOF,\n}\n\nimpl From<io::Error> for Error {\n    fn from(_err: io::Error) -> Error {\n        Error::Io\n    }\n}\n\n/// Tokens returned from the token stream.\n#[derive(PartialEq, Debug)]\nenum Token<'a> {\n    /// Left parenthesis\n    ListStart,\n\n    /// Right parenthesis\n    ListEnd,\n\n    /// String or float literal, quotes removed.\n    Literal(SExp<'a>),\n\n    /// Stream is out of tokens.\n    EOF,\n}\n\n/// An iterator over a string that yields a stream of Tokens.\n///\n/// Implementation note: it probably seems weird to store first, rest, AND string, since they should\n/// all be derivable from string.  But see below.\n#[derive(Copy, Clone, Debug)]\nstruct Tokens<'a> {\n    /// The part of the string that still needs to be parsed\n    string: &'a str,\n\n    /// The first character to parse\n    first: Option<char>,\n\n    /// The rest of the string after the first character\n    rest: &'a str,\n}\n\nimpl<'a> Tokens<'a> {\n    /// Initialize a token stream for a given string.\n    fn new(string: &str) -> Tokens {\n        let mut chars = string.chars();\n\n        match chars.next() {\n            Some(ch) => Tokens {\n                string: string,\n                first: Some(ch),\n                rest: chars.as_str(),\n            },\n            None => Tokens {\n                string: string,\n                first: None,\n                rest: string,\n            },\n        }\n    }\n\n    /// Utility function to update information in the iterator.  It might not be performant to keep\n    /// rest cached, but there are times where we don't know exactly what string is (at least, not\n    /// in a way that we can *safely* reconstruct it without allocating), so we keep both here.\n    /// With some unsafe code we could probably get rid of one of them (and maybe first, too).\n    fn update(&mut self, string: &'a str) {\n        self.string = string;\n        let mut chars = self.string.chars();\n\n        if let Some(ch) = chars.next() {\n            self.first = Some(ch);\n            self.rest = chars.as_str();\n        } else {\n            self.first = None;\n        };\n    }\n\n    /// This is where the lexing happens.  Note that it does not handle string escaping.\n    fn next_token(&mut self) -> Result<Token<'a>, Error> {\n        loop {\n            match self.first {\n                // List start\n                Some('(') => {\n                    self.update(self.rest);\n                    return Ok(ListStart);\n                }\n                // List end\n                Some(')') => {\n                    self.update(self.rest);\n                    return Ok(ListEnd);\n                }\n                // Quoted literal start\n                Some('\"') => {\n                    // Split the string at most once.  This lets us get a\n                    // reference to the next piece of the string without having\n                    // to loop through the string again.\n                    let mut iter = self.rest.splitn(2, '\"');\n                    // The first time splitn is run it will never return None, so this is safe.\n                    let str = iter.next().unwrap();\n                    match iter.next() {\n                        // Extract the interior of the string without allocating.  If we want to\n                        // handle string escaping, we would have to allocate at some point though.\n                        Some(s) => {\n                            self.update(s);\n                            return Ok(Literal(Str(str)));\n                        }\n                        None => return Err(UnterminatedStringLiteral),\n                    }\n                }\n                // Plain old literal start\n                Some(c) => {\n                    // Skip whitespace.  This could probably be made more efficient.\n                    if c.is_whitespace() {\n                        self.update(self.rest);\n                        continue;\n                    }\n                    // Since we've exhausted all other possibilities, this must be a real literal.\n                    // Unlike the quoted case, it's not an error to encounter EOF before whitespace.\n                    let mut end_ch = None;\n                    let str = {\n                        let mut iter = self.string.splitn(2, |ch: char| {\n                            let term = ch == ')' || ch == '(';\n                            if term {\n                                end_ch = Some(ch)\n                            }\n                            term || ch.is_whitespace()\n                        });\n                        // The first time splitn is run it will never return None, so this is safe.\n                        let str = iter.next().unwrap();\n                        self.rest = iter.next().unwrap_or(\"\");\n                        str\n                    };\n                    match end_ch {\n                        // self.string will be incorrect in the Some(_) case.  The only reason it's\n                        // okay is because the next time next() is called in this case, we know it\n                        // will be '(' or ')', so it will never reach any code that actually looks\n                        // at self.string.  In a real implementation this would be enforced by\n                        // visibility rules.\n                        Some(_) => self.first = end_ch,\n                        None => self.update(self.rest),\n                    }\n                    return Ok(Literal(parse_literal(str)));\n                }\n                None => return Ok(EOF),\n            }\n        }\n    }\n}\n\n/// This is not the most efficient way to do this, because we end up going over numeric literals\n/// twice, but it avoids having to write our own number parsing logic.\nfn parse_literal(literal: &str) -> SExp {\n    match literal.bytes().next() {\n        Some(b'0'..=b'9') | Some(b'-') => match f64::from_str(literal) {\n            Ok(f) => F64(f),\n            Err(_) => Str(literal),\n        },\n        _ => Str(literal),\n    }\n}\n\n/// Parse context, holds information required by the parser (and owns any allocations it makes)\nstruct ParseContext<'a> {\n    /// The string being parsed.  Not required, but convenient.\n    string: &'a str,\n\n    /// Arena holding any allocations made by the parser.\n    arena: Option<Arena<Vec<SExp<'a>>>>,\n\n    /// Stored in the parse context so it can be reused once allocated.\n    stack: Vec<Vec<SExp<'a>>>,\n}\n\nimpl<'a> ParseContext<'a> {\n    /// Create a new parse context from a given string\n    fn new(string: &'a str) -> ParseContext<'a> {\n        ParseContext {\n            string: string,\n            arena: None,\n            stack: Vec::new(),\n        }\n    }\n}\n\nimpl<'a> SExp<'a> {\n    /// Serialize a SExp.\n    fn encode<T: io::Write>(&self, writer: &mut T) -> Result<(), Error> {\n        match *self {\n            F64(f) => {\n                match f.classify() {\n                    // We don't want to identify NaN, Infinity, etc. as floats.\n                    FpCategory::Normal | FpCategory::Zero => {\n                        write!(writer, \"{}\", f)?;\n                        Ok(())\n                    }\n                    _ => Err(Error::NoReprForFloat),\n                }\n            }\n            List(l) => {\n                // Writing a list is very straightforward--write a left parenthesis, then\n                // recursively call encode on each member, and then write a right parenthesis.  The\n                // only reason the logic is as long as it is is to make sure we don't write\n                // unnecessary spaces between parentheses in the zero or one element cases.\n                write!(writer, \"{}\", '(')?;\n                let mut iter = l.iter();\n                if let Some(sexp) = iter.next() {\n                    sexp.encode(writer)?;\n                    for sexp in iter {\n                        write!(writer, \"{}\", ' ')?;\n                        sexp.encode(writer)?;\n                    }\n                }\n                write!(writer, \"{}\", ')')?;\n                Ok(())\n            }\n            Str(s) => {\n                write!(writer, \"\\\"{}\\\"\", s)?;\n                Ok(())\n            }\n        }\n    }\n\n    /// Deserialize a SExp.\n    fn parse(ctx: &'a mut ParseContext<'a>) -> Result<SExp<'a>, Error> {\n        ctx.arena = Some(Arena::new());\n        // Hopefully this unreachable! gets optimized out, because it should literally be\n        // unreachable.\n        let arena = match ctx.arena {\n            Some(ref mut arena) => arena,\n            None => unreachable!(),\n        };\n        let ParseContext {\n            string,\n            ref mut stack,\n            ..\n        } = *ctx;\n        // Make sure the stack is cleared--we keep it in the context to avoid unnecessary\n        // reallocation between parses (if you need to remember old parse information for a new\n        // list, you can pass in a new context).\n        stack.clear();\n        let mut tokens = Tokens::new(string);\n        // First, we check the very first token to see if we're parsing a full list.  It\n        // simplifies parsing a lot in the subsequent code if we can assume that.\n        let next = tokens.next_token();\n        let mut list = match next? {\n            ListStart => Vec::new(),\n            Literal(s) => {\n                return if tokens.next_token()? == EOF {\n                    Ok(s)\n                } else {\n                    Err(ExpectedEOF)\n                };\n            }\n            ListEnd => return Err(IncorrectCloseDelimiter),\n            EOF => return Err(UnexpectedEOF),\n        };\n\n        // We know we're in a list if we got this far.\n        loop {\n            let tok = tokens.next_token();\n            match tok? {\n                ListStart => {\n                    // We push the previous context onto our stack when we start reading a new list.\n                    stack.push(list);\n                    list = Vec::new()\n                }\n                Literal(s) => list.push(s), // Plain old literal, push it onto the current list\n                ListEnd => {\n                    match stack.pop() {\n                        // Pop the old context off the stack on list end.\n                        Some(mut l) => {\n                            // We allocate a slot for the current list in our parse context (needed\n                            // for safety) before pushing it onto its parent list.\n                            l.push(List(&*arena.alloc(list)));\n                            // Now reset the current list to the parent list\n                            list = l;\n                        }\n                        // There was nothing on the stack, so we're at the end of the topmost list.\n                        // The check to make sure there are no more tokens is required for\n                        // correctness.\n                        None => {\n                            return match tokens.next_token()? {\n                                EOF => Ok(List(&*arena.alloc(list))),\n                                _ => Err(ExpectedEOF),\n                            };\n                        }\n                    }\n                }\n                // We encountered an EOF before the list ended--that's an error.\n                EOF => return Err(UnexpectedEOF),\n            }\n        }\n    }\n\n    /// Convenience method for the common case where you just want to encode a SExp as a String.\n    fn buffer_encode(&self) -> Result<String, Error> {\n        let mut m = Vec::new();\n        self.encode(&mut m)?;\n        // Because encode() only ever writes valid UTF-8, we can safely skip the secondary check we\n        // normally have to do when converting from Vec<u8> to String.  If we didn't know that the\n        // buffer was already UTF-8, we'd want to call container_as_str() here.\n        unsafe { Ok(String::from_utf8_unchecked(m)) }\n    }\n}\n\nconst SEXP_STRUCT: SExp<'static> = List(&[\n    List(&[Str(\"data\"), Str(\"quoted data\"), F64(123.), F64(4.5)]),\n    List(&[\n        Str(\"data\"),\n        List(&[Str(\"!@#\"), List(&[F64(4.5)]), Str(\"(more\"), Str(\"data)\")]),\n    ]),\n]);\n\nfn try_encode() -> Result<String, Error> {\n    SEXP_STRUCT.buffer_encode()\n}\n\nconst SEXP_STRING_IN: &str = r#\"((data \"quoted data\" 123 4.5)\n(data (!@# (4.5) \"(more\" \"data)\")))\"#;\n\nfn try_decode<'a>(ctx: &'a mut ParseContext<'a>) -> Result<SExp<'a>, Error> {\n    SExp::parse(ctx)\n}\n\nfn main() {\n    println!(\"{:?}\", try_encode());\n    let ctx = &mut ParseContext::new(SEXP_STRING_IN);\n    println!(\"{:?}\", try_decode(ctx));\n}\n\n#[bench]\nfn bench_decode(b: &mut test::Bencher) {\n    b.iter(|| {\n        let ctx = &mut ParseContext::new(SEXP_STRING_IN);\n        assert!(try_decode(ctx).is_ok());\n    })\n}\n\n#[bench]\nfn bench_encode(b: &mut test::Bencher) {\n    b.iter(|| {\n        assert!(try_encode().is_ok());\n    })\n}\n\n#[test]\nfn test_sexp_encode() {\n    const SEXP_STRING: &'static str =\n        r#\"((\"data\" \"quoted data\" 123 4.5) (\"data\" (\"!@#\" (4.5) \"(more\" \"data)\")))\"#;\n    assert_eq!(Ok(SEXP_STRING.to_string()), try_encode());\n}\n\n#[test]\nfn test_sexp_decode() {\n    let ctx = &mut ParseContext::new(SEXP_STRING_IN);\n    assert_eq!(Ok(SEXP_STRUCT), try_decode(ctx));\n}\n",
    "path": "tasks/s-expressions",
    "remote_code": null,
    "title": "S-Expressions",
    "url": "http://rosettacode.org/wiki/S-Expressions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "SEDOLs",
    "url": "http://rosettacode.org/wiki/SEDOLs"
  },
  {
    "local_code": "#![cfg_attr(\n    feature = \"cargo-clippy\",\n    allow(many_single_char_names, needless_range_loop)\n)]\n\n//! Straight port from golang crypto/sha1 library implementation\nuse std::io::{Result, Write};\nuse std::num::Wrapping as wr;\n\n/// The size of a SHA1 checksum in bytes.\nconst SIZE: usize = 20;\n\n/// The blocksize of SHA1 in bytes.\nconst CHUNK: usize = 64;\nconst INIT: [wr<u32>; 5] = [\n    wr(0x6745_2301),\n    wr(0xEFCD_AB89),\n    wr(0x98BA_DCFE),\n    wr(0x1032_5476),\n    wr(0xC3D2_E1F0),\n];\n\nfn main() {\n    let mut d = Digest::new();\n    let _ = write!(&mut d, \"The quick brown fox jumps over the lazy dog\");\n    let sha1 = d.sha1();\n\n    for h in &sha1 {\n        print!(\"{:x} \", *h);\n    }\n}\n\n/// digest represents the partial evaluation of a checksum.\nstruct Digest {\n    h: [wr<u32>; 5],\n    x: [u8; CHUNK],\n    nx: usize,\n    len: u64,\n}\n\nimpl Digest {\n    fn new() -> Digest {\n        Digest {\n            h: INIT,\n            x: [0u8; CHUNK],\n            nx: 0,\n            len: 0u64,\n        }\n    }\n\n    fn sha1(&mut self) -> [u8; SIZE] {\n        let mut len = self.len;\n        // Padding.  Add a 1 bit and 0 bits until 56 bytes mod 64.\n        let mut tmp: [u8; 64] = [0u8; 64];\n        tmp[0] = 0x80u8;\n\n        let m: usize = (len % 64u64) as usize;\n        if m < 56 {\n            self.write_all(&tmp[0..56 - m]).unwrap();\n        } else {\n            self.write_all(&tmp[0..64 + 56 - m]).unwrap();\n        }\n\n        // Length in bits (=length in bytes*8=shift 3 bits to the right).\n        len <<= 3;\n        for (i, byte) in tmp.iter_mut().take(8).enumerate() {\n            *byte = (len >> (56 - 8 * i)) as u8;\n        }\n        self.write_all(&tmp[0..8]).unwrap();\n\n        assert!(self.nx == 0);\n\n        let mut digest: [u8; SIZE] = [0u8; SIZE];\n        for (i, s) in self.h.iter().enumerate() {\n            digest[i * 4] = (*s >> 24).0 as u8;\n            digest[i * 4 + 1] = (*s >> 16).0 as u8;\n            digest[i * 4 + 2] = (*s >> 8).0 as u8;\n            digest[i * 4 + 3] = s.0 as u8;\n        }\n        digest\n    }\n\n    fn process_block(&self, data: &[u8]) -> [wr<u32>; 5] {\n        let k: [u32; 4] = [0x5A82_7999, 0x6ED9_EBA1, 0x8F1B_BCDC, 0xCA62_C1D6];\n\n        #[inline]\n        fn part(a: wr<u32>, b: wr<u32>) -> (wr<u32>, wr<u32>) {\n            ((a << 5 | a >> (32 - 5)), (b << 30 | b >> (32 - 30)))\n        }\n\n        let mut w: [u32; 16] = [0u32; 16];\n\n        let (mut h0, mut h1, mut h2, mut h3, mut h4) =\n            (self.h[0], self.h[1], self.h[2], self.h[3], self.h[4]);\n\n        let mut p = data;\n\n        while p.len() >= CHUNK {\n            for i in 0..16 {\n                let j = i * 4;\n                w[i] = u32::from(p[j]) << 24\n                    | u32::from(p[j + 1]) << 16\n                    | u32::from(p[j + 2]) << 8\n                    | u32::from(p[j + 3]);\n            }\n\n            let (mut a, mut b, mut c, mut d, mut e) = (h0, h1, h2, h3, h4);\n\n            for i in 0..16 {\n                let f = b & c | (!b) & d;\n                let (a5, b30) = part(a, b);\n                let t = a5 + f + e + wr(w[i & 0xf]) + wr(k[0]);\n                b = a;\n                a = t;\n                e = d;\n                d = c;\n                c = b30;\n            }\n            for i in 16..20 {\n                let tmp = w[(i - 3) & 0xf] ^ w[(i - 8) & 0xf] ^ w[(i - 14) & 0xf] ^ w[(i) & 0xf];\n                w[i & 0xf] = tmp << 1 | tmp >> (32 - 1);\n                let f = b & c | (!b) & d;\n                let (a5, b30) = part(a, b);\n                let t = a5 + f + e + wr(w[i & 0xf]) + wr(k[0]);\n                b = a;\n                a = t;\n                e = d;\n                d = c;\n                c = b30;\n            }\n            for i in 20..40 {\n                let tmp = w[(i - 3) & 0xf] ^ w[(i - 8) & 0xf] ^ w[(i - 14) & 0xf] ^ w[(i) & 0xf];\n                w[i & 0xf] = tmp << 1 | tmp >> (32 - 1);\n                let f = b ^ c ^ d;\n                let (a5, b30) = part(a, b);\n                let t = a5 + f + e + wr(w[i & 0xf]) + wr(k[1]);\n                b = a;\n                a = t;\n                e = d;\n                d = c;\n                c = b30;\n            }\n            for i in 40..60 {\n                let tmp = w[(i - 3) & 0xf] ^ w[(i - 8) & 0xf] ^ w[(i - 14) & 0xf] ^ w[(i) & 0xf];\n                w[i & 0xf] = tmp << 1 | tmp >> (32 - 1);\n                let f = ((b | c) & d) | (b & c);\n                let (a5, b30) = part(a, b);\n                let t = a5 + f + e + wr(w[i & 0xf]) + wr(k[2]);\n                b = a;\n                a = t;\n                e = d;\n                d = c;\n                c = b30;\n            }\n            for i in 60..80 {\n                let tmp = w[(i - 3) & 0xf] ^ w[(i - 8) & 0xf] ^ w[(i - 14) & 0xf] ^ w[(i) & 0xf];\n                w[i & 0xf] = tmp << 1 | tmp >> (32 - 1);\n                let f = b ^ c ^ d;\n                let (a5, b30) = part(a, b);\n                let t = a5 + f + e + wr(w[i & 0xf]) + wr(k[3]);\n                b = a;\n                a = t;\n                e = d;\n                d = c;\n                c = b30;\n            }\n            h0 += a;\n            h1 += b;\n            h2 += c;\n            h3 += d;\n            h4 += e;\n\n            p = &p[CHUNK..];\n        }\n        [h0, h1, h2, h3, h4]\n    }\n}\n\nimpl Default for Digest {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl Write for Digest {\n    fn write(&mut self, buf: &[u8]) -> Result<usize> {\n        self.write_all(buf)?;\n        Ok(buf.len())\n    }\n\n    #[inline]\n    fn write_all(&mut self, buf: &[u8]) -> Result<()> {\n        let mut buf_m = buf;\n\n        self.len += buf_m.len() as u64;\n\n        if self.nx > 0 {\n            let mut n = buf_m.len();\n            if n > CHUNK - self.nx {\n                n = CHUNK - self.nx;\n            }\n            for i in 0..n {\n                self.x[self.nx + i] = buf_m[i];\n            }\n            self.nx += n;\n            if self.nx == CHUNK {\n                let x = &(self.x[..]);\n                self.h = self.process_block(x);\n                self.nx = 0;\n            }\n            buf_m = &buf_m[n..];\n        }\n        if buf_m.len() >= CHUNK {\n            let n = buf_m.len() & !(CHUNK - 1);\n            let x = &(self.x[n..]);\n            self.h = self.process_block(x);\n            buf_m = &buf_m[n..];\n        }\n        let ln = buf_m.len();\n        if ln > 0 {\n            assert!(self.x.len() >= ln);\n            self.x.as_mut().write_all(buf_m).unwrap();\n            self.nx = ln;\n        }\n        Ok(())\n    }\n\n    fn flush(&mut self) -> Result<()> {\n        Ok(())\n    }\n}\n\n#[test]\nfn known_sha1s() {\n    let input_output = [\n        (\n            \"His money is twice tainted: 'taint yours and 'taint mine.\",\n            [\n                0x59u8, 0x7f, 0x6a, 0x54, 0x0, 0x10, 0xf9, 0x4c, 0x15, 0xd7, 0x18, 0x6, 0xa9, 0x9a,\n                0x2c, 0x87, 0x10, 0xe7, 0x47, 0xbd,\n            ],\n        ),\n        (\n            \"The quick brown fox jumps over the lazy dog\",\n            [\n                0x2fu8, 0xd4, 0xe1, 0xc6, 0x7a, 0x2d, 0x28, 0xfc, 0xed, 0x84, 0x9e, 0xe1, 0xbb,\n                0x76, 0xe7, 0x39, 0x1b, 0x93, 0xeb, 0x12,\n            ],\n        ),\n        (\n            \"The quick brown fox jumps over the lazy cog\",\n            [\n                0xdeu8, 0x9f, 0x2c, 0x7f, 0xd2, 0x5e, 0x1b, 0x3a, 0xfa, 0xd3, 0xe8, 0x5a, 0x0b,\n                0xd1, 0x7d, 0x9b, 0x10, 0x0d, 0xb4, 0xb3,\n            ],\n        ),\n    ];\n\n    for &(i, o) in &input_output {\n        let mut d = Digest::new();\n        let _ = write!(&mut d, \"{}\", i);\n        let sha1 = d.sha1();\n\n        assert_eq!(sha1, o);\n    }\n}\n",
    "path": "tasks/sha-1",
    "remote_code": null,
    "title": "SHA-1",
    "url": "http://rosettacode.org/wiki/SHA-1"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/SHA-256\n\nextern crate ring;\n\nuse ring::digest::{digest, SHA256};\n\nfn main() {\n    println!(\"{}\", sha_256(\"Rosetta code\"));\n}\n\nfn sha_256(input: &str) -> String {\n    let result = digest(&SHA256, input.as_bytes());\n    result.as_ref().iter().map(|b| format!(\"{:x}\", b)).collect()\n}\n\n#[test]\nfn test_rosetta() {\n    let expected_hash = \"764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf\";\n    assert_eq!(sha_256(\"Rosetta code\"), expected_hash);\n}\n",
    "path": "tasks/sha-256",
    "remote_code": "use sha2::{Digest, Sha256};\n\nfn hex_string(input: &[u8]) -> String {\n    input.as_ref().iter().map(|b| format!(\"{:x}\", b)).collect()\n}\n\nfn main() {\n    // create a Sha256 object\n    let mut hasher = Sha256::new();\n\n    // write input message\n    hasher.input(b\"Rosetta code\");\n\n    // read hash digest and consume hasher\n    let result = hasher.result();\n\n    let hex = hex_string(&result);\n\n    assert_eq!(\n        hex,\n        \"764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf\"\n    );\n    \n    println!(\"{}\", hex)\n}\n",
    "title": "SHA-256",
    "url": "http://rosettacode.org/wiki/SHA-256"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "SOAP",
    "url": "http://rosettacode.org/wiki/SOAP"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "SQL-based authentication",
    "url": "http://rosettacode.org/wiki/SQL-based_authentication"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Safe addition",
    "url": "http://rosettacode.org/wiki/Safe_addition"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Safe primes and unsafe primes",
    "url": "http://rosettacode.org/wiki/Safe_primes_and_unsafe_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sailors, coconuts and a monkey problem",
    "url": "http://rosettacode.org/wiki/Sailors,_coconuts_and_a_monkey_problem"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Same Fringe",
    "url": "http://rosettacode.org/wiki/Same_Fringe"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Scope modifiers",
    "url": "http://rosettacode.org/wiki/Scope_modifiers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Scope/Function names and labels",
    "url": "http://rosettacode.org/wiki/Scope/Function_names_and_labels"
  },
  {
    "local_code": "fn main() {\n    let haystack = vec![\n        \"Zig\", \"Zag\", \"Wally\", \"Ronald\", \"Bush\", \"Krusty\", \"Charlie\", \"Bush\", \"Boz\", \"Zag\",\n    ];\n\n    println!(\n        \"First occurence of 'Bush' at {:?}\",\n        haystack.iter().position(|s| *s == \"Bush\")\n    );\n    println!(\n        \"Last occurence of 'Bush' at {:?}\",\n        haystack.iter().rposition(|s| *s == \"Bush\")\n    );\n    println!(\n        \"First occurence of 'Rob' at {:?}\",\n        haystack.iter().position(|s| *s == \"Rob\")\n    );\n}\n",
    "path": "tasks/search-a-list",
    "remote_code": "fn main() {\n    let haystack=vec![\"Zig\", \"Zag\", \"Wally\", \"Ronald\", \"Bush\", \"Krusty\", \"Charlie\", \n                        \"Bush\", \"Boz\", \"Zag\"];\n\n    println!(\"First occurence of 'Bush' at {:?}\",haystack.iter().position(|s| *s==\"Bush\"));\n    println!(\"Last occurence of 'Bush' at {:?}\",haystack.iter().rposition(|s| *s==\"Bush\"));\n    println!(\"First occurence of 'Rob' at {:?}\",haystack.iter().position(|s| *s==\"Rob\"));\n}\n",
    "title": "Search a list",
    "url": "http://rosettacode.org/wiki/Search_a_list"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Search a list of records",
    "url": "http://rosettacode.org/wiki/Search_a_list_of_records"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Secure temporary file",
    "url": "http://rosettacode.org/wiki/Secure_temporary_file"
  },
  {
    "local_code": "fn is_self_describing(mut n: u64) -> bool {\n    // Compute the length of the number (the number of digits)\n    let mut tmp = n;\n    let mut len = 0;\n    while tmp > 0 {\n        len += 1;\n        tmp /= 10;\n    }\n\n    // In base 10, numbers with more than 10 digits can't be self-describing\n    if len > 10 || len == 0 {\n        return false;\n    }\n\n    // Go through each digit of the number, count how many times each digit occurs, and then\n    // subtract how often each digit is supposed to occur according to the number\n    let mut cnt = [0i32; 10];\n    for i in 0..len {\n        cnt[(n % 10) as usize] += 1;\n        cnt[len - i - 1] -= (n % 10) as i32;\n        n /= 10;\n    }\n\n    // If the number is self-describing, then all counters should be zero\n    cnt.iter().all(|&c| c == 0)\n}\n\nfn main() {\n    // Print out all self-describing numbers below 10^8\n    for i in 0u64..100_000_000 {\n        if is_self_describing(i) {\n            println!(\"{} is self-describing\", i);\n        }\n    }\n}\n\n#[test]\nfn test_is_self_describing() {\n    let tests = [\n        (0, false),\n        (1, false),\n        (200, false),\n        (1337, false),\n        (2020, true),\n        (1210, true),\n        (21200, true),\n        (3211000, true),\n        (42101000, true),\n        (43101000, false),\n        (521001000, true),\n        (6210001000, true),\n    ];\n\n    for &(n, expected) in &tests {\n        assert_eq!(is_self_describing(n), expected);\n    }\n}\n",
    "path": "tasks/self-describing-numbers",
    "remote_code": "\nfn is_self_desc(xx: u64) -> bool\n{\n    let s: String = xx.to_string();\n    let mut count_vec = vec![0; 10];\n    for c in s.chars() {\n        count_vec[c.to_digit(10).unwrap() as usize] += 1;\n    }\n    for (i, c) in s.chars().enumerate() {\n        if count_vec[i] != c.to_digit(10).unwrap() as usize {\n            return false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    for i in 1..100000000 {\n        if is_self_desc(i) {\n            println!(\"{}\", i)\n        }\n    }\n}\n",
    "title": "Self-describing numbers",
    "url": "http://rosettacode.org/wiki/Self-describing_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Self-referential sequence",
    "url": "http://rosettacode.org/wiki/Self-referential_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Semiprime",
    "url": "http://rosettacode.org/wiki/Semiprime"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Semordnilap",
    "url": "http://rosettacode.org/wiki/Semordnilap"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Send an unknown method call",
    "url": "http://rosettacode.org/wiki/Send_an_unknown_method_call"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Send email",
    "url": "http://rosettacode.org/wiki/Send_email"
  },
  {
    "local_code": "/// the formula that should produce no perfect squares\nfn non_sq(n: u64) -> u64 {\n    (n + (0.5 + (n as f64).sqrt()) as u64)\n}\n\nfn main() {\n    // print the first 22 non squares\n    for n in (1u64..23).map(non_sq) {\n        println!(\"{}\", n);\n    }\n}\n\n#[test]\nfn test_no_squares() {\n    // check if a number is a square\n    let is_square = |n: u64| {\n        let r = (n as f64).sqrt() as u64;\n        r * r == n\n    };\n    // verify that there are no squares in the first million of\n    // values calculated by non_sq\n    for ns in (1u64..1000001).map(non_sq) {\n        assert!(!is_square(ns));\n    }\n}\n",
    "path": "tasks/sequence-of-non-squares",
    "remote_code": "\nfn f(n: i64) -> i64 {\n    n + (0.5 + (n as f64).sqrt()) as i64\n}\n\nfn is_sqr(n: i64) -> bool {\n    let a = (n as f64).sqrt() as i64;\n    n == a * a || n == (a+1) * (a+1) || n == (a-1) * (a-1) \n}\n\nfn main() {\n    println!( \"{:?}\", (1..23).map(|n| f(n)).collect::<Vec<i64>>() );\n    let count = (1..1_000_000).map(|n| f(n)).filter(|&n| is_sqr(n)).count();\n    println!(\"{} unexpected squares found\", count);\n}\n",
    "title": "Sequence of non-squares",
    "url": "http://rosettacode.org/wiki/Sequence_of_non-squares"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sequence of primes by trial division",
    "url": "http://rosettacode.org/wiki/Sequence_of_primes_by_trial_division"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sequence of primorial primes",
    "url": "http://rosettacode.org/wiki/Sequence_of_primorial_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sequence: nth number with exactly n divisors",
    "url": "http://rosettacode.org/wiki/Sequence:_nth_number_with_exactly_n_divisors"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sequence: smallest number greater than previous term with exactly n divisors",
    "url": "http://rosettacode.org/wiki/Sequence:_smallest_number_greater_than_previous_term_with_exactly_n_divisors"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sequence: smallest number with exactly n divisors",
    "url": "http://rosettacode.org/wiki/Sequence:_smallest_number_with_exactly_n_divisors"
  },
  {
    "local_code": "use std::collections::HashSet;\n\nfn main() {\n    // The first set contains integers from 0 to 7\n    let set1 = (0i32..7).collect::<HashSet<i32>>();\n\n    // The second set contains integers from 5 to 10\n    let set2 = (5i32..10).collect();\n\n    // A subset of set1\n    let subset1 = (2i32..5).collect::<HashSet<i32>>();\n\n    // Test if element is member of the set\n    assert!(set1.contains(&1));\n\n    // Test if subset1 is subset of set1\n    assert!(subset1.is_subset(&set1));\n\n    // Test if set1_copy is equal to set1\n    let set1_copy = set1.clone();\n    assert!(set1_copy == set1);\n\n    println!();\n    println!(\"Print the union of set1 and set2\");\n    for num in set1.union(&set2) {\n        println!(\"{}\", num);\n    }\n\n    println!();\n    println!(\"Print the intersection of set1 and set2\");\n    for num in set1.intersection(&set2) {\n        println!(\"{}\", num);\n    }\n\n    println!();\n    println!(\"Print the difference between set1 and set2\");\n    for num in set1.difference(&set2) {\n        println!(\"{}\", num);\n    }\n}\n",
    "path": "tasks/set",
    "remote_code": "use std::collections::HashSet;\n\nfn main() {\n  let a = vec![1, 3, 4].into_iter().collect::<HashSet<i32>>();\n  let b = vec![3, 5, 6].into_iter().collect::<HashSet<i32>>();\n\n  println!(\"Set A: {:?}\", a.iter().collect::<Vec<_>>());\n  println!(\"Set B: {:?}\", b.iter().collect::<Vec<_>>());\n  println!(\"Does A contain 4? {}\", a.contains(&4));\n  println!(\"Union: {:?}\", a.union(&b).collect::<Vec<_>>());\n  println!(\"Intersection: {:?}\", a.intersection(&b).collect::<Vec<_>>());\n  println!(\"Difference: {:?}\", a.difference(&b).collect::<Vec<_>>());\n  println!(\"Is A a subset of B? {}\", a.is_subset(&b));\n  println!(\"Is A equal to B? {}\", a == b);\n}",
    "title": "Set",
    "url": "http://rosettacode.org/wiki/Set"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Set consolidation",
    "url": "http://rosettacode.org/wiki/Set_consolidation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Set of real numbers",
    "url": "http://rosettacode.org/wiki/Set_of_real_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Set puzzle",
    "url": "http://rosettacode.org/wiki/Set_puzzle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Seven-sided dice from five-sided dice",
    "url": "http://rosettacode.org/wiki/Seven-sided_dice_from_five-sided_dice"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sexy primes",
    "url": "http://rosettacode.org/wiki/Sexy_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Shell one-liner",
    "url": "http://rosettacode.org/wiki/Shell_one-liner"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Shoelace formula for polygonal area",
    "url": "http://rosettacode.org/wiki/Shoelace_formula_for_polygonal_area"
  },
  {
    "local_code": "fn a(x: bool) -> bool {\n    println!(\"Inside function a\");\n    x\n}\n\nfn b(x: bool) -> bool {\n    println!(\"Inside function b\");\n    x\n}\n\nfn main() {\n    let booleans = [true, false];\n\n    for &i in &booleans {\n        for &j in &booleans {\n            println!(\"{} and {} is {}\", i, j, a(i) && b(j));\n            println!(\"{} or {} is {}\", i, j, a(i) || b(j));\n        }\n    }\n}\n",
    "path": "tasks/short-circuit-evaluation",
    "remote_code": "fn a(foo: bool) -> bool {\n    println!(\"a\");\n    foo\n}\n\nfn b(foo: bool) -> bool {\n    println!(\"b\");\n    foo\n}\n\nfn main() {\n    for i in vec![true, false] {\n        for j in vec![true, false] {\n            println!(\"{} and {} == {}\", i, j, a(i) && b(j));\n            println!(\"{} or {} == {}\", i, j, a(i) || b(j));\n            println!();\n        }\n    }\n}",
    "title": "Short-circuit evaluation",
    "url": "http://rosettacode.org/wiki/Short-circuit_evaluation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Shortest common supersequence",
    "url": "http://rosettacode.org/wiki/Shortest_common_supersequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Show Ascii table",
    "url": "http://rosettacode.org/wiki/Show_Ascii_table"
  },
  {
    "local_code": "extern crate time;\n\nuse time::{at_utc, Timespec};\n\nfn main() {\n    let epoch = at_utc(Timespec::new(0, 0));\n    println!(\"{}\", epoch.asctime());\n}\n",
    "path": "tasks/show-the-epoch",
    "remote_code": "extern crate time;\n\nuse time::{at_utc, Timespec};\n\nfn main() {\n    let epoch = at_utc(Timespec::new(0, 0));  \n    println!(\"{}\", epoch.asctime());\n}",
    "title": "Show the epoch",
    "url": "http://rosettacode.org/wiki/Show_the_epoch"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    for i in 0..4 {\n        println!(\"\\nN={}\", i);\n        println!(\"{}\", sierpinski_carpet(i));\n    }\n}\n\nfn sierpinski_carpet(n: u32) -> String {\n    let mut carpet = vec![\"#\".to_string()];\n    for _ in 0..n {\n        let mut top: Vec<_> = carpet.iter().map(|x| x.repeat(3)).collect();\n        let middle: Vec<_> = carpet\n            .iter()\n            .map(|x| x.to_string() + &x.replace(\"#\", \" \") + x)\n            .collect();\n        let bottom = top.clone();\n\n        top.extend(middle);\n        top.extend(bottom);\n        carpet = top;\n    }\n    carpet.join(\"\\n\")\n}\n\n",
    "title": "Sierpinski carpet",
    "url": "http://rosettacode.org/wiki/Sierpinski_carpet"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sierpinski pentagon",
    "url": "http://rosettacode.org/wiki/Sierpinski_pentagon"
  },
  {
    "local_code": "use std::iter::repeat;\n\nfn main() {\n    let order = 4;\n    let height = 1 << order;\n    let mut state: Vec<bool> = repeat(true).take(height + 1).collect();\n\n    // Compute the triangle line-by-line by viewing it as Pascal's triangle (mod 2)\n    for i in 0..height {\n        for _ in 0..height - i - 1 {\n            print!(\" \");\n        }\n\n        for filled in state.iter().take(i + 1) {\n            let fill = if *filled { \"*\" } else { \" \" };\n\n            print!(\" {}\", fill);\n        }\n\n        // Compute the next line\n        for j in (i as i32..0).rev().step_by(1) {\n            state[j as usize] ^= state[(j - 1) as usize];\n        }\n\n        println!();\n    }\n}\n",
    "path": "tasks/sierpinski-triangle",
    "remote_code": null,
    "title": "Sierpinski triangle",
    "url": "http://rosettacode.org/wiki/Sierpinski_triangle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sierpinski triangle/Graphical",
    "url": "http://rosettacode.org/wiki/Sierpinski_triangle/Graphical"
  },
  {
    "local_code": "use std::iter::repeat;\n\nfn int_sqrt(n: usize) -> usize {\n    (n as f64).sqrt() as usize\n}\n\n/// Return the prime numbers up to limit\n#[cfg_attr(feature = \"clippy\", allow(needless_range_loop))]\nfn simple_sieve(limit: usize) -> Vec<usize> {\n    if limit < 2 {\n        return vec![];\n    }\n\n    let mut primes: Vec<bool> = repeat(true).take(limit + 1).collect();\n\n    for prime in 2..(int_sqrt(limit) + 1) {\n        if primes[prime] {\n            for multiple in (prime * prime..limit + 1).step_by(prime) {\n                primes[multiple] = false\n            }\n        }\n    }\n\n    (2..limit + 1).filter(|&n| primes[n]).collect()\n}\n\nfn main() {\n    println!(\"{:?}\", simple_sieve(100))\n}\n\n#[test]\nfn test_basic() {\n    let primes = simple_sieve(30);\n    assert!(primes == [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]);\n}\n",
    "path": "tasks/sieve-of-eratosthenes",
    "remote_code": "fn simple_sieve(limit: usize) -> Vec<usize> {\n\n    let mut is_prime = vec![true; limit+1];\n    is_prime[0] = false;\n    if limit >= 1 { is_prime[1] = false }\n\n    for num in 2..limit+1 {\n        if is_prime[num] {\n            let mut multiple = num*num;\n            while multiple <= limit {\n                is_prime[multiple] = false;\n                multiple += num;\n            }\n        }\n    }\n\n    is_prime.iter().enumerate()\n        .filter_map(|(pr, &is_pr)| if is_pr {Some(pr)} else {None} )\n        .collect()\n}\n\nfn main() {\n    println!(\"{:?}\", simple_sieve(100));\n}",
    "title": "Sieve of Eratosthenes",
    "url": "http://rosettacode.org/wiki/Sieve_of_Eratosthenes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Simple database",
    "url": "http://rosettacode.org/wiki/Simple_database"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Simple windowed application",
    "url": "http://rosettacode.org/wiki/Simple_windowed_application"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Simulate input/Keyboard",
    "url": "http://rosettacode.org/wiki/Simulate_input/Keyboard"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Simulate input/Mouse",
    "url": "http://rosettacode.org/wiki/Simulate_input/Mouse"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Singleton",
    "url": "http://rosettacode.org/wiki/Singleton"
  },
  {
    "local_code": "#![allow(dead_code)]\n\n//! Rust's `Option<T>` type makes the definition of a singly-linked list trivial. The use of\n//! `Box<T>` (an owned pointer) is necessary because it has a known size, thus making sure the\n//! struct that contains it can have a finite size.\n//!\n//! ```\n//! struct Node<T> {\n//!     elem: T,\n//!     next: Option<Box<Node<T>>>,\n//! }\n//! ```\n//!\n//! However, the above example would not be suitable for a library because, first and foremost, it\n//! is private by default but simply making it public would not allow for any encapsulation.\n\n/// Type alias\ntype Link<T> = Option<Box<Node<T>>>;\n\n/// User-facing interface for list\n#[derive(Debug)]\npub struct List<T> {\n    head: Link<T>,\n}\n\n/// Private implementation of Node\n#[derive(Debug)]\nstruct Node<T> {\n    elem: T,\n    next: Link<T>,\n}\n\nimpl<T> List<T> {\n    /// List constructor\n    #[inline]\n    pub fn new() -> Self {\n        List { head: None }\n    }\n\n    // Add other methods here...\n}\n\nimpl<T> Default for List<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nfn main() {\n    let _ = List::<i32>::new();\n}\n",
    "path": "tasks/singly-linked-list/element-definition",
    "remote_code": "extern crate LinkedList; // Name is arbitrary here\n\nuse LinkedList::List;\n\nfn main() {\n    let list = List::new();\n    // Do stuff\n}",
    "title": "Singly-linked list/Element definition",
    "url": "http://rosettacode.org/wiki/Singly-linked_list/Element_definition"
  },
  {
    "local_code": "#![allow(dead_code)]\n\ntype Link<T> = Option<Box<Node<T>>>;\n\npub struct List<T> {\n    head: Link<T>,\n}\n\nstruct Node<T> {\n    elem: T,\n    next: Link<T>,\n}\n\nimpl<T> List<T> {\n    pub fn new() -> Self {\n        List { head: None }\n    }\n\n    pub fn push(&mut self, elem: T) {\n        let new_node = Box::new(Node {\n            elem: elem,\n            next: self.head.take(),\n        });\n        self.head = Some(new_node);\n    }\n}\n\nimpl<T> Default for List<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nfn main() {\n    let mut list = List::new();\n    list.push(1);\n}\n",
    "path": "tasks/singly-linked-list/element-insertion",
    "remote_code": "impl<T> List<T> {\n    pub fn new() -> Self {\n        List { head: None }\n    }\n\n    pub fn push(&mut self, elem: T) {\n    let new_node = Box::new(Node {\n        elem: elem,\n        next: self.head.take(),\n    });\n    self.head = Some(new_node);\n}",
    "title": "Singly-linked list/Element insertion",
    "url": "http://rosettacode.org/wiki/Singly-linked_list/Element_insertion"
  },
  {
    "local_code": "type Link<T> = Option<Box<Node<T>>>;\n\npub struct List<T> {\n    head: Link<T>,\n}\n\nstruct Node<T> {\n    elem: T,\n    next: Link<T>,\n}\n\nimpl<T> List<T> {\n    pub fn new() -> Self {\n        List { head: None }\n    }\n\n    pub fn push(&mut self, elem: T) {\n        let new_node = Box::new(Node {\n            elem: elem,\n            next: self.head.take(),\n        });\n        self.head = Some(new_node);\n    }\n}\n\nimpl<T> Default for List<T> {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Iteration by value (simply empties the list as the caller now owns all values)\npub struct IntoIter<T>(List<T>);\n\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.head.take().map(|node| {\n            let node = *node;\n            self.0.head = node.next;\n            node.elem\n        })\n    }\n}\n\n/// Iteration by immutable reference\npub struct Iter<'a, T: 'a> {\n    next: Option<&'a Node<T>>,\n}\n\nimpl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next.take().map(|node| {\n            self.next = node.next.as_ref().map(|node| &**node);\n            &node.elem\n        })\n    }\n}\n\n/// Iteration by mutable reference\npub struct IterMut<'a, T: 'a> {\n    next: Option<&'a mut Node<T>>,\n}\n\nimpl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next.take().map(|node| {\n            self.next = node.next.as_mut().map(|node| &mut **node);\n            &mut node.elem\n        })\n    }\n}\n\n/// Methods implemented for List<T>\nimpl<T> List<T> {\n    pub fn iter(&self) -> Iter<T> {\n        Iter {\n            next: self.head.as_ref().map(|node| &**node),\n        }\n    }\n\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut {\n            next: self.head.as_mut().map(|node| &mut **node),\n        }\n    }\n}\n\nimpl<T> IntoIterator for List<T> {\n    type Item = T;\n    type IntoIter = IntoIter<T>;\n\n    fn into_iter(self) -> Self::IntoIter {\n        IntoIter(self)\n    }\n}\n\nfn main() {\n    let mut list = List::new();\n    list.push(1);\n    list.push(2);\n    list.push(3);\n\n    for item in list.iter() {\n        println!(\"{}\", item);\n    }\n}\n",
    "path": "tasks/singly-linked-list/traversal",
    "remote_code": "// \n//\n// Iteration by value (simply empties the list as the caller now owns all values)\n//\n//\npub struct IntoIter<T>(List<T>);\n\nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.head.take().map(|node| { \n            let node = *node;\n            self.0.head = node.next;\n            node.elem\n        })\n    }\n}\n\n//\n//\n// Iteration by immutable reference\n//\n//\n\npub struct Iter<'a, T: 'a> {\n    next: Option<&'a Node<T>>,\n}\n\nimpl<'a, T> Iterator for Iter<'a, T> {\n    type Item = &'a T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next.take().map(|node| {\n            self.next = node.next.as_ref().map(|node| &**node);\n            &node.elem\n        })\n    }\n}\n\n//\n//\n// Iteration by mutable reference\n//\n//\n\npub struct IterMut<'a, T: 'a> {\n    next: Option<&'a mut Node<T>>,\n}\n\nimpl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next.take().map(|node| {\n            self.next = node.next.as_mut().map(|node| &mut **node);\n            &mut node.elem\n        })\n    }\n}\n\n//\n//\n// Methods implemented for List<T>\n//\n//\n\nimpl<T> List<T> {\n    pub fn into_iter(self) -> IntoIter<T> {\n        IntoIter(self)\n    }\n\n    pub fn iter<'a>(&'a self) -> Iter<'a,T> {\n        Iter { next: self.head.as_ref().map(|node| &**node) }\n    }\n\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut { next: self.head.as_mut().map(|node| &mut **node) }\n    }\n\n}",
    "title": "Singly-linked list/Traversal",
    "url": "http://rosettacode.org/wiki/Singly-linked_list/Traversal"
  },
  {
    "local_code": "//! Sleeps for the number of seconds specified on the command line.\n\nuse std::env;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let amount: u64 = env::args().nth(1).unwrap().parse().unwrap();\n    println!(\"Sleeping...\");\n    thread::sleep(Duration::from_secs(amount));\n    println!(\"Awake!\");\n}\n",
    "path": "tasks/sleep",
    "remote_code": "use std::{io, time, thread};\n\nfn main() {\n    println!(\"How long should we sleep in milliseconds?\");\n    \n    let mut sleep_string = String::new();\n\n    io::stdin().read_line(&mut sleep_string)\n               .expect(\"Failed to read line\");\n\n    let sleep_timer: u64 = sleep_string.trim()\n                                       .parse()\n                                       .expect(\"Not an integer\");\n    let sleep_duration = time::Duration::from_millis(sleep_timer);\n    \n    println!(\"Sleeping...\");\n    thread::sleep(sleep_duration);\n    println!(\"Awake!\");\n}",
    "title": "Sleep",
    "url": "http://rosettacode.org/wiki/Sleep"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Smarandache prime-digital sequence",
    "url": "http://rosettacode.org/wiki/Smarandache_prime-digital_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Smith numbers",
    "url": "http://rosettacode.org/wiki/Smith_numbers"
  },
  {
    "local_code": "use std::io::prelude::*;\nuse std::net::TcpStream;\n\nfn main() {\n    // Open a tcp socket connecting to 127.0.0.1:256, no error handling (unwrap)\n    let mut my_stream = TcpStream::connect(\"127.0.0.1:256\").unwrap();\n\n    // Write 'hello socket world' to the stream\n    write!(my_stream, \"hello socket world\").unwrap();\n} // <- my_stream's drop function gets called, which closes the socket\n",
    "path": "tasks/sockets",
    "remote_code": "use std::io::prelude::*;\nuse std::net::TcpStream;\n\nfn main() {\n    // Open a tcp socket connecting to 127.0.0.1:256, no error handling (unwrap)\n    let mut my_stream = TcpStream::connect(\"127.0.0.1:256\").unwrap();\n\n    // Write 'hello socket world' to the stream, ignoring the result of write\n    let _ = my_stream.write(b\"hello socket world\");\n\n} // <- my_stream's drop function gets called, which closes the socket",
    "title": "Sockets",
    "url": "http://rosettacode.org/wiki/Sockets"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sokoban",
    "url": "http://rosettacode.org/wiki/Sokoban"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Solve a Hidato puzzle",
    "url": "http://rosettacode.org/wiki/Solve_a_Hidato_puzzle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Solve a Holy Knight's tour",
    "url": "http://rosettacode.org/wiki/Solve_a_Holy_Knight's_tour"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Solve a Hopido puzzle",
    "url": "http://rosettacode.org/wiki/Solve_a_Hopido_puzzle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Solve a Numbrix puzzle",
    "url": "http://rosettacode.org/wiki/Solve_a_Numbrix_puzzle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Solve the no connection puzzle",
    "url": "http://rosettacode.org/wiki/Solve_the_no_connection_puzzle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sort a list of object identifiers",
    "url": "http://rosettacode.org/wiki/Sort_a_list_of_object_identifiers"
  },
  {
    "local_code": "#[derive(Debug, PartialEq)]\npub struct Element {\n    name: String,\n    value: String,\n}\n\nimpl Element {\n    fn new(name: &str, value: &str) -> Element {\n        Element {\n            name: name.to_string(),\n            value: value.to_string(),\n        }\n    }\n}\n\npub fn sort_by_name(elements: &mut Vec<Element>) {\n    elements.sort_by(|a, b| a.name.cmp(&b.name));\n}\n\nfn main() {\n    let mut values = vec![\n        Element::new(\"Iron\", \"Fe\"),\n        Element::new(\"Cobalt\", \"Co\"),\n        Element::new(\"Nickel\", \"Ni\"),\n        Element::new(\"Copper\", \"Cu\"),\n        Element::new(\"Zinc\", \"Zn\"),\n    ];\n    sort_by_name(&mut values);\n    println!(\"{:?}\", values);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_example() {\n        let mut values = vec![\n            Element::new(\"Iron\", \"Fe\"),\n            Element::new(\"Cobalt\", \"Co\"),\n            Element::new(\"Nickel\", \"Ni\"),\n            Element::new(\"Copper\", \"Cu\"),\n            Element::new(\"Zinc\", \"Zn\"),\n        ];\n        sort_by_name(&mut values);\n        assert_eq!(\n            values,\n            vec![\n                Element::new(\"Cobalt\", \"Co\"),\n                Element::new(\"Copper\", \"Cu\"),\n                Element::new(\"Iron\", \"Fe\"),\n                Element::new(\"Nickel\", \"Ni\"),\n                Element::new(\"Zinc\", \"Zn\"),\n            ]\n        );\n    }\n}\n",
    "path": "tasks/sort-an-array-of-composite-structures",
    "remote_code": null,
    "title": "Sort an array of composite structures",
    "url": "http://rosettacode.org/wiki/Sort_an_array_of_composite_structures"
  },
  {
    "local_code": "fn main() {\n    let mut a = vec![9, 8, 7, 6, 5, 4, 3, 2, 1, 0];\n\n    // Merge sort in place, allocates ~2*n memory\n    a.sort();\n    println!(\"{:?}\", a);\n}\n\n#[test]\nfn test_sort() {\n    let mut a = vec![3, 1, 4, 1, 5, 9];\n    a.sort();\n    assert!(a == vec![1, 1, 3, 4, 5, 9]);\n}\n",
    "path": "tasks/sort-an-integer-array",
    "remote_code": "fn main() {\n    let mut a = vec!(9, 8, 7, 6, 5, 4, 3, 2, 1, 0);\n\n    a.sort();\n    println!(\"{:?}\", a);\n}",
    "title": "Sort an integer array",
    "url": "http://rosettacode.org/wiki/Sort_an_integer_array"
  },
  {
    "local_code": "pub fn sort_disjoint(values: &mut [i32], indices: &[usize]) {\n    let mut sublist_indices = indices.to_owned();\n    sublist_indices.sort();\n    let mut sublist: Vec<i32> = sublist_indices.iter().map(|&i| values[i]).collect();\n    sublist.sort();\n    for i in 0..sublist.len() {\n        values[sublist_indices[i]] = sublist[i];\n    }\n}\n\nfn main() {\n    let mut values = [7, 6, 5, 4, 3, 2, 1, 0];\n    let indices = [6, 1, 7];\n    sort_disjoint(&mut values, &indices);\n    println!(\"{:?}\", values);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::sort_disjoint;\n    #[test]\n    fn test_example() {\n        let mut values = [7, 6, 5, 4, 3, 2, 1, 0];\n        let indices = [6, 1, 7];\n        sort_disjoint(&mut values, &indices);\n        assert_eq!(values, [7, 0, 5, 4, 3, 2, 1, 6]);\n    }\n    #[test]\n    fn test_sort_one() {\n        let mut values = [0];\n        let indices = [0];\n        sort_disjoint(&mut values, &indices);\n        assert_eq!(values, [0]);\n    }\n    #[test]\n    fn test_sort_all() {\n        let mut values = [7, 6, 5, 4, 3, 2, 1, 0];\n        let indices = [6, 1, 7, 2, 0, 4, 3, 5];\n        sort_disjoint(&mut values, &indices);\n        assert_eq!(values, [0, 1, 2, 3, 4, 5, 6, 7]);\n    }\n}\n",
    "path": "tasks/sort-disjoint-sublist",
    "remote_code": null,
    "title": "Sort disjoint sublist",
    "url": "http://rosettacode.org/wiki/Sort_disjoint_sublist"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sort numbers lexicographically",
    "url": "http://rosettacode.org/wiki/Sort_numbers_lexicographically"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let country_city = [(\"UK\", \"London\"),\n                        (\"US\", \"New York\"),\n                        (\"US\", \"Birmingham\"),\n                        (\"UK\", \"Birmingham\")];\n\n    let mut city_sorted = country_city.clone();\n    city_sorted.sort_by_key(|k| k.1);\n\n    let mut country_sorted = country_city.clone();\n    country_sorted.sort_by_key(|k| k.0);\n\n\n    println!(\"Original:\");\n    for x in &country_city {\n        println!(\"{} {}\", x.0, x.1);\n    }\n\n    println!(\"\\nWhen sorted by city:\");\n    for x in &city_sorted {\n        println!(\"{} {}\", x.0, x.1);\n    }\n\n    println!(\"\\nWhen sorted by county:\");\n    for x in &country_sorted {\n        println!(\"{} {}\", x.0, x.1);\n    }\n}",
    "title": "Sort stability",
    "url": "http://rosettacode.org/wiki/Sort_stability"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sort three variables",
    "url": "http://rosettacode.org/wiki/Sort_three_variables"
  },
  {
    "local_code": "fn sort_custom(strings: &mut Vec<&str>) {\n    use std::cmp::Ordering;\n    strings.sort_by(|a, b| {\n        if a.len() > b.len() {\n            return Ordering::Less;\n        }\n        if a.len() < b.len() {\n            return Ordering::Greater;\n        }\n        a.cmp(b)\n    });\n}\n\nfn main() {\n    let mut strings = vec![\n        \"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\",\n    ];\n    sort_custom(&mut strings);\n    println!(\"{:?}\", strings);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::sort_custom;\n    #[test]\n    fn test_descending_in_length() {\n        let mut strings = vec![\"a\", \"aa\", \"aaa\", \"aaaa\", \"aaaaa\"];\n        sort_custom(&mut strings);\n        assert_eq!(strings, [\"aaaaa\", \"aaaa\", \"aaa\", \"aa\", \"a\"]);\n    }\n    #[test]\n    fn test_ascending_lexicographically() {\n        let mut strings = vec![\"baaaa\", \"abaaa\", \"aabaa\", \"aaaba\", \"aaaab\"];\n        sort_custom(&mut strings);\n        assert_eq!(strings, [\"aaaab\", \"aaaba\", \"aabaa\", \"abaaa\", \"baaaa\"]);\n    }\n    #[test]\n    fn test_mixture() {\n        let mut strings = vec![\"a\", \"A\", \"ba\", \"aa\", \"AA\", \"aAa\", \"aaa\"];\n        sort_custom(&mut strings);\n        assert_eq!(strings, [\"aAa\", \"aaa\", \"AA\", \"aa\", \"ba\", \"A\", \"a\"]);\n    }\n}\n",
    "path": "tasks/sort-using-a-custom-comparator",
    "remote_code": "\nfn main() {\n    let mut words = [\"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\"];\n    words.sort_by(|l, r| Ord::cmp(&r.len(), &l.len()).then(Ord::cmp(l, r)));\n    println!(\"{:?}\", words);\n}\n",
    "title": "Sort using a custom comparator",
    "url": "http://rosettacode.org/wiki/Sort_using_a_custom_comparator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sorting algorithms/Bead sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Bead_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\nextern crate rand;\n\nuse rand::prelude::*;\n\nfn bogo_sort<T: Ord>(v: &mut [T]) {\n    let mut rng = thread_rng();\n    while !is_sorted(v) {\n        v.shuffle(&mut rng);\n    }\n}\n\n// helper function that checks for ascending order\nfn is_sorted<T: Ord>(v: &[T]) -> bool {\n    if v.len() > 1 {\n        for i in 0..(v.len() - 1) {\n            if v[i] > v[i + 1] {\n                return false;\n            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n    bogo_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n}\n\n#[cfg(test)]\nmod tests {\n    // The sort is random, so it could take a very long time!\n    test_sort!(super::bogo_sort, #[ignore]);\n}\n",
    "path": "tasks/sorting-algorithms/bogosort",
    "remote_code": "extern crate rand;\nuse rand::Rng;\n\nfn bogosort_by<T,F>(order: F, coll: &mut [T])\n    where F: Fn(&T, &T) -> bool\n{\n    let mut rng = rand::thread_rng();\n    while !is_sorted_by(&order, coll) {\n        rng.shuffle(coll);\n    }\n}\n\n#[inline]\nfn is_sorted_by<T,F>(order: F, coll: &[T]) -> bool\n    where F: Fn(&T,&T) -> bool,\n{\n    coll[..].iter().zip(&coll[1..]).all(|(x,y)| order(x,y))\n}\n\n \nfn main() {\n    let mut testlist = [1,55,88,24,990876,312,67,0,854,13,4,7];\n    bogosort_by(|x,y| x < y, &mut testlist);\n    println!(\"{:?}\", testlist);\n    bogosort_by(|x,y| x > y, &mut testlist);\n    println!(\"{:?}\", testlist);\n}\n",
    "title": "Sorting algorithms/Bogosort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Bogosort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\n/// Progress through the slice and 'bubble' elements up until they are in order.\nfn bubble_sort<T: PartialOrd>(v: &mut [T]) {\n    (1..v.len() + 1).rev().all(|length| {\n        let mut changes = 0;\n\n        for index in 0..length - 1 {\n            if v[index] > v[index + 1] {\n                changes += 1;\n                v.swap(index, index + 1);\n            }\n        }\n\n        // Continue to iterate if any 'bubble-ing' took place\n        changes > 0\n    });\n}\n\nfn main() {\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    bubble_sort(&mut numbers);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::bubble_sort);\n}\n",
    "path": "tasks/sorting-algorithms/bubble-sort",
    "remote_code": "fn bubble_sort<T: Ord>(values: &mut[T]) {\n    let mut n = values.len();\n    let mut swapped = true;\n\n    while swapped {\n        swapped = false;\n\n        for i in 1..n {\n            if values[i - 1] > values[i] {\n                values.swap(i - 1, i);\n                swapped = true;\n            }\n        }\n\n        n = n - 1;\n    }\n}\n\nfn main() {\n    // Sort numbers.\n    let mut numbers = [8, 7, 1, 2, 9, 3, 4, 5, 0, 6];\n    println!(\"Before: {:?}\", numbers);\n\n    bubble_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n\n    // Sort strings.\n    let mut strings = [\"empty\", \"beach\", \"art\", \"car\", \"deal\"];\n    println!(\"Before: {:?}\", strings);\n\n    bubble_sort(&mut strings);\n    println!(\"After: {:?}\", strings);\n}",
    "title": "Sorting algorithms/Bubble sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\n// Progress through the slice and 'bubble' elements up and down until they are in order.\nfn cocktail_sort<T: PartialOrd>(v: &mut [T]) {\n    (1..v.len() + 1).rev().all(|length| {\n        let mut swapped: bool = false;\n        // bubble up\n        for index in 0..length - 1 {\n            if v[index] > v[index + 1] {\n                swapped = true;\n                v.swap(index, index + 1);\n            }\n        }\n        // break if no swap occured before bubbling down\n        if !swapped {\n            return false;\n        }\n        // bubble down\n        for index in (0..length - 1).rev() {\n            if v[index] > v[index + 1] {\n                swapped = true;\n                v.swap(index, index + 1);\n            }\n        }\n        // Continue to iterate if any swapping took place\n        swapped\n    });\n}\n\nfn main() {\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n    cocktail_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::cocktail_sort);\n}\n",
    "path": "tasks/sorting-algorithms/cocktail-sort",
    "remote_code": null,
    "title": "Sorting algorithms/Cocktail sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\n#[cfg_attr(feature = \"clippy\", allow(needless_range_loop))]\nfn comb_sort<T: PartialOrd>(v: &mut [T]) {\n    let len = v.len();\n    let mut gap: usize = v.len();\n    let mut swapped: bool = true;\n    while gap > 1 || swapped {\n        if gap > 1 {\n            gap = (gap as f32 / 1.25) as usize;\n        }\n        swapped = false;\n        for i in 0..len - gap {\n            if v[i] > v[i + gap] {\n                swapped = true;\n                v.swap(i, i + gap);\n            }\n        }\n    }\n}\n\nfn main() {\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n    comb_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::comb_sort);\n}\n",
    "path": "tasks/sorting-algorithms/comb-sort",
    "remote_code": null,
    "title": "Sorting algorithms/Comb sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Comb_sort"
  },
  {
    "local_code": "#[cfg_attr(feature = \"cargo-clippy\", allow(needless_range_loop))]\nfn counting_sort(array: &mut [i32], min: i32, max: i32) {\n    // nothing to do for arrays shorter than 2\n    if array.len() < 2 {\n        return;\n    }\n\n    // we count occurences of values\n    let size = (max - min + 1) as usize;\n    let mut count = vec![0; size];\n\n    for e in array.iter() {\n        count[(*e - min) as usize] += 1;\n    }\n\n    // then we write values back, sorted\n    let mut index = 0;\n    for value in 0..count.len() {\n        for _ in 0..count[value] {\n            array[index] = value as i32;\n            index += 1;\n        }\n    }\n}\n\nfn main() {\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    counting_sort(&mut numbers, -31, 782);\n}\n\n#[cfg(test)]\nmod tests {\n    extern crate meta;\n\n    fn check_sort(array: &mut [i32], min: i32, max: i32) {\n        super::counting_sort(array, min, max);\n\n        meta::test_utils::check_sorted(array);\n    }\n\n    #[test]\n    fn rosetta_vector() {\n        let numbers = &mut [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n        check_sort(numbers, -31, 782);\n    }\n\n    #[test]\n    fn one_element_vector() {\n        let numbers = &mut [0i32];\n        check_sort(numbers, 0, 0);\n    }\n\n    #[test]\n    fn repeat_vector() {\n        let numbers = &mut [1i32, 1, 1, 1, 1];\n        check_sort(numbers, 1, 1);\n    }\n\n    #[test]\n    fn worst_case_vector() {\n        let numbers = &mut [20i32, 10, 0, -1, -5];\n        check_sort(numbers, -5, 20);\n    }\n\n    #[test]\n    fn already_sorted_vector() {\n        let numbers = &mut [-1i32, 0, 3, 6, 99];\n        check_sort(numbers, -1, 99);\n    }\n\n    #[test]\n    #[should_panic]\n    fn bad_min() {\n        let numbers = &mut [-1i32, 0, 3, 6, 99];\n        check_sort(numbers, 2, 99);\n    }\n}\n",
    "path": "tasks/sorting-algorithms/counting-sort",
    "remote_code": "fn counting_sort(\n    mut data: Vec<usize>,\n    min: usize,\n    max: usize,\n) -> Vec<usize> {\n    // create and fill counting bucket with 0\n    let mut count: Vec<usize> = Vec::with_capacity(data.len());\n    count.resize(data.len(), 0);\n\n    for num in &data {\n        count[num - min] = count[num - min] + 1;\n    }\n    let mut z: usize = 0;\n    for i in min..max+1 {\n        while count[i - min] > 0 {\n            data[z] = i;\n            z += 1;\n            count[i - min] = count[i - min] - 1;\n        }\n    }\n\n    data\n}\n\nfn main() {\n    let arr1 = vec![1, 0, 2, 9, 3, 8, 4, 7, 5, 6];\n    println!(\"{:?}\", counting_sort(arr1, 0, 9));\n\n    let arr2 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    println!(\"{:?}\", counting_sort(arr2, 0, 9));\n\n    let arr3 = vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0];\n    println!(\"{:?}\", counting_sort(arr3, 0, 10));\n}",
    "title": "Sorting algorithms/Counting sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Counting_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\nfn gnome_sort<T: PartialOrd>(v: &mut [T]) {\n    let len = v.len();\n    let mut i: usize = 1;\n    let mut j: usize = 2;\n    while i < len {\n        if v[i - 1] <= v[i] {\n            i = j;\n            j += 1;\n        } else {\n            v.swap(i - 1, i);\n            i -= 1;\n            if i == 0 {\n                i = j;\n                j += 1;\n            }\n        }\n    }\n}\n\nfn main() {\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n    gnome_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::gnome_sort);\n}\n",
    "path": "tasks/sorting-algorithms/gnome-sort",
    "remote_code": null,
    "title": "Sorting algorithms/Gnome sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Gnome_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\n/// This is ported from the Dart heap sort implementation\nfn heap_sort<T: Ord>(a: &mut [T]) {\n    let count = a.len();\n\n    if count == 0 {\n        return;\n    }\n\n    // first place 'a' in max-heap order\n    heapify(a, count);\n\n    let mut end = count - 1;\n    while end > 0 {\n        // swap the root (maximum value) of the heap with the\n        // last element of the heap\n        a.swap(0, end);\n\n        // put the heap back in max-heap order\n        sift_down(a, 0, end - 1);\n\n        // decrement the size of the heap so that the previous\n        // max value will stay in its proper place\n        end -= 1;\n    }\n}\n\nfn heapify<T: Ord>(a: &mut [T], count: usize) {\n    if count < 2 {\n        return;\n    }\n\n    // start is assigned the index in 'a' of the last parent node\n    let mut start: i32 = (count as i32 - 2) / 2; // binary heap\n\n    while start >= 0 {\n        // sift down the node at index 'start' to the proper place\n        // such that all nodes below the 'start' index are in heap order\n        sift_down(a, start as usize, count - 1);\n        start -= 1;\n    }\n}\n\nfn sift_down<T: Ord>(a: &mut [T], start: usize, end: usize) {\n    // end represents the limit of how far down the heap to shift\n    let mut root = start;\n\n    // while the root has at least one child\n    while (root * 2 + 1) <= end {\n        // root*2+1 points to the left child\n        let mut child: usize = root * 2 + 1 as usize;\n\n        // if the chile has a sibling and the child's value is less that its sibling's...\n        if child + 1 <= end && a[child] < a[child + 1] {\n            // .. then point to the right child instead\n            child += 1;\n        }\n\n        // out of max-heap order\n        if a[root] < a[child] {\n            a.swap(root, child);\n            // repeat to continue shifting down the child now\n            root = child;\n        } else {\n            return;\n        }\n    }\n}\n\npub fn main() {\n    let mut arr = [1i32, 5, 2, 7, 3, 9, 4, 6, 8];\n    heap_sort(&mut arr);\n    println!(\"After sort: {:?}\", arr);\n\n    let mut arr = [1i32, 2, 3, 4, 5, 6, 7, 8, 9];\n    heap_sort(&mut arr);\n    println!(\"After sort: {:?}\", arr);\n\n    let mut arr = [9i32, 8, 7, 6, 5, 4, 3, 2, 1];\n    heap_sort(&mut arr);\n    println!(\"After sort: {:?}\", arr);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::heap_sort);\n}\n",
    "path": "tasks/sorting-algorithms/heapsort",
    "remote_code": "fn main() {\n    let mut v = [4, 6, 8, 1, 0, 3, 2, 2, 9, 5];\n    heap_sort(&mut v, |x, y| x < y);\n    println!(\"{:?}\", v);\n}\n\nfn heap_sort<T, F>(array: &mut [T], order: F)\nwhere\n    F: Fn(&T, &T) -> bool,\n{\n    let len = array.len();\n    // Create heap\n    for start in (0..len / 2).rev() {\n        shift_down(array, &order, start, len - 1)\n    }\n\n    for end in (1..len).rev() {\n        array.swap(0, end);\n        shift_down(array, &order, 0, end - 1)\n    }\n}\n\nfn shift_down<T, F>(array: &mut [T], order: &F, start: usize, end: usize)\nwhere\n    F: Fn(&T, &T) -> bool,\n{\n    let mut root = start;\n    loop {\n        let mut child = root * 2 + 1;\n        if child > end {\n            break;\n        }\n        if child + 1 <= end && order(&array[child], &array[child + 1]) {\n            child += 1;\n        }\n        if order(&array[root], &array[child]) {\n            array.swap(root, child);\n            root = child\n        } else {\n            break;\n        }\n    }\n}",
    "title": "Sorting algorithms/Heapsort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Heapsort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\nfn insertion_sort<T>(arr: &mut [T])\nwhere\n    T: Ord,\n{\n    for i in 1..arr.len() {\n        let mut j = i;\n        while j > 0 && arr[j] < arr[j - 1] {\n            arr.swap(j, j - 1);\n            j -= 1;\n        }\n    }\n}\n\nfn main() {\n    let mut arr = vec![6, 8, 5, 9, 3, 2, 1, 4, 7];\n    insertion_sort(&mut arr);\n    println!(\"{:?}\", arr);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::insertion_sort);\n}\n",
    "path": "tasks/sorting-algorithms/insertion-sort",
    "remote_code": "fn insertion_sort<T: std::cmp::Ord>(arr: &mut [T]) {\n    for i in 1..arr.len() {\n        let mut j = i;\n        while j > 0 && arr[j] < arr[j-1] {\n            arr.swap(j, j-1);\n            j = j-1;\n        }\n    }\n}",
    "title": "Sorting algorithms/Insertion sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Insertion_sort"
  },
  {
    "local_code": "//! This is an idiomatic-but-slow implementation. A more efficient implementation\n//! would use `unsafe` to avoid allocating so many temporary vectors.\n\nfn merge_sort<E: PartialOrd + Clone>(arr: &[E]) -> Vec<E> {\n    if arr.len() <= 1 {\n        return arr.to_vec();\n    }\n    let midpoint = arr.len() / 2;\n    let left = merge_sort(&arr[0..midpoint]);\n    let right = merge_sort(&arr[midpoint..]);\n    merge(&left[..], &right[..])\n}\n\nfn merge<E: PartialOrd + Clone>(left: &[E], right: &[E]) -> Vec<E> {\n    let mut merged = Vec::with_capacity(left.len() + right.len());\n    let mut i = 0;\n    let mut j = 0;\n    while i < left.len() && j < right.len() {\n        if left[i] <= right[j] {\n            merged.push(left[i].clone());\n            i += 1;\n        } else {\n            merged.push(right[j].clone());\n            j += 1;\n        }\n    }\n    while i < left.len() {\n        merged.push(left[i].clone());\n        i += 1;\n    }\n    while j < right.len() {\n        merged.push(right[j].clone());\n        j += 1;\n    }\n    merged\n}\n\npub fn main() {\n    let arr = [1i32, 9, 3, 2, 1003, 23, -123, 7];\n    let sorted = merge_sort(&arr);\n    println!(\"{:?}\", sorted);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::merge_sort;\n\n    #[test]\n    fn sorted() {\n        let arr = [1i32, 2, 3, 4, 6, 8];\n        assert_eq!(merge_sort(&arr), arr.to_vec());\n    }\n\n    #[test]\n    fn reverse() {\n        let arr = [8i32, 6, 4, 3, 2, 1];\n        assert_eq!(merge_sort(&arr), vec![1i32, 2, 3, 4, 6, 8]);\n    }\n\n    #[test]\n    fn random() {\n        let arr = [12i32, 54, 2, 93, 13, 43, 15, 299, 234];\n        assert_eq!(\n            merge_sort(&arr),\n            vec![2i32, 12, 13, 15, 43, 54, 93, 234, 299]\n        );\n    }\n}\n",
    "path": "tasks/sorting-algorithms/merge-sort",
    "remote_code": "\nfn merge<T: Copy + PartialOrd>(x1: &[T], x2: &[T], y: &mut [T]) {\n\tassert_eq!(x1.len() + x2.len(), y.len());\n\tlet mut i = 0;\n\tlet mut j = 0;\n\tlet mut k = 0;\n\twhile i < x1.len() && j < x2.len() {\n\t\tif x1[i] < x2[j] {\n\t\t\ty[k] = x1[i];\n\t\t\tk += 1;\n\t\t\ti += 1;\n\t\t} else {\n\t\t\ty[k] = x2[j];\n\t\t\tk += 1;\n\t\t\tj += 1;\n\t\t}\n\t}\n\tif i < x1.len() {\n\t\ty[k..].copy_from_slice(&x1[i..]);\n\t}\n\tif j < x2.len() {\n\t\ty[k..].copy_from_slice(&x2[j..]);\n\t}\n}\n",
    "title": "Sorting algorithms/Merge sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Merge_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\nfn pancake_sort<T: Ord>(v: &mut [T]) {\n    let len = v.len();\n    // trivial case -- no flips\n    if len < 2 {\n        return;\n    }\n    for i in (0..len).rev() {\n        // find index of the maximum element within `v[0..i]` (inclusive)\n        let max_index = v\n            .iter()\n            .take(i + 1)\n            .enumerate()\n            .max_by_key(|&(_, elem)| elem)\n            .map(|(idx, _)| idx)\n            .expect(\"already checked to be non-empty\");\n        // if `max_index` is not where it's supposed to be\n        // do two flips to move it to `i`\n        if max_index != i {\n            flip(v, max_index);\n            flip(v, i);\n        }\n    }\n}\n\n// function to flip a section of a mutable collection from 0..num (inclusive)\nfn flip<E: PartialOrd>(v: &mut [E], num: usize) {\n    v[0..num + 1].reverse();\n}\n\nfn main() {\n    // Sort numbers\n    let mut numbers = [4, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n    pancake_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n\n    // Sort strings\n    let mut strings = [\"beach\", \"hotel\", \"airplane\", \"car\", \"house\", \"art\"];\n    println!(\"Before: {:?}\", strings);\n    pancake_sort(&mut strings);\n    println!(\"After: {:?}\", strings);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::pancake_sort);\n}\n",
    "path": "tasks/sorting-algorithms/pancake-sort",
    "remote_code": null,
    "title": "Sorting algorithms/Pancake sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Pancake_sort"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sorting algorithms/Patience sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Patience_sort"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sorting algorithms/Permutation sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Permutation_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\n/// We use an [in-place quick sort].\n///\n/// [in-place quick sort]: http://en.wikipedia.org/wiki/Quicksort#In-place_version\nfn quick_sort<T: Ord>(v: &mut [T]) {\n    let len = v.len();\n    if len < 2 {\n        return;\n    }\n\n    let pivot_index = partition(v);\n\n    // Sort the left side\n    quick_sort(&mut v[0..pivot_index]);\n\n    // Sort the right side\n    quick_sort(&mut v[pivot_index + 1..len]);\n}\n\n/// Reorders the slice with values lower than the pivot at the left side,\n/// and values bigger than it at the right side.\n/// Also returns the store index.\n#[cfg_attr(feature = \"clippy\", allow(needless_range_loop))]\nfn partition<T: Ord>(v: &mut [T]) -> usize {\n    let len = v.len();\n    let pivot_index = len / 2;\n\n    v.swap(pivot_index, len - 1);\n\n    let mut store_index = 0;\n    for i in 0..(len - 1) {\n        if v[i] <= v[len - 1] {\n            v.swap(i, store_index);\n            store_index += 1;\n        }\n    }\n\n    v.swap(store_index, len - 1);\n    store_index\n}\n\nfn main() {\n    // Sort numbers\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n\n    quick_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n\n    // Sort strings\n    let mut strings = [\"beach\", \"hotel\", \"airplane\", \"car\", \"house\", \"art\"];\n    println!(\"Before: {:?}\", strings);\n\n    quick_sort(&mut strings);\n    println!(\"After: {:?}\", strings);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::quick_sort);\n}\n",
    "path": "tasks/sorting-algorithms/quicksort",
    "remote_code": "fn main() {\n    println!(\"Sort numbers in descending order\");\n    let mut numbers = [4, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n\n    quick_sort(&mut numbers, &|x,y| x > y);\n    println!(\"After:  {:?}\\n\", numbers);\n\n    println!(\"Sort strings alphabetically\");\n    let mut strings = [\"beach\", \"hotel\", \"airplane\", \"car\", \"house\", \"art\"];\n    println!(\"Before: {:?}\", strings);\n\n    quick_sort(&mut strings, &|x,y| x < y);\n    println!(\"After:  {:?}\\n\", strings);\n    \n    println!(\"Sort strings by length\");\n    println!(\"Before: {:?}\", strings);\n\n    quick_sort(&mut strings, &|x,y| x.len() < y.len());\n    println!(\"After:  {:?}\", strings);    \n}\n\nfn quick_sort<T,F>(v: &mut [T], f: &F) \n    where F: Fn(&T,&T) -> bool\n{\n    let len = v.len();\n    if len >= 2 {\n        let pivot_index = partition(v, f);\n        quick_sort(&mut v[0..pivot_index], f);\n        quick_sort(&mut v[pivot_index + 1..len], f);\n    }\n}\n\nfn partition<T,F>(v: &mut [T], f: &F) -> usize \n    where F: Fn(&T,&T) -> bool\n{\n    let len = v.len();\n    let pivot_index = len / 2;\n    let last_index = len - 1;\n\n    v.swap(pivot_index, last_index);\n\n    let mut store_index = 0;\n    for i in 0..last_index {\n        if f(&v[i], &v[last_index]) {\n            v.swap(i, store_index);\n            store_index += 1;\n        }\n    }\n\n    v.swap(store_index, len - 1);\n    store_index\n}",
    "title": "Sorting algorithms/Quicksort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Quicksort"
  },
  {
    "local_code": "fn merge(in1: &[i32], in2: &[i32], out: &mut [i32]) {\n    let (left, right) = out.split_at_mut(in1.len());\n    left.clone_from_slice(in1);\n    right.clone_from_slice(in2);\n}\n\n// least significant digit radix sort\nfn radix_sort(data: &mut [i32]) {\n    for bit in 0..31 {\n        // types of small and big is Vec<i32>.\n        // It will be infered from the next call of merge function.\n        let (small, big): (Vec<_>, Vec<_>) = data.iter().partition(|&&x| (x >> bit) & 1 == 0);\n        merge(&small, &big, data);\n    }\n    // last bit is sign\n    let (negative, positive): (Vec<_>, Vec<_>) = data.iter().partition(|&&x| x < 0);\n    merge(&negative, &positive, data);\n}\n\nfn main() {\n    let mut data = [170, 45, 75, -90, -802, 24, 2, 66, -17, 2];\n    println!(\"Before: {:?}\", data);\n    radix_sort(&mut data);\n    println!(\"After: {:?}\", data);\n}\n\n#[cfg(test)]\nmod tests {\n    extern crate rand;\n    use self::rand::{thread_rng, Rng};\n\n    use super::radix_sort;\n\n    fn check_numbers(numbers: &mut [i32]) {\n        let mut correct = numbers.to_vec();\n        correct.sort();\n        radix_sort(numbers);\n        assert_eq!(correct, numbers);\n    }\n\n    #[test]\n    fn test_rosetta_vector() {\n        check_numbers(&mut [170, 45, 75, -90, -802, 24, 2, 66, -17, 2]);\n    }\n\n    #[test]\n    fn test_empty_vector() {\n        check_numbers(&mut []);\n    }\n\n    #[test]\n    fn test_one_element_vector() {\n        check_numbers(&mut [0i32]);\n    }\n\n    #[test]\n    fn test_repeat_vector() {\n        check_numbers(&mut [1i32, 1, 1, 1, 1]);\n    }\n\n    #[test]\n    fn test_already_sorted_vector() {\n        check_numbers(&mut [-1i32, 0, 3, 6, 99]);\n    }\n\n    #[test]\n    fn test_random_numbers() {\n        let mut rng = thread_rng();\n        let mut numbers: Vec<i32> = (0..500).map(|_| rng.gen()).collect();\n        check_numbers(numbers.as_mut_slice());\n    }\n}\n",
    "path": "tasks/sorting-algorithms/radix-sort",
    "remote_code": null,
    "title": "Sorting algorithms/Radix sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Radix_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\n#[cfg_attr(feature = \"clippy\", allow(needless_range_loop))]\nfn selection_sort<T: Ord>(v: &mut [T]) {\n    if v.is_empty() {\n        return;\n    }\n\n    let len = v.len();\n\n    for j in 0..len - 1 {\n        let mut min_index = j;\n        for i in j + 1..len {\n            if v[i] <= v[min_index] {\n                min_index = i;\n            }\n        }\n        v.swap(j, min_index);\n    }\n}\n\nfn main() {\n    // Sort numbers\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n\n    selection_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n\n    // Sort strings\n    let mut strings = [\"beach\", \"hotel\", \"airplane\", \"car\", \"house\", \"art\"];\n    println!(\"Before: {:?}\", strings);\n\n    selection_sort(&mut strings);\n    println!(\"After: {:?}\", strings);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::selection_sort);\n}\n",
    "path": "tasks/sorting-algorithms/selection-sort",
    "remote_code": "\nfn selection_sort(array: &mut [i32]) {\n\n    let mut min;\n\n    for i in 0..array.len() {\n\n        min = i;\n\n        for j in (i+1)..array.len() {\n\n            if array[j] < array[min] {\n                min = j;\n            }\n        }\n\n        let tmp = array[i];\n        array[i] = array[min];\n        array[min] = tmp;\n    }\n}\n\nfn main() {\n\n    let mut array = [ 9, 4, 8, 3, -5, 2, 1, 6 ];\n    println!(\"The initial array is {:?}\", array);\n\n    selection_sort(&mut array);\n    println!(\" The sorted array is {:?}\", array);\n}\n",
    "title": "Sorting algorithms/Selection sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Selection_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\n#[cfg_attr(feature = \"clippy\", allow(needless_range_loop))]\nfn shell_sort<T: Ord + Copy>(v: &mut [T]) {\n    let mut gap = v.len() / 2;\n    let len = v.len();\n    while gap > 0 {\n        for i in gap..len {\n            let temp = v[i];\n            let mut j = i;\n            while j >= gap && v[j - gap] > temp {\n                v[j] = v[j - gap];\n                j -= gap;\n            }\n            v[j] = temp;\n        }\n        gap /= 2;\n    }\n}\n\nfn main() {\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n    shell_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::shell_sort);\n}\n",
    "path": "tasks/sorting-algorithms/shell-sort",
    "remote_code": null,
    "title": "Sorting algorithms/Shell sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Shell_sort"
  },
  {
    "local_code": "use std::thread;\nuse std::time::Duration;\n\nfn sleepsort<I>(nums: I)\nwhere\n    I: Iterator<Item = u64>,\n{\n    let threads: Vec<_> = nums\n        .map(|n| {\n            thread::spawn(move || {\n                thread::sleep(Duration::from_millis(n));\n                println!(\"{}\", n);\n            })\n        })\n        .collect();\n\n    for t in threads {\n        t.join().unwrap();\n    }\n}\n\nfn main() {\n    sleepsort(std::env::args().skip(1).map(|s| s.parse().unwrap()));\n}\n",
    "path": "tasks/sorting-algorithms/sleep-sort",
    "remote_code": "use std::thread;\n\nfn sleepsort<I: Iterator<Item=u32>>(nums: I) {\n    let threads: Vec<_> = nums.map(|n|\n        thread::spawn(move || {\n            thread::sleep_ms(n);\n            println!(\"{}\", n); })).collect();\n    for t in threads { t.join(); }\n}\n\nfn main() {\n    sleepsort(std::env::args().skip(1).map(|s| s.parse().unwrap()));\n}",
    "title": "Sorting algorithms/Sleep sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Sleep_sort"
  },
  {
    "local_code": "#[cfg(test)]\n#[macro_use]\nextern crate meta;\n\nfn stoogesort<E>(a: &mut [E])\nwhere\n    E: PartialOrd,\n{\n    if a.is_empty() {\n        return;\n    }\n\n    let len = a.len();\n\n    if a.first().unwrap() > a.last().unwrap() {\n        a.swap(0, len - 1);\n    }\n    if len - 1 > 1 {\n        let t = len / 3;\n        stoogesort(&mut a[..len - 1]);\n        stoogesort(&mut a[t..]);\n        stoogesort(&mut a[..len - 1]);\n    }\n}\n\nfn main() {\n    let mut numbers = vec![1_i32, 9, 4, 7, 6, 5, 3, 2, 8];\n    println!(\"Before: {:?}\", &numbers);\n    stoogesort(&mut numbers);\n    println!(\"After: {:?}\", &numbers);\n}\n\n#[cfg(test)]\nmod tests {\n    test_sort!(super::stoogesort);\n}\n",
    "path": "tasks/sorting-algorithms/stooge-sort",
    "remote_code": "fn stoogesort<E>(a: &mut [E])\n    where E: PartialOrd\n{\n    let len = a.len();\n\n    if a.first().unwrap() > a.last().unwrap() {\n        a.swap(0, len - 1);\n    }\n    if len - 1 > 1 {\n        let t = len / 3;\n        stoogesort(&mut a[..len - 1]);\n        stoogesort(&mut a[t..]);\n        stoogesort(&mut a[..len - 1]);\n    }\n}\n\nfn main() {\n    let mut numbers = vec![1_i32, 9, 4, 7, 6, 5, 3, 2, 8];\n    println!(\"Before: {:?}\", &numbers);\n    stoogesort(&mut numbers);\n    println!(\"After: {:?}\", &numbers);\n}",
    "title": "Sorting algorithms/Stooge sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Stooge_sort"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sorting algorithms/Strand sort",
    "url": "http://rosettacode.org/wiki/Sorting_algorithms/Strand_sort"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Soundex",
    "url": "http://rosettacode.org/wiki/Soundex"
  },
  {
    "local_code": "extern crate regex;\n\nuse std::f64;\n\nuse regex::Regex;\n\nconst BARS: &str = \"▁▂▃▄▅▆▇█\";\n\nfn read_samples(input: &str) -> Vec<f64> {\n    let regex = Regex::new(r\"[\\s,]+\").unwrap();\n\n    input\n        .split(&regex)\n        .map(|value| value.parse().unwrap())\n        .collect()\n}\n\nfn sparkline(samples: &[f64]) -> String {\n    let min = samples.iter().cloned().fold(f64::NAN, f64::min);\n    let max = samples.iter().cloned().fold(f64::NAN, f64::max);\n\n    let diff = (max - min) / ((BARS.chars().count() - 1) as f64);\n\n    samples\n        .iter()\n        .map(|sample| (sample - min) / diff)\n        .map(|idx| BARS.chars().nth(idx as usize).unwrap())\n        .collect()\n}\n\nfn main() {\n    let samples = \"1 2 3 4 5 6 7 8 7 6 5 4 3 2 1\";\n    println!(\"{}\", samples);\n    println!(\"{}\", sparkline(&read_samples(samples)));\n\n    let samples = \"1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5\";\n    println!(\"{}\", samples);\n    println!(\"{}\", sparkline(&read_samples(samples)));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{read_samples, sparkline};\n\n    #[test]\n    fn simple() {\n        assert_eq!(\n            \"▁▂▃▄▅▆▇█▇▆▅▄▃▂▁\",\n            sparkline(&read_samples(\"1 2 3 4 5 6 7 8 7 6 5 4 3 2 1\"))\n        );\n    }\n\n    #[test]\n    fn complex() {\n        assert_eq!(\n            \"▂▁▄▃▆▅█▇\",\n            sparkline(&read_samples(\"1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5\"))\n        );\n    }\n}\n",
    "path": "tasks/sparkline-in-unicode",
    "remote_code": "\nconst BARS: &'static str = \"▁▂▃▄▅▆▇█\";\n\nfn print_sparkline(s: &str){\n    let v = BARS.chars().collect::<Vec<char>>();\n    let line: String = s.replace(\",\", \" \").split(\" \")\n                            .filter(|x| !x.is_empty())\n                            .map(|x| v[x.parse::<f64>().unwrap().ceil() as usize - 1])\n                            .collect();\n    println!(\"{:?}\", line);\n}\n\nfn main(){\n    let s1 = \"1 2 3 4 5 6 7 8 7 6 5 4 3 2 1\";\n    print_sparkline(s1);\n    let s2 = \"1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5\";\n    print_sparkline(s2);\n}\n",
    "title": "Sparkline in unicode",
    "url": "http://rosettacode.org/wiki/Sparkline_in_unicode"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Special characters",
    "url": "http://rosettacode.org/wiki/Special_characters"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Special variables",
    "url": "http://rosettacode.org/wiki/Special_variables"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Speech synthesis",
    "url": "http://rosettacode.org/wiki/Speech_synthesis"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Spelling of ordinal numbers",
    "url": "http://rosettacode.org/wiki/Spelling_of_ordinal_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    let characters = ['|', '/', '-', '\\\\'];\n    let mut current = 0;\n\n    println!(\"{}[2J\", 27 as char); // Clear screen.\n\n    loop {\n        println!(\"{}[;H{}\", 27 as char, characters[current]); // Move cursor to 1,1 and output the next character.\n        current += 1; // Advance current character.\n        if current == 4 {current = 0;} // If we reached the end of the array, start from the beginning.\n        std::thread::sleep(std::time::Duration::from_millis(250)); // Sleep 250 ms.\n    }\n}",
    "title": "Spinning rod animation/Text",
    "url": "http://rosettacode.org/wiki/Spinning_rod_animation/Text"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Spiral matrix",
    "url": "http://rosettacode.org/wiki/Spiral_matrix"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Split a character string based on change of character",
    "url": "http://rosettacode.org/wiki/Split_a_character_string_based_on_change_of_character"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Square but not cube",
    "url": "http://rosettacode.org/wiki/Square_but_not_cube"
  },
  {
    "local_code": "fn sieve(limit: usize) -> Vec<usize> {\n    let mut c = vec![false; limit + 1];\n    let mut p = 3;\n    loop {\n        let p2 = p * p;\n        if p2 > limit {\n            break;\n        }\n        (p2..=limit).step_by(2 * p).for_each(|i| c[i] = true);\n        loop {\n            p += 2;\n            if !c[p] {\n                break;\n            }\n        }\n    }\n    let mut two: Vec<usize> = vec![2];\n    two.drain(0..1)\n        .chain(\n            c.iter()\n                .enumerate()\n                .skip(3)\n                .step_by(2)\n                .filter_map(|(i, composite)| if *composite { None } else { Some(i) }),\n        )\n        .collect()\n}\n\nfn square_free(from: u64, to: u64) -> Vec<u64> {\n    let limit = ((to as f64).sqrt()) as usize;\n    let primes = sieve(limit);\n    let results = (from..=to)\n        .filter(|i| {\n            primes\n                .iter()\n                .map(|p| *p as u64)\n                .map(|p| p.pow(2))\n                .take_while(|p2| *p2 <= *i)\n                .all(|p2| *i % p2 != 0)\n        })\n        .collect();\n    results\n}\n\nconst TRILLION: u64 = 1000000000000;\nfn main() {\n    println!(\"Square-free integers from 1 to 145:\");\n    let sf = square_free(1, 145);\n    sf.iter().enumerate().for_each(|(i, n)| {\n        if i > 0 && i % 20 == 0 {\n            println!();\n        }\n        print!(\"{:4}\", n);\n    });\n\n    println!(\n        \"\\n\\nSquare-free integers from {} to {}\",\n        TRILLION,\n        TRILLION + 145\n    );\n    let sf = square_free(TRILLION, TRILLION + 145);\n    sf.iter().enumerate().for_each(|(i, n)| {\n        if i > 0 && i % 5 == 0 {\n            println!();\n        }\n        print!(\"{:14}\", n);\n    });\n\n    println!(\"\\n\\nNumber of square-free integers:\");\n    (2..7).map(|i| (10 as u64).pow(i)).for_each(|n| {\n        println!(\"  from {} to {} = {}\", 1, n, square_free(1, n).len());\n    });\n}\n\n#[test]\nfn test() {\n    assert_eq!(\n        square_free(1, 145),\n        vec![\n            1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30, 31, 33, 34, 35,\n            37, 38, 39, 41, 42, 43, 46, 47, 51, 53, 55, 57, 58, 59, 61, 62, 65, 66, 67, 69, 70, 71,\n            73, 74, 77, 78, 79, 82, 83, 85, 86, 87, 89, 91, 93, 94, 95, 97, 101, 102, 103, 105,\n            106, 107, 109, 110, 111, 113, 114, 115, 118, 119, 122, 123, 127, 129, 130, 131, 133,\n            134, 137, 138, 139, 141, 142, 143, 145\n        ]\n    );\n\n    assert_eq!(\n        square_free(TRILLION, TRILLION + 145),\n        vec![\n            1000000000001,\n            1000000000002,\n            1000000000003,\n            1000000000005,\n            1000000000006,\n            1000000000007,\n            1000000000009,\n            1000000000011,\n            1000000000013,\n            1000000000014,\n            1000000000015,\n            1000000000018,\n            1000000000019,\n            1000000000021,\n            1000000000022,\n            1000000000023,\n            1000000000027,\n            1000000000029,\n            1000000000030,\n            1000000000031,\n            1000000000033,\n            1000000000037,\n            1000000000038,\n            1000000000039,\n            1000000000041,\n            1000000000042,\n            1000000000043,\n            1000000000045,\n            1000000000046,\n            1000000000047,\n            1000000000049,\n            1000000000051,\n            1000000000054,\n            1000000000055,\n            1000000000057,\n            1000000000058,\n            1000000000059,\n            1000000000061,\n            1000000000063,\n            1000000000065,\n            1000000000066,\n            1000000000067,\n            1000000000069,\n            1000000000070,\n            1000000000073,\n            1000000000074,\n            1000000000077,\n            1000000000078,\n            1000000000079,\n            1000000000081,\n            1000000000082,\n            1000000000085,\n            1000000000086,\n            1000000000087,\n            1000000000090,\n            1000000000091,\n            1000000000093,\n            1000000000094,\n            1000000000095,\n            1000000000097,\n            1000000000099,\n            1000000000101,\n            1000000000102,\n            1000000000103,\n            1000000000105,\n            1000000000106,\n            1000000000109,\n            1000000000111,\n            1000000000113,\n            1000000000114,\n            1000000000115,\n            1000000000117,\n            1000000000118,\n            1000000000119,\n            1000000000121,\n            1000000000122,\n            1000000000123,\n            1000000000126,\n            1000000000127,\n            1000000000129,\n            1000000000130,\n            1000000000133,\n            1000000000135,\n            1000000000137,\n            1000000000138,\n            1000000000139,\n            1000000000141,\n            1000000000142,\n            1000000000145\n        ]\n    );\n}\n",
    "path": "tasks/square-free-integers",
    "remote_code": null,
    "title": "Square-free integers",
    "url": "http://rosettacode.org/wiki/Square-free_integers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Stable marriage problem",
    "url": "http://rosettacode.org/wiki/Stable_marriage_problem"
  },
  {
    "local_code": "#[derive(Debug)]\nstruct Stack<T> {\n    /// We use a vector because of simplicity\n    vec: Vec<T>,\n}\n\nimpl<T> Stack<T> {\n    fn new() -> Stack<T> {\n        Stack { vec: Vec::new() }\n    }\n\n    /// Adds an element at the top of the stack\n    fn push(&mut self, elem: T) {\n        self.vec.push(elem);\n    }\n\n    /// Removes and returns the element at the top of the stack\n    fn pop(&mut self) -> Option<T> {\n        self.vec.pop()\n    }\n\n    /// Returns a reference of the element at the top of the stack\n    fn peek(&self) -> Option<&T> {\n        self.vec.last()\n    }\n\n    /// Returns true if the stack is empty\n    fn empty(&self) -> bool {\n        self.vec.is_empty()\n    }\n}\n\nfn main() {\n    let mut stack = Stack::new();\n\n    // Fill the stack\n    stack.push(5i32);\n    stack.push(8);\n    stack.push(9);\n\n    // Show the element at the top\n    println!(\"{}\", stack.peek().unwrap());\n    // Show the element we popped\n    println!(\"{}\", stack.pop().unwrap());\n    if stack.empty() {\n        println!(\"The stack is empty.\")\n    } else {\n        println!(\"The stack is not empty.\")\n    }\n}\n\n#[test]\nfn test_basic() {\n    let mut stack = Stack::new();\n\n    // The stack is empty\n    assert!(stack.empty());\n\n    // Fill the stack\n    stack.push(5i32);\n    stack.push(8);\n    stack.push(9);\n\n    // The stack is not empty\n    assert!(!stack.empty());\n\n    // The element at the top is 9\n    assert!(stack.peek().unwrap() == &9);\n\n    // Remove one element\n    stack.pop();\n\n    // The element at the top is now 8\n    assert!(stack.peek().unwrap() == &8);\n}\n",
    "path": "tasks/stack",
    "remote_code": "fn main() {\n    let mut stack = Vec::new();\n    stack.push(\"Element1\");\n    stack.push(\"Element2\");\n    stack.push(\"Element3\");\n\n    assert_eq!(Some(&\"Element3\"), stack.last());\n    assert_eq!(Some(\"Element3\"), stack.pop());\n    assert_eq!(Some(\"Element2\"), stack.pop());\n    assert_eq!(Some(\"Element1\"), stack.pop());\n    assert_eq!(None, stack.pop());\n}",
    "title": "Stack",
    "url": "http://rosettacode.org/wiki/Stack"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Stack traces",
    "url": "http://rosettacode.org/wiki/Stack_traces"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Stair-climbing puzzle",
    "url": "http://rosettacode.org/wiki/Stair-climbing_puzzle"
  },
  {
    "local_code": "struct StDev {\n    len: usize,\n    sum: f32,\n    sum_sq: f32,\n}\n\nimpl StDev {\n    fn new() -> StDev {\n        StDev {\n            len: 0,\n            sum: 0.0,\n            sum_sq: 0.0,\n        }\n    }\n\n    fn stdev(&mut self, n: f32) -> f32 {\n        self.len += 1;\n        self.sum += n;\n        self.sum_sq += n.powi(2);\n        let f32_len = self.len as f32;\n        f32::sqrt(self.sum_sq / f32_len - self.sum.powi(2) / f32_len.powi(2))\n    }\n}\n\nimpl Default for StDev {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nfn main() {\n    let test_data: [i32; 8] = [2, 4, 4, 4, 5, 5, 7, 9];\n    let mut sd = StDev::new();\n    for i in &test_data {\n        println!(\"{}\", &sd.stdev(*i as f32));\n    }\n}\n\n#[test]\nfn test_stdev() {\n    let eps = 0.000001;\n    let mut sd = StDev::new();\n    // must be equal with up to eps precision\n    assert!((sd.stdev(2.0) - 0.0).abs() < eps);\n    assert!((sd.stdev(4.0) - 1.0).abs() < eps);\n    assert!((sd.stdev(4.0) - 0.942809).abs() < eps);\n    assert!((sd.stdev(4.0) - 0.866025).abs() < eps);\n    assert!((sd.stdev(5.0) - 0.979796).abs() < eps);\n    assert!((sd.stdev(5.0) - 1.0).abs() < eps);\n    assert!((sd.stdev(7.0) - 1.399708).abs() < eps);\n    assert!((sd.stdev(9.0) - 2.0).abs() < eps);\n}\n",
    "path": "tasks/standard-deviation",
    "remote_code": null,
    "title": "Standard deviation",
    "url": "http://rosettacode.org/wiki/Standard_deviation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Start from a main routine",
    "url": "http://rosettacode.org/wiki/Start_from_a_main_routine"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "State name puzzle",
    "url": "http://rosettacode.org/wiki/State_name_puzzle"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::distributions::Standard;\nuse rand::prelude::*;\n\npub fn mean(data: &[f32]) -> Option<f32> {\n    if data.is_empty() {\n        None\n    } else {\n        let sum: f32 = data.iter().sum();\n        Some(sum / data.len() as f32)\n    }\n}\n\npub fn variance(data: &[f32]) -> Option<f32> {\n    if data.is_empty() {\n        None\n    } else {\n        let mean = mean(data).unwrap();\n        let mut sum = 0f32;\n        for &x in data {\n            sum += (x - mean).powi(2);\n        }\n        Some(sum / data.len() as f32)\n    }\n}\n\npub fn standard_deviation(data: &[f32]) -> Option<f32> {\n    if data.is_empty() {\n        None\n    } else {\n        let variance = variance(data).unwrap();\n        Some(variance.sqrt())\n    }\n}\n\nfn print_histogram(width: u32, data: &[f32]) {\n    let mut histogram = [0; 10];\n    let len = histogram.len() as f32;\n    for &x in data {\n        histogram[(x * len) as usize] += 1;\n    }\n    let max_frequency = *histogram.iter().max().unwrap() as f32;\n    for (i, &frequency) in histogram.iter().enumerate() {\n        let bar_width = frequency as f32 * width as f32 / max_frequency;\n        print!(\"{:3.1}: \", i as f32 / len);\n        for _ in 0..bar_width as usize {\n            print!(\"*\");\n        }\n        println!();\n    }\n}\n\nfn main() {\n    let mut rng = rand::thread_rng();\n\n    for &number_of_samples in &[1000, 10_000, 1_000_000] {\n        let data = Standard\n            .sample_iter(&mut rng)\n            .take(number_of_samples)\n            .collect::<Vec<f32>>();\n        println!(\"  Statistics for sample size {}\", number_of_samples);\n        println!(\"Mean:               {:?}\", mean(&data));\n        println!(\"Variance:           {:?}\", variance(&data));\n        println!(\"Standard deviation: {:?}\", standard_deviation(&data));\n        print_histogram(40, &data);\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{mean, standard_deviation, variance};\n    use std::f32;\n\n    fn approx(statistics: Option<f32>, value: f32) -> bool {\n        (statistics.unwrap() - value).abs() <= f32::EPSILON\n    }\n\n    #[test]\n    fn test_mean() {\n        let empty = vec![];\n        assert_eq!(mean(&empty), None);\n        assert!(approx(mean(&[1.0]), 1.0));\n        assert!(approx(mean(&[1.0, 3.0]), 2.0));\n        assert!(approx(mean(&[1.0, 2.0, 3.0]), 2.0));\n    }\n\n    #[test]\n    fn test_variance() {\n        let empty = vec![];\n        assert_eq!(variance(&empty), None);\n        assert!(approx(variance(&[0.0]), 0.0));\n        assert!(approx(variance(&[1.0, 1.0, 1.0]), 0.0));\n        assert!(approx(variance(&[1.0, 2.0, 3.0]), 2.0 / 3.0));\n    }\n\n    #[test]\n    fn test_standard_deviation() {\n        let empty = vec![];\n        assert_eq!(standard_deviation(&empty), None);\n        assert!(approx(standard_deviation(&[0.0]), 0.0));\n        assert!(approx(standard_deviation(&[1.0, 1.0, 1.0]), 0.0));\n        assert!(approx(\n            standard_deviation(&[1.0, 2.0, 3.0]),\n            (2f32 / 3f32).sqrt()\n        ));\n    }\n}\n",
    "path": "tasks/statistics/basic",
    "remote_code": "#![feature(iter_arith)]\nextern crate rand;\n\nuse rand::distributions::{IndependentSample, Range};\n\npub fn mean(data: &[f32]) -> Option<f32> {\n    if data.is_empty() {\n        None\n    } else {\n        let sum: f32 = data.iter().sum();\n        Some(sum / data.len() as f32)\n    }\n}\n\npub fn variance(data: &[f32]) -> Option<f32> {\n    if data.is_empty() {\n        None\n    } else {\n        let mean = mean(data).unwrap();\n        let mut sum = 0f32;\n        for &x in data {\n            sum += (x - mean).powi(2);\n        }\n        Some(sum / data.len() as f32)\n    }\n}\n\npub fn standard_deviation(data: &[f32]) -> Option<f32> {\n    if data.is_empty() {\n        None\n    } else {\n        let variance = variance(data).unwrap();\n        Some(variance.sqrt())\n    }\n}\n\nfn print_histogram(width: u32, data: &[f32]) {\n    let mut histogram = [0; 10];\n    let len = histogram.len() as f32;\n    for &x in data {\n        histogram[(x * len) as usize] += 1;\n    }\n    let max_frequency = *histogram.iter().max().unwrap() as f32;\n    for (i, &frequency) in histogram.iter().enumerate() {\n        let bar_width = frequency as f32 * width as f32 / max_frequency;\n        print!(\"{:3.1}: \", i as f32 / len);\n        for _ in 0..bar_width as usize {\n            print!(\"*\");\n        }\n        println!(\"\");\n    }\n}\n\nfn main() {\n    let range = Range::new(0f32, 1f32);\n    let mut rng = rand::thread_rng();\n\n    for &number_of_samples in [1000, 10_000, 1_000_000].iter() {\n        let mut data = vec![];\n        for _ in 0..number_of_samples {\n            let x = range.ind_sample(&mut rng);\n            data.push(x);\n        }\n        println!(\"  Statistics for sample size {}\", number_of_samples);\n        println!(\"Mean:               {:?}\", mean(&data));\n        println!(\"Variance:           {:?}\", variance(&data));\n        println!(\"Standard deviation: {:?}\", standard_deviation(&data));\n        print_histogram(40, &data);\n    }\n}",
    "title": "Statistics/Basic",
    "url": "http://rosettacode.org/wiki/Statistics/Basic"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Statistics/Normal distribution",
    "url": "http://rosettacode.org/wiki/Statistics/Normal_distribution"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Stem-and-leaf plot",
    "url": "http://rosettacode.org/wiki/Stem-and-leaf_plot"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Stern-Brocot sequence",
    "url": "http://rosettacode.org/wiki/Stern-Brocot_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Stirling numbers of the first kind",
    "url": "http://rosettacode.org/wiki/Stirling_numbers_of_the_first_kind"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Stirling numbers of the second kind",
    "url": "http://rosettacode.org/wiki/Stirling_numbers_of_the_second_kind"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Straddling checkerboard",
    "url": "http://rosettacode.org/wiki/Straddling_checkerboard"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Stream Merge",
    "url": "http://rosettacode.org/wiki/Stream_Merge"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse std::ops::Add;\n\nfn main(){\n    let hello = String::from(\"Hello world\");\n    println!(\"{}\", hello.add(\"!!!!\"));\n}",
    "title": "String append",
    "url": "http://rosettacode.org/wiki/String_append"
  },
  {
    "local_code": "fn main() {\n    println!(\"{}\", \"jalapeño\".to_uppercase()); // JALAPEÑO\n    println!(\"{}\", \"JALAPEÑO\".to_lowercase()); // jalapeño\n}\n",
    "path": "tasks/string-case",
    "remote_code": "fn main() {\n    println!(\"{}\", \"jalapeño\".to_uppercase()); // JALAPEÑO\n    println!(\"{}\", \"JALAPEÑO\".to_lowercase()); // jalapeño\n}",
    "title": "String case",
    "url": "http://rosettacode.org/wiki/String_case"
  },
  {
    "local_code": "fn main() {\n    // only same types can be compared\n    // String and String or &str and &str\n    // exception: strict equality and inequality also work on &str and String\n    let a: &str = \"abc\";\n    let b: String = \"Bac\".to_owned();\n\n    // Strings are coerced to &str when borrowed and needed\n    if a == b {\n        println!(\"The strings are equal\")\n    }\n    if a != b {\n        println!(\"The strings are not equal\")\n    }\n    if a > &b {\n        println!(\"The first string is lexically after the second\")\n    }\n    if a < &b {\n        println!(\"The first string is lexically before the second\")\n    }\n    if a >= &b {\n        println!(\"The first string is not lexically before the second\")\n    }\n    if a <= &b {\n        println!(\"The first string is not lexically after the second\")\n    }\n\n    // case-insensitives:\n    // everything else, create owned Strings, then compare as above\n    let a2 = a.to_ascii_uppercase();\n    let b2 = b.to_ascii_uppercase();\n\n    // equality\n    // this avoids new allocations\n    if a.eq_ignore_ascii_case(&b) {\n        println!(\"Both strings are equal when ignoring case\")\n    }\n\n    if a2 == b2 {\n        println!(\"The strings are equal\")\n    }\n    if a2 != b2 {\n        println!(\"The strings are not equal\")\n    }\n    if a2 > b2 {\n        println!(\"The first string is lexically after the second\")\n    }\n    if a2 < b2 {\n        println!(\"The first string is lexically before the second\")\n    }\n    if a2 >= b2 {\n        println!(\"The first string is not lexically before the second\")\n    }\n    if a2 <= b2 {\n        println!(\"The first string is not lexically after the second\")\n    }\n}\n",
    "path": "tasks/string-comparison",
    "remote_code": "use std::ascii::AsciiExt; // for case insensitives only\n\nfn main() {\n    // only same types can be compared\n    // String and String or &str and &str\n    // exception: strict equality and inequality also work on &str and String\n    let a: &str = \"abc\";\n    let b: String = \"Bac\".to_owned();\n\n    // Strings are coerced to &str when borrowed and needed\n    if a == b { println!(\"The strings are equal\") }\n    if a != b { println!(\"The strings are not equal\") }\n    if a  > &b { println!(\"The first string is lexically after the second\") }\n    if a  < &b { println!(\"The first string is lexically before the second\") }\n    if a >= &b { println!(\"The first string is not lexically before the second\") }\n    if a <= &b { println!(\"The first string is not lexically after the second\") }\n\n    // case-insensitives:\n\n    // equality\n    // this avoids new allocations\n    if a.eq_ignore_ascii_case(&b) { println!(\"Both strings are equal when ignoring case\") }\n\n    // everything else, create owned Strings, then compare as above\n    let a2 = a.to_ascii_uppercase();\n    let b2 = b.to_ascii_uppercase();\n\n    // repeat checks\n}",
    "title": "String comparison",
    "url": "http://rosettacode.org/wiki/String_comparison"
  },
  {
    "local_code": "fn add_world(mut x: String) -> String {\n    // world is a &'a[u8]\n    let world = \" world\";\n    x.push_str(world);\n    x\n}\n\nfn main() {\n    // The call to_string() turns a &[u8] into a Vec<u8>.\n    // This is done because Vecs are growable but slices aren't.\n    let hello = \"hello\".to_string();\n    let hello_world = add_world(hello);\n    println!(\"{}\", hello_world);\n}\n\n#[test]\nfn test_string_concat() {\n    let super_hoverbear = \"super hoverbear\".to_string();\n    let super_hoverbear_world = add_world(super_hoverbear);\n    assert_eq!(super_hoverbear_world, \"super hoverbear world\".to_string());\n}\n",
    "path": "tasks/string-concatenation",
    "remote_code": "fn main() {\n    let s = \"hello\".to_owned();\n    println!(\"{}\", s);\n    \n    let s1 = s + \" world\";\n    println!(\"{}\", s1);\n}",
    "title": "String concatenation",
    "url": "http://rosettacode.org/wiki/String_concatenation"
  },
  {
    "local_code": "//! Rust has very powerful string interpolation. [Documentation here][doc]\n//!\n//! [doc]: https://doc.rust-lang.org/stable/std/fmt/\n\nfn main() {\n    println!(\"Mary had a {} lamb\", \"little\");\n    // You can specify order\n    println!(\"{1} had a {0} lamb\", \"little\", \"Mary\");\n    // Or named arguments if you prefer\n    println!(\"{name} had a {adj} lamb\", adj = \"little\", name = \"Mary\");\n}\n",
    "path": "tasks/string-interpolation-included",
    "remote_code": "fn main() {\n    println!(\"Mary had a {} lamb\", \"little\");\n    // You can specify order\n    println!(\"{1} had a {0} lamb\", \"little\", \"Mary\");\n    // Or named arguments if you prefer\n    println!(\"{name} had a {adj} lamb\", adj=\"little\", name=\"Mary\");\n}",
    "title": "String interpolation (included)",
    "url": "http://rosettacode.org/wiki/String_interpolation_(included)"
  },
  {
    "local_code": "fn main() {\n    let name = String::from(\"møøse\");\n    println!(\"bytes count: {}\", name.len());\n    println!(\"character count: {}\", name.chars().count());\n}\n",
    "path": "tasks/string-length",
    "remote_code": null,
    "title": "String length",
    "url": "http://rosettacode.org/wiki/String_length"
  },
  {
    "local_code": "fn match_string(container: &str, target: &str) -> (bool, bool, bool) {\n    let starts = container.starts_with(target);\n    let ends = container.ends_with(target);\n    let contains = starts || ends || container.contains(target);\n\n    (starts, contains, ends)\n}\n\nfn print_info(container: &str, target: &str) {\n    println!(r#\"Matching \"{}\" in the string \"{}\"\"#, target, container);\n    let (starts, contains, ends) = match_string(container, target);\n\n    if starts {\n        println!(r#\"\"{}\" starts with \"{}\"\"#, container, target);\n    }\n    if contains {\n        println!(r#\"\"{}\" contains \"{}\"\"#, container, target);\n    }\n    if ends {\n        println!(r#\"\"{}\" ends with \"{}\"\"#, container, target);\n    }\n}\n\nfn main() {\n    print_info(\"abcd\", \"ab\");\n    print_info(\"abcd\", \"bc\");\n    print_info(\"abcd\", \"cd\");\n}\n\n#[test]\nfn test_match_string() {\n    assert_eq!(match_string(\"abcd\", \"ab\"), (true, true, false));\n    assert_eq!(match_string(\"abcd\", \"ba\"), (false, false, false));\n    assert_eq!(match_string(\"abcd\", \"bc\"), (false, true, false));\n    assert_eq!(match_string(\"abcd\", \"cd\"), (false, true, true));\n}\n",
    "path": "tasks/string-matching",
    "remote_code": "fn print_match(possible_match: Option<usize>) {\n    match possible_match {\n        Some(match_pos) => println!(\"Found match at pos {}\", match_pos),\n        None => println!(\"Did not find any matches\")\n    }\n}\n\nfn main() {\n    let s1 = \"abcd\";\n    let s2 = \"abab\";\n    let s3 = \"ab\";\n    \n    // Determining if the first string starts with second string\n    assert!(s1.starts_with(s3));\n    // Determining if the first string contains the second string at any location\n    assert!(s1.contains(s3));\n    // Print the location of the match \n    print_match(s1.find(s3)); // Found match at pos 0\n    print_match(s1.find(s2)); // Did not find any matches\n    // Determining if the first string ends with the second string\n    assert!(s2.ends_with(s3));\n}",
    "title": "String matching",
    "url": "http://rosettacode.org/wiki/String_matching"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nlet mut s = \"World\".to_string();\ns.insert_str(0, \"Hello \");\nprintln!(\"{}\", s);\n",
    "title": "String prepend",
    "url": "http://rosettacode.org/wiki/String_prepend"
  },
  {
    "local_code": "fn main() {\n    println!(\n        \"{}\",\n        strip_characters(\"She was a soul stripper. She took my heart!\", \"aei\")\n    );\n}\n\nfn strip_characters(original: &str, to_strip: &str) -> String {\n    original\n        .chars()\n        .filter(|&c| !to_strip.contains(c))\n        .collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn correct_strip_characters() {\n        let test = \"She was a soul stripper. She took my heart!\";\n        let expected = \"Sh ws  soul strppr. Sh took my hrt!\";\n        assert_eq!(strip_characters(test, \"aei\"), expected);\n    }\n\n    #[test]\n    fn correct_strip_empty_string() {\n        assert_eq!(strip_characters(\"\", \"jkl\"), \"\");\n    }\n\n    #[test]\n    fn correct_strip_no_characters() {\n        assert_eq!(strip_characters(\"test string\", \"\"), \"test string\");\n    }\n}\n",
    "path": "tasks/strip-characters-from-a-string",
    "remote_code": "\nfn strip_characters(original : &str, to_strip : &str) -> String {\n    let mut result = String::new();\n    for c in original.chars() {\n        if !to_strip.contains(c) {\n           result.push(c);\n       }\n    }\n    result\n}\n",
    "title": "Strip a set of characters from a string",
    "url": "http://rosettacode.org/wiki/Strip_a_set_of_characters_from_a_string"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Strip block comments",
    "url": "http://rosettacode.org/wiki/Strip_block_comments"
  },
  {
    "local_code": "fn strip_comments(s: &str) -> &str {\n    let markers = ['#', ';'];\n    s.find(&markers[..]).map_or(s, |i| &s[..i]).trim()\n}\n\n#[test]\nfn test_strip_comments() {\n    let inputs = [\n        \"apples, pears # and bananas\",\n        \"apples, pears ; and bananas\",\n        \"  apples, pears \",\n    ];\n    let output = \"apples, pears\";\n\n    for &input in &inputs {\n        assert_eq!(strip_comments(input), output)\n    }\n}\n\nfn main() {\n    let inputs = [\n        \"apples, pears # and bananas\",\n        \"apples, pears ; and bananas\",\n        \"  apples, pears \",\n    ];\n\n    for &input in &inputs {\n        println!(\"Input: {}\\nStripped: {}\", input, strip_comments(input))\n    }\n}\n",
    "path": "tasks/strip-comments-from-a-string",
    "remote_code": "fn strip_comment<'a>(input: &'a str, markers: &[char]) -> &'a str {\n    input\n        .find(markers)\n        .map(|idx| &input[..idx])\n        .unwrap_or(input)\n        .trim()\n}\n\nfn main() {\n    println!(\"{:?}\", strip_comment(\"apples, pears # and bananas\", &['#', ';']));\n    println!(\"{:?}\", strip_comment(\"apples, pears ; and bananas\", &['#', ';']));\n    println!(\"{:?}\", strip_comment(\"apples, pears and bananas \", &['#', ';']));\n}",
    "title": "Strip comments from a string",
    "url": "http://rosettacode.org/wiki/Strip_comments_from_a_string"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Strip control codes and extended characters from a string",
    "url": "http://rosettacode.org/wiki/Strip_control_codes_and_extended_characters_from_a_string"
  },
  {
    "local_code": "fn main() {\n    let string = \"String without spaces\";\n    let spaces = \" \\x0B\\t\\r\\n \\u{A0} \\u{2000} \\u{3000} \";\n    let string_with_spaces = spaces.to_string() + string + spaces;\n\n    assert_eq!(string_with_spaces.trim(), string);\n    assert_eq!(\n        string_with_spaces.trim_start().to_string(),\n        string.to_string() + spaces\n    );\n    assert_eq!(\n        string_with_spaces.trim_end().to_string(),\n        spaces.to_string() + string\n    );\n}\n",
    "path": "tasks/strip-whitespace-from-a-string/top-and-tail",
    "remote_code": "fn main() {\n    let spaces = \" \\t\\n\\x0B\\x0C\\r \\u{A0} \\u{2000}\\u{3000}\";\n    let string_with_spaces = spaces.to_owned() + \"String without spaces\" + spaces;\n\n    assert_eq!(string_with_spaces.trim(), \"String without spaces\");\n    assert_eq!(string_with_spaces.trim_left(), \"String without spaces\".to_owned() + spaces);\n    assert_eq!(string_with_spaces.trim_right(), spaces.to_owned() + \"String without spaces\");\n}",
    "title": "Strip whitespace from a string/Top and tail",
    "url": "http://rosettacode.org/wiki/Strip_whitespace_from_a_string/Top_and_tail"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Strong and weak primes",
    "url": "http://rosettacode.org/wiki/Strong_and_weak_primes"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Subleq",
    "url": "http://rosettacode.org/wiki/Subleq"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nlet s = \"abc文字化けdef\";\nlet n = 2;\nlet m = 3;\n\n    // Print 3 characters starting at index 2 (c文字)\nprintln!(\"{}\", s.chars().skip(n).take(m).collect::<String>());\n\n    // Print all characters starting at index 2 (c文字化けdef)\nprintln!(\"{}\", s.chars().skip(n).collect::<String>());\n\n    // Print all characters except the last (abc文字化けde)\nprintln!(\"{}\", s.chars().rev().skip(1).collect::<String>());\n\n    // Print 3 characters starting with 'b' (bc文)\nlet cpos = s.find('b').unwrap();\nprintln!(\"{}\", s[cpos..].chars().take(m).collect::<String>());\n\n    // Print 3 characters starting with \"けd\" (けde)\nlet spos = s.find(\"けd\").unwrap();\nprintln!(\"{}\", s[spos..].chars().take(m).collect::<String>());\n",
    "title": "Substring",
    "url": "http://rosettacode.org/wiki/Substring"
  },
  {
    "local_code": "fn main() {\n    let string = \"Hello World\";\n    assert_eq!(Some(\"ello World\"), string.get(1..));\n    assert_eq!(Some(\"Hello Wor\"), string.get(..(string.len() - 2)));\n    assert_eq!(Some(\"lo Wo\"), string.get(3..(string.len() - 3)));\n    assert_eq!(None, string.get(42..)); // out of bounds\n}\n",
    "path": "tasks/substring/top-and-tail",
    "remote_code": null,
    "title": "Substring/Top and tail",
    "url": "http://rosettacode.org/wiki/Substring/Top_and_tail"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Subtractive generator",
    "url": "http://rosettacode.org/wiki/Subtractive_generator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Successive prime differences",
    "url": "http://rosettacode.org/wiki/Successive_prime_differences"
  },
  {
    "local_code": "use std::fmt;\nuse std::str::FromStr;\n\nconst BOARD_WIDTH: usize = 9;\nconst BOARD_HEIGHT: usize = 9;\nconst GROUP_WIDTH: usize = 3;\nconst GROUP_HEIGHT: usize = 3;\nconst MAX_NUMBER: usize = 9;\n\ntype BITS = u16;\nconst MASK_ALL: BITS = 0x1ff;\nconst INVALID_CELL: u32 = !0;\n\n#[derive(Copy, Clone, Eq, PartialEq, Debug)]\nstruct Sudoku {\n    map: [[BITS; BOARD_WIDTH]; BOARD_HEIGHT],\n}\n\nimpl Sudoku {\n    fn new() -> Sudoku {\n        Sudoku {\n            map: [[MASK_ALL; BOARD_WIDTH]; BOARD_HEIGHT],\n        }\n    }\n\n    fn get(&self, x: usize, y: usize) -> u32 {\n        match self.map[y][x].count_ones() {\n            0 => INVALID_CELL,\n            1 => self.map[y][x].trailing_zeros() + 1,\n            _ => 0,\n        }\n    }\n\n    fn set(&mut self, x: usize, y: usize, n: u32) {\n        self.map[y][x] = 1 << (n - 1);\n    }\n}\n\nimpl Default for Sudoku {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl FromStr for Sudoku {\n    type Err = ();\n\n    fn from_str(s: &str) -> Result<Sudoku, ()> {\n        let mut sudoku = Sudoku::new();\n\n        for (y, line) in s.lines().filter(|l| !l.is_empty()).enumerate() {\n            let line = line.trim_matches(|c: char| c.is_whitespace());\n            for (x, c) in line.chars().enumerate() {\n                if let Some(d) = c.to_digit(10) {\n                    if d != 0 {\n                        sudoku.set(x, y, d);\n                    }\n                } else {\n                    return Err(());\n                }\n            }\n        }\n\n        Ok(sudoku)\n    }\n}\n\nimpl fmt::Display for Sudoku {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let hbar = \"+---+---+---+\";\n\n        for y in 0..BOARD_HEIGHT {\n            if y % GROUP_HEIGHT == 0 {\n                writeln!(f, \"{}\", hbar)?;\n            }\n\n            for x in 0..BOARD_WIDTH {\n                if x % GROUP_WIDTH == 0 {\n                    write!(f, \"|\")?;\n                }\n\n                match self.get(x, y) {\n                    INVALID_CELL => write!(f, \"!\")?,\n                    0 => write!(f, \" \")?,\n                    d => write!(f, \"{}\", d)?,\n                }\n            }\n            writeln!(f, \"|\")?;\n        }\n        writeln!(f, \"{}\", hbar)?;\n\n        Ok(())\n    }\n}\n\nfn solve_sudoku(mut puzzle: Sudoku) -> Vec<Sudoku> {\n    let idx_in_grp = [\n        (0, 0),\n        (0, 1),\n        (0, 2),\n        (1, 0),\n        (1, 1),\n        (1, 2),\n        (2, 0),\n        (2, 1),\n        (2, 2),\n    ];\n\n    loop {\n        let bkup = puzzle;\n\n        // If the number at cell (x, y) is uniquely determined, that number must\n        // not have appeared at the cells in the same row/column/group.\n        for y in 0..BOARD_HEIGHT {\n            for x in 0..BOARD_WIDTH {\n                if puzzle.map[y][x].count_ones() != 1 {\n                    continue;\n                }\n\n                let (x0, y0) = (\n                    (x / GROUP_WIDTH) * GROUP_WIDTH,\n                    (y / GROUP_HEIGHT) * GROUP_HEIGHT,\n                );\n\n                let row = (0..BOARD_WIDTH).map(|x| (x, y));\n                let col = (0..BOARD_HEIGHT).map(|y| (x, y));\n                let grp = idx_in_grp.iter().map(|&(dx, dy)| (x0 + dx, y0 + dy));\n\n                let it = row\n                    .chain(col)\n                    .chain(grp)\n                    .filter(|&pos: &(usize, usize)| pos != (x, y));\n\n                let mask = !puzzle.map[y][x] & MASK_ALL;\n                for (x, y) in it {\n                    puzzle.map[y][x] &= mask;\n                }\n            }\n        }\n\n        // If `n` appears only once at the cell in the row/column/group, the\n        // number of the cell must be `n`.\n        for n in 0..MAX_NUMBER {\n            let bit = 1 << n;\n\n            // Check each rows\n            for y in 0..BOARD_HEIGHT {\n                let next = {\n                    let mut it = (0..BOARD_WIDTH).filter(|&x| puzzle.map[y][x] & bit != 0);\n                    let next = it.next();\n                    if next.is_none() || it.next().is_some() {\n                        continue;\n                    }\n                    next\n                };\n                puzzle.map[y][next.unwrap()] = bit;\n            }\n\n            // Check each column\n            for x in 0..BOARD_WIDTH {\n                let next = {\n                    let mut it = (0..BOARD_HEIGHT).filter(|&y| puzzle.map[y][x] & bit != 0);\n                    let next = it.next();\n                    if next.is_none() || it.next().is_some() {\n                        continue;\n                    }\n                    next\n                };\n                puzzle.map[next.unwrap()][x] = bit;\n            }\n\n            // Check each group\n            for y0 in (0..BOARD_HEIGHT).step_by(GROUP_WIDTH) {\n                for x0 in (0..BOARD_WIDTH).step_by(GROUP_HEIGHT) {\n                    let next = {\n                        let mut it = idx_in_grp\n                            .iter()\n                            .map(|&(dx, dy)| (x0 + dx, y0 + dy))\n                            .filter(|&(x, y)| puzzle.map[y][x] & bit != 0);\n                        let next = it.next();\n                        if next.is_none() || it.next().is_some() {\n                            continue;\n                        }\n                        next\n                    };\n                    let (x, y) = next.unwrap();\n                    puzzle.map[y][x] = bit;\n                }\n            }\n        }\n\n        // Loop until no cell can be filled.\n        if puzzle == bkup {\n            break;\n        }\n    }\n\n    let it = (0..BOARD_HEIGHT * BOARD_WIDTH)\n        .map(|i| (i % BOARD_WIDTH, i / BOARD_WIDTH))\n        .map(|(x, y)| (x, y, puzzle.map[y][x].count_ones() as BITS))\n        .collect::<Vec<_>>();\n\n    // If some cells have no possible number, there is no answer.\n    if it.iter().any(|&(_x, _y, cnt)| cnt == 0) {\n        return vec![];\n    }\n\n    // If all cells have exact one possible number, this is a answer.\n    if it.iter().all(|&(_x, _y, cnt)| cnt == 1) {\n        return vec![puzzle];\n    }\n\n    // Find the first undetermined cell.\n    let (x, y, _cnt) = *it\n        .iter()\n        .filter(|&&(_x, _y, cnt)| cnt > 1)\n        .min_by_key(|&&(_x, _y, cnt)| cnt)\n        .unwrap();\n\n    let mut answers = vec![];\n    for n in 0..MAX_NUMBER {\n        let bit = 1 << n;\n        if puzzle.map[y][x] & bit == 0 {\n            continue;\n        }\n\n        // Assuming the number at (x, y) is `n`, try to solve the problem again.\n        // If some answers are found, append them to the `answers`.\n        let mut p2 = puzzle;\n        p2.map[y][x] = bit;\n        answers.extend(solve_sudoku(p2).into_iter());\n    }\n    answers\n}\n\nconst INPUT: &str = r\"\n    850002400\n    720000009\n    004000000\n    000107002\n    305000900\n    040000000\n    000080070\n    017000000\n    000036040\n\";\n\nfn main() {\n    let puzzle = INPUT.parse::<Sudoku>().unwrap();\n\n    println!(\"{}\", puzzle);\n\n    for answer in &solve_sudoku(puzzle) {\n        println!(\"{}\", answer);\n    }\n}\n\n#[cfg(test)]\nconst SOLUTION: &str = r\"\n    859612437\n    723854169\n    164379528\n    986147352\n    375268914\n    241593786\n    432981675\n    617425893\n    598736241\n\";\n\n#[test]\nfn solution() {\n    let puzzle = INPUT.parse::<Sudoku>().unwrap();\n    let answer = SOLUTION.parse::<Sudoku>().unwrap();\n    let solution = solve_sudoku(puzzle);\n    assert_eq!(solution, [answer]);\n}\n",
    "path": "tasks/sudoku",
    "remote_code": "type Sudoku = [u8; 81];\n\nfn is_valid(val: u8, x: usize, y: usize, sudoku_ar: &mut Sudoku) -> bool {\n    (0..9).all(|i| sudoku_ar[y * 9 + i] != val && sudoku_ar[i * 9 + x] != val) && {\n        let (start_x, start_y) = ((x / 3) * 3, (y / 3) * 3);\n        (start_y..start_y + 3).all(|i| (start_x..start_x + 3).all(|j| sudoku_ar[i * 9 + j] != val))\n    }\n}\n\nfn place_number(pos: usize, sudoku_ar: &mut Sudoku) -> bool {\n    (pos..81).find(|&p| sudoku_ar[p] == 0).map_or(true, |pos| {\n        let (x, y) = (pos % 9, pos / 9);\n        for n in 1..10 {\n            if is_valid(n, x, y, sudoku_ar) {\n                sudoku_ar[pos] = n;\n                if place_number(pos + 1, sudoku_ar) {\n                    return true;\n                }\n                sudoku_ar[pos] = 0;\n            }\n        }\n        false\n    })\n}\n\nfn pretty_print(sudoku_ar: Sudoku) {\n    let line_sep = \"------+-------+------\";\n    println!(\"{}\", line_sep);\n    for (i, e) in sudoku_ar.iter().enumerate() {\n        print!(\"{} \", e);\n        if (i + 1) % 3 == 0 && (i + 1) % 9 != 0 {\n            print!(\"| \");\n        }\n        if (i + 1) % 9 == 0 {\n            println!(\" \");\n        }\n        if (i + 1) % 27 == 0 {\n            println!(\"{}\", line_sep);\n        }\n    }\n}\n\nfn solve(sudoku_ar: &mut Sudoku) -> bool {\n    place_number(0, sudoku_ar)\n}\n\nfn main() {\n    let mut sudoku_ar: Sudoku = [\n        8, 5, 0, 0, 0, 2, 4, 0, 0,\n        7, 2, 0, 0, 0, 0, 0, 0, 9,\n        0, 0, 4, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 1, 0, 7, 0, 0, 2,\n        3, 0, 5, 0, 0, 0, 9, 0, 0,\n        0, 4, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 8, 0, 0, 7, 0,\n        0, 1, 7, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 3, 6, 0, 4, 0\n    ];\n    if solve(&mut sudoku_ar) {\n        pretty_print(sudoku_ar);\n    } else {\n        println!(\"Unsolvable\");\n    }\n}",
    "title": "Sudoku",
    "url": "http://rosettacode.org/wiki/Sudoku"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Suffixation of decimal numbers",
    "url": "http://rosettacode.org/wiki/Suffixation_of_decimal_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sum and Product Puzzle",
    "url": "http://rosettacode.org/wiki/Sum_and_Product_Puzzle"
  },
  {
    "local_code": "fn main() {\n    let arr: [i32; 9] = [1i32, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    // using fold\n    let sum = arr.iter().fold(0i32, |a, &b| a + b);\n    let product = arr.iter().fold(1i32, |a, &b| a * b);\n    println!(\"the sum is {} and the product is {}\", sum, product);\n\n    // or using sum and product\n    let sum = arr.iter().sum::<i32>();\n    let product = arr.iter().product::<i32>();\n    println!(\"the sum is {} and the product is {}\", sum, product);\n}\n",
    "path": "tasks/sum-and-product-of-an-array",
    "remote_code": "\n\nfn main() {\n    let arr = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    // using fold\n    let sum = arr.iter().fold(0i32, |a, &b| a + b);\n    let product = arr.iter().fold(1i32, |a, &b| a * b);\n    println!(\"the sum is {} and the product is {}\", sum, product);\n\n    // or using sum and product\n    let sum = arr.iter().sum::<i32>();\n    let product = arr.iter().product::<i32>();\n    println!(\"the sum is {} and the product is {}\", sum, product);\n}\n",
    "title": "Sum and product of an array",
    "url": "http://rosettacode.org/wiki/Sum_and_product_of_an_array"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Sum_digits_of_an_integer\n\nfn sum(n: usize, base: usize) -> usize {\n    let mut total = 0;\n    let mut n = n;\n    while n != 0 {\n        total += n % base;\n        n /= base\n    }\n    total\n}\n\n#[test]\nfn base_10() {\n    assert_eq!(sum(1, 10), 1);\n    assert_eq!(sum(1234, 10), 10);\n}\n\n#[test]\nfn base_16() {\n    assert_eq!(sum(0xfe, 16), 29);\n    assert_eq!(sum(0xf0e, 16), 29);\n}\n\nfn main() {\n    println!(\"{}\", sum(1234, 10));\n}\n",
    "path": "tasks/sum-digits-of-an-integer",
    "remote_code": "struct DigitIter(usize, usize);\n\nimpl Iterator for DigitIter {\n    type Item = usize;\n    fn next(&mut self) -> Option<Self::Item> {\n        if self.0 == 0 {\n            None\n        } else {\n            let ret = self.0 % self.1;\n            self.0 /= self.1;\n            Some(ret)\n        }\n    }\n}\n\nfn main() {\n    println!(\"{}\", DigitIter(1234,10).sum::<usize>());\n}",
    "title": "Sum digits of an integer",
    "url": "http://rosettacode.org/wiki/Sum_digits_of_an_integer"
  },
  {
    "local_code": "fn sum35(lim: u64) -> u64 {\n    let mut sum: u64 = 0;\n    for i in 3..lim {\n        if i % 3 == 0 || i % 5 == 0 {\n            sum += i;\n        }\n    }\n    sum\n}\n\nfn main() {\n    let limit = 10_000;\n    println!(\n        \"Sum of multiples of 3 and 5 from 0 till {} are: {}\",\n        limit,\n        sum35(limit)\n    );\n}\n\n#[test]\nfn test_sum35() {\n    assert_eq!(233_168, sum35(1000));\n    assert_eq!(35_553_600, sum35(12_345));\n}\n",
    "path": "tasks/sum-multiples-of-3-and-5",
    "remote_code": "\nextern crate rug;\n\nuse rug::Integer;\nuse rug::ops::Pow;\n\nfn main() {\n    for i in [3, 20, 100, 1_000].iter() {\n        let ten = Integer::from(10);\n        let mut limit = Integer::from(Integer::from(&ten.pow(*i as u32)) - 1);\n        let mut aux_3_1 = &limit.mod_u(3u32);\n        let mut aux_3_2 = Integer::from(&limit - aux_3_1);\n        let mut aux_3_3 = Integer::from(&aux_3_2/3);\n        let mut aux_3_4 = Integer::from(3 + aux_3_2);\n        let mut aux_3_5 = Integer::from(&aux_3_3*&aux_3_4);\n        let mut aux_3_6 = Integer::from(&aux_3_5/2);\n \n        let mut aux_5_1 = &limit.mod_u(5u32);\n        let mut aux_5_2 = Integer::from(&limit - aux_5_1); \n        let mut aux_5_3 = Integer::from(&aux_5_2/5);\n        let mut aux_5_4 = Integer::from(5 + aux_5_2); \n        let mut aux_5_5 = Integer::from(&aux_5_3*&aux_5_4);\n        let mut aux_5_6 = Integer::from(&aux_5_5/2); \n\n        let mut aux_15_1 = &limit.mod_u(15u32);\n        let mut aux_15_2 = Integer::from(&limit - aux_15_1); \n        let mut aux_15_3 = Integer::from(&aux_15_2/15);\n        let mut aux_15_4 = Integer::from(15 + aux_15_2);\n        let mut aux_15_5 = Integer::from(&aux_15_3*&aux_15_4);\n        let mut aux_15_6 = Integer::from(&aux_15_5/2); \n\n        let mut result_aux_1 = Integer::from(&aux_3_6 + &aux_5_6); \n        let mut result = Integer::from(&result_aux_1 - &aux_15_6);\n \n        println!(\"Sum for 10^{} : {}\",i,result);\n    }\n}\n",
    "title": "Sum multiples of 3 and 5",
    "url": "http://rosettacode.org/wiki/Sum_multiples_of_3_and_5"
  },
  {
    "local_code": "fn main() {\n    let sum: f64 = (1u64..=1000).fold(0., |sum, num| sum + 1. / (num * num) as f64);\n    println!(\"{}\", sum);\n}\n",
    "path": "tasks/sum-of-a-series",
    "remote_code": "const LOWER: i32 = 1;\nconst UPPER: i32 = 1000;\n\n// Because the rule for our series is simply adding one, the number of terms are the number of\n// digits between LOWER and UPPER\nconst NUMBER_OF_TERMS: i32 = (UPPER + 1) - LOWER;\nfn main() {\n    // Formulaic method\n    println!(\"{}\", (NUMBER_OF_TERMS * (LOWER + UPPER)) / 2);\n    // Naive method\n    println!(\"{}\", (LOWER..UPPER + 1).fold(0, |sum, x| sum + x));\n}\n",
    "title": "Sum of a series",
    "url": "http://rosettacode.org/wiki/Sum_of_a_series"
  },
  {
    "local_code": "fn sq_sum(v: &[f64]) -> f64 {\n    v.iter().fold(0., |sum, &num| sum + num * num)\n}\n\nfn main() {\n    let v = vec![3.0, 1.0, 4.0, 1.0, 5.5, 9.7];\n    println!(\"{}\", sq_sum(&v));\n\n    let u: Vec<f64> = vec![];\n    println!(\"{}\", sq_sum(&u));\n}\n",
    "path": "tasks/sum-of-squares",
    "remote_code": "fn sq_sum(v: &[f64]) -> f64 {\n    v.iter().fold(0., |sum, &num| sum + num*num)\n}\n\nfn main() {\n    let v = vec![3.0, 1.0, 4.0, 1.0, 5.5, 9.7];\n    println!(\"{}\", sq_sum(&v));\n\n    let u : Vec<f64> = vec![];\n    println!(\"{}\", sq_sum(&u));\n}",
    "title": "Sum of squares",
    "url": "http://rosettacode.org/wiki/Sum_of_squares"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sum to 100",
    "url": "http://rosettacode.org/wiki/Sum_to_100"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Sunflower fractal",
    "url": "http://rosettacode.org/wiki/Sunflower_fractal"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Super-d numbers",
    "url": "http://rosettacode.org/wiki/Super-d_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Superellipse",
    "url": "http://rosettacode.org/wiki/Superellipse"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Superpermutation minimisation",
    "url": "http://rosettacode.org/wiki/Superpermutation_minimisation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "#[derive(Debug, Clone)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n#[derive(Debug, Clone)]\nstruct Polygon(Vec<Point>);\n\nfn is_inside(p: &Point, cp1: &Point, cp2: &Point) -> bool {\n    (cp2.x - cp1.x) * (p.y - cp1.y) > (cp2.y - cp1.y) * (p.x - cp1.x)\n}\n\nfn compute_intersection(cp1: &Point, cp2: &Point, s: &Point, e: &Point) -> Point {\n    let dc = Point {\n        x: cp1.x - cp2.x,\n        y: cp1.y - cp2.y,\n    };\n    let dp = Point {\n        x: s.x - e.x,\n        y: s.y - e.y,\n    };\n    let n1 = cp1.x * cp2.y - cp1.y * cp2.x;\n    let n2 = s.x * e.y - s.y * e.x;\n    let n3 = 1.0 / (dc.x * dp.y - dc.y * dp.x);\n    Point {\n        x: (n1 * dp.x - n2 * dc.x) * n3,\n        y: (n1 * dp.y - n2 * dc.y) * n3,\n    }\n}\n\nfn sutherland_hodgman_clip(subject_polygon: &Polygon, clip_polygon: &Polygon) -> Polygon {\n    let mut result_ring = subject_polygon.0.clone();\n    let mut cp1 = clip_polygon.0.last().unwrap();\n    for cp2 in &clip_polygon.0 {\n        let input = result_ring;\n        let mut s = input.last().unwrap();\n        result_ring = vec![];\n        for e in &input {\n            if is_inside(e, cp1, cp2) {\n                if !is_inside(s, cp1, cp2) {\n                    result_ring.push(compute_intersection(cp1, cp2, s, e));\n                }\n                result_ring.push(e.clone());\n            } else if is_inside(s, cp1, cp2) {\n                result_ring.push(compute_intersection(cp1, cp2, s, e));\n            }\n            s = e;\n        }\n        cp1 = cp2;\n    }\n    Polygon(result_ring)\n}\n\nfn main() {\n    let _p = |x: f64, y: f64| Point { x, y };\n    let subject_polygon = Polygon(vec![\n        _p(50.0, 150.0), _p(200.0, 50.0), _p(350.0, 150.0), _p(350.0, 300.0), _p(250.0, 300.0),\n        _p(200.0, 250.0), _p(150.0, 350.0), _p(100.0, 250.0), _p(100.0, 200.0),\n    ]);\n    let clip_polygon = Polygon(vec![\n        _p(100.0, 100.0),_p(300.0, 100.0),_p(300.0, 300.0),_p(100.0, 300.0),\n    ]);\n    let result = sutherland_hodgman_clip(&subject_polygon, &clip_polygon);\n    println!(\"{:?}\", result);\n}",
    "title": "Sutherland-Hodgman polygon clipping",
    "url": "http://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Symmetric difference",
    "url": "http://rosettacode.org/wiki/Symmetric_difference"
  },
  {
    "local_code": "//! Reader unit reads lines from input.txt, send lines one at a time to printer unit, which then\n//! prints lines, keeping track of lines printed. At the end of the file, the reader unit requests\n//! number of lines printed from the printer unit, and then prints them.\n\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\nuse std::sync::mpsc::{channel, Receiver, Sender};\nuse std::thread;\n\nconst FILENAME: &str = \"resources/input.txt\";\n\nenum Message {\n    Line(String),\n    End,\n}\n\nfn printer(i_snd: &Sender<i32>, msg_rcv: &Receiver<Message>) {\n    let mut count = 0;\n    while let Message::Line(line) = msg_rcv.recv().unwrap() {\n        println!(\"{}\", line);\n        count += 1;\n    }\n    i_snd.send(count).unwrap();\n}\n\nfn reader(msg_snd: &Sender<Message>, i_rcv: &Receiver<i32>) {\n    let file = BufReader::new(File::open(FILENAME).unwrap());\n    for line in file.lines() {\n        msg_snd.send(Message::Line(line.unwrap())).unwrap();\n    }\n    msg_snd.send(Message::End).unwrap();\n    println!(\"Total Lines: {}\", i_rcv.recv().unwrap());\n}\n\nfn main() {\n    let (msg_snd, msg_rcv) = channel();\n    let (i_snd, i_rcv) = channel();\n\n    thread::spawn(move || printer(&i_snd, &msg_rcv));\n    thread::spawn(move || reader(&msg_snd, &i_rcv));\n}\n",
    "path": "tasks/synchronous-concurrency",
    "remote_code": "use std::fs::File;\nuse std::io::BufReader;\nuse std::io::BufRead;\n\nuse std::thread::spawn;\nuse std::sync::mpsc::{SyncSender, Receiver, sync_channel};\n\nfn main() {\n    let (tx, rx): (SyncSender<String>, Receiver<String>) = sync_channel::<String>(0);\n\n    // Reader thread.\n    spawn(move || {\n        let file = File::open(\"input.txt\").unwrap();\n        let reader = BufReader::new(file);\n\n        for line in reader.lines() {\n            match line {\n                Ok(msg) => tx.send(msg).unwrap(),\n                Err(e) => println!(\"{}\", e)\n            }\n        }\n\n        drop(tx);\n    });\n\n    // Writer thread.\n    spawn(move || {\n        let mut loop_count: u16 = 0;\n\n        loop {\n            let recvd = rx.recv();\n\n            match recvd {\n                Ok(msg) => {\n                    println!(\"{}\", msg);\n                    loop_count += 1;\n                },\n                Err(_) => break // rx.recv() will only err when tx is closed.\n            }\n        }\n\n        println!(\"Line count: {}\", loop_count);\n    }).join().unwrap();\n}",
    "title": "Synchronous concurrency",
    "url": "http://rosettacode.org/wiki/Synchronous_concurrency"
  },
  {
    "local_code": "extern crate time;\nuse time::{at, get_time, strftime};\n\nfn main() {\n    // Prints the current time as a timespec containing the seconds\n    // and nanoseconds since 1970-01-01T00:00:00Z.\n    let time_ts = get_time();\n    println!(\"seconds: {} nanoseconds: {}\", time_ts.sec, time_ts.nsec);\n\n    // Convert the timespec to a broken-down time value Tm\n    // Could also use \"let time_tm = now();\" to get directly\n    let time_tm = at(time_ts);\n\n    // Display time formatted according to the asctime format in ISO\n    // C, in the local timezone, eg \"Wed Oct 29 22:26:17 2014\"\n    println!(\"ctime: {}\", time_tm.ctime());\n\n    // Display time formatted according to RFC 822,\n    // eg \"Wed, 29 Oct 2014 22:26:17\"\n    println!(\"rfc822: {}\", time_tm.rfc822());\n\n    // Display time formatted according to RFC 3339/ISO8601\n    // eg \"2014-10-29T22:26:17+07:00\"\n    println!(\"rfc3339: {}\", time_tm.rfc3339());\n\n    // Display time in a custom format (eg \"22:26:17\") using strftime\n    println!(\"Custom: {}\", strftime(\"%H:%M:%S\", &time_tm).unwrap());\n}\n",
    "path": "tasks/system-time",
    "remote_code": null,
    "title": "System time",
    "url": "http://rosettacode.org/wiki/System_time"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Table creation/Postal addresses",
    "url": "http://rosettacode.org/wiki/Table_creation/Postal_addresses"
  },
  {
    "local_code": "extern crate chrono;\n\nuse std::env;\nuse std::fs::OpenOptions;\nuse std::io::prelude::*;\nuse std::io::{self, BufReader, BufWriter};\n\nconst FILENAME: &str = \"NOTES.TXT\";\n\nfn show_notes() -> Result<(), io::Error> {\n    // Create the file if not found.\n    let file = OpenOptions::new()\n        .read(true)\n        .create(true)\n        .write(true)\n        .open(FILENAME)?;\n    let mut buf_reader = BufReader::new(file);\n    let mut contents = String::new();\n    buf_reader.read_to_string(&mut contents)?;\n    println!(\"{}\", contents);\n    Ok(())\n}\n\nfn add_to_notes(note: &str) -> Result<(), io::Error> {\n    // Disable overwriting, instead write to the end of the file.\n    let file = OpenOptions::new()\n        .append(true)\n        .create(true)\n        .open(FILENAME)?;\n    let mut buf_writer = BufWriter::new(file);\n\n    let date_and_time = chrono::Local::now();\n    writeln!(buf_writer, \"{}\", date_and_time)?;\n\n    writeln!(buf_writer, \"\\t{}\", note)\n}\n\nfn main() {\n    let note = env::args().skip(1).collect::<Vec<_>>();\n\n    if note.is_empty() {\n        show_notes().expect(\"failed to print NOTES.TXT\");\n    } else {\n        add_to_notes(&note.join(\" \")).expect(\"failed to write to NOTES.TXT\");\n    }\n}\n",
    "path": "tasks/take-notes-on-the-command-line",
    "remote_code": null,
    "title": "Take notes on the command line",
    "url": "http://rosettacode.org/wiki/Take_notes_on_the_command_line"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Tarjan",
    "url": "http://rosettacode.org/wiki/Tarjan"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Taxicab_numbers\n\nuse std::cmp::Ordering;\nuse std::collections::BinaryHeap;\n\n/// A type to represent a pair-sum of cubes.\n/// value = a^3 + b^3\n#[derive(Copy, Clone, PartialEq, Eq)]\nstruct SumCubes {\n    a: u64,\n    b: u64,\n    value: u64,\n}\n\nimpl SumCubes {\n    fn new(a: u64, b: u64) -> SumCubes {\n        SumCubes {\n            value: a.pow(3) + b.pow(3),\n            a: a,\n            b: b,\n        }\n    }\n}\n\nimpl PartialOrd for SumCubes {\n    fn partial_cmp(&self, other: &SumCubes) -> Option<Ordering> {\n        // Comparison is reversed to make PriorityQueue behave like a min-heap\n        (other.value, other.a, other.b).partial_cmp(&(self.value, self.a, self.b))\n    }\n}\n\nimpl Ord for SumCubes {\n    fn cmp(&self, other: &SumCubes) -> Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\n\n/// An iterator through all Taxicab numbers\nstruct TaxicabNumbers {\n    /// Use a BinaryHeap as a priority queue to iterate through sums of\n    /// cubes efficiently in increasing order\n    pq: BinaryHeap<SumCubes>,\n}\n\nimpl TaxicabNumbers {\n    fn new() -> TaxicabNumbers {\n        let mut res = TaxicabNumbers {\n            pq: BinaryHeap::new(),\n        };\n        res.pq.push(SumCubes::new(1, 1)); // Start with 1^3 + 1^3\n        res\n    }\n}\n\nimpl Default for TaxicabNumbers {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl Iterator for TaxicabNumbers {\n    type Item = Vec<SumCubes>;\n\n    fn next(&mut self) -> Option<Vec<SumCubes>> {\n        let mut ways = Vec::new(); // All the ways we can express the current\n                                   // value as a sum of cubes\n        ways.push(SumCubes::new(0, 0)); // Just a sentinel value\n\n        loop {\n            let nxt = self.pq.pop().unwrap();\n            if nxt.value == ways[0].value {\n                // If the next sum is the same as the current one,\n                // then we found another way to express the current value\n                ways.push(nxt);\n            } else if ways.len() > 1 {\n                // If we can express the current value in more than one ways,\n                // then it's a Taxicab number\n                self.pq.push(nxt);\n                return Some(ways);\n            } else {\n                ways.clear();\n                ways.push(nxt);\n            }\n\n            // Populate the priority queue with more sums\n            self.pq.push(SumCubes::new(nxt.a + 1, nxt.b));\n            if nxt.a == nxt.b {\n                self.pq.push(SumCubes::new(nxt.a + 1, nxt.b + 1));\n            }\n        }\n    }\n}\n\nfn main() {\n    let numbers = TaxicabNumbers::new();\n    for (at, ways) in numbers\n        .take(2006)\n        .enumerate()\n        .filter(|&(at, _)| at + 1 <= 25 || at + 1 >= 2000)\n    {\n        print!(\"{:>4}:{:>10}\", at + 1, ways[0].value);\n        for &SumCubes { a, b, .. } in &ways {\n            print!(\" = {:>4}^3 + {:>4}^3\", a, b);\n        }\n        println!();\n    }\n}\n\n#[test]\nfn test_taxicab_numbers() {\n    // A001235 on OEIS\n    let seq = [\n        1729u64, 4104, 13832, 20683, 32832, 39312, 40033, 46683, 64232, 65728, 110656, 110808,\n        134379, 149389, 165464, 171288, 195841, 216027, 216125, 262656, 314496, 320264, 327763,\n        373464, 402597, 439101, 443889, 513000, 513856, 515375, 525824, 558441, 593047, 684019,\n        704977,\n    ];\n\n    for (&expected, ways) in seq.iter().zip(TaxicabNumbers::new()) {\n        assert!(ways.len() > 1);\n        for &SumCubes { value, .. } in &ways {\n            assert_eq!(value, expected);\n        }\n    }\n}\n",
    "path": "tasks/taxicab-numbers",
    "remote_code": "\nuse std::collections::HashMap;\nuse itertools::Itertools;\n\nfn cubes(n: u64) -> Vec<u64> {\n\tlet mut cube_vector = Vec::new();\n\tfor i in 1..=n {\n\t\tcube_vector.push(i.pow(3));\n\t}\n\tcube_vector\n}\n\nfn main() {\n\tlet c = cubes(1201);\n\tlet it = c.iter().combinations(2);\n\tlet mut m = HashMap::new();\n\tfor x in it {\n\t\tlet sum = x[0] + x[1];\n\t\tm.entry(sum).or_insert(Vec::new()).push(x)\n\t} \n\t\n\tlet mut result = Vec::new();\n\t\n\tfor (k,v) in m.iter() {\n\t\tif v.len() > 1 {\n\t\t\tresult.push((k,v));\n\t\t}\n\t}\n\t\n\tresult.sort();\n\tfor f in result {\n\t\tprintln!(\"{:?}\", f);\n\t}\n}\n",
    "title": "Taxicab numbers",
    "url": "http://rosettacode.org/wiki/Taxicab_numbers"
  },
  {
    "local_code": "fn main() -> Result<(), std::num::ParseFloatError> {\n    let args = std::env::args();\n    if args.len() == 2 {\n        let k: f64 = args.skip(1).next().unwrap().parse()?;\n        if k < 0.0 {\n            println!(\"{:2.2} K is below absolute zero\", k);\n        } else {\n            println!(\n                \"K {:2.2}\\nC {:2.2}\\nF {:2.2}\\nR {:2.2}\",\n                k,\n                kelvin_to_celsius(k),\n                kelvin_to_fahrenheit(k),\n                kelvin_to_rankine(k)\n            );\n        }\n    }\n    Ok(())\n}\n\nfn kelvin_to_celsius(k: f64) -> f64 {\n    k - 273.15\n}\n\nfn kelvin_to_fahrenheit(k: f64) -> f64 {\n    k * 1.8 - 459.67\n}\n\nfn kelvin_to_rankine(k: f64) -> f64 {\n    k * 1.8\n}\n\n#[test]\nfn test() {\n    let k = 21.0;\n    assert_eq!(kelvin_to_celsius(k), -252.14999999999998);\n    assert_eq!(kelvin_to_fahrenheit(k), -421.87);\n    assert_eq!(kelvin_to_rankine(k), 37.800000000000004);\n}\n",
    "path": "tasks/temperature-conversion",
    "remote_code": null,
    "title": "Temperature conversion",
    "url": "http://rosettacode.org/wiki/Temperature_conversion"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "print!(\"\\x1B[2J\");",
    "title": "Terminal control/Clear the screen",
    "url": "http://rosettacode.org/wiki/Terminal_control/Clear_the_screen"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Coloured text",
    "url": "http://rosettacode.org/wiki/Terminal_control/Coloured_text"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Cursor movement",
    "url": "http://rosettacode.org/wiki/Terminal_control/Cursor_movement"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Cursor positioning",
    "url": "http://rosettacode.org/wiki/Terminal_control/Cursor_positioning"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Dimensions",
    "url": "http://rosettacode.org/wiki/Terminal_control/Dimensions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Display an extended character",
    "url": "http://rosettacode.org/wiki/Terminal_control/Display_an_extended_character"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Hiding the cursor",
    "url": "http://rosettacode.org/wiki/Terminal_control/Hiding_the_cursor"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Inverse video",
    "url": "http://rosettacode.org/wiki/Terminal_control/Inverse_video"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Positional read",
    "url": "http://rosettacode.org/wiki/Terminal_control/Positional_read"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Preserve screen",
    "url": "http://rosettacode.org/wiki/Terminal_control/Preserve_screen"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "fn main() {\n    print!(\"\\x07\");\n}",
    "title": "Terminal control/Ringing the terminal bell",
    "url": "http://rosettacode.org/wiki/Terminal_control/Ringing_the_terminal_bell"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Terminal control/Unicode output",
    "url": "http://rosettacode.org/wiki/Terminal_control/Unicode_output"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Ternary logic",
    "url": "http://rosettacode.org/wiki/Ternary_logic"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Test a function",
    "url": "http://rosettacode.org/wiki/Test_a_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Test integerness",
    "url": "http://rosettacode.org/wiki/Test_integerness"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Text processing/1",
    "url": "http://rosettacode.org/wiki/Text_processing/1"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Text processing/2",
    "url": "http://rosettacode.org/wiki/Text_processing/2"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Text processing/Max licenses in use",
    "url": "http://rosettacode.org/wiki/Text_processing/Max_licenses_in_use"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Textonyms",
    "url": "http://rosettacode.org/wiki/Textonyms"
  },
  {
    "local_code": "//! includes the XOR version of the encryption scheme\n\nuse std::num::Wrapping as w;\n\nconst MSG: &str = \"a Top Secret secret\";\nconst KEY: &str = \"this is my secret key\";\n\nfn main() {\n    let mut isaac = Isaac::new();\n    isaac.seed(KEY, true);\n    let encr = isaac.vernam(MSG.as_bytes());\n\n    println!(\"msg: {}\", MSG);\n    println!(\"key: {}\", KEY);\n    print!(\"XOR: \");\n    for a in &encr {\n        print!(\"{:02X}\", *a);\n    }\n\n    let mut isaac = Isaac::new();\n    isaac.seed(KEY, true);\n    let decr = isaac.vernam(&encr[..]);\n\n    print!(\"\\nXOR dcr: \");\n    println!(\"{}\", String::from_utf8(decr).unwrap())\n}\n\nmacro_rules! mix_v(\n   ($a:expr) => (\n   {\n       $a[0] ^= $a[1] << 11; $a[3] += $a[0]; $a[1] += $a[2];\n       $a[1] ^= $a[2] >> 2;  $a[4] += $a[1]; $a[2] += $a[3];\n       $a[2] ^= $a[3] << 8;  $a[5] += $a[2]; $a[3] += $a[4];\n       $a[3] ^= $a[4] >> 16; $a[6] += $a[3]; $a[4] += $a[5];\n       $a[4] ^= $a[5] << 10; $a[7] += $a[4]; $a[5] += $a[6];\n       $a[5] ^= $a[6] >> 4;  $a[0] += $a[5]; $a[6] += $a[7];\n       $a[6] ^= $a[7] << 8;  $a[1] += $a[6]; $a[7] += $a[0];\n       $a[7] ^= $a[0] >> 9;  $a[2] += $a[7]; $a[0] += $a[1];\n   } );\n);\n\nstruct Isaac {\n    mm: [w<u32>; 256],\n    aa: w<u32>,\n    bb: w<u32>,\n    cc: w<u32>,\n    rand_rsl: [w<u32>; 256],\n    rand_cnt: u32,\n}\n\nimpl Isaac {\n    fn new() -> Isaac {\n        Isaac {\n            mm: [w(0u32); 256],\n            aa: w(0),\n            bb: w(0),\n            cc: w(0),\n            rand_rsl: [w(0u32); 256],\n            rand_cnt: 0,\n        }\n    }\n\n    fn isaac(&mut self) {\n        self.cc += w(1);\n        self.bb += self.cc;\n\n        for i in 0..256 {\n            let w(x) = self.mm[i];\n            match i % 4 {\n                0 => self.aa ^= self.aa << 13,\n                1 => self.aa ^= self.aa >> 6,\n                2 => self.aa ^= self.aa << 2,\n                3 => self.aa ^= self.aa >> 16,\n                _ => unreachable!(),\n            }\n\n            self.aa += self.mm[((i + 128) % 256) as usize];\n            let w(y) = self.mm[((x >> 2) % 256) as usize] + self.aa + self.bb;\n            self.bb = self.mm[((y >> 10) % 256) as usize] + w(x);\n            self.rand_rsl[i] = self.bb;\n        }\n\n        self.rand_cnt = 0;\n    }\n\n    fn rand_init(&mut self, flag: bool) {\n        let mut a_v = [w(0x9e37_79b9u32); 8];\n\n        for _ in 0..4 {\n            // scramble it\n            mix_v!(a_v);\n        }\n\n        for i in (0..256).step_by(8) {\n            // fill in mm[] with messy stuff\n            if flag {\n                // use all the information in the seed\n                for (j, value) in a_v.iter_mut().enumerate().take(8) {\n                    *value += self.rand_rsl[i + j];\n                }\n            }\n            mix_v!(a_v);\n            for (j, value) in a_v.iter().enumerate().take(8) {\n                self.mm[i + j] = *value;\n            }\n        }\n\n        if flag {\n            // do a second pass to make all of the seed affect all of mm\n            for i in (0..256).step_by(8) {\n                for (j, value) in a_v.iter_mut().enumerate().take(8) {\n                    *value += self.mm[i + j];\n                }\n                mix_v!(a_v);\n                for (j, value) in a_v.iter().enumerate().take(8) {\n                    self.mm[i + j] = *value;\n                }\n            }\n        }\n\n        self.isaac(); // fill in the first set of results\n        self.rand_cnt = 0; // prepare to use the first set of results\n    }\n\n    /// Get a random 32-bit value\n    fn i_random(&mut self) -> u32 {\n        let r = self.rand_rsl[self.rand_cnt as usize];\n        self.rand_cnt += 1;\n        if self.rand_cnt > 255 {\n            self.isaac();\n            self.rand_cnt = 0;\n        }\n        r.0\n    }\n\n    /// Seed ISAAC with a string\n    fn seed(&mut self, seed: &str, flag: bool) {\n        for i in 0..256 {\n            self.mm[i] = w(0);\n        }\n        for i in 0..256 {\n            self.rand_rsl[i] = w(0);\n        }\n\n        for i in 0..seed.len() {\n            self.rand_rsl[i] = w(u32::from(seed.as_bytes()[i]));\n        }\n        // initialize ISAAC with seed\n        self.rand_init(flag);\n    }\n\n    /// Get a random character in printable ASCII range\n    fn i_rand_ascii(&mut self) -> u8 {\n        (self.i_random() % 95 + 32) as u8\n    }\n\n    /// XOR message\n    fn vernam(&mut self, msg: &[u8]) -> Vec<u8> {\n        msg.iter()\n            .map(|&b| (self.i_rand_ascii() ^ b))\n            .collect::<Vec<u8>>()\n    }\n}\n\nimpl Default for Isaac {\n    fn default() -> Self {\n        Isaac::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{Isaac, KEY, MSG};\n    const ENCRIPTED: [u8; 19] = [\n        0x1C, 0x06, 0x36, 0x19, 0x0B, 0x12, 0x60, 0x23, 0x3B, 0x35, 0x12, 0x5F, 0x1E, 0x1D, 0x0E,\n        0x2F, 0x4C, 0x54, 0x22,\n    ];\n\n    #[test]\n    fn encrypt() {\n        let mut isaac = Isaac::new();\n        isaac.seed(KEY, true);\n        let encr = isaac.vernam(MSG.as_bytes());\n\n        for (a, b) in encr.iter().zip(ENCRIPTED.iter()) {\n            assert_eq!(a, b);\n        }\n    }\n\n    #[test]\n    fn decrypt() {\n        let expected = MSG;\n\n        let mut isaac = Isaac::new();\n        isaac.seed(KEY, true);\n        let decr = isaac.vernam(&ENCRIPTED[..]);\n\n        for (&a, b) in decr.iter().zip(expected.bytes()) {\n            assert_eq!(a, b);\n        }\n    }\n}\n",
    "path": "tasks/the-isaac-cipher",
    "remote_code": null,
    "title": "The ISAAC Cipher",
    "url": "http://rosettacode.org/wiki/The_ISAAC_Cipher"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "The Name Game",
    "url": "http://rosettacode.org/wiki/The_Name_Game"
  },
  {
    "local_code": "fn main() {\n    let days = [\n        \"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\", \"eighth\", \"ninth\",\n        \"tenth\", \"eleventh\", \"twelfth\",\n    ];\n\n    let gifts = [\n        \"A Partridge in a Pear Tree\",\n        \"Two Turtle Doves and\",\n        \"Three French Hens\",\n        \"Four Calling Birds\",\n        \"Five Golden Rings\",\n        \"Six Geese a Laying\",\n        \"Seven Swans a Swimming\",\n        \"Eight Maids a Milking\",\n        \"Nine Ladies Dancing\",\n        \"Ten Lords a Leaping\",\n        \"Eleven Pipers Piping\",\n        \"Twelve Drummers Drumming\",\n    ];\n\n    #[cfg_attr(feature = \"cargo-clippy\", allow(needless_range_loop))]\n    for i in 0..12 {\n        println!(\"On the {} day of Christmas,\", days[i]);\n        println!(\"My true love gave to me:\");\n\n        for j in (0..i + 1).rev() {\n            println!(\"{}\", gifts[j]);\n        }\n        println!()\n    }\n}\n",
    "path": "tasks/the-twelve-days-of-christmas",
    "remote_code": "fn main() {\n    let days = [\"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\", \"eighth\",\n                \"ninth\", \"tenth\", \"eleventh\", \"twelfth\"];\n\n    let gifts = [\"A Patridge in a Pear Tree\",\n                 \"Two Turtle Doves and\",\n                 \"Three French Hens\",\n                 \"Four Calling Birds\",\n                 \"Five Golden Rings\",\n                 \"Six Geese a Laying\",\n                 \"Seven Swans a Swimming\",\n                 \"Eight Maids a Milking\",\n                 \"Nine Ladies Dancing\",\n                 \"Ten Lords a Leaping\",\n                 \"Eleven Pipers Piping\",\n                 \"Twelve Drummers Drumming\"];\n\n    for i in 0..12 {\n        println!(\"On the {} day of Christmas,\", days[i]);\n        println!(\"My true love gave to me:\");\n\n        for j in (0..i + 1).rev() {\n            println!(\"{}\", gifts[j]);\n        }\n        println!()\n    }\n}",
    "title": "The Twelve Days of Christmas",
    "url": "http://rosettacode.org/wiki/The_Twelve_Days_of_Christmas"
  },
  {
    "local_code": "const N: usize = 32;\nconst STEP: f64 = 0.05;\n\nfn main() {\n    let x: Vec<f64> = (0..N).map(|i| i as f64 * STEP).collect();\n    let sin = x.iter().map(|x| x.sin()).collect();\n    let cos = x.iter().map(|x| x.cos()).collect();\n    let tan = x.iter().map(|x| x.tan()).collect();\n\n    println!(\n        \"{}\\n{}\\n{}\",\n        6. * thiele(&sin, &x, 0.5),\n        3. * thiele(&cos, &x, 0.5),\n        4. * thiele(&tan, &x, 1.)\n    );\n}\n\nfn thiele(x: &Vec<f64>, y: &Vec<f64>, xin: f64) -> f64 {\n    let mut p: Vec<Vec<f64>> = (0..N).map(|i| (i..N).map(|_| 0.0).collect()).collect();\n\n    (0..N).for_each(|i| p[i][0] = y[i]);\n\n    (0..N - 1).for_each(|i| p[i][1] = (x[i] - x[i + 1]) / (p[i][0] - p[i + 1][0]));\n\n    (2..N).for_each(|i| {\n        (0..N - i).for_each(|j| {\n            p[j][i] = (x[j] - x[j + i]) / (p[j][i - 1] - p[j + 1][i - 1]) + p[j + 1][i - 2];\n        })\n    });\n\n    let mut a = 0.;\n    (2..N).rev().for_each(|i| {\n        a = (xin - x[i - 1]) / (p[0][i] - p[0][i - 2] + a);\n    });\n    y[0] + (xin - x[0]) / (p[0][1] + a)\n}\n",
    "path": "tasks/thieles-interpolation-formula",
    "remote_code": null,
    "title": "Thiele's interpolation formula",
    "url": "http://rosettacode.org/wiki/Thiele's_interpolation_formula"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "const ITERATIONS: usize = 8;\n\nfn neg(sequence: &String) -> String {\n    sequence.chars()\n        .map(|ch| {\n            (1 - ch.to_digit(2).unwrap()).to_string()\n        })\n        .collect::<String>()\n}\n\nfn main() {\n    let mut sequence: String = String::from(\"0\");\n    for i in 0..ITERATIONS {\n        println!(\"{}: {}\", i + 1, sequence);\n        sequence = format!(\"{}{}\", sequence, neg(&sequence));\n    }\n}",
    "title": "Thue-Morse",
    "url": "http://rosettacode.org/wiki/Thue-Morse"
  },
  {
    "local_code": "extern crate rand;\n\nuse GameState::{ComputerWin, Draw, PlayerWin, Playing};\n\nuse rand::prelude::*;\n\n#[derive(PartialEq, Debug)]\nenum GameState {\n    PlayerWin,\n    ComputerWin,\n    Draw,\n    Playing,\n}\n\ntype Board = [[char; 3]; 3];\n\nfn main() {\n    let mut rng = StdRng::from_entropy();\n\n    let mut board: Board = [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']];\n\n    draw_board(board);\n    loop {\n        player_turn(&mut board);\n        if check_win(board) != Playing {\n            break;\n        }\n        computer_turn(&mut rng, &mut board);\n        if check_win(board) != Playing {\n            break;\n        }\n        draw_board(board);\n    }\n\n    draw_board(board);\n    let announcement = match check_win(board) {\n        PlayerWin => \"The Player has won!\",\n        ComputerWin => \"The Computer has won!\",\n        Draw => \"Draw!\",\n        Playing => unreachable!(),\n    };\n    println!(\"{}\", announcement);\n}\n\nfn is_empty(cell: &char) -> bool {\n    *cell != 'X' && *cell != 'O'\n}\n\nfn check_win(board: Board) -> GameState {\n    // check for win\n    for (i, row) in board.iter().enumerate() {\n        if row[0] == row[1] && row[0] == row[2] {\n            return which_win(row[0]);\n        } else if board[0][i] == board[1][i] && board[0][i] == board[2][i] {\n            return which_win(board[0][i]);\n        }\n    }\n    if board[0][0] == board[1][1] && board[0][0] == board[2][2] {\n        return which_win(board[0][0]);\n    } else if board[0][2] == board[1][1] && board[0][2] == board[2][0] {\n        return which_win(board[0][2]);\n    }\n\n    // check if it's not a draw\n    let is_draw = board.iter().flat_map(|row| row).any(is_empty);\n    if is_draw {\n        Playing\n    } else {\n        Draw\n    }\n}\n\nfn which_win(s: char) -> GameState {\n    match s {\n        'X' => PlayerWin,\n        'O' => ComputerWin,\n        _ => unreachable!(),\n    }\n}\n\nfn player_turn(board: &mut Board) {\n    use std::io;\n\n    println!(\"Player, enter your field of choice!: \");\n    let mut ln = String::new();\n    io::stdin()\n        .read_line(&mut ln)\n        .expect(\"Failed to read stdin\");\n    let choice = ln.trim().parse::<usize>().expect(\"Failed to parse input\");\n    let row = (choice - 1) / 3;\n    let col = (choice - 1) % 3;\n\n    if board[row][col] == 'X' || board[row][col] == 'O' {\n        println!(\"Someone already took this field!\");\n        player_turn(board);\n    } else {\n        board[row][col] = 'X';\n    }\n}\n\nfn computer_turn<R: Rng>(rng: &mut R, board: &mut Board) {\n    let possible_choices: Vec<_> = board\n        .iter()\n        .flatten()\n        .enumerate()\n        .filter(|&(_, c)| is_empty(c))\n        .map(|(i, _)| i)\n        .collect();\n\n    let choice = possible_choices.choose(rng).unwrap();\n    println!(\"Computer chose: {}\", choice);\n    let row = choice / 3;\n    let col = choice % 3;\n    board[row][col] = 'O';\n}\n\nfn draw_board(board: Board) {\n    for row in &board {\n        println!(\"{} {} {}\", row[0], row[1], row[2]);\n    }\n}\n\n#[test]\nfn test_which_win() {\n    assert_eq!(which_win('X'), PlayerWin);\n    assert_eq!(which_win('O'), ComputerWin);\n}\n\n#[test]\nfn test_check_win() {\n    assert_eq!(\n        check_win([['X', 'X', 'X'], ['4', 'O', 'O'], ['7', '8', '9']]),\n        PlayerWin\n    );\n    assert_eq!(\n        check_win([['O', 'X', '3'], ['X', 'O', '6'], ['X', '8', 'O']]),\n        ComputerWin\n    );\n    assert_eq!(\n        check_win([['O', 'X', 'X'], ['X', 'O', 'O'], ['O', 'X', 'X']]),\n        Draw\n    );\n}\n",
    "path": "tasks/tic-tac-toe",
    "remote_code": null,
    "title": "Tic-tac-toe",
    "url": "http://rosettacode.org/wiki/Tic-tac-toe"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Time a function",
    "url": "http://rosettacode.org/wiki/Time_a_function"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Tokenize_a_string\n\nfn main() {\n    let s = \"Hello,How,Are,You,Today\";\n    let tokens: Vec<&str> = s.split(',').collect();\n    println!(\"{}\", tokens.join(\".\"));\n}\n",
    "path": "tasks/tokenize-a-string",
    "remote_code": "fn main() {\n    let s = \"Hello,How,Are,You,Today\";\n    let tokens: Vec<&str> = s.split(\",\").collect();\n    println!(\"{}\", tokens.join(\".\"));\n}",
    "title": "Tokenize a string",
    "url": "http://rosettacode.org/wiki/Tokenize_a_string"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "const SEPARATOR: char = '|';\nconst ESCAPE: char = '^';\nconst STRING: &str = \"one^|uno||three^^^^|four^^^|^cuatro|\";\n\nfn tokenize(string: &str) -> Vec<String> {\n    let mut token = String::new();\n    let mut tokens: Vec<String> = Vec::new();\n    let mut chars = string.chars();\n    while let Some(ch) = chars.next() {\n        match ch {\n            SEPARATOR => {\n                tokens.push(token);\n                token = String::new();\n            },\n            ESCAPE => {\n                if let Some(next) = chars.next() {\n                    token.push(next);\n                }\n            },\n            _ => token.push(ch),\n        }\n    }\n    tokens.push(token);\n    tokens\n}\n\nfn main() {\n    println!(\"{:#?}\", tokenize(STRING));\n}",
    "title": "Tokenize a string with escaping",
    "url": "http://rosettacode.org/wiki/Tokenize_a_string_with_escaping"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Tonelli-Shanks algorithm",
    "url": "http://rosettacode.org/wiki/Tonelli-Shanks_algorithm"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Top rank per group",
    "url": "http://rosettacode.org/wiki/Top_rank_per_group"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Topic variable",
    "url": "http://rosettacode.org/wiki/Topic_variable"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Topological sort",
    "url": "http://rosettacode.org/wiki/Topological_sort"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Topswops",
    "url": "http://rosettacode.org/wiki/Topswops"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Total circles area",
    "url": "http://rosettacode.org/wiki/Total_circles_area"
  },
  {
    "local_code": "use num::integer::gcd;\n\nfn main() {\n    // Compute the totient of the first 25 natural integers\n    println!(\"N\\t phi(n)\\t Prime\");\n    for n in 1..26 {\n        let phi_n = phi(n);\n        println!(\"{}\\t {}\\t {:?}\", n, phi_n, phi_n == n - 1);\n    }\n\n    // Compute the number of prime numbers for various steps\n    [1, 100, 1000, 10000, 100000]\n        .windows(2)\n        .scan(0, |acc, window| {\n            let (lower, upper) = (window[0], window[1]);\n            *acc += (lower..=upper).filter(is_prime).count();\n            Some((upper, *acc))\n        })\n        .for_each(|x| println!(\"Until {}: {} prime numbers\", x.0, x.1));\n}\n\nfn is_prime(n: &usize) -> bool {\n    phi(*n) == *n - 1\n}\n\nfn phi(n: usize) -> usize {\n    (1..=n).filter(|&x| gcd(n, x) == 1).count()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{is_prime, phi};\n\n    #[test]\n    fn test_totient_primes() {\n        let results = vec![\n            (1, 1, false),\n            (2, 1, true),\n            (3, 2, true),\n            (4, 2, false),\n            (5, 4, true),\n            (6, 2, false),\n            (7, 6, true),\n            (8, 4, false),\n            (9, 6, false),\n            (10, 4, false),\n            (11, 10, true),\n            (12, 4, false),\n            (13, 12, true),\n            (14, 6, false),\n            (15, 8, false),\n            (16, 8, false),\n            (17, 16, true),\n            (18, 6, false),\n            (19, 18, true),\n            (20, 8, false),\n            (21, 12, false),\n            (22, 10, false),\n            (23, 22, true),\n            (24, 8, false),\n            (25, 20, false),\n        ];\n        for n in 1..26 {\n            let phi_n = phi(n);\n            assert_eq!((n, phi_n, phi_n == n - 1), results[n - 1]);\n        }\n    }\n\n    #[test]\n    #[ignore]\n    fn test_totient_prime_list() {\n        let results: Vec<usize> = [1, 100, 1000, 10000, 100000]\n            .windows(2)\n            .scan(0, |acc, window| {\n                let (lower, upper) = (window[0], window[1]);\n                *acc += (lower..=upper).filter(is_prime).count();\n                Some(*acc)\n            })\n            .collect();\n\n        assert_eq!(results, vec![25, 168, 1229, 9592]);\n    }\n}\n",
    "path": "tasks/totient-function",
    "remote_code": "use num::integer::gcd;\n\nfn main() {\n    // Compute the totient of the first 25 natural integers\n    println!(\"N\\t phi(n)\\t Prime\");\n    for n in 1..26 {\n        let phi_n = phi(n);\n        println!(\"{}\\t {}\\t {:?}\", n, phi_n, phi_n == n - 1);\n    }\n\n    // Compute the number of prime numbers for various steps\n    [1, 100, 1000, 10000, 100000]\n        .windows(2)\n        .scan(0, |acc, tuple| {\n            *acc += (tuple[0]..=tuple[1]).filter(is_prime).count();\n            Some((tuple[1], *acc))\n        })\n        .for_each(|x| println!(\"Until {}: {} prime numbers\", x.0, x.1));\n}\n\nfn is_prime(n: &usize) -> bool {\n    phi(*n) == *n - 1\n}\n\nfn phi(n: usize) -> usize {\n    (1..=n).filter(|&x| gcd(n, x) == 1).count()\n}",
    "title": "Totient function",
    "url": "http://rosettacode.org/wiki/Totient_function"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Towers_of_Hanoi\n\nfn play(n: i32, from: i32, to: i32, via: i32) {\n    if n > 0 {\n        play(n - 1, from, via, to);\n        println!(\"Move disk from pole {} to pole {}\", from, to);\n        play(n - 1, via, to, from);\n    }\n}\n\nfn main() {\n    play(4, 1, 2, 3);\n}\n",
    "path": "tasks/towers-of-hanoi",
    "remote_code": "fn move_(n: i32, from: i32, to: i32, via: i32) {\n    if n > 0 {\n        move_(n - 1, from, via, to);\n        println!(\"Move disk from pole {} to pole {}\", from, to);\n        move_(n - 1, via, to, from);\n    }\n}\n\nfn main() {\n    move_(4, 1,2,3);\n}",
    "title": "Towers of Hanoi",
    "url": "http://rosettacode.org/wiki/Towers_of_Hanoi"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "\nuse std::io::{self, BufRead};\n\nfn op(x: f32) -> Option<f32> {\n    let y = x.abs().sqrt() + 5.0 * x * x * x;\n    if y < 400.0 {\n        Some(y)\n    } else {\n        None\n    }\n}\n\nfn main() {\n    println!(\"Please enter 11 numbers (one number per line)\");\n    let stdin = io::stdin();\n\n    let xs = stdin\n        .lock()\n        .lines()\n        .map(|ox| ox.unwrap().trim().to_string())\n        .flat_map(|s| str::parse::<f32>(&s))\n        .take(11)\n        .collect::<Vec<_>>();\n\n    for x in xs.into_iter().rev() {\n        match op(x) {\n            Some(y) => println!(\"{}\", y),\n            None => println!(\"overflow\"),\n        };\n    }\n}\n",
    "title": "Trabb Pardo–Knuth algorithm",
    "url": "http://rosettacode.org/wiki/Trabb_Pardo%E2%80%93Knuth_algorithm"
  },
  {
    "local_code": "#![feature(box_syntax, box_patterns)]\n\nuse std::collections::VecDeque;\n\n#[derive(Debug)]\nstruct TreeNode<T> {\n    value: T,\n    left: Option<Box<TreeNode<T>>>,\n    right: Option<Box<TreeNode<T>>>,\n}\n\n#[cfg_attr(feature = \"cargo-clippy\", allow(enum_variant_names))]\nenum TraversalMethod {\n    PreOrder,\n    InOrder,\n    PostOrder,\n    LevelOrder,\n}\n\nimpl<T> TreeNode<T> {\n    pub fn from_array(arr: &[[i8; 3]]) -> TreeNode<i8> {\n        let l = match arr[0][1] {\n            -1 => None,\n            i => Some(Box::new(TreeNode::<i8>::from_array(\n                &arr[(i - arr[0][0]) as usize..],\n            ))),\n        };\n        let r = match arr[0][2] {\n            -1 => None,\n            i => Some(Box::new(TreeNode::<i8>::from_array(\n                &arr[(i - arr[0][0]) as usize..],\n            ))),\n        };\n\n        TreeNode {\n            value: arr[0][0],\n            left: l,\n            right: r,\n        }\n    }\n\n    pub fn traverse(&self, tr: &TraversalMethod) -> Vec<&TreeNode<T>> {\n        match *tr {\n            TraversalMethod::PreOrder => self.iterative_preorder(),\n            TraversalMethod::InOrder => self.iterative_inorder(),\n            TraversalMethod::PostOrder => self.iterative_postorder(),\n            TraversalMethod::LevelOrder => self.iterative_levelorder(),\n        }\n    }\n\n    fn iterative_preorder(&self) -> Vec<&TreeNode<T>> {\n        let mut stack: Vec<&TreeNode<T>> = Vec::new();\n        let mut res: Vec<&TreeNode<T>> = Vec::new();\n\n        stack.push(self);\n        while !stack.is_empty() {\n            let node = stack.pop().unwrap();\n            res.push(node);\n            match node.right {\n                None => {}\n                Some(box ref n) => stack.push(n),\n            }\n            match node.left {\n                None => {}\n                Some(box ref n) => stack.push(n),\n            }\n        }\n        res\n    }\n\n    // Leftmost to rightmost\n    fn iterative_inorder(&self) -> Vec<&TreeNode<T>> {\n        let mut stack: Vec<&TreeNode<T>> = Vec::new();\n        let mut res: Vec<&TreeNode<T>> = Vec::new();\n        let mut p = self;\n\n        loop {\n            // Stack parents and right children while left-descending\n            loop {\n                match p.right {\n                    None => {}\n                    Some(box ref n) => stack.push(n),\n                }\n                stack.push(p);\n                match p.left {\n                    None => break,\n                    Some(box ref n) => p = n,\n                }\n            }\n            // Visit the nodes with no right child\n            p = stack.pop().unwrap();\n            while !stack.is_empty() && p.right.is_none() {\n                res.push(p);\n                p = stack.pop().unwrap();\n            }\n            // First node that can potentially have a right child:\n            res.push(p);\n            if stack.is_empty() {\n                break;\n            } else {\n                p = stack.pop().unwrap();\n            }\n        }\n        res\n    }\n\n    // Left-to-right postorder is same sequence as right-to-left preorder, reversed\n    fn iterative_postorder(&self) -> Vec<&TreeNode<T>> {\n        let mut stack: Vec<&TreeNode<T>> = Vec::new();\n        let mut res: Vec<&TreeNode<T>> = Vec::new();\n\n        stack.push(self);\n        while !stack.is_empty() {\n            let node = stack.pop().unwrap();\n            res.push(node);\n            match node.left {\n                None => {}\n                Some(box ref n) => stack.push(n),\n            }\n            match node.right {\n                None => {}\n                Some(box ref n) => stack.push(n),\n            }\n        }\n        let rev_iter = res.iter().rev();\n        let mut rev: Vec<&TreeNode<T>> = Vec::new();\n        for elem in rev_iter {\n            rev.push(elem);\n        }\n        rev\n    }\n\n    fn iterative_levelorder(&self) -> Vec<&TreeNode<T>> {\n        let mut queue: VecDeque<&TreeNode<T>> = VecDeque::new();\n        let mut res: Vec<&TreeNode<T>> = Vec::new();\n\n        queue.push_back(self);\n        while !queue.is_empty() {\n            let node = queue.pop_front().unwrap();\n            res.push(node);\n            match node.left {\n                None => {}\n                Some(box ref n) => queue.push_back(n),\n            }\n            match node.right {\n                None => {}\n                Some(box ref n) => queue.push_back(n),\n            }\n        }\n        res\n    }\n}\n\nfn main() {\n    // Array representation of task tree\n    let arr_tree = [\n        [1, 2, 3],\n        [2, 4, 5],\n        [3, 6, -1],\n        [4, 7, -1],\n        [5, -1, -1],\n        [6, 8, 9],\n        [7, -1, -1],\n        [8, -1, -1],\n        [9, -1, -1],\n    ];\n\n    let root = TreeNode::<i8>::from_array(&arr_tree);\n\n    let method_labels = [\n        (TraversalMethod::PreOrder, \"pre-order:\"),\n        (TraversalMethod::InOrder, \"in-order:\"),\n        (TraversalMethod::PostOrder, \"post-order:\"),\n        (TraversalMethod::LevelOrder, \"level-order:\"),\n    ];\n\n    for method_label in &method_labels {\n        print!(\"{}\\t\", method_label.1);\n        for n in root.traverse(&method_label.0) {\n            print!(\" {}\", n.value);\n        }\n        println!();\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::{TraversalMethod, TreeNode};\n\n    macro_rules! trav_values {\n        ($x:expr) => {\n            $x.iter().map(|n| n.value).collect();\n        };\n    }\n\n    #[test]\n    fn test_traversals() {\n        let arr_tree = [\n            [1, 2, 3],\n            [2, 4, 5],\n            [3, 6, -1],\n            [4, 7, -1],\n            [5, -1, -1],\n            [6, 8, 9],\n            [7, -1, -1],\n            [8, -1, -1],\n            [9, -1, -1],\n        ];\n        let root = TreeNode::<i8>::from_array(&arr_tree);\n\n        let mut res: Vec<i8>;\n        res = trav_values!(root.traverse(&TraversalMethod::PreOrder));\n        assert_eq!(res.as_slice(), &[1, 2, 4, 7, 5, 3, 6, 8, 9]);\n        res = trav_values!(root.traverse(&TraversalMethod::InOrder));\n        assert_eq!(res.as_slice(), &[7, 4, 2, 5, 1, 8, 6, 9, 3]);\n        res = trav_values!(root.traverse(&TraversalMethod::PostOrder));\n        assert_eq!(res.as_slice(), &[7, 4, 5, 2, 8, 9, 6, 3, 1]);\n        res = trav_values!(root.traverse(&TraversalMethod::LevelOrder));\n        assert_eq!(res.as_slice(), &[1, 2, 3, 4, 5, 6, 7, 8, 9]);\n    }\n}\n",
    "path": "tasks/tree-traversal",
    "remote_code": null,
    "title": "Tree traversal",
    "url": "http://rosettacode.org/wiki/Tree_traversal"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Trigonometric functions",
    "url": "http://rosettacode.org/wiki/Trigonometric_functions"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Truncatable primes",
    "url": "http://rosettacode.org/wiki/Truncatable_primes"
  },
  {
    "local_code": "use std::env;\nuse std::fs::OpenOptions;\nuse std::str::FromStr;\n\nfn main() {\n    if env::args().count() != 3 {\n        println!(\"Usage: {} <filename> <size>\", env::args().nth(0).unwrap());\n    } else {\n        let filename = env::args().nth(1).unwrap();\n        let size = env::args().nth(2).unwrap();\n        match u64::from_str(&size) {\n            Ok(integer_size) => {\n                let file = OpenOptions::new().write(true).open(filename).unwrap();\n                let _ = file.set_len(integer_size);\n            }\n            Err(_) => println!(\"Invalid size\"),\n        }\n    }\n}\n",
    "path": "tasks/truncate-a-file",
    "remote_code": null,
    "title": "Truncate a file",
    "url": "http://rosettacode.org/wiki/Truncate_a_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Truth table",
    "url": "http://rosettacode.org/wiki/Truth_table"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Twelve statements",
    "url": "http://rosettacode.org/wiki/Twelve_statements"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "const INPUT1: &str = \"http%3A%2F%2Ffoo%20bar%2F\";\nconst INPUT2: &str = \"google.com/search?q=%60Abdu%27l-Bah%C3%A1\";\n\nfn append_frag(text: &mut String, frag: &mut String) {\n    if !frag.is_empty() {\n        let encoded = frag.chars()\n            .collect::<Vec<char>>()\n            .chunks(2)\n            .map(|ch| {\n                u8::from_str_radix(&ch.iter().collect::<String>(), 16).unwrap()\n            }).collect::<Vec<u8>>();\n        text.push_str(&std::str::from_utf8(&encoded).unwrap());\n        frag.clear();\n    }\n}\n\nfn decode(text: &str) -> String {\n    let mut output = String::new();\n    let mut encoded_ch = String::new();\n    let mut iter = text.chars();\n    while let Some(ch) = iter.next() {\n        if ch == '%' {\n            encoded_ch.push_str(&format!(\"{}{}\", iter.next().unwrap(), iter.next().unwrap()));\n        } else {\n            append_frag(&mut output, &mut encoded_ch);\n            output.push(ch);\n        }\n    }\n    append_frag(&mut output, &mut encoded_ch);\n    output\n}\n\nfn main() {\n    println!(\"{}\", decode(INPUT1));\n    println!(\"{}\", decode(INPUT2));\n}",
    "title": "URL decoding",
    "url": "http://rosettacode.org/wiki/URL_decoding"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "URL encoding",
    "url": "http://rosettacode.org/wiki/URL_encoding"
  },
  {
    "local_code": "extern crate url;\n\nuse url::Url;\n\nfn print_url(url: &Url) {\n    println!(\"scheme:      {:?}\", url.scheme());\n    if let Some(ref host) = url.host() {\n        println!(\"domain:      {:?}\", host);\n    }\n    if let Some(ref port) = url.port() {\n        println!(\"port:        {:?}\", port);\n    }\n    println!(\"path:        {:?}\", url.path());\n    if let Some(query) = url.query() {\n        println!(\"query:       {:?}\", query);\n    }\n    if let Some(fragment) = url.fragment() {\n        println!(\"fragment:    {:?}\", fragment);\n    }\n}\n\nfn main() {\n    let urls = vec![\n        \"foo://example.com:8042/over/there?name=ferret#nose\",\n        \"urn:example:animal:ferret:nose\",\n        \"jdbc:mysql://test_user:ouupppssss@localhost:3306/sakila?profileSQL=true\",\n        \"ftp://ftp.is.co.za/rfc/rfc1808.txt\",\n        \"http://www.ietf.org/rfc/rfc2396.txt#header1\",\n        \"ldap://[2001:db8::7]/c=GB?objectClass=one&objectClass=two\",\n        \"mailto:John.Doe@example.com\",\n        \"news:comp.infosystems.www.servers.unix\",\n        \"tel:+1-816-555-1212\",\n        \"telnet://192.0.2.16:80/\",\n        \"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\",\n        \"ssh://alice@example.com\",\n        \"https://bob:pass@example.com/place\",\n        \"http://example.com/?a=1&b=2+2&c=3&c=4&d=%65%6e%63%6F%64%65%64\",\n    ];\n    for url in urls {\n        println!(\"URL: {}\", url);\n        print_url(&Url::parse(url).unwrap());\n        println!();\n    }\n}\n",
    "path": "tasks/url-parser",
    "remote_code": null,
    "title": "URL parser",
    "url": "http://rosettacode.org/wiki/URL_parser"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "UTF-8 encode and decode",
    "url": "http://rosettacode.org/wiki/UTF-8_encode_and_decode"
  },
  {
    "local_code": "use std::fmt;\n\nenum Direction {\n    RIGHT,\n    UP,\n    LEFT,\n    DOWN,\n}\nuse Direction::*;\n\nfn is_prime(a: u32) -> bool {\n    match a {\n        2 => true,\n        x if x <= 1 || x % 2 == 0 => false,\n        _ => {\n            let max = f64::from(a).sqrt() as u32;\n            for x in (3..max).step_by(2) {\n                if a % x == 0 {\n                    return false;\n                }\n            }\n            true\n        }\n    }\n}\n\nstruct Ulam {\n    u: Vec<Vec<String>>,\n}\n\nimpl fmt::Display for Ulam {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for row in &self.u {\n            let pretty = format!(\"{:?}\", row).replace('\\\"', \"\").replace(\", \", \"\");\n            write!(f, \"{}\\n\", pretty)?;\n        }\n        writeln!(f)\n    }\n}\n\n#[cfg_attr(feature = \"cargo-clippy\", allow(many_single_char_names))]\nfn generate(n: u32, s: u32, c: char) -> Ulam {\n    let mut spiral = vec![vec![\"\".to_string(); n as usize]; n as usize];\n    let mut dir = RIGHT;\n    let mut y = (n / 2) as usize;\n    let mut x = if n % 2 == 0 { y - 1 } else { y }; // shift left for even n's\n    for j in s..n * n + s {\n        spiral[y][x] = if is_prime(j) {\n            if c == '\\0' {\n                format!(\"{:4}\", j)\n            } else {\n                format!(\"  {} \", c)\n            }\n        } else {\n            \" ---\".to_string()\n        };\n\n        match dir {\n            RIGHT => {\n                if x as u32 <= n - 1 && spiral[y - 1][x].is_empty() && j > s {\n                    dir = UP;\n                }\n            }\n            UP => {\n                if spiral[y][x - 1].is_empty() {\n                    dir = LEFT;\n                }\n            }\n            LEFT => {\n                if x == 0 || spiral[y + 1][x].is_empty() {\n                    dir = DOWN;\n                }\n            }\n            DOWN => {\n                if spiral[y][x + 1].is_empty() {\n                    dir = RIGHT;\n                }\n            }\n        };\n\n        match dir {\n            RIGHT => x += 1,\n            UP => y -= 1,\n            LEFT => x -= 1,\n            DOWN => y += 1,\n        };\n    }\n    Ulam { u: spiral }\n}\n\n// Program entry point.\nfn main() {\n    print!(\"{}\", generate(9, 1, '\\0'));\n    print!(\"{}\", generate(9, 1, '*'));\n}\n",
    "path": "tasks/ulam-spiral-for-primes",
    "remote_code": "use std::fmt;\n\nenum Direction { RIGHT, UP, LEFT, DOWN }\nuse ulam::Direction::*;\n\n/// Indicates whether an integer is a prime number or not.\nfn is_prime(a: u32) -> bool {\n    match a {\n        2 => true,\n        x if x <= 1 || x % 2 == 0 => false,\n        _ => {\n            let max = f64::sqrt(a as f64) as u32;\n            let mut x =  3;\n            while x <= max {\n                if a % x == 0 { return false; }\n                x += 2;\n            }\n            true\n        }\n    }\n}\n\npub struct Ulam { u : Vec<Vec<String>> }\n\nimpl Ulam {\n    /// Generates one `Ulam` object.\n    pub fn new(n: u32, s: u32, c: char) -> Ulam {\n        let mut spiral = vec![vec![String::new(); n as usize]; n as usize];\n        let mut dir = RIGHT;\n        let mut y = (n / 2) as usize;\n        let mut x = if n % 2 == 0 { y - 1 } else { y }; // shift left for even n's\n        for j in s..n * n + s {\n            spiral[y][x] = if is_prime(j) {\n                if c == '\\0' { format!(\"{:4}\", j) } else { format!(\"  {} \", c) }\n            }\n            else { String::from(\" ---\") };\n\n            match dir {\n                RIGHT => if x as u32 <= n - 1 && spiral[y - 1][x].is_empty() && j > s { dir = UP; },\n                UP => if spiral[y][x - 1].is_empty() { dir = LEFT; },\n                LEFT => if x == 0 || spiral[y + 1][x].is_empty() { dir = DOWN; },\n                DOWN => if spiral[y][x + 1].is_empty() { dir = RIGHT; }\n            };\n\n            match dir { RIGHT => x += 1, UP => y -= 1, LEFT => x -= 1, DOWN => y += 1 };\n        }\n        Ulam { u: spiral }\n    }\n}\n\nimpl fmt::Display for Ulam {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for row in &self.u {\n            writeln!(f, \"{}\", format!(\"{:?}\", row).replace(\"\\\"\", \"\").replace(\", \", \"\"));\n        };\n        writeln!(f, \"\")\n    }\n}",
    "title": "Ulam spiral (for primes)",
    "url": "http://rosettacode.org/wiki/Ulam_spiral_(for_primes)"
  },
  {
    "local_code": "extern crate rand;\n\nuse rand::prelude::*;\n\nfn rand_n<R: Rng>(rng: &mut R, n: u32) -> usize {\n    (rng.gen_range(0, n) == 0) as usize // maps `false` to 0 and `true` to 1\n}\n\nfn unbiased<R: Rng>(rng: &mut R, n: u32) -> usize {\n    let mut bit = rand_n(rng, n);\n    while bit == rand_n(rng, n) {\n        bit = rand_n(rng, n);\n    }\n    bit\n}\n\nfn main() {\n    const SAMPLES: usize = 100_000;\n    let mut rng = thread_rng();\n\n    println!(\" Bias    rand_n  unbiased\");\n    for n in 3..=6 {\n        let mut count_biased = 0;\n        let mut count_unbiased = 0;\n        for _ in 0..SAMPLES {\n            count_biased += rand_n(&mut rng, n);\n            count_unbiased += unbiased(&mut rng, n);\n        }\n\n        let b_percentage = 100.0 * count_biased as f64 / SAMPLES as f64;\n        let ub_percentage = 100.0 * count_unbiased as f64 / SAMPLES as f64;\n        println!(\n            \"bias {}:  {:0.2}%   {:0.2}%\",\n            n, b_percentage, ub_percentage\n        );\n    }\n}\n\n#[test]\nfn test_unbiased() {\n    let mut rng = thread_rng();\n    const SAMPLES: usize = 10_000;\n\n    for n in 3..=6 {\n        let mut count = 0;\n        for _ in 0..SAMPLES {\n            count += unbiased(&mut rng, n);\n        }\n\n        let ratio = 1000 * count / SAMPLES;\n        assert!(ratio > 450 && ratio < 550, \"{}\", ratio);\n    }\n}\n",
    "path": "tasks/unbias-a-random-generator",
    "remote_code": null,
    "title": "Unbias a random generator",
    "url": "http://rosettacode.org/wiki/Unbias_a_random_generator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Undefined values",
    "url": "http://rosettacode.org/wiki/Undefined_values"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Unicode strings",
    "url": "http://rosettacode.org/wiki/Unicode_strings"
  },
  {
    "local_code": "#![feature(non_ascii_idents)]\n\n// Rust warns about non-snake-case variable names by default, and will suggest `δ` as the variable\n// name instead.\n#[allow(non_snake_case)]\nfn main() {\n    let mut Δ: i32 = 1;\n    Δ += 1;\n    println!(\"{}\", Δ);\n}\n",
    "path": "tasks/unicode-variable-names",
    "remote_code": "#![feature(non_ascii_idents)]\n#![allow(non_snake_case)]\n\nfn main() {\n    let mut Δ: i32 = 1;\n    Δ += 1;\n    println!(\"{}\", Δ);\n}",
    "title": "Unicode variable names",
    "url": "http://rosettacode.org/wiki/Unicode_variable_names"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Universal Turing machine",
    "url": "http://rosettacode.org/wiki/Universal_Turing_machine"
  },
  {
    "local_code": "//! Works only with correct paths or no arguments at all\n\nuse std::path::Path;\nuse std::{env, fs};\n\nfn main() -> Result<(), std::io::Error> {\n    // ignoring all arguments except the 1st\n    if let Some(path) = env::args().nth(1) {\n        // check if the program received an argument\n        print_files(Path::new(&path))?;\n    } else {\n        // note that current_dir value might be invalid, so it's a Result\n        print_files(&env::current_dir()?)?;\n    };\n    Ok(())\n}\n\nfn print_files(path: &Path) -> std::io::Result<()> {\n    // flatten entries to avoid calling .unwrap()\n    let mut entries: Vec<_> = fs::read_dir(path)?\n        .flat_map(|entry| entry.ok().map(|f| f.file_name()))\n        .collect();\n    // read_dir does not guarantee order\n    entries.sort();\n    entries.iter().for_each(|f| {\n        println!(\"{}\", f.to_string_lossy());\n    });\n    Ok(())\n}\n",
    "path": "tasks/unix/ls",
    "remote_code": "use std::{env, fmt, fs, process};\nuse std::io::{self, Write};\nuse std::path::Path;\n\nfn main() {\n    let cur = env::current_dir().unwrap_or_else(|e| exit_err(e, 1));\n    let arg = env::args().nth(1);\n    print_files(arg.as_ref().map_or(cur.as_path(), |p| Path::new(p)))\n        .unwrap_or_else(|e| exit_err(e, 2));\n}\n\n#[inline]\nfn print_files(path: &Path) -> io::Result<()> {\n    for x in try!(fs::read_dir(path)) {\n        println!(\"{}\", try!(x).file_name().to_string_lossy());\n    }\n    Ok(())\n}\n\n#[inline]\nfn exit_err<T>(msg: T, code: i32) -> ! where T: fmt::Display {\n    writeln!(&mut io::stderr(), \"{}\", msg).expect(\"Could not write to stderr\");\n    process::exit(code)\n}",
    "title": "Unix/ls",
    "url": "http://rosettacode.org/wiki/Unix/ls"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Unprimeable numbers",
    "url": "http://rosettacode.org/wiki/Unprimeable_numbers"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Update a configuration file",
    "url": "http://rosettacode.org/wiki/Update_a_configuration_file"
  },
  {
    "local_code": "//! In order to run this task, you will need to compile the C program locating in the task linked\n//! above. The C program will need to be linked with the library produced by this file.\n//!\n//! 1. Compile this library:\n//!\n//!     ```bash\n//!     $ cargo build --release\n//!     ```\n//!\n//! 2. Copy the C program into query.c.\n//! 3. Compile and link the C program with the produced library:\n//!\n//!     ```bash\n//!     $ LD_LIBRARY_PATH=/path/to/library gcc query.c -o query -Wall -Werror libquery\n//!     ```\n//! 4. Run the resulting binary.\n//!\n//!     ```bash\n//!     $ LD_LIBRARY_PATH=/path/to/library ./query\n//!     Here am I\n//!     ```\n\n#![crate_type = \"dylib\"]\n\nextern crate libc;\n\nuse std::ffi::CString;\n\nuse libc::{c_char, c_int, size_t};\n\n#[no_mangle]\n#[allow(non_snake_case)]\npub unsafe extern \"C\" fn Query(data: *mut c_char, length: *mut size_t) -> c_int {\n    let string = \"Here am I\";\n    if *length + 1 < string.len() {\n        0\n    } else {\n        let c_string = CString::new(string).unwrap();\n        libc::strcpy(data, c_string.as_ptr());\n        *length = string.len();\n        1\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::Query;\n\n    #[test]\n    fn buffer_too_small() {\n        unsafe {\n            const BUF_SIZE: usize = 3;\n            let mut buffer = [0; BUF_SIZE];\n            assert_eq!(0, Query(buffer.as_mut_ptr(), &mut BUF_SIZE));\n        }\n    }\n\n    #[test]\n    fn buffer_contains_data() {\n        use std::ffi::{CStr, CString};\n\n        unsafe {\n            const BUF_SIZE: usize = 1024;\n            let mut buffer = [0; BUF_SIZE];\n            assert_eq!(1, Query(buffer.as_mut_ptr(), &mut BUF_SIZE));\n            assert_eq!(\n                CString::new(\"Here am I\").unwrap(),\n                CStr::from_ptr(buffer.as_ptr()).to_owned()\n            );\n        }\n    }\n}\n",
    "path": "tasks/use-another-language-to-call-a-function",
    "remote_code": null,
    "title": "Use another language to call a function",
    "url": "http://rosettacode.org/wiki/Use_another_language_to_call_a_function"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "User input/Graphical",
    "url": "http://rosettacode.org/wiki/User_input/Graphical"
  },
  {
    "local_code": "//! This program demonstrates proper error handling.\n\nuse std::fmt::Display;\nuse std::io::{self, Write};\nuse std::process;\n\nfn grab_input(msg: &str) -> io::Result<String> {\n    let mut buf = String::new();\n    print!(\"{}: \", msg);\n    io::stdout().flush()?;\n\n    io::stdin().read_line(&mut buf)?;\n    Ok(buf)\n}\n\nfn exit_err<T: Display>(msg: T, code: i32) -> ! {\n    let _ = writeln!(&mut io::stderr(), \"Error: {}\", msg);\n    process::exit(code)\n}\n\nfn main() {\n    let s = grab_input(\"Give me a string\")\n        .unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)));\n\n    println!(\"You entered: {}\", s.trim());\n\n    let n: i32 = grab_input(\"Give me an integer\")\n        .unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)))\n        .trim()\n        .parse()\n        .unwrap_or_else(|e| exit_err(&e, 2));\n\n    println!(\"You entered: {}\", n);\n}\n",
    "path": "tasks/user-input/text",
    "remote_code": "use std::io::{self, Write};\nuse std::fmt::Display;\nuse std::process;\n\nfn main() {\n    let s = grab_input(\"Give me a string\")\n        .unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)));\n\n    println!(\"You entered: {}\", s.trim());\n\n    let n: i32 = grab_input(\"Give me an integer\")\n        .unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)))\n        .trim()\n        .parse()\n        .unwrap_or_else(|e| exit_err(&e, 2));\n\n    println!(\"You entered: {}\", n);\n}\n\nfn grab_input(msg: &str) -> io::Result<String> {\n    let mut buf = String::new();\n    print!(\"{}: \", msg);\n    try!(io::stdout().flush());\n\n    try!(io::stdin().read_line(&mut buf));\n    Ok(buf)\n}\n\nfn exit_err<T: Display>(msg: T, code: i32) -> ! {\n    let _ = writeln!(&mut io::stderr(), \"Error: {}\", msg);\n    process::exit(code)\n}",
    "title": "User input/Text",
    "url": "http://rosettacode.org/wiki/User_input/Text"
  },
  {
    "local_code": "extern crate luhn_test_of_credit_card_numbers;\n\nuse luhn_test_of_credit_card_numbers::luhn_test;\n\npub fn validate_isin(isin: &str) -> bool {\n    if !isin.chars().all(|x| x.is_alphanumeric()) || isin.len() != 12 {\n        return false;\n    }\n    if !isin[..2].chars().all(|x| x.is_alphabetic())\n        || !isin[2..12].chars().all(|x| x.is_alphanumeric())\n        || !isin.chars().last().unwrap().is_numeric()\n    {\n        return false;\n    }\n\n    let bytes = isin.as_bytes();\n\n    let s2 = bytes\n        .iter()\n        .flat_map(|&c| {\n            if c.is_ascii_digit() {\n                vec![c]\n            } else {\n                (c + 10 - ('A' as u8)).to_string().into_bytes()\n            }\n        })\n        .collect::<Vec<u8>>();\n\n    let string = std::str::from_utf8(&s2).unwrap();\n    let number = string.parse::<u64>().unwrap();\n\n    return luhn_test(number as u64);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::validate_isin;\n\n    #[test]\n    fn test_validate_isin() {\n        assert_eq!(validate_isin(\"US0378331005\"), true);\n        assert_eq!(validate_isin(\"US0373831005\"), false);\n        assert_eq!(validate_isin(\"U50378331005\"), false);\n        assert_eq!(validate_isin(\"US03378331005\"), false);\n        assert_eq!(validate_isin(\"AU0000XVGZA3\"), true);\n        assert_eq!(validate_isin(\"AU0000VXGZA3\"), true);\n        assert_eq!(validate_isin(\"FR0000988040\"), true);\n    }\n}\n",
    "path": "tasks/validate-isin",
    "remote_code": null,
    "title": "Validate International Securities Identification Number",
    "url": "http://rosettacode.org/wiki/Validate_International_Securities_Identification_Number"
  },
  {
    "local_code": "use std::cmp::{max, min};\n\nstatic TENS: [u64; 20] = [\n    1,\n    10,\n    100,\n    1000,\n    10000,\n    100000,\n    1000000,\n    10000000,\n    100000000,\n    1000000000,\n    10000000000,\n    100000000000,\n    1000000000000,\n    10000000000000,\n    100000000000000,\n    1000000000000000,\n    10000000000000000,\n    100000000000000000,\n    1000000000000000000,\n    10000000000000000000,\n];\n\n/// Get the number of digits present in x\nfn ndigits(mut x: u64) -> u64 {\n    let mut n = 0;\n\n    while x != 0 {\n        n += 1;\n        x /= 10;\n    }\n\n    n\n}\n\nfn dtally(mut x: u64) -> u64 {\n    let mut t = 0;\n\n    while x != 0 {\n        t += 1 << ((x % 10) * 6);\n        x /= 10;\n    }\n\n    t\n}\n\n/// Get a list of all fangs of x. Get only the first divider of each fang. The second one can be found simply with x / fang.\nfn fangs(x: u64) -> Vec<u64> {\n    let mut nd = ndigits(x) as usize;\n\n    let mut fangs = vec![];\n\n    if nd & 1 != 1 {\n        nd /= 2;\n\n        let lo = max(TENS[nd - 1], (x + TENS[nd] - 2) / (TENS[nd] - 1));\n        let hi = min(x / lo, (x as f64).sqrt() as u64);\n\n        let t = dtally(x);\n\n        for a in lo..(hi + 1) {\n            let b = x / a;\n            if a * b == x && ((a % 10) > 0 || b % 10 > 0) && t == dtally(a) + dtally(b) {\n                fangs.push(a);\n            }\n        }\n    }\n\n    fangs\n}\n\n/// Pretty print the fangs of x\nfn print_fangs(x: u64, fangs: Vec<u64>) {\n    print!(\"{} = \", x);\n\n    if fangs.is_empty() {\n        print!(\"is not vampiric\");\n    } else {\n        for fang in fangs {\n            print!(\"{} x {}, \", fang, x / fang);\n        }\n    }\n    print!(\"\\n\");\n}\n\nfn main() {\n    println!(\"The first 25 vampire numbers are :\");\n\n    let mut nfangs = 0;\n    let mut x = 1;\n\n    while nfangs < 25 {\n        let fangs = fangs(x);\n        if !fangs.is_empty() {\n            nfangs += 1;\n            print_fangs(x, fangs);\n        }\n\n        x += 1;\n    }\n\n    println!(\"\\nSpecial requests :\");\n\n    print_fangs(16758243290880, fangs(16758243290880));\n    print_fangs(24959017348650, fangs(24959017348650));\n    print_fangs(14593825548650, fangs(14593825548650));\n}\n\n#[test]\nfn test() {\n    assert_eq!(\n        fangs(16758243290880),\n        vec![1982736, 2123856, 2751840, 2817360]\n    );\n\n    assert_eq!(\n        fangs(24959017348650),\n        vec![2947050, 2949705, 4125870, 4129587, 4230765]\n    );\n\n    assert_eq!(fangs(14593825548650), vec![]);\n}\n",
    "path": "tasks/vampire-number",
    "remote_code": null,
    "title": "Vampire number",
    "url": "http://rosettacode.org/wiki/Vampire_number"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Van Eck sequence",
    "url": "http://rosettacode.org/wiki/Van_Eck_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Van der Corput sequence",
    "url": "http://rosettacode.org/wiki/Van_der_Corput_sequence"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Variable size/Get",
    "url": "http://rosettacode.org/wiki/Variable_size/Get"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Variable size/Set",
    "url": "http://rosettacode.org/wiki/Variable_size/Set"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Variable-length quantity",
    "url": "http://rosettacode.org/wiki/Variable-length_quantity"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Variables",
    "url": "http://rosettacode.org/wiki/Variables"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Variadic function",
    "url": "http://rosettacode.org/wiki/Variadic_function"
  },
  {
    "local_code": "#[derive(Clone, Copy, PartialEq, Debug)]\nstruct Vector {\n    x: f32,\n    y: f32,\n    z: f32,\n}\n\nimpl Vector {\n    fn new(x: f32, y: f32, z: f32) -> Vector {\n        Vector { x: x, y: y, z: z }\n    }\n}\n\nfn dot(a: Vector, b: Vector) -> f32 {\n    a.x * b.x + a.y * b.y + a.z * b.z\n}\n\nfn cross(a: Vector, b: Vector) -> Vector {\n    Vector {\n        x: { a.y * b.z - a.z * b.y },\n        y: { a.z * b.x - a.x * b.z },\n        z: { a.x * b.y - a.y * b.x },\n    }\n}\n\nfn scalar3(a: Vector, b: Vector, c: Vector) -> f32 {\n    dot(a, cross(b, c))\n}\n\nfn vector3(a: Vector, b: Vector, c: Vector) -> Vector {\n    cross(a, cross(b, c))\n}\n\nfn main() {\n    let a = Vector::new(3.0, 4.0, 5.0);\n    let b = Vector::new(4.0, 3.0, 5.0);\n    let c = Vector::new(-5.0, -12.0, -13.0);\n\n    println!(\"Dot product: {}\", dot(a, b));\n    println!(\"Cross product: {:?}\", cross(a, b));\n    println!(\"Scalar triple product: {}\", scalar3(a, b, c));\n    println!(\"Vector triple product: {:?}\", vector3(a, b, c));\n}\n\n#[test]\nfn vector_dot_product() {\n    let a = Vector::new(1.0, 3.0, -5.0);\n    let b = Vector::new(4.0, -2.0, -1.0);\n    assert_eq!(dot(a, b), 3.0);\n}\n\n#[test]\nfn vector_cross_product() {\n    let a = Vector::new(2.0, 3.0, 4.0);\n    let b = Vector::new(5.0, 6.0, 7.0);\n    assert_eq!(\n        cross(a, b),\n        Vector {\n            x: -3.0,\n            y: 6.0,\n            z: -3.0,\n        }\n    );\n}\n",
    "path": "tasks/vector-products",
    "remote_code": "#[derive(Debug)]\nstruct Vector {\n    x: f64,\n    y: f64,\n    z: f64,\n}\n\nimpl Vector {\n    fn new(x: f64, y: f64, z: f64) -> Self {\n        Vector {\n            x: x,\n            y: y,\n            z: z,\n        }\n    }\n\n    fn dot_product(&self, other: &Vector) -> f64 {\n        (self.x * other.x) + (self.y * other.y) + (self.z * other.z)\n    }\n\n    fn cross_product(&self, other: &Vector) -> Vector {\n        Vector::new(self.y * other.z - self.z * other.y,\n                    self.z * other.x - self.x * other.z,\n                    self.x * other.y - self.y * other.x)\n    }\n\n    fn scalar_triple_product(&self, b: &Vector, c: &Vector) -> f64 {\n        self.dot_product(&b.cross_product(&c))\n    }\n\n    fn vector_triple_product(&self, b: &Vector, c: &Vector) -> Vector {\n        self.cross_product(&b.cross_product(&c))\n    }\n}\n\nfn main(){\n    let a = Vector::new(3.0, 4.0, 5.0);\n    let b = Vector::new(4.0, 3.0, 5.0);\n    let c = Vector::new(-5.0, -12.0, -13.0);\n\n    println!(\"a . b = {}\", a.dot_product(&b));\n    println!(\"a x b = {:?}\", a.cross_product(&b));\n    println!(\"a . (b x c) = {}\", a.scalar_triple_product(&b, &c));\n    println!(\"a x (b x c) = {:?}\", a.vector_triple_product(&b, &c));\n}",
    "title": "Vector products",
    "url": "http://rosettacode.org/wiki/Vector_products"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Verify distribution uniformity/Chi-squared test",
    "url": "http://rosettacode.org/wiki/Verify_distribution_uniformity/Chi-squared_test"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Verify distribution uniformity/Naive",
    "url": "http://rosettacode.org/wiki/Verify_distribution_uniformity/Naive"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Video display modes",
    "url": "http://rosettacode.org/wiki/Video_display_modes"
  },
  {
    "local_code": "const ASCII_A: u8 = b'A';\n\nfn main() {\n    let msg = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\n    let key = \"VIGENERECIPHER\";\n\n    let enc = vigenere(msg, key, true);\n    let dec = vigenere(&enc, key, false);\n\n    println!(\"msg: {}\", msg);\n    println!(\"key: {}\", key);\n    println!(\"enc: {}\", enc);\n    println!(\"dec: {}\", dec);\n}\n\nfn vigenere(plaintext: &str, key: &str, encrypt: bool) -> String {\n    let plaintext_bytes = to_sanitized_bytes(plaintext);\n    let key_bytes = to_sanitized_bytes(key);\n    let key_len = key_bytes.len();\n    let mut output = String::with_capacity(plaintext_bytes.len());\n\n    for (i, byte) in plaintext_bytes.iter().enumerate() {\n        let c = *byte;\n        let b = key_bytes[i % key_len];\n\n        let output_byte = if encrypt {\n            enc_byte(c, b)\n        } else {\n            dec_byte(c, b)\n        };\n\n        output.push(output_byte as char);\n    }\n    output\n}\n\nfn to_sanitized_bytes(string: &str) -> Vec<u8> {\n    string\n        .chars()\n        .filter(|&c| c.is_alphabetic())\n        .map(|c| c.to_ascii_uppercase() as u8)\n        .collect::<Vec<u8>>()\n}\n\nfn enc_byte(m: u8, k: u8) -> u8 {\n    ASCII_A + (m.wrapping_add(k).wrapping_sub(2 * (ASCII_A))) % 26\n}\n\nfn dec_byte(c: u8, k: u8) -> u8 {\n    ASCII_A + (c.wrapping_sub(k).wrapping_add(26)) % 26\n}\n\n#[test]\nfn test_enc_dec() {\n    let plaintext = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\n    let key = \"VIGENERECIPHER\";\n\n    let enc = vigenere(plaintext, key, true);\n    assert_eq!(\n        \"WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\",\n        enc\n    );\n    let dec = vigenere(&enc, key, false);\n    assert_eq!(\n        \"BEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\",\n        dec\n    );\n}\n\n#[test]\nfn test_equal_len_key_and_plaintext() {\n    let plaintext = \"VIGENERECIPHER\";\n    let key = \"REHPICERENEGIV\";\n    // to be sure nobody breaks this test\n    assert_eq!(plaintext.len(), key.len());\n\n    let enc = vigenere(plaintext, key, true);\n    assert_eq!(\"MMNTVGVVGVTNMM\", enc);\n    let dec = vigenere(&enc, key, false);\n    assert_eq!(plaintext, dec);\n}\n\n#[test]\nfn test_empty_string_enc_dec() {\n    let enc = vigenere(\"\", \"\", true);\n    assert_eq!(\"\", enc);\n    let dec = vigenere(\"\", \"\", false);\n    assert_eq!(\"\", dec);\n}\n",
    "path": "tasks/vigenere-cipher",
    "remote_code": "use std::ascii::AsciiExt;\n\nstatic A: u8 = 'A' as u8;\n\nfn uppercase_and_filter(input: &str) -> Vec<u8> {\n    let alphabet = b\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    let mut result = Vec::new();\n\n    for c in input.chars() {\n        // Ignore anything that is not in our short list of chars. We can then safely cast to u8.\n        if alphabet.iter().any(|&x| x as char == c) {\n            result.push(c.to_ascii_uppercase() as u8);\n        }\n    }\n\n    return result;\n}\n\nfn vigenere(key: &str, text: &str, is_encoding: bool) -> String {\n\n    let key_bytes = uppercase_and_filter(key);\n    let text_bytes = uppercase_and_filter(text);\n\n    let mut result_bytes = Vec::new();\n\n    for (i, c) in text_bytes.iter().enumerate() {\n        let c2 = if is_encoding {\n            (c + key_bytes[i % key_bytes.len()] - 2 * A) % 26 + A\n        } else {\n            (c + 26 - key_bytes[i % key_bytes.len()]) % 26 + A\n        };\n        result_bytes.push(c2);\n    }\n\n    String::from_utf8(result_bytes).unwrap()\n}\n\nfn main() {\n    let text = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\n    let key = \"VIGENERECIPHER\";\n\n    println!(\"Text: {}\", text);\n    println!(\"Key:  {}\", key);\n\n    let encoded = vigenere(key, text, true);\n    println!(\"Code: {}\", encoded);\n    let decoded = vigenere(key, &encoded, false);\n    println!(\"Back: {}\", decoded);\n}",
    "title": "Vigenère cipher",
    "url": "http://rosettacode.org/wiki/Vigen%C3%A8re_cipher"
  },
  {
    "local_code": "const FREQ: [f64; 26] = [\n    0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015, 0.06094, 0.06966, 0.00153,\n    0.00772, 0.04025, 0.02406, 0.06749, 0.07507, 0.01929, 0.00095, 0.05987, 0.06327, 0.09056,\n    0.02758, 0.00978, 0.02360, 0.00150, 0.01974, 0.00074,\n];\n\nconst ENCODED: &str = r##\"\nMOMUD EKAPV TQEFM OEVHP AJMII CDCTI FGYAG JSPXY ALUYM NSMYH\nVUXJE LEPXJ FXGCM JHKDZ RYICU HYPUS PGIGM OIYHF WHTCQ KMLRD\nITLXZ LJFVQ GHOLW CUHLO MDSOE KTALU VYLNZ RFGBX PHVGA LWQIS\nFGRPH JOOFW GUBYI LAPLA LCAFA AMKLG CETDW VOELJ IKGJB XPHVG\nALWQC SNWBU BYHCU HKOCE XJEYK BQKVY KIIEH GRLGH XEOLW AWFOJ\nILOVV RHPKD WIHKN ATUHN VRYAQ DIVHX FHRZV QWMWV LGSHN NLVZS\nJLAKI FHXUF XJLXM TBLQV RXXHR FZXGV LRAJI EXPRV OSMNP KEPDT\nLPRWM JAZPK LQUZA ALGZX GVLKL GJTUI ITDSU REZXJ ERXZS HMPST\nMTEOE PAPJH SMFNB YVQUZ AALGA YDNMP AQOWT UHDBV TSMUE UIMVH\nQGVRW AEFSP EMPVE PKXZY WLKJA GWALT VYYOB YIXOK IHPDS EVLEV\nRVSGB JOGYW FHKBL GLXYA MVKIS KIEHY IMAPX UOISK PVAGN MZHPW\nTTZPV XFCCD TUHJH WLAPF YULTB UXJLN SIJVV YOVDJ SOLXG TGRVO\nSFRII CTMKO JFCQF KTINQ BWVHG TENLH HOGCS PSFPV GJOKM SIFPR\nZPAAS ATPTZ FTPPD PORRF TAXZP KALQA WMIUD BWNCT LEFKO ZQDLX\nBUXJL ASIMR PNMBF ZCYLV WAPVF QRHZV ZGZEF KBYIO OFXYE VOWGB\nBXVCB XBAWG LQKCM ICRRX MACUO IKHQU AJEGL OIJHH XPVZW JEWBA\nFWAML ZZRXJ EKAHV FASMU LVVUT TGK\n\"##;\n\nconst ASCII_A: u8 = b'A';\n\nfn best_match(a: &[f64]) -> u8 {\n    let sum: f64 = a.iter().sum();\n    let mut best_fit = 1E100;\n    let mut best_rotate = 0;\n    (0..26).for_each(|rotate| {\n        let mut fit = 0.0;\n        (0..26).for_each(|i| {\n            let d = a[(i + rotate) % 26] / sum - FREQ[i];\n            fit += d * d / FREQ[i];\n        });\n        if fit < best_fit {\n            best_fit = fit;\n            best_rotate = rotate as u8;\n        }\n    });\n\n    best_rotate\n}\n\nfn freq_every_nth(msg: &Vec<u8>, interval: usize) -> (f64, Vec<char>) {\n    let len = msg.len();\n    let mut key = vec!['?'; interval];\n    let mut out = [0.0; 26];\n    let mut accu = [0.0; 26];\n    (0..interval).for_each(|j| {\n        out = [0.0; 26];\n        (j..len)\n            .step_by(interval)\n            .for_each(|i| out[(msg[i] - ASCII_A) as usize] += 1.0);\n        let rot = best_match(&out);\n        key[j] = (rot + ASCII_A) as char;\n        (0..26).for_each(|i| {\n            accu[i] += out[(i + rot as usize) % 26];\n        })\n    });\n\n    let sum: f64 = accu.iter().sum();\n    let mut ret = 0.0;\n    (0..26).for_each(|i| {\n        let d = accu[i] / sum - FREQ[i];\n        ret += d * d / FREQ[i];\n    });\n\n    (ret, key)\n}\n\nfn main() {\n    let mut best_fit = 1E100;\n    let mut best_key = String::new();\n\n    let sanitized_encoded = to_sanitized_bytes(ENCODED);\n    (1..=26).for_each(|j| {\n        let (fit, key) = freq_every_nth(&sanitized_encoded, j);\n        if fit < best_fit {\n            best_fit = fit;\n            best_key = key.iter().collect();\n        }\n    });\n    println!(\"Best key: {}\", &best_key);\n    println!(\"Decrypted text:\\n{}\", vigenere(ENCODED, &best_key, false));\n}\n\nfn vigenere(plaintext: &str, key: &str, encrypt: bool) -> String {\n    let plaintext_bytes = to_sanitized_bytes(plaintext);\n    let key_bytes = to_sanitized_bytes(key);\n    let key_len = key_bytes.len();\n    let mut output = String::with_capacity(plaintext_bytes.len());\n\n    for (i, byte) in plaintext_bytes.iter().enumerate() {\n        let c = *byte;\n        let b = key_bytes[i % key_len];\n\n        let output_byte = if encrypt {\n            enc_byte(c, b)\n        } else {\n            dec_byte(c, b)\n        };\n\n        output.push(output_byte as char);\n    }\n    output\n}\n\nfn to_sanitized_bytes(string: &str) -> Vec<u8> {\n    string\n        .chars()\n        .filter(|&c| c.is_alphabetic())\n        .map(|c| c.to_ascii_uppercase() as u8)\n        .collect::<Vec<u8>>()\n}\n\nfn enc_byte(m: u8, k: u8) -> u8 {\n    ASCII_A + (m.wrapping_add(k).wrapping_sub(2 * (ASCII_A))) % 26\n}\n\nfn dec_byte(c: u8, k: u8) -> u8 {\n    ASCII_A + (c.wrapping_sub(k).wrapping_add(26)) % 26\n}\n",
    "path": "tasks/vigenere-cipher-cryptanalysis",
    "remote_code": null,
    "title": "Vigenère cipher/Cryptanalysis",
    "url": "http://rosettacode.org/wiki/Vigen%C3%A8re_cipher/Cryptanalysis"
  },
  {
    "local_code": "#[macro_use]\nextern crate serde_derive;\n\nextern crate rand;\nextern crate serde;\nextern crate serde_json;\nextern crate term_painter;\n\nuse std::cmp::Ordering;\nuse std::env;\nuse std::fmt::{Debug, Display, Formatter, Result};\n\nuse rand::distributions::Uniform;\nuse rand::Rng;\nuse term_painter::Color::*;\nuse term_painter::ToStyle;\n\ntype NodePtr = Option<usize>;\n\n#[derive(Debug, PartialEq, Clone, Copy)]\nenum Side {\n    Left,\n    Right,\n    Up,\n}\n\n#[derive(Debug, PartialEq, Clone, Copy)]\nenum DisplayElement {\n    TrunkSpace,\n    SpaceLeft,\n    SpaceRight,\n    SpaceSpace,\n    Root,\n}\n\nimpl DisplayElement {\n    fn string(&self) -> String {\n        let x = match *self {\n            DisplayElement::TrunkSpace => \"    │   \",\n            DisplayElement::SpaceRight => \"    ┌───\",\n            DisplayElement::SpaceLeft => \"    └───\",\n            DisplayElement::SpaceSpace => \"        \",\n            DisplayElement::Root => \"├──\",\n        };\n        x.to_string()\n    }\n}\n\n#[derive(Debug, Clone, Copy, Deserialize, Serialize)]\nstruct Node<K, V> {\n    key: K,\n    value: V,\n    left: NodePtr,\n    right: NodePtr,\n    up: NodePtr,\n}\n\nimpl<K: Ord + Copy, V: Copy> Node<K, V> {\n    pub fn new(k: K, v: V) -> Node<K, V> {\n        Node {\n            key: k,\n            value: v,\n            left: None,\n            right: None,\n            up: None,\n        }\n    }\n\n    pub fn set_ptr(&mut self, side: Side, to: NodePtr) {\n        let field = match side {\n            Side::Up => &mut self.up,\n            Side::Left => &mut self.left,\n            _ => &mut self.right,\n        };\n        *field = to;\n    }\n\n    pub fn get_ptr(&self, side: Side) -> NodePtr {\n        match side {\n            Side::Up => self.up,\n            Side::Left => self.left,\n            _ => self.right,\n        }\n    }\n}\n\n#[derive(Debug, Serialize, Deserialize)]\nstruct Tree<K, V> {\n    root: NodePtr,\n    store: Vec<Node<K, V>>,\n}\n\nimpl<K: Ord + Copy + Debug + Display, V: Debug + Copy + Display> Tree<K, V> {\n    pub fn get_node(&self, np: NodePtr) -> Node<K, V> {\n        assert!(np.is_some());\n        self.store[np.unwrap()]\n    }\n\n    pub fn get_key(&self, np: NodePtr) -> K {\n        assert!(np.is_some());\n        self.store[np.unwrap()].key\n    }\n\n    pub fn _get_value(&self, np: NodePtr) -> V {\n        assert!(np.is_some());\n        self.store[np.unwrap()].value\n    }\n\n    pub fn get_pointer(&self, np: NodePtr, side: Side) -> NodePtr {\n        assert!(np.is_some());\n        self.store[np.unwrap()].get_ptr(side)\n    }\n\n    pub fn set_pointer(&mut self, np: NodePtr, side: Side, to: NodePtr) {\n        assert!(np.is_some());\n        self.store[np.unwrap()].set_ptr(side, to);\n    }\n\n    pub fn new() -> Self {\n        Tree {\n            root: None,\n            store: Vec::<Node<K, V>>::with_capacity(128),\n        }\n    }\n\n    pub fn insert(&mut self, k: K, v: V) -> Option<Node<K, V>> {\n        let mut n = Node::new(k, v);\n\n        if self.root.is_none() {\n            assert!(self.store.is_empty());\n            self.store.push(n);\n            self.root = Some(0);\n            return Some(n);\n        }\n\n        let mut p = self.root; // Possibly None\n        let mut prev = p;\n        let mut side = Side::Left;\n        while let Some(_) = p {\n            prev = p;\n            match n.key.cmp(&self.get_key(p)) {\n                Ordering::Less => {\n                    side = Side::Left;\n                    p = self.get_pointer(p, side);\n                }\n                Ordering::Greater => {\n                    side = Side::Right;\n                    p = self.get_pointer(p, side);\n                }\n                Ordering::Equal => {\n                    // Key exists\n                    return None;\n                }\n            }\n        }\n        // Set child's pointer\n        n.up = prev;\n        // Stow the node\n        self.store.push(n);\n        // Set parent's pointer\n        let ptr = Some(self.store.len() - 1);\n        self.set_pointer(prev, side, ptr);\n        Some(n)\n    }\n\n    // Prints the tree with root p.  The idea is to do an in-order traversal\n    // (reverse in-order in this case, where right is on top), and print nodes as they\n    // are visited, one per line. Each invocation of display() gets its own copy\n    // of the display element vector e, which is grown with either whitespace or\n    // a trunk element, then modified in its last and possibly second-to-last\n    // characters in context.\n    fn display(&self, p: NodePtr, side: Side, e: &[DisplayElement], f: &mut Formatter) {\n        if p.is_none() {\n            return;\n        }\n\n        let mut elems = e.to_vec();\n        let node = self.get_node(p);\n        let mut tail = DisplayElement::SpaceSpace;\n        if node.up != self.root {\n            // If the direction is switching, I need the trunk element to appear in the lines\n            // printed before that node is visited.\n            if side == Side::Left && node.right.is_some() {\n                elems.push(DisplayElement::TrunkSpace);\n            } else {\n                elems.push(DisplayElement::SpaceSpace);\n            }\n        }\n        let hindex = elems.len() - 1;\n        self.display(node.right, Side::Right, &elems, f);\n\n        if p == self.root {\n            elems[hindex] = DisplayElement::Root;\n            tail = DisplayElement::TrunkSpace;\n        } else if side == Side::Right {\n            // Right subtree finished\n            elems[hindex] = DisplayElement::SpaceRight;\n            // Prepare trunk element in case there is a left subtree\n            tail = DisplayElement::TrunkSpace;\n        } else if side == Side::Left {\n            elems[hindex] = DisplayElement::SpaceLeft;\n            let parent = self.get_node(node.up);\n            if parent.up.is_some() && self.get_pointer(parent.up, Side::Right) == node.up {\n                // Direction switched, need trunk element starting with this node/line\n                elems[hindex - 1] = DisplayElement::TrunkSpace;\n            }\n        }\n\n        // Visit node => print accumulated elements. Each node gets a line and each line gets a\n        // node.\n        for e in elems.clone() {\n            let _ = write!(f, \"{}\", e.string());\n        }\n        let _ = write!(\n            f,\n            \"{key:>width$} \",\n            key = Green.bold().paint(node.key),\n            width = 2\n        );\n        let _ = write!(\n            f,\n            \"{value:>width$}\\n\",\n            value = Blue.bold().paint(format!(\"{:.*}\", 2, node.value)),\n            width = 4\n        );\n\n        // Overwrite last element before continuing traversal\n        elems[hindex] = tail;\n\n        self.display(node.left, Side::Left, &elems, f);\n    }\n}\n\nimpl<K: Ord + Copy + Debug + Display, V: Debug + Copy + Display> Display for Tree<K, V> {\n    fn fmt(&self, f: &mut Formatter) -> Result {\n        if self.root.is_none() {\n            write!(f, \"[empty]\")\n        } else {\n            let v: Vec<DisplayElement> = vec![];\n            self.display(self.root, Side::Up, &v, f);\n            Ok(())\n        }\n    }\n}\n\nfn random_tree(n: u32) -> Tree<i32, f32> {\n    let mut tree: Tree<i32, f32> = Tree::new();\n    let mut rng = rand::thread_rng();\n    // Use `Uniform` rather than `gen_range`'s `Uniform::sample_single` for speed\n    let key_range = Uniform::new(-(n as i32) / 2, (n as i32) / 2);\n    let value_range = Uniform::new(-1.0, 1.0);\n    tree.insert(0, rng.sample(value_range));\n    for _ in 0..n - 1 {\n        tree.insert(rng.sample(key_range), rng.sample(value_range));\n    }\n    tree\n}\n\n/// Prints json representation of tree as well, useful for shorter code listings.\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    let mut r_nodes: u32 = 20;\n\n    match args.len() {\n        1 => {}\n        2 => {\n            r_nodes = args[1].parse::<u32>().unwrap();\n        }\n        _ => {\n            println!(\"visualize_a_tree <no. of nodes>\");\n            return;\n        }\n    }\n\n    let tree = random_tree(r_nodes);\n    let encoded = serde_json::to_string(&tree).unwrap();\n\n    println!(\"{}\", tree);\n    println!(\"{}\", encoded);\n\n    println!(\"\\nCanned tree, decoded:\");\n    _main_for_rosetta()\n}\n\n/// Decodes and prints a previously generated tree.  Presenting this with display(), the fmt()\n/// overload, and the struct & enum definitions is sufficient for this demonstration.\nfn _main_for_rosetta() {\n    let encoded = r#\"{\"root\":0,\"store\":[{\"key\":0,\"value\":0.45,\"left\":1,\"right\":3,\n        \"up\":null},{\"key\":-8,\"value\":-0.94,\"left\":7,\"right\":2,\"up\":0}, {\"key\":-1,\n        \"value\":0.15,\"left\":8,\"right\":null,\"up\":1},{\"key\":7, \"value\":-0.29,\"left\":4,\n        \"right\":9,\"up\":0},{\"key\":5,\"value\":0.80,\"left\":5,\"right\":null,\"up\":3},\n        {\"key\":4,\"value\":-0.85,\"left\":6,\"right\":null,\"up\":4},{\"key\":3,\"value\":-0.46,\n        \"left\":null,\"right\":null,\"up\":5},{\"key\":-10,\"value\":-0.85,\"left\":null,\n        \"right\":13,\"up\":1},{\"key\":-6,\"value\":-0.42,\"left\":null,\"right\":10,\"up\":2},\n        {\"key\":9,\"value\":0.63,\"left\":12,\"right\":null,\"up\":3},{\"key\":-3,\"value\":-0.83,\n        \"left\":null,\"right\":11,\"up\":8},{\"key\":-2,\"value\":0.75,\"left\":null,\"right\":null,\n        \"up\":10},{\"key\":8,\"value\":-0.48,\"left\":null,\"right\":null,\"up\":9},{\"key\":-9,\n        \"value\":0.53,\"left\":null,\"right\":null,\"up\":7}]}\"#;\n    let tree: Tree<i32, f32> = serde_json::from_str(encoded).unwrap();\n    println!(\"{}\", tree);\n}\n\n#[cfg(test)]\nmod tests {\n    use random_tree;\n    use serde_json;\n\n    use super::{Side, Tree};\n\n    #[test]\n    fn test_insert() {\n        let mut tree: Tree<i32, f32> = Tree::new();\n        tree.insert(0, 0.0);\n        tree.insert(8, 8.8);\n        tree.insert(-8, -8.8);\n        assert!(tree.insert(4, 4.4).is_some());\n        tree.insert(12, 12.12);\n\n        assert_eq!(\n            tree._get_value(tree.get_pointer(tree.root, Side::Left)),\n            -8.8\n        );\n        assert_eq!(\n            tree._get_value(\n                tree.get_pointer(tree.get_pointer(tree.root, Side::Right), Side::Right)\n            ),\n            12.12\n        );\n        assert_eq!(\n            tree.get_pointer(\n                tree.get_pointer(tree.get_pointer(tree.root, Side::Right), Side::Right),\n                Side::Left\n            ),\n            None\n        );\n\n        tree = random_tree(100);\n        assert!(tree.store.len() > 0);\n    }\n\n    #[test]\n    fn test_decode() {\n        let encoded = r#\"{\"root\":0,\"store\":[{\"key\":0,\"value\":0.45,\"left\":1,\"right\":3,\n            \"up\":null},{\"key\":-8,\"value\":-0.94,\"left\":7,\"right\":2,\"up\":0}, {\"key\":-1,\n            \"value\":0.15,\"left\":8,\"right\":null,\"up\":1},{\"key\":7, \"value\":-0.29,\"left\":4,\n            \"right\":9,\"up\":0},{\"key\":5,\"value\":0.80,\"left\":5,\"right\":null,\"up\":3},\n            {\"key\":4,\"value\":-0.85,\"left\":6,\"right\":null,\"up\":4},{\"key\":3,\"value\":-0.46,\n            \"left\":null,\"right\":null,\"up\":5},{\"key\":-10,\"value\":-0.85,\"left\":null,\n            \"right\":13,\"up\":1},{\"key\":-6,\"value\":-0.42,\"left\":null,\"right\":10,\"up\":2},\n            {\"key\":9,\"value\":0.63,\"left\":12,\"right\":null,\"up\":3},{\"key\":-3,\"value\":-0.83,\n            \"left\":null,\"right\":11,\"up\":8},{\"key\":-2,\"value\":0.75,\"left\":null,\"right\":null,\n            \"up\":10},{\"key\":8,\"value\":-0.48,\"left\":null,\"right\":null,\"up\":9},{\"key\":-9,\n            \"value\":0.53,\"left\":null,\"right\":null,\"up\":7}]}\"#;\n        let tree: Tree<i32, f32> = serde_json::from_str(encoded).unwrap();\n        assert_eq!(tree.root, Some(0));\n        assert_eq!(tree.store[4].key, 5);\n        assert_eq!(tree.store[4].value, 0.80);\n        assert_eq!(tree.store[4].right, None);\n        assert_eq!(tree.store[12].up, Some(9));\n        assert_eq!(tree.store[9].left, Some(12));\n    }\n}\n",
    "path": "tasks/visualize-a-tree",
    "remote_code": null,
    "title": "Visualize a tree",
    "url": "http://rosettacode.org/wiki/Visualize_a_tree"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Vogel's approximation method",
    "url": "http://rosettacode.org/wiki/Vogel's_approximation_method"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Voronoi diagram",
    "url": "http://rosettacode.org/wiki/Voronoi_diagram"
  },
  {
    "local_code": "extern crate regex;\nextern crate structopt;\n\nuse regex::Regex;\nuse structopt::StructOpt;\n\n/// Walks the directory tree, starting with the current working directory. Print filenames matching\n/// the regular expression `PATTERN`.\n#[derive(Debug, StructOpt)]\nstruct Opt {\n    /// Regular expression pattern\n    #[structopt(name = \"PATTERN\")]\n    pattern: Regex,\n}\n\nfn main() {\n    let opt = Opt::from_args();\n    let paths = std::fs::read_dir(\".\").unwrap();\n\n    for path in paths {\n        let path = path.unwrap().path();\n        let path = path.to_str().unwrap();\n\n        if opt.pattern.is_match(path) {\n            println!(\"{}\", path);\n        }\n    }\n}\n",
    "path": "tasks/walk-a-directory/non-recursively",
    "remote_code": "extern crate docopt;\nextern crate regex;\nextern crate rustc_serialize;\n\nuse docopt::Docopt;\nuse regex::Regex;\n\nconst USAGE: &'static str = \"\nUsage: rosetta <pattern>\n\nWalks the directory tree starting with the current working directory and\nprint filenames matching <pattern>.\n\";\n\n#[derive(Debug, RustcDecodable)]\nstruct Args {\n    arg_pattern: String,\n}\n\nfn main() {\n    let args: Args = Docopt::new(USAGE)\n        .and_then(|d| d.decode())\n        .unwrap_or_else(|e| e.exit());\n\n    let re = Regex::new(&args.arg_pattern).unwrap();\n    let paths = std::fs::read_dir(\".\").unwrap();\n\n    for path in paths {\n        let path = path.unwrap().path();\n        let path = path.to_str().unwrap();\n\n        if re.is_match(path) {\n            println!(\"{}\", path);\n        }\n    }\n}",
    "title": "Walk a directory/Non-recursively",
    "url": "http://rosettacode.org/wiki/Walk_a_directory/Non-recursively"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Walk_a_directory/Recursively\nextern crate regex;\n\nuse regex::Regex;\nuse std::convert::AsRef;\nuse std::fs;\nuse std::path::Path;\n\nfn walk<P>(pth: P, regex: &Regex)\nwhere\n    P: AsRef<Path>,\n{\n    let result = match fs::read_dir(pth) {\n        Ok(result) => result,\n        Err(_) => return,\n    };\n\n    for subpath in result {\n        if let Ok(subp) = subpath {\n            if let Ok(filename) = subp.path().into_os_string().into_string() {\n                if regex.is_match(&filename) {\n                    println!(\"{}\", filename);\n                }\n                walk(filename, regex);\n            }\n        }\n    }\n}\n\nfn main() {\n    walk(\".\", &Regex::new(r\".*\\.rs\").unwrap());\n}\n",
    "path": "tasks/walk-a-directory/recursively",
    "remote_code": "#![feature(fs_walk)]\n\nuse std::fs;\nuse std::path::Path;\n\nfn main() {\n    for f in fs::walk_dir(&Path::new(\"/home/pavel/Music\")).unwrap() {\n        let p = f.unwrap().path();\n        if p.extension().unwrap_or(\"\".as_ref()) == \"mp3\" {\n            println!(\"{:?}\", p);\n        }\n    }\n}",
    "title": "Walk a directory/Recursively",
    "url": "http://rosettacode.org/wiki/Walk_a_directory/Recursively"
  },
  {
    "local_code": "use std::cmp::min;\n\nfn getfill(pattern: &[usize]) -> usize {\n    let mut total = 0;\n    for (idx, val) in pattern.iter().enumerate() {\n        let l_peak = pattern[..idx].iter().max();\n        let r_peak = pattern[idx + 1..].iter().max();\n        if l_peak.is_some() && r_peak.is_some() {\n            let peak = min(l_peak.unwrap(), r_peak.unwrap());\n            if peak > val {\n                total += peak - val;\n            }\n        }\n    }\n    total\n}\n\nfn main() {\n    let patterns = vec![\n        vec![1, 5, 3, 7, 2],\n        vec![5, 3, 7, 2, 6, 4, 5, 9, 1, 2],\n        vec![2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],\n        vec![5, 5, 5, 5],\n        vec![5, 6, 7, 8],\n        vec![8, 7, 7, 6],\n        vec![6, 7, 10, 7, 6],\n    ];\n\n    for pattern in patterns {\n        println!(\"pattern: {:?}, fill: {}\", &pattern, getfill(&pattern));\n    }\n}\n\n#[test]\nfn test_getfill() {\n    let patterns = vec![\n        vec![1, 5, 3, 7, 2],\n        vec![5, 3, 7, 2, 6, 4, 5, 9, 1, 2],\n        vec![2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],\n        vec![5, 5, 5, 5],\n        vec![5, 6, 7, 8],\n        vec![8, 7, 7, 6],\n        vec![6, 7, 10, 7, 6],\n    ];\n\n    let answers = vec![2, 14, 35, 0, 0, 0, 0];\n\n    for (idx, pattern) in patterns.iter().enumerate() {\n        assert_eq!(answers[idx], getfill(&pattern));\n    }\n}\n",
    "path": "tasks/water-collected-between-towers",
    "remote_code": "\nuse std::cmp::min;\n\nfn getfill(pattern: &[usize]) -> usize {\n    let mut total = 0;\n    for (idx, val) in pattern.iter().enumerate() {\n        let l_peak = pattern[..idx].iter().max();\n        let r_peak = pattern[idx + 1..].iter().max();\n        if l_peak.is_some() && r_peak.is_some() {\n            let peak = min(l_peak.unwrap(), r_peak.unwrap());\n            if peak > val {\n                total += peak - val;\n            }\n        }\n    }\n    total\n}\n\nfn main() {\n    let patterns = vec![\n        vec![1, 5, 3, 7, 2],\n        vec![5, 3, 7, 2, 6, 4, 5, 9, 1, 2],\n        vec![2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],\n        vec![5, 5, 5, 5],\n        vec![5, 6, 7, 8],\n        vec![8, 7, 7, 6],\n        vec![6, 7, 10, 7, 6],\n    ];\n\n    for pattern in patterns {\n        println!(\"pattern: {:?}, fill: {}\", &pattern, getfill(&pattern));\n    }\n}\n",
    "title": "Water collected between towers",
    "url": "http://rosettacode.org/wiki/Water_collected_between_towers"
  },
  {
    "local_code": "use regex::Regex;\nuse std::error::Error;\n/// Create a program that downloads the time from this URL: http://tycho.usno.navy.mil/cgi-bin/timer.pl\n/// and then prints the current UTC time by extracting just the UTC time from the web page's HTML.\n/// For an introduction to the ecosystem of web scraping in Rust,\n/// read https://kadekillary.work/post/webscraping-rust/\n\nconst A_URL: &str = \"http://tycho.usno.navy.mil/cgi-bin/timer.pl\";\nfn extract_timestamp(raw_html: &str) -> Option<regex::Match> {\n    let pattern = Regex::new(r\"<BR>(?P<time>.*) UTC\").unwrap();\n    pattern.captures(raw_html).unwrap().name(\"time\")\n}\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let raw_html = reqwest::get(A_URL)?.text()?;\n    if let Some(timestamp) = extract_timestamp(&raw_html) {\n        print!(\"{}\", timestamp.as_str());\n    } else {\n        eprint!(\"Error: Could not parse URL for getting current time.\");\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::extract_timestamp;\n\n    #[test]\n    fn test_extract_timestamp() {\n        let body = r#\"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final\"//EN>\n            <html>\n            <body>\n            <TITLE>What time is it?</TITLE>\n            <H2> US Naval Observatory Master Clock Time</H2> <H3><PRE>\n            <BR>Aug. 12, 23:55:08 UTC\t\tUniversal Time\n            <BR>Aug. 12, 07:55:08 PM EDT\t\tEastern Time\n            <BR>Aug. 12, 06:55:08 PM CDT\t\tCentral Time\n            <BR>Aug. 12, 05:55:08 PM MDT\t\tMountain Time\n            <BR>Aug. 12, 04:55:08 PM PDT\t\tPacific Time\n            <BR>Aug. 12, 03:55:08 PM AKDT\tAlaska Time\n            <BR>Aug. 12, 01:55:08 PM HAST\tHawaii-Aleutian Time\n            </PRE></H3><P><A HREF=\"http://www.usno.navy.mil\"> US Naval Observatory</A>\n\n            </body></html>\n            \"#;\n        assert_eq!(\n            extract_timestamp(&body).unwrap().as_str(),\n            \"Aug. 12, 23:55:08\"\n        );\n    }\n}\n",
    "path": "tasks/web-scraping",
    "remote_code": null,
    "title": "Web scraping",
    "url": "http://rosettacode.org/wiki/Web_scraping"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Weird numbers",
    "url": "http://rosettacode.org/wiki/Weird_numbers"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Window_creation\n\n#[cfg(feature = \"gtk\")]\nmod graphical {\n    extern crate gtk;\n\n    use self::gtk::traits::*;\n    use self::gtk::{Inhibit, Window, WindowType};\n\n    pub fn create_window() {\n        gtk::init().expect(\"Failed to initialize GTK\");\n\n        let window = Window::new(WindowType::Toplevel);\n        window.connect_delete_event(|_, _| {\n            gtk::main_quit();\n            Inhibit(false)\n        });\n        window.show_all();\n        gtk::main();\n    }\n}\n\n#[cfg(feature = \"gtk\")]\nfn main() {\n    graphical::create_window();\n}\n\n#[cfg(not(feature = \"gtk\"))]\nfn main() {}\n",
    "path": "tasks/window-creation",
    "remote_code": null,
    "title": "Window creation",
    "url": "http://rosettacode.org/wiki/Window_creation"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Window creation/X11",
    "url": "http://rosettacode.org/wiki/Window_creation/X11"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Window management",
    "url": "http://rosettacode.org/wiki/Window_management"
  },
  {
    "local_code": "use std::mem;\nuse std::thread;\nuse std::time::Duration;\n\n#[derive(Copy, Clone)]\nenum Cell {\n    Empty(char),\n    Head,\n    Tail,\n    Conductor,\n}\n\nimpl Cell {\n    fn from_char(c: char) -> Cell {\n        match c {\n            '.' => Cell::Conductor,\n            'H' => Cell::Head,\n            't' => Cell::Tail,\n            c => Cell::Empty(c),\n        }\n    }\n    fn to_char(&self) -> char {\n        match *self {\n            Cell::Conductor => '.',\n            Cell::Head => 'H',\n            Cell::Tail => 't',\n            Cell::Empty(c) => c,\n        }\n    }\n}\n\nfn next_world(input: &[Cell], output: &mut [Cell], w: usize, h: usize) {\n    for i in 0..(w * h) {\n        match input[i] {\n            Cell::Empty(c) => output[i] = Cell::Empty(c),\n            Cell::Tail => output[i] = Cell::Conductor,\n            Cell::Head => output[i] = Cell::Tail,\n            Cell::Conductor => {\n                let nc = vec![\n                    input.get(i - w - 1),\n                    input.get(i - w),\n                    input.get(i - w + 1),\n                    input.get(i - 1),\n                    input.get(i + 1),\n                    input.get(i + w - 1),\n                    input.get(i + w),\n                    input.get(i + w + 1),\n                ]\n                .iter()\n                .fold(0, |sum, &o| {\n                    if let Some(&Cell::Head) = o {\n                        sum + 1\n                    } else {\n                        sum\n                    }\n                });\n                output[i] = if nc == 1 || nc == 2 {\n                    Cell::Head\n                } else {\n                    Cell::Conductor\n                };\n            }\n        }\n    }\n}\n\nfn main() {\n    let (w, h) = (14usize, 7usize);\n    let mut world: Vec<Cell> = r\"\n+-----------+\n|tH.........|\n|.   .      |\n|   ...     |\n|.   .      |\n|Ht.. ......|\n+-----------+\n\"\n    .chars()\n    .map(Cell::from_char)\n    .collect();\n    let mut next: Vec<Cell> = world.clone();\n\n    loop {\n        for cell in &world {\n            print!(\"{}\", cell.to_char());\n        }\n        println!();\n        next_world(&world, &mut next, w, h);\n        mem::swap(&mut world, &mut next);\n\n        // Use VT100 cursor control sequences to animate in-place\n        print!(\"\\x1b[{}A\", 8);\n        print!(\"\\x1b[{}D\", 14);\n        thread::sleep(Duration::from_millis(100));\n    }\n}\n\n#[test]\nfn test() {\n    let (w, h) = (14usize, 7usize);\n    let mut world: Vec<Cell> = r\"\n+-----------+\n|tH.........|\n|.   .      |\n|   ...     |\n|.   .      |\n|Ht.. ......|\n+-----------+\n\"\n    .chars()\n    .map(Cell::from_char)\n    .collect();\n    let mut next: Vec<Cell> = world.clone();\n\n    for _ in 0..10 {\n        next_world(&world, &mut next, w, h);\n        mem::swap(&mut world, &mut next);\n    }\n\n    let result: String = world.iter().map(|c| c.to_char()).collect();\n    let correct = r\"\n+-----------+\n|.tH.tH.tH.t|\n|H   t      |\n|   HHH     |\n|H   .      |\n|t.tH ......|\n+-----------+\n\";\n    assert_eq!(result, correct);\n}\n",
    "path": "tasks/wireworld",
    "remote_code": null,
    "title": "Wireworld",
    "url": "http://rosettacode.org/wiki/Wireworld"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Word frequency",
    "url": "http://rosettacode.org/wiki/Word_frequency"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Word search",
    "url": "http://rosettacode.org/wiki/Word_search"
  },
  {
    "local_code": "//! Using the [minimum length greedy algorithm].\n//!\n//! Implemented as a lazy `String` iterator, returning a wrapped line each time.\n//!\n//! [minimum length greedy algorithm]: http://en.wikipedia.org/wiki/Word_wrap#Minimum_length\nuse std::mem::swap;\nuse std::str::SplitWhitespace;\n\npub struct WordWrap<'a> {\n    words: SplitWhitespace<'a>,\n    line_length: usize,\n    next_line: String,\n}\n\nimpl<'a> WordWrap<'a> {\n    fn new(text: &'a str, line_length: usize) -> WordWrap {\n        WordWrap {\n            words: text.split_whitespace(),\n            line_length: line_length,\n            next_line: String::new(),\n        }\n    }\n}\n\nimpl<'a> Iterator for WordWrap<'a> {\n    type Item = String;\n\n    #[cfg_attr(feature = \"clippy\", allow(while_let_on_iterator))]\n    fn next(&mut self) -> Option<String> {\n        // Move anything left over from last run to this_line\n        let mut this_line = String::new();\n        swap(&mut self.next_line, &mut this_line);\n\n        let mut space_left = self.line_length - this_line.chars().count();\n        const SPACE_WIDTH: usize = 1;\n\n        // Loop, adding words until we run out of words or hit the line length\n        while let Some(word) = self.words.next() {\n            let word_length = word.chars().count();\n\n            // If not the first word for this line\n            if space_left != self.line_length {\n                if word_length + SPACE_WIDTH > space_left {\n                    // Out of space, save word for next line\n                    self.next_line.push_str(word);\n                    break;\n                } else {\n                    // Add a space and keep going\n                    this_line.push(' ');\n                    space_left -= SPACE_WIDTH;\n                }\n            }\n\n            // Add word to this line\n            this_line.push_str(word);\n            space_left -= word_length;\n        }\n\n        if this_line.is_empty() {\n            None\n        } else {\n            Some(this_line)\n        }\n    }\n}\n\nfn main() {\n    let text = \"In olden times when wishing still helped one, there lived a king whose daughters \\\n                were all beautiful, but the youngest was so beautiful that the sun itself, which \\\n                has seen so much, was astonished whenever it shone in her face.  Close by the \\\n                king's castle lay a great dark forest, and under an old lime tree in the forest \\\n                was a well, and when the day was very warm, the king's child went out into the \\\n                forest and sat down by the side of the cool fountain, and when she was bored she \\\n                took a golden ball, and threw it up on high and caught it, and this ball was her \\\n                favorite plaything.\";\n\n    for length in 72..81 {\n        println!(\"Text wrapped at {}\", length);\n        for line in WordWrap::new(text, length) {\n            println!(\"{}\", line);\n        }\n        println!();\n    }\n}\n\n#[test]\nfn test_empty_string() {\n    assert_eq!(WordWrap::new(\"\", 80).next(), None);\n}\n\n#[test]\nfn test_single_word_shorter_than_line() {\n    assert_eq!(WordWrap::new(\"Hello\", 80).next().unwrap(), \"Hello\");\n}\n\n#[test]\nfn test_two_words_shorter_than_line() {\n    assert_eq!(\n        WordWrap::new(\"Hello world\", 80).next().unwrap(),\n        \"Hello world\"\n    );\n}\n\n#[test]\nfn test_wrap_second_word() {\n    let mut w = WordWrap::new(\"Hello world\", 10);\n    assert_eq!(w.next().unwrap(), \"Hello\");\n    assert_eq!(w.next().unwrap(), \"world\");\n}\n\n#[test]\nfn test_wrap_punctuation() {\n    let mut w = WordWrap::new(\"Hello, world\", 6);\n    assert_eq!(w.next().unwrap(), \"Hello,\");\n    assert_eq!(w.next().unwrap(), \"world\");\n}\n\n#[test]\nfn test_squash_multiple_spaces() {\n    let mut w = WordWrap::new(\" Hello  to the    world    \", 10);\n    assert_eq!(w.next().unwrap(), \"Hello to\");\n    assert_eq!(w.next().unwrap(), \"the world\");\n    assert_eq!(w.next(), None);\n}\n\n#[test]\nfn test_unicode() {\n    let mut w = WordWrap::new(\"Nous étions à l'Étude, quand le Proviseur entra\", 11);\n    assert_eq!(w.next().unwrap(), \"Nous étions\");\n    assert_eq!(w.next().unwrap(), \"à l'Étude,\");\n    assert_eq!(w.next().unwrap(), \"quand le\");\n    assert_eq!(w.next().unwrap(), \"Proviseur\");\n    assert_eq!(w.next().unwrap(), \"entra\");\n}\n",
    "path": "tasks/word-wrap",
    "remote_code": null,
    "title": "Word wrap",
    "url": "http://rosettacode.org/wiki/Word_wrap"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "World Cup group stage",
    "url": "http://rosettacode.org/wiki/World_Cup_group_stage"
  },
  {
    "local_code": "use std::fs::OpenOptions;\nuse std::io::prelude::*;\n\nfn main() {\n    let contents = r\"(Over)write a file so that it contains a string.\n\nThe reverse of Read entire file-for when you want to update or\ncreate a file which you would read in its entirety all at once.\";\n\n    let mut output = OpenOptions::new()\n        .write(true)\n        .create(true)\n        .truncate(true)\n        .open(\"output.txt\")\n        .unwrap();\n    output.write_all(contents.as_bytes()).unwrap();\n}\n",
    "path": "tasks/write-entire-file",
    "remote_code": null,
    "title": "Write entire file",
    "url": "http://rosettacode.org/wiki/Write_entire_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Write float arrays to a text file",
    "url": "http://rosettacode.org/wiki/Write_float_arrays_to_a_text_file"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "pub fn char_from_id(id: u8) -> char {\n    [' ', '#', '/', '_', 'L', '|', '\\n'][id as usize]\n}\n\nconst ID_BITS: u8 = 3;\n\npub fn decode(code: &[u8]) -> String {\n    let mut ret = String::new();\n    let mut carry = 0;\n    let mut carry_bits = 0;\n    for &b in code {\n        let mut bit_pos = ID_BITS - carry_bits;\n        let mut cur = b >> bit_pos;\n        let mask = (1 << bit_pos) - 1;\n        let id = carry | (b & mask) << carry_bits;\n        ret.push(char_from_id(id));\n        while bit_pos + ID_BITS < 8 {\n            ret.push(char_from_id(cur & ((1 << ID_BITS) - 1)));\n            cur >>= ID_BITS;\n            bit_pos += ID_BITS;\n        }\n        carry = cur;\n        carry_bits = 8 - bit_pos;\n    }\n    ret\n}\n\nfn main() {\n    let code = [\n        72, 146, 36, 0, 0, 0, 0, 0, 0, 0, 128, 196, 74, 182, 41, 1, 0, 0, 0, 0, 0, 0, 160, 196, 77, 0,\n        52, 1, 18, 0, 9, 144, 36, 9, 146, 36, 113, 147, 36, 9, 160, 4, 80, 130, 100, 155, 160, 41, 145,\n        155, 108, 74, 128, 38, 64, 19, 41, 73, 2, 160, 137, 155, 0, 84, 130, 38, 64, 19, 112, 155, 18,\n        160, 137, 155, 0, 160, 18, 42, 73, 18, 36, 73, 2, 128, 74, 76, 1, 0, 40, 128, 219, 38, 104, 219,\n        4, 0, 160, 0\n    ];\n\n    println!(\"{}\", decode(&code));\n}",
    "title": "Write language name in 3D ASCII",
    "url": "http://rosettacode.org/wiki/Write_language_name_in_3D_ASCII"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Write to Windows event log",
    "url": "http://rosettacode.org/wiki/Write_to_Windows_event_log"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "XML/DOM serialization",
    "url": "http://rosettacode.org/wiki/XML/DOM_serialization"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": "extern crate xml; // provided by the xml-rs crate\nuse xml::{name::OwnedName, reader::EventReader, reader::XmlEvent};\n\nconst DOCUMENT: &str = r#\"\n<Students>\n  <Student Name=\"April\" Gender=\"F\" DateOfBirth=\"1989-01-02\" />\n  <Student Name=\"Bob\" Gender=\"M\"  DateOfBirth=\"1990-03-04\" />\n  <Student Name=\"Chad\" Gender=\"M\"  DateOfBirth=\"1991-05-06\" />\n  <Student Name=\"Dave\" Gender=\"M\"  DateOfBirth=\"1992-07-08\">\n    <Pet Type=\"dog\" Name=\"Rover\" />\n  </Student>\n  <Student DateOfBirth=\"1993-09-10\" Gender=\"F\" Name=\"&#x00C9;mily\" />\n</Students>\n\"#;\n\nfn main() -> Result<(), xml::reader::Error> {\n    let parser = EventReader::new(DOCUMENT.as_bytes());\n\n    let tag_name = OwnedName::local(\"Student\");\n    let attribute_name = OwnedName::local(\"Name\");\n\n    for event in parser {\n        match event? {\n            XmlEvent::StartElement {\n                name,\n                attributes,\n                ..\n            } if name == tag_name => {\n                if let Some(attribute) = attributes.iter().find(|&attr| attr.name == attribute_name) {\n                    println!(\"{}\", attribute.value);\n                }\n            }\n            _ => (),\n        }\n    }\n    Ok(())\n}",
    "title": "XML/Input",
    "url": "http://rosettacode.org/wiki/XML/Input"
  },
  {
    "local_code": "extern crate xml;\n\nuse std::collections::HashMap;\nuse std::str;\n\nuse xml::writer::{EmitterConfig, XmlEvent};\n\nfn characters_to_xml(characters: HashMap<String, String>) -> String {\n    let mut output: Vec<u8> = Vec::new();\n    let mut writer = EmitterConfig::new()\n        .perform_indent(true)\n        .create_writer(&mut output);\n\n    writer\n        .write(XmlEvent::start_element(\"CharacterRemarks\"))\n        .unwrap();\n\n    for (character, line) in &characters {\n        let element = XmlEvent::start_element(\"Character\").attr(\"name\", character);\n        writer.write(element).unwrap();\n        writer.write(XmlEvent::characters(line)).unwrap();\n        writer.write(XmlEvent::end_element()).unwrap();\n    }\n\n    writer.write(XmlEvent::end_element()).unwrap();\n    str::from_utf8(&output).unwrap().to_string()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::characters_to_xml;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_xml_output() {\n        let mut input = HashMap::new();\n        input.insert(\n            \"April\".to_string(),\n            \"Bubbly: I'm > Tam and <= Emily\".to_string(),\n        );\n        input.insert(\n            \"Tam O'Shanter\".to_string(),\n            \"Burns: \\\"When chapman billies leave the street ...\\\"\".to_string(),\n        );\n        input.insert(\"Emily\".to_string(), \"Short & shrift\".to_string());\n\n        let output = characters_to_xml(input);\n\n        println!(\"{}\", output);\n        assert!(output.contains(\n            \"<Character name=\\\"Tam O&apos;Shanter\\\">Burns: \\\"When chapman \\\n             billies leave the street ...\\\"</Character>\"\n        ));\n        assert!(output\n            .contains(\"<Character name=\\\"April\\\">Bubbly: I'm > Tam and &lt;= Emily</Character>\"));\n        assert!(output.contains(\"<Character name=\\\"Emily\\\">Short &amp; shrift</Character>\"));\n    }\n}\n",
    "path": "tasks/xml-output",
    "remote_code": "extern crate xml;\n\nuse std::collections::HashMap;\nuse std::str;\n\nuse xml::writer::{EmitterConfig, XmlEvent};\n\nfn characters_to_xml(characters: HashMap<String, String>) -> String {\n    let mut output: Vec<u8> = Vec::new();\n    let mut writer = EmitterConfig::new()\n        .perform_indent(true)\n        .create_writer(&mut output);\n\n    writer\n        .write(XmlEvent::start_element(\"CharacterRemarks\"))\n        .unwrap();\n\n    for (character, line) in &characters {\n        let element = XmlEvent::start_element(\"Character\").attr(\"name\", character);\n        writer.write(element).unwrap();\n        writer.write(XmlEvent::characters(line)).unwrap();\n        writer.write(XmlEvent::end_element()).unwrap();\n    }\n\n    writer.write(XmlEvent::end_element()).unwrap();\n    str::from_utf8(&output).unwrap().to_string()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::characters_to_xml;\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_xml_output() {\n        let mut input = HashMap::new();\n        input.insert(\n            \"April\".to_string(),\n            \"Bubbly: I'm > Tam and <= Emily\".to_string(),\n        );\n        input.insert(\n            \"Tam O'Shanter\".to_string(),\n            \"Burns: \\\"When chapman billies leave the street ...\\\"\".to_string(),\n        );\n        input.insert(\"Emily\".to_string(), \"Short & shrift\".to_string());\n\n        let output = characters_to_xml(input);\n\n        println!(\"{}\", output);\n        assert!(output.contains(\n            \"<Character name=\\\"Tam O&apos;Shanter\\\">Burns: \\\"When chapman \\\n             billies leave the street ...\\\"</Character>\"\n        ));\n        assert!(output\n            .contains(\"<Character name=\\\"April\\\">Bubbly: I'm > Tam and &lt;= Emily</Character>\"));\n        assert!(output.contains(\"<Character name=\\\"Emily\\\">Short &amp; shrift</Character>\"));\n    }\n}",
    "title": "XML/Output",
    "url": "http://rosettacode.org/wiki/XML/Output"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "XML/XPath",
    "url": "http://rosettacode.org/wiki/XML/XPath"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Xiaolin Wu's line algorithm",
    "url": "http://rosettacode.org/wiki/Xiaolin_Wu's_line_algorithm"
  },
  {
    "local_code": "#![cfg_attr(feature = \"cargo-clippy\", allow(double_parens, type_complexity))]\n\nuse std::sync::Arc;\n\n// Arc<Box<Closure>>\nmacro_rules! abc {\n    ($x:expr) => {\n        Arc::new(Box::new($x))\n    };\n}\n\n#[derive(Clone)]\nenum Mu<T> {\n    Roll(Arc<Box<dyn Fn(Mu<T>) -> T>>),\n}\n\nfn unroll<T>(Mu::Roll(f): Mu<T>) -> Arc<Box<dyn Fn(Mu<T>) -> T>> {\n    Arc::clone(&f)\n}\n\npub type Func<A> = Arc<Box<dyn Fn(A) -> A>>;\npub type RecFunc<A> = Arc<Box<dyn Fn(Func<A>) -> Func<A>>>;\n\npub fn y<A: 'static>(f: RecFunc<A>) -> Func<A> {\n    let g: Arc<Box<dyn Fn(Mu<Func<A>>) -> Func<A>>> = abc!(move |x: Mu<Func<A>>| -> Func<A> {\n        let f = Arc::clone(&f);\n        abc!(move |a: A| -> A {\n            let f = Arc::clone(&f);\n            f(unroll(x.clone())(x.clone()))(a)\n        })\n    });\n    g(Mu::Roll(Arc::clone(&g)))\n}\n\n#[macro_export]\nmacro_rules! y {\n    (| $name:ident | $fun:tt) => {\n        y(abc!(|$name| abc!($fun)))\n    };\n}\n\nfn fac(n: u32) -> u32 {\n    let fn_: Func<u32> = y!(|f| (move |x| if x == 0 { 1 } else { f(x - 1) * x }));\n    fn_(n)\n}\n\nfn fib(n: u32) -> u32 {\n    let fn_: Func<u32> = y!(|f| (move |x| if x < 2 { x } else { f(x - 1) + f(x - 2) }));\n    fn_(n)\n}\n\nfn main() {\n    println!(\"{}\", fac(10));\n    println!(\"{}\", fib(10))\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn fac() {\n        assert_eq!(super::fac(10), 3628800);\n    }\n\n    #[test]\n    fn fib() {\n        assert_eq!(super::fib(10), 55);\n    }\n}\n",
    "path": "tasks/y-combinator",
    "remote_code": "//! A simple implementation of the Y Combinator\n// λf.(λx.xx)(λx.f(xx))\n// <=> λf.(λx.f(xx))(λx.f(xx))\n \n// CREDITS: A better version of the previous code that was posted here, with detailed explanation.\n// See <y> and also <y_apply>.\n \n// A function type that takes its own type as an input is an infinite recursive type.\n// We introduce a trait that will allow us to have an input with the same type as self, and break the recursion.\n// The input is going to be a trait object that implements the desired function in the interface.\n// NOTE: We will be coercing a reference to a closure into this trait object.\n\ntrait Apply<T, R> {\n  fn apply(\n    &self,\n    &Apply<T, R>,\n    T\n  ) -> R;\n}\n\n// In Rust, closures fall into three kinds: FnOnce, FnMut and Fn.\n// FnOnce assumed to be able to be called just once if it is not Clone. It is impossible to\n// write recursive FnOnce that is not Clone.\n// All FnMut are also FnOnce, although you can call them multiple times, they are not allow to\n// have a reference to themselves. So it is also not possible to write recursive FnMut closures\n// that is not Clone.\n// All Fn are also FnMut, and all closures of Fn are also Clone. However, programmers can create\n// Fn objects that are not Clone\n\n// This will work for all Fn objects, not just closures\n// And it is a little bit more efficient for Fn closures as it do not clone itself.\nimpl<T, R, F> Apply<T, R> for F where F:\n  Fn(&Apply<T, R>, T) -> R\n{\n  fn apply(\n    &self,\n    f: &Apply<T, R>,\n    t: T\n  ) -> R {\n    self(f, t)\n \n    // NOTE: Each letter is an individual symbol.\n    // (λx.(λy.xxy))(λx.(λy.f(λz.xxz)y))t\n    // => (λx.xx)(λx.f(xx))t\n    // => (Yf)t\n  }\n}\n\n// This works for all closures that is Clone, and those are Fn.\n// impl<T, R, F> Apply<T, R> for F where F: FnOnce( &Apply<T, R>, T ) -> R + Clone {\n//     fn apply( &self, f: &Apply<T, R>, t: T ) -> R {\n//         (self.clone())( f, t )\n \n//         // If we were to pass in self as f, we get -\n//         // NOTE: Each letter is an individual symbol.\n//         // λf.λt.sft\n//         // => λs.λt.sst [s/f]\n//         // => λs.ss\n//     }\n// }\n\n// Before 1.26 we have some limitations and so we need some workarounds. But now impl Trait is stable and we can\n// write the following:\n\nfn y<T,R>(f:impl Fn(&Fn(T) -> R, T) -> R) -> impl Fn(T) -> R {\n  move |t| (\n    |x: &Apply<T,R>, y| x.apply(x, y)\n  ) (\n    &|x: &Apply<T,R>, y| f(\n      &|z| x.apply(x,z),\n      y\n    ),\n    t\n  )\n}\n\n// fn y<T,R>(f:impl FnOnce(&Fn(T) -> R, T) -> R + Clone) -> impl FnOnce(T) -> R {\n//    |t| (|x: &Apply<T,R>,y| x.apply(x,y))\n//        (&move |x:&Apply<T,R>,y| f(&|z| x.apply(x,z), y), t)\n \n//     // NOTE: Each letter is an individual symbol.\n//     // (λx.(λy.xxy))(λx.(λy.f(λz.xxz)y))t\n//     // => (λx.xx)(λx.f(xx))t\n//     // => (Yf)t\n// }\n\n// Previous version removed as they are just hacks when impl Trait is not available.\n\nfn fac(n: usize) -> usize {\n  let almost_fac = |f: &Fn(usize) -> usize, x|\n    if x == 0 {\n      1\n    } else {\n      x * f(x - 1)\n    }\n  ;\n  let fac = y( almost_fac );\n  fac(n)\n}\n\nfn fib( n: usize ) -> usize {\n  let almost_fib = |f: &Fn(usize) -> usize, x|\n    if x < 2 {\n      1\n    } else {\n      f(x - 2) + f(x - 1)\n    };\n  let fib = y(almost_fib);\n  fib(n)\n}\n\nfn optimal_fib( n: usize ) -> usize {\n  let almost_fib = |f: &Fn((usize,usize,usize)) -> usize, (i0,i1,x)| \n    match x {\n      0 => i0,\n      1 => i1,\n      x => f((i1,i0+i1, x-1))\n    }        \n  ;\n  let fib = |x| y(almost_fib)((1,1,x));\n  fib(n)\n}\n\nfn main() {\n  println!(\"{}\", fac(10));\n  println!(\"{}\", fib(10));\n  println!(\"{}\", optimal_fib(10));\n}",
    "title": "Y combinator",
    "url": "http://rosettacode.org/wiki/Y_combinator"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Yahoo! search interface",
    "url": "http://rosettacode.org/wiki/Yahoo!_search_interface"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Yin and yang",
    "url": "http://rosettacode.org/wiki/Yin_and_yang"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Zebra puzzle",
    "url": "http://rosettacode.org/wiki/Zebra_puzzle"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Zeckendorf arithmetic",
    "url": "http://rosettacode.org/wiki/Zeckendorf_arithmetic"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Zeckendorf number representation",
    "url": "http://rosettacode.org/wiki/Zeckendorf_number_representation"
  },
  {
    "local_code": "// http://rosettacode.org/wiki/Zero_to_the_zero_power\nfn main() {\n    println!(\"0 ^ 0 = {}\", 0i64.pow(0));\n}\n",
    "path": "tasks/zero-to-the-zero-power",
    "remote_code": "fn main() {\n    println!(\"{}\",0u32.pow(0));\n}",
    "title": "Zero to the zero power",
    "url": "http://rosettacode.org/wiki/Zero_to_the_zero_power"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Zhang-Suen thinning algorithm",
    "url": "http://rosettacode.org/wiki/Zhang-Suen_thinning_algorithm"
  },
  {
    "local_code": "//! Implements with the sorting indexes algorithm explained in the [discussion page].\n//!\n//! [discussion page]:http://rosettacode.org/wiki/Talk:Zig-zag_matrix\nuse std::cmp::Ordering;\nuse std::cmp::Ordering::{Equal, Greater, Less};\nuse std::iter::repeat;\n\n#[derive(Debug, PartialEq, Eq)]\nstruct SortIndex {\n    x: usize,\n    y: usize,\n}\n\nimpl SortIndex {\n    fn new(x: usize, y: usize) -> SortIndex {\n        SortIndex { x: x, y: y }\n    }\n}\n\nimpl PartialOrd for SortIndex {\n    fn partial_cmp(&self, other: &SortIndex) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for SortIndex {\n    fn cmp(&self, other: &SortIndex) -> Ordering {\n        let lower = if self.x + self.y == other.x + other.y {\n            if (self.x + self.y) % 2 == 0 {\n                self.x < other.x\n            } else {\n                self.y < other.y\n            }\n        } else {\n            (self.x + self.y) < (other.x + other.y)\n        };\n\n        if lower {\n            Less\n        } else if self == other {\n            Equal\n        } else {\n            Greater\n        }\n    }\n}\n\nfn zigzag(n: usize) -> Vec<Vec<usize>> {\n    let mut l: Vec<SortIndex> = (0..n * n).map(|i| SortIndex::new(i % n, i / n)).collect();\n    l.sort();\n\n    let init_vec = vec![0; n];\n    let mut result: Vec<Vec<usize>> = repeat(init_vec).take(n).collect();\n    for (i, &SortIndex { x, y }) in l.iter().enumerate() {\n        result[y][x] = i\n    }\n    result\n}\n\nfn main() {\n    println!(\"{:?}\", zigzag(5));\n}\n\n#[test]\nfn result() {\n    let exp = vec![\n        vec![0, 1, 5, 6, 14],\n        vec![2, 4, 7, 13, 15],\n        vec![3, 8, 12, 16, 21],\n        vec![9, 11, 17, 20, 22],\n        vec![10, 18, 19, 23, 24],\n    ];\n    assert_eq!(zigzag(5), exp);\n}\n",
    "path": "tasks/zig-zag-matrix",
    "remote_code": null,
    "title": "Zig-zag matrix",
    "url": "http://rosettacode.org/wiki/Zig-zag_matrix"
  },
  {
    "local_code": null,
    "path": null,
    "remote_code": null,
    "title": "Zumkeller numbers",
    "url": "http://rosettacode.org/wiki/Zumkeller_numbers"
  }
]